[{"key": "abdelaziz2020graph4code", "year": "2020", "title": "Graph4Code: A Machine Interpretable Knowledge Graph for Code", "abstract": "<p>Knowledge graphs have proven extremely useful in powering diverse applications in semantic search and natural language understanding. Graph4Code is a knowledge graph about program code that can similarly power diverse applications such as program search, code understanding, refactoring, bug detection, and code automation. The graph uses generic techniques to capture the semantics of Python code: the key nodes in the graph are classes, functions and methods in popular Python modules. Edges indicate function usage (e.g., how data flows through function calls, as derived from program analysis of real code), and documentation about functions (e.g., code documentation, usage documentation, or forum discussions such as StackOverflow). We make extensive use of named graphs in RDF to make the knowledge graph extensible by the community. We describe a set of generic extraction techniques that we applied to over 1.3M Python files drawn from GitHub, over 2,300 Python modules, as well as 47M forum posts to generate a graph with over 2 billion triples. We also provide a number of initial use cases of the knowledge graph in code assistance, enforcing best practices, debugging and type inference. The graph and all its artifacts are available to the community for use.</p>\n", "tags": ["dataset"], "tsne_embedding": [6.962216377258301, 12.893817901611328]}, {"key": "agashe2019julce", "year": "2019", "title": "JuICe: A Large Scale Distantly Supervised Dataset for Open Domain Context-based Code Generation", "abstract": "<p>Interactive programming with interleaved code snippet cells and natural language markdown is recently gaining popularity in the form of Jupyter notebooks, which accelerate prototyping and collaboration. To study code generation conditioned on a long context history, we present JuICe, a corpus of 1.5 million examples with a curated test set of 3.7K instances based on online programming assignments. Compared with existing contextual code generation datasets, JuICe provides refined human-curated data, open-domain code, and an order of magnitude more training data. Using JuICe, we train models for two tasks: (1) generation of the API call sequence in a code cell, and (2) full code cell generation, both conditioned on the NL-Code history up to a particular code cell. Experiments using current baseline code generation models show that both context and distant supervision aid in generation, and that the dataset is challenging for current systems.</p>\n", "tags": ["dataset", "bimodal"], "tsne_embedding": [3.9827187061309814, -2.385345458984375]}, {"key": "aggarwal2015using", "year": "2015", "title": "Using Machine Translation for Converting Python 2 to Python 3 Code", "abstract": "<p>In this paper, we have tried to use Statistical machine translation in order to convert Python 2 code to Python 3 code. We use data from two projects and achieve a high BLEU score. We also investigate the cross-project training and testing to analyze the errors so as to ascertain differences with previous case. We have described a pilot study on modeling programming languages as natural language to build translation models on the lines of natural languages. This can be further worked on to translate between versions of a programming language or cross-programming-languages code translation.</p>\n", "tags": ["migration"], "tsne_embedding": [2.361804485321045, 2.5731523036956787]}, {"key": "ahmad2020transformer", "year": "2020", "title": "A Transformer-based Approach for Source Code Summarization", "abstract": "<p>Generating a readable summary that describes the functionality of a program is known as source code summarization. In this task, learning code representation by modeling the pairwise relationship between code tokens to capture their long-range dependencies is crucial. To learn code representation for summarization, we explore the Transformer model that uses a self-attention mechanism and has shown to be effective in capturing long-range dependencies. In this work, we show that despite the approach is simple, it outperforms the state-of-the-art techniques by a significant margin. We perform extensive analysis and ablation studies that reveal several important findings, e.g., the absolute encoding of source code tokens\u2019 position hinders, while relative encoding significantly improves the summarization performance. We have made our code publicly available to facilitate future research.</p>\n", "tags": ["summarization"], "tsne_embedding": [3.673835515975952, 0.25437626242637634]}, {"key": "ahmed2019learning", "year": "2019", "title": "Learning Lenient Parsing & Typing via Indirect Supervision", "abstract": "<p>Both professional coders and teachers frequently deal with imperfect (fragmentary, incomplete, ill-formed) code. Such fragments are common in StackOverflow; students also frequently produce ill-formed code, for which instructors, TAs (or students themselves) must find repairs. In either case, the developer experience could be greatly improved if such code could somehow be parsed &amp; typed; this makes them more amenable to use within IDEs and allows early detection and repair of potential errors. We introduce a lenient parser, which can parse &amp; type fragments, even ones with simple errors. Training a machine learner to leniently parse &amp; type imperfect code requires a large training set of pairs of imperfect code and its repair (and/or type information); such training sets are limited by human effort and curation. In this paper, we present a novel indirectly supervised approach to train a lenient parser, without access to such human-curated training data. We leverage the huge corpus of mostly correct code available on Github, and the massive, efficient learning capacity of Transformer-based NN architectures. Using GitHub data, we first create a large dataset of fragments of code and corresponding tree fragments and type annotations; we then randomly corrupt the input fragments (while requiring correct output) by seeding errors that mimic corruptions found in StackOverflow and student data. Using this data, we train high-capacity transformer models to overcome both fragmentation and corruption. With this novel approach, we can achieve reasonable performance on parsing &amp; typing StackOverflow fragments; we also demonstrate that our approach achieves best-in-class performance on a large dataset of student errors.</p>\n", "tags": ["types"], "tsne_embedding": [-8.469992637634277, -5.344999313354492]}, {"key": "allamanis2013mining", "year": "2013", "title": "Mining Source Code Repositories at Massive Scale Using Language Modeling ", "abstract": "<p>The tens of thousands of high-quality open source software projects on the Internet raise the exciting possibility of studying software development by finding patterns across truly large source code repositories. This could enable new tools for developing code, encouraging reuse, and navigating large projects. In this paper, we build the first giga-token probabilistic language model of source code, based on 352 million lines of Java. This is 100 times the scale of the pioneering work by Hindle et al. The giga-token model is significantly better at the code suggestion task than previous models. More broadly, our approach provides a new \u201clens\u201d for analyzing software projects, enabling new complexity metrics based on statistical analysis of large corpora. We call these metrics data-driven complexity metrics. We propose new metrics that measure the complexity of a code module and the topical centrality of a module to a software project. In particular, it is possible to distinguish reusable utility classes from classes that are part of a program\u2019s core logic based solely on general information theoretic criteria.</p>\n", "tags": ["language model"], "tsne_embedding": [5.612248420715332, -5.083770751953125]}, {"key": "allamanis2014learning", "year": "2014", "title": "Learning Natural Coding Conventions", "abstract": "<p>Every programmer has a characteristic style, ranging from preferences\nabout identifier naming to preferences about object relationships and\ndesign patterns. Coding conventions define a consistent syntactic style,\nfostering readability and hence maintainability. When collaborating,\nprogrammers strive to obey a project\u2019s coding conventions. However,\none third of reviews of changes contain feedback about coding conventions,\nindicating that programmers do not always follow them and that project\nmembers care deeply about adherence. Unfortunately, programmers are\noften unaware of coding conventions because inferring them requires a\nglobal view, one that aggregates the many local decisions programmers\nmake and identifies emergent consensus on style. We present Naturalize,\na framework that learns the style of a codebase, and suggests revisions\nto improve stylistic consistency. Naturalize builds on recent work in\napplying statistical natural language processing to source code. We\napply Naturalize to suggest natural identifier names and formatting\nconventions. We present four tools focused on ensuring natural code\nduring development and release management, including code review.\nNaturalize achieves 94% accuracy in its top suggestions for identifier\nnames. We used Naturalize to generate 18 patches for 5 open source\nprojects: 14 were accepted.</p>\n", "tags": ["naming", "language model", "style"], "tsne_embedding": [-10.13827133178711, 2.2817654609680176]}, {"key": "allamanis2014mining", "year": "2014", "title": "Mining Idioms from Source Code", "abstract": "<p>We present the first method for automatically mining code idioms from a corpus of previously written, idiomatic software projects. We take the view that a code idiom is a syntactic fragment that recurs across projects and has a single semantic purpose. Idioms may have metavariables, such as the body of a for loop. Modern IDEs commonly provide facilities for manually defining idioms and inserting them on demand, but this does not help programmers to write idiomatic code in languages or using libraries with which they are unfamiliar. We present Haggis, a system for mining code idioms that builds on recent advanced techniques from statistical natural language processing, namely, nonparametric Bayesian probabilistic tree substitution grammars. We apply Haggis to several of the most popular open source projects from GitHub. We present a wide range of evidence that the resulting idioms are semantically meaningful, demonstrating that they do indeed recur across software projects and that they occur more frequently in illustrative code examples collected from a Q&amp;A site. Manual examination of the most common idioms indicate that they describe important program concepts, including object creation, exception handling, and resource management.</p>\n", "tags": ["pattern mining", "grammar", "AST"], "tsne_embedding": [0.9964050054550171, 4.192008018493652]}, {"key": "allamanis2015bimodal", "year": "2015", "title": "A Bimodal Modelling of Source Code and Natural Language", "abstract": "<p>We consider the problem of building probabilistic models that jointly \nmodel short natural language utterances and source code snippets. The\naim is to bring together recent work on statistical modelling of source\ncode and work on bimodal models of images and natural language. The\nresulting models are useful for a variety of tasks that involve natural\nlanguage and source code. We demonstrate their performance on two\nretrieval tasks: retrieving source code snippets given a natural language\nquery, and retrieving natural language descriptions given a source code\nquery (i.e., source code captioning). Experiments show there to be\npromise in this direction, and that modelling the structure of source\ncode improves performance.</p>\n", "tags": ["search", "grammar", "AST", "bimodal"], "tsne_embedding": [5.75609016418457, -1.0398554801940918]}, {"key": "allamanis2015suggesting", "year": "2015", "title": "Suggesting Accurate Method and Class Names", "abstract": "<p>Descriptive names are a vital part of readable, and hence maintainable, code. Recent progress on automatically suggesting names for local variables tantalizes with the prospect of replicating that success with method and class names.  However, suggesting names for methods and classes is much more difficult. This is because good method and class names need to be functionally descriptive, but suggesting such names requires that the model goes beyond local context. We introduce a neural probabilistic language model for source code that is specifically designed for the method naming problem. Our model learns which names are semantically similar by assigning them to locations, called embeddings, in a high-dimensional continuous space, in such a way that names with similar embeddings tend to be used in similar contexts. These embeddings seem to contain semantic information about tokens, even though they are learned only from statistical co-occurrences of tokens.  Furthermore, we introduce a variant of our model\nthat is, to our knowledge, the first that can propose neologisms, names that have not appeared in the training corpus. We obtain state of the art results on the method, class, and even the simpler variable naming tasks. More broadly, the continuous embeddings that are learned by our model have the potential for wide application within software engineering.</p>\n\n", "tags": ["naming"], "tsne_embedding": [2.165968656539917, 0.3003450036048889]}, {"key": "allamanis2016convolutional", "year": "2016", "title": "A Convolutional Attention Network for Extreme Summarization of Source Code", "abstract": "<p>Attention mechanisms in neural networks have proved useful for problems in which\nthe input and output do not have fixed dimension. Often there exist features that\nare locally translation invariant and would be valuable for directing the model\u2019s attention,\nbut previous attentional architectures are not constructed to learn such features specifically.\nWe introduce an attentional neural network that employs convolution on the input tokens to detect\nlocal time-invariant and long-range topical attention features in a context-dependent way. We\napply this architecture to the problem of extreme summarization of source code snippets into short,\ndescriptive function name-like summaries. Using those features, the model sequentially generates a\nsummary by marginalizing over two attention mechanisms: one that predicts the next summary token based \nn the attention weights of the input tokens and another that is able to copy a code token as-is directly\ninto the summary. We demonstrate our convolutional attention neural network\u2019s performance on 10 popular Java\nprojects showing that it achieves better performance compared to previous attentional mechanisms.</p>\n", "tags": ["naming", "summarization"], "tsne_embedding": [1.8593409061431885, 0.8049426674842834]}, {"key": "allamanis2017mining", "year": "2017", "title": "Mining Semantic Loop Idioms from Big Code", "abstract": "<p>During maintenance, developers spend a lot of time transforming existing code: refactoring, optimizing, and adding checks to make it more robust. Much of this work is the drudgery of identifying and replacing specific patterns, yet it resists automation, because of meaningful patterns are hard to automatically find. We present a technique for mining loop idioms, surprisingly probable semantic patterns that occur in loops, from big code to find meaningful patterns. First, we show that automatically identifiable patterns exist, in great numbers, with a large scale empirical study of loop over 25 MLOC. We find that loops in this corpus are simple and predictable: 90% of them have fewer than 15LOC and 90% have no nesting and very simple control structure. Encouraged by this result, we coil loops to abstract away syntactic diversity to define information rich loop idioms. We show that only 50 loop idioms cover 50% of the concrete loops. We show how loop idioms can help a tool developers identify and prioritize refactorings. We also show how our framework opens the door to data-driven tool and language design discovering opportunities to introduce new API calls and language constructs: loop idioms show that LINQ would benefit from an Enumerate operator, a result confirmed by the fact that precisely this feature is one of the most requested features on StackOverflow with 197 votes and 95k views.</p>\n", "tags": ["pattern mining", "grammar"], "tsne_embedding": [-10.654590606689453, 0.36273548007011414]}, {"key": "allamanis2017smartpaste", "year": "2017", "title": "SmartPaste: Learning to Adapt Source Code", "abstract": "<p>Deep Neural Networks have been shown to succeed at a range of natural\nlanguage tasks such as machine translation and text summarization.\nWhile tasks on source code (ie, formal languages) have been considered\nrecently, most work in this area does not attempt to capitalize on the\nunique opportunities offered by its known syntax and structure. In this\nwork, we introduce SmartPaste, a first task that requires to use such\ninformation. The task is a variant of the program repair problem that\nrequires to adapt a given (pasted) snippet of code to surrounding,\nexisting source code. As first solutions, we design a set of deep\nneural models that learn to represent the context of each variable\nlocation and variable usage in a data flow-sensitive way. Our\nevaluation suggests that our models can learn to solve the SmartPaste\ntask in many cases, achieving 58.6% accuracy, while learning meaningful\nrepresentation of variable usages.</p>\n", "tags": ["representation", "variable misuse"], "tsne_embedding": [5.662540435791016, 1.8432313203811646]}, {"key": "allamanis2018learning", "year": "2018", "title": "Learning to Represent Programs with Graphs", "abstract": "<p>Learning tasks on source code (i.e., formal languages) have been considered recently, but most work has tried to transfer natural language methods and does not capitalize on the unique opportunities offered by code\u2019s known syntax. For example, long-range dependencies induced by using the same variable or function in distant locations are often not considered. We propose to use graphs to represent both the syntactic and semantic structure of code and use graph-based deep learning methods to learn to reason over program structures.</p>\n\n<p>In this work, we present how to construct graphs from source code and how to scale Gated Graph Neural Networks training to such large graphs. We evaluate our method on two tasks: VarNaming, in which a network attempts to predict the name of a variable given its usage, and VarMisuse, in which the network learns to reason about selecting the correct variable that should be used at a given program location. Our comparison to methods that use less structured program representations shows the advantages of modeling known structure, and suggests that our models learn to infer meaningful names and to solve the VarMisuse task in many cases. Additionally, our testing showed that VarMisuse identifies a number of bugs in mature open-source projects.</p>\n", "tags": ["naming", "GNN", "representation", "variable misuse", "defect"], "tsne_embedding": [5.521982192993164, 11.177644729614258]}, {"key": "allamanis2019adverse", "year": "2019", "title": "The Adverse Effects of Code Duplication in Machine Learning Models of Code", "abstract": "<p>The field of big code relies on mining large corpora of code to perform some learning task. A significant threat to this approach has been recently identified by Lopes et al. (2017) who found a large amount of code duplication on GitHub. However, the impact of code duplication has not been noticed by researchers devising machine learning models for source code. In this article, we study the effect of code duplication to machine learning models showing that reported metrics are sometimes inflated by up to 100% when testing on duplicated code corpora compared to the performance on de-duplicated corpora which more accurately represent how machine learning models of code are used by software engineers. We present an \u201cerrata\u201d for widely used datasets, list best practices for collecting code corpora and evaluating machine learning models on them, and release tools to help the community avoid this problem in future research.</p>\n", "tags": ["dataset"], "tsne_embedding": [1.0567169189453125, -3.05021333694458]}, {"key": "allamanis2020typilus", "year": "2020", "title": "Typilus: Neural Type Hints", "abstract": "<p>Type inference over partial contexts in dynamically typed languages is challenging. In this work, we present a graph neural network model that predicts types by probabilistically reasoning over a program\u2019s structure, names, and patterns. The network uses deep similarity learning to learn a TypeSpace \u2013 a continuous relaxation of the discrete space of types \u2013 and how to embed the type properties of a symbol (i.e. identifier) into it. Importantly, our model can employ one-shot learning to predict an open vocabulary of types, including rare and user-defined ones. We realise our approach in Typilus for Python that combines the TypeSpace with an optional type checker. We show that Typilus accurately predicts types. Typilus confidently predicts types for 70% of all annotatable symbols; when it predicts a type, that type optionally type checks 95% of the time. Typilus can also find incorrect type annotations; two important and popular open source libraries, fairseq and allennlp, accepted our pull requests that fixed the annotation errors Typilus discovered.</p>\n", "tags": ["types", "GNN"], "tsne_embedding": [5.9474778175354, 12.705589294433594]}, {"key": "alon2018code2seq", "year": "2019", "title": "code2seq: Generating Sequences from Structured Representations of Code", "abstract": "<p>The ability to generate natural language sequences from source code snippets has a variety of applications such as code summarization, documentation, and retrieval. Sequence-to-sequence (seq2seq) models, adopted from neural machine translation (NMT), have achieved state-of-the-art performance on these tasks by treating source code as a sequence of tokens. We present code2seq: an alternative approach that leverages the syntactic structure of programming languages to better encode source code. Our model represents a code snippet as the set of compositional paths in its abstract syntax tree (AST) and uses attention to select the relevant paths while decoding.</p>\n\n<p>We demonstrate the effectiveness of our approach for two tasks, two programming languages, and four datasets of up to 16M examples. Our model significantly outperforms previous models that were specifically designed for programming languages, as well as general state-of-the-art NMT models. An interactive online demo of our model is available at http://code2seq.org.</p>\n", "tags": ["naming", "summarization", "representation"], "tsne_embedding": [6.159789562225342, 4.314037322998047]}, {"key": "alon2018general", "year": "2018", "title": "A General Path-Based Representation for Predicting Program Properties", "abstract": "<p>Predicting program properties such as names or expression types has a wide range of applications. It can ease the task of programming and increase programmer productivity. A major challenge when learning from programs is how to represent programs in a way that facilitates effective learning. \nWe present a general path-based representation for learning from programs. Our representation is purely syntactic and extracted automatically. The main idea is to represent a program using paths in its abstract syntax tree (AST). This allows a learning model to leverage the structured nature of code rather than treating it as a flat sequence of tokens. \nWe show that this representation is general and can: (i) cover different prediction tasks, (ii) drive different learning algorithms (for both generative and discriminative models), and (iii) work across different programming languages. \nWe evaluate our approach on the tasks of predicting variable names, method names, and full types. We use our representation to drive both CRF-based and word2vec-based learning, for programs of four languages: JavaScript, Java, Python and C#. Our evaluation shows that our approach obtains better results than task-specific handcrafted representations across different tasks and programming languages.</p>\n", "tags": ["naming", "representation"], "tsne_embedding": [4.996427536010742, 0.8055734038352966]}, {"key": "alon2019code2vec", "year": "2019", "title": "code2vec: Learning Distributed Representations of Code", "abstract": "<p>We present a neural model for representing snippets of code as continuous distributed vectors (\u201ccode embeddings\u201d).\n The main idea is to represent a code snippet as a single fixed-length\ncode vector, which can be used to\npredict semantic properties of the snippet. To this end, code is first decomposed to a collection of paths in its\nabstract syntax tree. Then, the network learns the atomic representation of each path while\nsimultaneously\nlearning how to aggregate a set of them.</p>\n\n<p>We demonstrate the effectiveness of our approach by using it to predict a method\u2019s name from the vector\nrepresentation of its body. We evaluate our approach by training a model on a dataset of 12M methods. We\nshow that code vectors trained on this dataset can predict method names from files that were unobserved\nduring training. Furthermore, we show that our model learns useful method name vectors that capture\nsemantic similarities, combinations, and analogies.</p>\n\n<p>A comparison of our approach to previous techniques over the same dataset shows an improvement of\nmore than 75%, making it the first to successfully predict method names based on a large, cross-project\ncorpus. Our trained model, visualizations and vector similarities are available as an interactive online demo at\nhttp://code2vec.org. The code, data and trained models are available at\nhttps://github.com/tech-srl/code2vec.</p>\n", "tags": ["naming", "summarization", "representation"], "tsne_embedding": [8.929677963256836, -0.302359938621521]}, {"key": "alond2019structural", "year": "2019", "title": "Structural Language Models for Any-Code Generation", "abstract": "<p>We address the problem of Any-Code Generation (AnyGen) - generating code without any restriction on the vocabulary or structure. The state-of-the-art in this problem is the sequence-to-sequence (seq2seq) approach, which treats code as a sequence and does not leverage any structural information. We introduce a new approach to AnyGen that leverages the strict syntax of programming languages to model a code snippet as a tree - structural language modeling (SLM). SLM estimates the probability of the program\u2019s abstract syntax tree (AST) by decomposing it into a product of conditional probabilities over its nodes. We present a neural model that computes these conditional probabilities by considering all AST paths leading to a target node. Unlike previous structural techniques that have severely restricted the kinds of expressions that can be generated, our approach can generate arbitrary expressions in any programming language. Our model significantly outperforms both seq2seq and a variety of existing structured approaches in generating Java and C# code. We make our code, datasets, and models available online.</p>\n", "tags": ["generation"], "tsne_embedding": [7.401042461395264, -1.3901593685150146]}, {"key": "amodio2017neural", "year": "2017", "title": "Neural Attribute Machines for Program Generation", "abstract": "<p>Recurrent neural networks have achieved remarkable success at generating sequences with complex structures, thanks to advances that include richer embeddings of input and cures for vanishing gradients. Trained only on sequences from a known grammar, though, they can still struggle to learn rules and constraints of the grammar. Neural Attribute Machines (NAMs) are equipped with a logical machine that represents the underlying grammar, which is used to teach the constraints to the neural machine by (i) augmenting the input sequence, and (ii) optimizing a custom loss function. Unlike traditional RNNs, NAMs are exposed to the grammar, as well as samples from the language of the grammar. During generation, NAMs make significantly fewer violations of the constraints of the underlying grammar than RNNs trained only on samples from the language of the grammar.</p>\n\n", "tags": ["grammar", "generation", "representation"], "tsne_embedding": [1.1194099187850952, 11.772555351257324]}, {"key": "arakelyan2020towards", "year": "2020", "title": "Towards Learning Representations of Binary Executable Files for Security Tasks", "abstract": "<p>Tackling binary analysis problems has traditionally implied manually defining rules and heuristics. As an alternative, we are suggesting using machine learning models for learning distributed representations of binaries that can be applicable for a number of downstream tasks. We construct a computational graph from the binary executable and use it with a graph convolutional neural network to learn a high dimensional representation of the program. We show the versatility of this approach by using our representations to solve two semantically different binary analysis tasks \u2013 algorithm classification and vulnerability discovery. We compare the proposed approach to our own strong baseline as well as published results and demonstrate improvement on the state of the art methods for both tasks.</p>\n", "tags": ["GNN", "representation"], "tsne_embedding": [7.496018886566162, 9.686734199523926]}, {"key": "ashwath2020predicting", "year": "2020", "title": "Predicting Vulnerability in Large Codebases With Deep Code Representation", "abstract": "<p>Currently, while software engineers write code for various modules, quite often, various types of errors - coding, logic, semantic, and others (most of which are not caught by compilation and other tools) get introduced. Some of these bugs might be found in the later stage of testing, and many times it is reported by customers on production code. Companies have to spend many resources, both money and time in finding and fixing the bugs which would have been avoided if coding was done right. Also, concealed flaws in software can lead to security vulnerabilities that potentially allow attackers to compromise systems and applications. Interestingly, same or similar issues/bugs, which were fixed in the past (although in different modules), tend to get introduced in production code again.\nWe developed a novel AI-based system which uses the deep representation of Abstract Syntax Tree (AST) created from the source code and also the active feedback loop to identify and alert the potential bugs that could be caused at the time of development itself i.e. as the developer is writing new code (logic and/or function). This tool integrated with IDE as a plugin would work in the background, point out existing similar functions/code-segments and any associated bugs in those functions. The tool would enable the developer to incorporate suggestions right at the time of development, rather than waiting for UT/QA/customer to raise a defect.\nWe assessed our tool on both open-source code and also on Cisco codebase for C and C++ programing language. Our results confirm that deep representation of source code and the active feedback loop is an assuring approach for predicting security and other vulnerabilities present in the code.</p>\n", "tags": ["AST", "program analysis", "static analysis"], "tsne_embedding": [-3.8328957557678223, -5.380051136016846]}, {"key": "aye2020sequence", "year": "2020", "title": "Sequence Model Design for Code Completion in the Modern IDE", "abstract": "<p>Code completion plays a prominent role in modern integrated development environments (IDEs). Machine learning has become ubiquitous in analogous natural language writing and search software, surfacing more relevant autocompletions and search suggestions in fewer keystrokes. Prior research has reported training high-accuracy, deep neural networks for modeling source code, but little attention has been given to the practical constraints imposed by interactive developer tools. In particular, neural language models for source code modeling like the one described in Maybe Deep Neural Networks are the Best Choice for Modeling Source Code are framed around code completion, but only report accuracy of next-token prediction. However, in order for a language model (LM) to work well within real-world code completion systems, it must also always make suggestions that produce valid code that typechecks to support code completion\u2019s role in correctness-checking; return instantaneous results to help programmers code more efficiently in fewer keystrokes; and be small enough to fit comfortably on disk and in memory on developer workstations, since virtually all modern IDEs run locally and support offline usage. To meet these additional requirements, we propose a novel design for predicting top-k next tokens that combines static analysis\u2019 ability to enumerate all valid keywords and in-scope identifiers with the ability of a language model to place a probability distribution over them. Our model mixes character-level input representation with token output to represent out-of-vocabulary (OOV) tokens meaningfully and minimize prediction latency. OOV tokens can be predicted through detection of local repetition common in software. This design achieves state-of-art accuracy in source code modeling and fits the constraints imposed by real-world code completion implementations in modern IDEs.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [-8.482331275939941, -1.9507368803024292]}, {"key": "barone2017parallel", "year": "2017", "title": "A parallel corpus of Python functions and documentation strings for automated code documentation and code generation", "abstract": "<p>Automated documentation of programming source code and automated code generation from natural language are challenging tasks of both practical and scientific interest. Progress in these areas has been limited by the low availability of parallel corpora of code and natural language descriptions, which tend to be small and constrained to specific domains.</p>\n\n<p>In this work we introduce a large and diverse parallel corpus of a hundred thousands Python functions with their documentation strings (\u201cdocstrings\u201d) generated by scraping open source repositories on GitHub. We describe baseline results for the code documentation and code generation tasks obtained by neural machine translation. We also experiment with \ndata augmentation techniques to further increase the amount of training data.</p>\n\n<p>We release our datasets and processing scripts in order to stimulate research in these areas.</p>\n\n", "tags": ["documentation", "summarization", "dataset"], "tsne_embedding": [1.8276259899139404, -3.2884724140167236]}, {"key": "bavishi2017context2name", "year": "2017", "title": "Context2Name: A Deep Learning-Based Approach to Infer Natural Variable Names from Usage Contexts", "abstract": "<p>Most of the JavaScript code deployed in the wild has been minified, a process in which identifier names are replaced\nwith short, arbitrary and meaningless names. Minified code occupies less space, but also makes the code extremely difficult to manually inspect and understand. This paper presents Context2Name, a deep learning-based technique that partially reverses the effect of minification by predicting natural\nidentifier names for minified names. The core idea is to predict from the usage context of a variable a name that captures\nthe meaning of the variable. The approach combines a lightweight, token-based static analysis with an auto-encoder\nneural network that summarizes usage contexts and a recurrent neural network that predict natural names for a given\nusage context. We evaluate Context2Name\nwith a large corpus of real-world JavaScript code and show that it successfully predicts 60.4% of all minified identifiers. A comparison\nwith the state-of-the-art tools JSNice and JSNaughty shows\nthat our approach predicts 17% and 43% more names than the\nbest existing approaches, while taking only 2.6 milliseconds\nto predict a name, on average.</p>\n", "tags": ["naming"], "tsne_embedding": [-3.6217715740203857, 5.204199314117432]}, {"key": "bavishi2019autopandas", "year": "2019", "title": "AutoPandas: neural-backed generators for program synthesis", "abstract": "<p>Developers nowadays have to contend with a growing number of APIs. While in the long-term they are very useful to developers, many modern APIs have an incredibly steep learning curve, due to their hundreds of functions handling many arguments, obscure documentation, and frequently changing semantics. For APIs that perform data transformations, novices can often provide an I/O example demonstrating the desired transformation, but may be stuck on how to translate it to the API. A programming-by-example synthesis engine that takes such I/O examples and directly produces programs in the target API could help such novices. Such an engine presents unique challenges due to the breadth of real-world APIs, and the often-complex constraints over function arguments. We present a generator-based synthesis approach to contend with these problems. This approach uses a program candidate generator, which encodes basic constraints on the space of programs. We introduce neural-backed operators which can be seamlessly integrated into the program generator. To improve the efficiency of the search, we simply use these operators at non-deterministic decision points, instead of relying on domain-specific heuristics. We implement this technique for the Python pandas library in AutoPandas. AutoPandas supports 119 pandas dataframe transformation functions. We evaluate AutoPandas on 26 real-world benchmarks and find it solves 17 of them.</p>\n", "tags": ["synthesis", "GNN", "API"], "tsne_embedding": [1.824886679649353, -2.092557191848755]}, {"key": "beltramelli2017pix2code", "year": "2017", "title": "pix2code: Generating Code from a Graphical User Interface Screenshot", "abstract": "<p>Transforming a graphical user interface screenshot created by a designer into computer code is a typical task conducted by a developer in order to build customized software, websites and mobile applications. In this paper, we show that Deep Learning techniques can be leveraged to automatically generate code given a graphical user interface screenshot as input. Our model is able to generate code targeting three different platforms (i.e. iOS, Android and web-based technologies) from a single input image with over 77% of accuracy.</p>\n\n", "tags": ["generation", "bimodal"], "tsne_embedding": [1.4715147018432617, -5.585085868835449]}, {"key": "bennun2018neural", "year": "2018", "title": "Neural Code Comprehension: A Learnable Representation of Code Semantics", "abstract": "<p>With the recent success of embeddings in natural language processing, research has been conducted into applying similar methods to code analysis. Most works attempt to process the code directly or use a syntactic tree representation, treating it like sentences written in a natural language. However, none of the existing methods are sufficient to comprehend program semantics robustly, due to structural features such as function calls, branching, and interchangeable order of statements. In this paper, we propose a novel processing technique to learn code semantics, and apply it to a variety of program analysis tasks. In particular, we stipulate that a robust distributional hypothesis of code applies to both human- and machine-generated programs. Following this hypothesis, we define an embedding space, inst2vec, based on an Intermediate Representation (IR) of the code that is independent of the source programming language. We provide a novel definition of contextual flow for this IR, leveraging both the underlying data- and control-flow of the program. We then analyze the embeddings qualitatively using analogies and clustering, and evaluate the learned representation on three different high-level tasks. We show that with a single RNN architecture and pre-trained fixed embeddings, inst2vec outperforms specialized approaches for performance prediction (compute device mapping, optimal thread coarsening); and algorithm classification from raw code (104 classes), where we set a new state-of-the-art.</p>\n", "tags": ["representation"], "tsne_embedding": [3.1322765350341797, 3.2701876163482666]}, {"key": "bhatia2016automated", "year": "2016", "title": "Automated Correction for Syntax Errors in Programming Assignments using Recurrent Neural Networks", "abstract": "<p>We present a method for automatically generating repair feedback for syntax errors for introductory programming problems. Syntax errors constitute one of the largest classes of errors (34%) in our dataset of student submissions obtained from a MOOC course on edX. The previous techniques for generating automated feedback on programming assignments have focused on functional correctness and style considerations of student programs. These techniques analyze the program AST of the program and then perform some dynamic and symbolic analyses to compute repair feedback. Unfortunately, it is not possible to generate ASTs for student programs with syntax errors and therefore the previous feedback techniques are not applicable in repairing syntax errors. We present a technique for providing feedback on syntax errors that uses Recurrent neural networks (RNNs) to model syntactically valid token sequences. Our approach is inspired from the recent work on learning language models from Big Code (large code corpus). For a given programming assignment, we first learn an RNN to model all valid token sequences using the set of syntactically correct student submissions. Then, for a student submission with\nsyntax errors, we query the learnt RNN model with the prefix token sequence to predict token sequences that can fix the error by either replacing or inserting the predicted token sequence at the error location. We evaluate our technique on over 14, 000 student submissions with syntax errors. Our technique can completely repair 31.69% (4501/14203) of submissions with syntax errors and in addition partially correct 6.39% (908/14203) of the submissions.</p>\n", "tags": ["repair"], "tsne_embedding": [-8.145730018615723, -6.51169490814209]}, {"key": "bhatia2018neurosymbolic", "year": "2018", "title": "Neuro-symbolic program corrector for introductory programming assignments", "abstract": "<p>Automatic correction of programs is a challenging problem with numerous real world applications in security, verification, and education. One application that is becoming increasingly important is the correction of student submissions in online courses for providing feedback. Most existing program repair techniques analyze Abstract Syntax Trees (ASTs) of programs, which are unfortunately unavailable for programs with syntax errors. In this paper, we propose a novel Neuro-symbolic approach that combines neural networks with constraint-based reasoning. Specifically, our method first uses a Recurrent Neural Network (RNN) to perform syntax repairs for the buggy programs; subsequently, the resulting syntactically-fixed programs are repaired using constraint-based techniques to ensure functional correctness. The RNNs are trained using a corpus of syntactically correct submissions for a given programming assignment, and are then queried to fix syntax errors in an incorrect programming submission by replacing or inserting the predicted tokens at the error location. We evaluate our technique on a dataset comprising of over 14,500 student submissions with syntax errors. Our method is able to repair syntax errors in 60% (8689) of submissions, and finds functionally correct repairs for 23.8% (3455) submissions.</p>\n", "tags": ["repair"], "tsne_embedding": [-7.809405326843262, -6.256154537200928]}, {"key": "bhoopchand2016learning", "year": "2016", "title": "Learning Python Code Suggestion with a Sparse Pointer Network", "abstract": "<p>To enhance developer productivity, all modern integrated development environments (IDEs) include code suggestion functionality that proposes likely next tokens at the cursor. While current IDEs work well for statically-typed languages, their reliance on type annotations means that they do not provide the same level of support for dynamic programming languages as for statically-typed languages. Moreover, suggestion engines in modern IDEs do not propose expressions or multi-statement idiomatic code. Recent work has shown that language models can improve code suggestion systems by learning from software repositories. This paper introduces a neural language model with a sparse pointer network aimed at capturing very long-range dependencies. We release a large-scale code suggestion corpus of 41M lines of Python code crawled from GitHub. On this corpus, we found standard neural language models to perform well at suggesting local phenomena, but struggle to refer to identifiers that are introduced many tokens in the past. By augmenting a neural language model with a pointer network specialized in referring to predefined classes of identifiers, we obtain a much lower perplexity and a 5 percentage points increase in accuracy for code suggestion compared to an LSTM baseline. In fact, this increase in code suggestion accuracy is due to a 13 times more accurate prediction of identifiers. Furthermore, a qualitative analysis shows this model indeed captures interesting long-range dependencies, like referring to a class member defined over 60 tokens in the past.</p>\n", "tags": ["language model", "autocomplete"], "tsne_embedding": [-3.595399856567383, 4.322347164154053]}, {"key": "bichsel2016statistical", "year": "2016", "title": "Statistical Deobfuscation of Android Applications", "abstract": "<p>This work presents a new approach for deobfuscating Android APKs based on probabilistic learning of large code bases (termed \u201cBig Code\u201d). The key idea is to learn a probabilistic model over thousands of non-obfuscated Android applications and to use this probabilistic model to deobfuscate new, unseen Android APKs. The concrete focus of the paper is on reversing layout obfuscation, a popular transformation which renames key program elements such as classes, packages, and methods, thus making it difficult to understand what the program does. Concretely, the paper: (i) phrases the layout deobfuscation problem of Android APKs as structured prediction in a probabilistic graphical model, (ii) instantiates this model with a rich set of features and constraints that capture the Android setting, ensuring both semantic equivalence and high prediction accuracy, and (iii) shows how to leverage powerful inference and learning algorithms to achieve overall precision and scalability of the probabilistic predictions.</p>\n\n<p>We implemented our approach in a tool called DeGuard and used it to: (i) reverse the layout obfuscation performed by the popular ProGuard system on benign, open-source applications, (ii) predict third-party libraries imported by benign APKs (also obfuscated by ProGuard), and (iii) rename obfuscated program elements of Android malware. The experimental results indicate that DeGuard is practically effective: it recovers 79.1% of the program element names obfuscated with ProGuard, it predicts third-party libraries with accuracy of 91.3%, and it reveals string decoders and classes that handle sensitive data in Android malware.</p>\n\n", "tags": ["deobfuscation", "naming"], "tsne_embedding": [-6.314533710479736, 1.3913930654525757]}, {"key": "bielik2016phog", "year": "2016", "title": "PHOG: Probabilistic Model for Code", "abstract": "<p>We introduce a new generative model for code called probabilistic higher order grammar (PHOG). PHOG generalizes probabilistic context free grammars (PCFGs) by allowing conditioning of a production rule beyond the parent non-terminal, thus capturing rich contexts relevant to programs. Even though PHOG is more powerful than a PCFG, it can be learned from data just as efficiently. We trained a PHOG model on a large JavaScript code corpus and show that it is more precise than existing models, while similarly fast. As a result, PHOG can immediately benefit existing programming tools based on probabilistic models of code.</p>\n", "tags": ["grammar", "generation", "language model"], "tsne_embedding": [4.845308780670166, -0.7343668341636658]}, {"key": "bielik2020adversarial", "year": "2020", "title": "Adversarial Robustness for Code", "abstract": "<p>We propose a novel technique which addresses the challenge of learning accurate and robust models of code in a principled way. Our method consists of three key components: (i) learning to abstain from making a prediction if uncertain, (ii) adversarial training, and (iii) representation refinement which learns the program parts relevant for the prediction and abstracts the rest. These components are used to iteratively train multiple models, each of which learns a suitable program representation necessary to make robust predictions on a different subset of the dataset. We instantiated our approach to the task of type inference for dynamically typed languages and demonstrate its effectiveness by learning a model that achieves 88% accuracy and 84% robustness. Further, our evaluation shows that using the combination of all three components is key to obtaining accurate and robust models.</p>\n", "tags": ["adversarial", "types"], "tsne_embedding": [-1.1726051568984985, 4.5184502601623535]}, {"key": "briem2020offside", "year": "2020", "title": "OffSide: Learning to Identify Mistakes in Boundary Conditions", "abstract": "<p>Mistakes in boundary conditions are the cause of many bugs in software.\nThese mistakes happen when, e.g., developers make use of <code class=\"language-plaintext highlighter-rouge\">&lt;</code> or <code class=\"language-plaintext highlighter-rouge\">&gt;</code> in cases\nwhere they should have used <code class=\"language-plaintext highlighter-rouge\">&lt;=</code> or <code class=\"language-plaintext highlighter-rouge\">&gt;=</code>. Mistakes in boundary conditions\nare often hard to find and manually detecting them might be very time-consuming\nfor developers. While researchers have been proposing techniques to cope with\nmistakes in the boundaries for a long time, the automated detection of such bugs still\nremains a challenge. We conjecture that, for a tool to be able to precisely identify mistakes\nin boundary conditions, it should be able to capture the overall context of the source code\nunder analysis. In this work, we propose a deep learning model that learn mistakes in boundary\nconditions and, later, is able to identifythem in unseen code snippets. We train and test a\nmodel on over 1.5 million code snippets, with and without mistakes in different boundary conditions.\nOur model shows an accuracy from 55% up to 87%. The model is also able to detect 24 out of 41\nreal-world bugs;however, with a high false positive rate. The existing state-of-the-practice linter\ntools are not able to detect any of the bugs. We hope this paper can pave the road towards deep\nlearning models that will be able to support developers in detecting mistakes in boundary conditions.</p>\n", "tags": ["defect"], "tsne_embedding": [-4.587807655334473, -5.500904560089111]}, {"key": "brockschmidt2019generative", "year": "2019", "title": "Generative Code Modeling with Graphs", "abstract": "<p>Generative models forsource code are an interesting structured prediction problem, requiring to reason about both hard syntactic and semantic constraints as well as about natural, likely programs. We present a novel model for this problem that uses a graph to represent the intermediate state of the generated output. Our model generates code by interleaving grammar-driven expansion steps with graph augmentation and neural message passing steps. An experimental evaluation shows that our new model can generate semantically meaningful expressions, outperforming a range of strong baselines.</p>\n", "tags": ["grammar", "generation", "GNN"], "tsne_embedding": [6.618169784545898, 10.238835334777832]}, {"key": "brody2020neural", "year": "2020", "title": "Neural Edit Completion", "abstract": "<p>We address the problem of predicting edit completions based on a learned model that was trained on past edits. Given a code snippet that is partially edited, our goal is to predict a completion of the edit for the rest of the snippet. We refer to this task as the EditCompletion task and present a novel approach for tackling it. The main idea is to directly represent structural edits. This allows us to model the likelihood of the edit itself, rather than learning the likelihood of the edited code. We represent an edit operation as a path in the program\u2019s Abstract Syntax Tree (AST), originating from the source of the edit to the target of the edit. Using this representation, we present a powerful and lightweight neural model for the EditCompletion task. We conduct a thorough evaluation, comparing our approach to a variety of representation and modeling approaches that are driven by multiple strong models such as LSTMs, Transformers, and neural CRFs. Our experiments show that our model achieves 28% relative gain over state-of-the-art sequential models and 2\u00d7 higher accuracy than syntactic models that learn to generate the edited code instead of modeling the edits directly. We make our code, dataset, and trained models publicly available.</p>\n", "tags": ["edit", "AST", "autocomplete"], "tsne_embedding": [3.4751012325286865, -1.0668319463729858]}, {"key": "bruch2009learning", "year": "2009", "title": "Learning from Examples to Improve Code Completion Systems", "abstract": "<p>The suggestions made by current IDE\u2019s code completion features are based exclusively on static type system of the programming language. As a result, often proposals are made which are irrelevant for a particular working context. Also, these suggestions are ordered alphabetically rather than by their relevance in a particular context. In this paper, we present intelligent code completion systems that learn from existing code repositories. We have implemented three such systems, each using the information contained in\nrepositories in a different way. We perform a large-scale quantitative evaluation of these systems, integrate the best performing one into Eclipse, and evaluate the latter also by a user study. Our experiments give evidence that intelligent code completion systems which learn from examples significantly outperform mainstream code completion systems in terms of the relevance of their suggestions and thus have the potential to enhance developers\u2019 productivity.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [-3.2052385807037354, 0.36602407693862915]}, {"key": "buech2019learning", "year": "2019", "title": "Learning-based Recursive Aggregation of Abstract Syntax Trees for Code Clone Detection", "abstract": "<p>Code clone detection remains a crucial challenge in maintaining software projects. Many classic approaches rely on handcrafted aggregation schemes, while recent work uses supervised or unsupervised learning. In this work, we study several aspects of aggregation schemes for code clone detection based on supervised learning. To this aim, we implement an AST-based Recursive Neural Network. Firstly, our ablation study shows the influence of model choices and hyperparameters. We introduce error scaling as a way to effectively and efficiently address the class imbalance problem arising in code clone detection. Secondly, we study the influence of pretrained embeddings representing nodes in ASTs. We show that simply averaging all node vectors of a given AST yields strong baseline aggregation scheme. Further, learned AST aggregation schemes greatly benefit from pretrained node embeddings. Finally, we show the importance of carefully separating training and test data by clone clusters, to reliably measure generalization of models learned with supervision.</p>\n", "tags": ["AST", "grammar", "clone"], "tsne_embedding": [7.889636039733887, -0.4606820046901703]}, {"key": "bui2018bilateral", "year": "2018", "title": "Bilateral Dependency Neural Networks for Cross-Language Algorithm Classification", "abstract": "<p>Algorithm  classification  is  to  automatically  identify\nthe  classes  of  a  program  based  on  the  algorithm(s)  and/or  data\nstructure(s)  implemented  in  the  program.  It  can  be  useful  for\nvarious tasks, such as code reuse, code theft detection, and malware detection. Code similarity metrics, on the basis of features\nextracted from syntax and semantics, have been used to classify\nprograms.  Such  features,  however,  often  need  manual  selection\neffort  and  are  specific  to  individual  programming  languages,\nlimiting  the  classifiers  to  programs  in  the  same  language.\nTo recognize the similarities and differences among algorithms\nimplemented   in   different   languages,   this   paper   describes   a\nframework  of  Bilateral  Neural  Networks  (Bi-NN)  that  builds  a\nneural  network  on  top  of  two  underlying  sub-networks,  each  of\nwhich encodes syntax and semantics of code in one language. A\nwhole  Bi-NN  can  be  trained  with  bilateral  programs  that  implement the same algorithms and/or data structures in different\nlanguages  and  then  be  applied  to  recognize  algorithm  classes\nacross  languages.</p>\n\n<p>We  have  instantiated  the  framework  with  several  kinds  of\ntoken-,  tree-  and  graph-based  neural  networks  that  encode  and\nlearn  various  kinds  of  information  in  code.  We  have  applied\nthe  instances  of  the  framework  to  a  code  corpus  collected  from\nGitHub containing thousands of Java and C++ programs imple-\nmenting 50 different algorithms and data structures. Our evalua-\ntion results show that the use of Bi-NN indeed produces promising\nalgorithm  classification  results  both  within  one  language  and\nacross  languages,  and  the  encoding  of  dependencies  from  code\ninto  the  underlying  neural  networks  helps  improve  algorithm\nclassification  accuracy  further.  In  particular,  our  custom-built\ndependency trees with tree-based convolutional neural networks\nachieve  the  highest  classification  accuracy  among  the  different\ninstances  of  the  framework  that  we  have  evaluated.  Our  study\npoints  to  a  possible  future  research  direction  to  tailor  bilateral\nand  multilateral  neural  networks  that  encode  more  relevant\nsemantics  for  code  learning,  mining  and  analysis  tasks</p>\n", "tags": ["representation"], "tsne_embedding": [4.937786102294922, 3.8467421531677246]}, {"key": "bui2018cross", "year": "2018", "title": "Cross-Language Learning for Program Classification using Bilateral Tree-Based Convolutional Neural Networks", "abstract": "<p>Towards the vision of translating code that implements an algorithm from one programming language into another, this\npaper  proposes  an  approach  for  automated  program  classification using\nbilateral tree-based convolutional neural networks\n(BiTBCNNs).  It  is  layered  on  top  of  two  tree-based\nconvolutional neural networks (TBCNNs), each of which recognizes the algorithm of code written in an individual programming language. The combination layer of the networks\nrecognizes the similarities and differences among code in different programming languages. The BiTBCNNs are trained\nusing  the  source  code  in  different  languages  but  known  to\nimplement  the  same  algorithms  and/or  functionalities.  For\na  preliminary  evaluation,  we  use  3591  Java  and  3534  C++\ncode snippets from 6 algorithms we crawled systematically\nfrom GitHub. We obtained over 90% accuracy in the cross-language binary classification task to tell whether any given\ntwo code snippets implement a same algorithm. Also, for the\nalgorithm classification task, i.e., to predict which one of the\nsix algorithm labels is implemented by an arbitrary C++ code\nsnippet, we achieved over 80% precision.</p>\n", "tags": ["representation", "grammar"], "tsne_embedding": [4.923643112182617, 3.9183669090270996]}, {"key": "bui2018hierarchical", "year": "2018", "title": "Hierarchical Learning of Cross-Language Mappings through Distributed Vector Representations for Code", "abstract": "<p>Translating a program written in one programming language to another can be useful for software development tasks that need functionality implementations in different languages. Although past studies have considered this problem, they may be either specific to the language grammars, or specific to certain kinds of code elements (e.g., tokens, phrases, API uses). This paper proposes a new approach to automatically learn cross-language representations for various kinds of structural code elements that may be used for program translation. Our key idea is two folded: First, we normalize and enrich code token streams with additional structural and semantic information, and train cross-language vector representations for the tokens (a.k.a. shared embeddings based on word2vec, a neural-network-based technique for producing word embeddings; Second, hierarchically from bottom up, we construct shared embeddings for code elements of higher levels of granularity (e.g., expressions, statements, methods) from the embeddings for their constituents, and then build mappings among code elements across languages based on similarities among embeddings. \nOur preliminary evaluations on about 40,000 Java and C# source files from 9 software projects show that our approach can automatically learn shared embeddings for various code elements in different languages and identify their cross-language mappings with reasonable Mean Average Precision scores. When compared with an existing tool for mapping library API methods, our approach identifies many more mappings accurately. The mapping results and code can be accessed at this https URL. We believe that our idea for learning cross-language vector representations with code structural information can be a useful step towards automated program translation.</p>\n", "tags": ["representation"], "tsne_embedding": [5.622296333312988, 4.929583549499512]}, {"key": "bui2019learning", "year": "2019", "title": "SAR: Learning Cross-Language API Mappings with Little Knowledge", "abstract": "<p>To save manual effort, developers often translate programs from one programming language to another, instead of implementing it from scratch. Translating application program interfaces (APIs) used in one language to functionally equivalent ones available in another language is an important aspect of program translation. Existing approaches facilitate the translation by automatically identifying the API mappings across programming languages. However, all these approaches still require large amount of manual effort in preparing parallel program corpora, ranging from pairs of APIs, to manually identified code in different languages that are considered as functionally equivalent. To minimize the manual effort in identifying parallel program corpora and API mappings, this paper aims at an automated approach to map APIs across languages with much less knowledge a priori needed than other existing approaches. The approach is based on an realization of the notion of domain adaption combined with code embedding, which can better align two vector spaces: taking as input large sets of programs, our approach first generates numeric vector representations of the programs, especially the APIs used in each language, and it adapts generative adversarial networks (GAN) to align the vectors from the spaces of two languages. For a better alignment, we initialize the GAN with parameters derived from optional API mapping seeds that can be identified accurately with a simple automatic signature-based matching heuristic. Then the cross-language API mappings can be identified via nearest-neighbors queries in the aligned vector spaces.</p>\n", "tags": ["representation", "API"], "tsne_embedding": [4.93565559387207, 5.624118804931641]}, {"key": "bui2020efficient", "year": "2020", "title": "Efficient Framework for Learning Code Representations through Semantic-Preserving Program Transformations", "abstract": "<p>Recent learning techniques for the representation of code depend mostly on human-annotated (labeled) data. In this work, we are proposing Corder, a self-supervised learning system that can learn to represent code without having to label data. The key innovation is that we train the source code model by asking it to recognize similar and dissimilar code snippets through a contrastive learning paradigm. We use a set of semantic-preserving transformation operators to generate snippets that are syntactically diverse but semantically equivalent. The contrastive learning objective, at the same time, maximizes agreement between different views of the same snippets and minimizes agreement between transformed views of different snippets. We train different instances of Corder on 3 neural network encoders, which are Tree-based CNN, ASTNN, and Code2vec over 2.5 million unannotated Java methods mined from GitHub. Our result shows that the Corder pre-training improves code classification and method name prediction with large margins. Furthermore, the code vectors generated by Corder are adapted to code clustering which has been shown to significantly beat the other baselines.</p>\n", "tags": ["pre-training"], "tsne_embedding": [7.084998607635498, -0.08265093713998795]}, {"key": "cai2020tag", "year": "2020", "title": "TAG : Type Auxiliary Guiding for Code Comment Generation", "abstract": "<p>Existing leading code comment generation approaches with the structure-to-sequence framework ignores the type information of the interpretation of the code, e.g., operator, string, etc. However, introducing the type information into the existing framework is non-trivial due to the hierarchical dependence among the type information. In order to address the issues above, we propose a Type Auxiliary Guiding encoder-decoder framework for the code comment generation task which considers the source code as an N-ary tree with type information associated with each node. Specifically, our framework is featured with a Type-associated Encoder and a Type-restricted Decoder which enables adaptive summarization of the source code. We further propose a hierarchical reinforcement learning method to resolve the training difficulties of our proposed framework. Extensive evaluations demonstrate the state-of-the-art performance of our framework with both the auto-evaluated metrics and case studies.</p>\n", "tags": ["bimodal", "documentation"], "tsne_embedding": [1.101100206375122, -0.2487572431564331]}, {"key": "cambronero2019deep", "year": "2019", "title": "When Deep Learning Met Code Search", "abstract": "<p>There have been multiple recent proposals on using deep neural networks for code search using natural language. Common across these proposals is the idea of embedding code and natural language queries, into real vectors and then using vector distance to approximate semantic correlation between code and the query. Multiple approaches exist for learning these embeddings, including unsupervised techniques, which rely only on a corpus of code examples, and supervised techniques, which use an aligned corpus of paired code and natural language descriptions. The goal of this supervision is to produce embeddings that are more similar for a query and the corresponding desired code snippet.</p>\n\n<p>Clearly, there are choices in whether to use supervised techniques at all, and if one does, what sort of network and training to use for supervision. This paper is the first to evaluate these choices systematically. To this end, we assembled implementations of state-of-the-art techniques to run on a common platform, training and evaluation corpora. To explore the design space in network complexity, we also introduced a new design point that is a minimal supervision extension to an existing unsupervised technique.</p>\n\n<p>Our evaluation shows that: 1. adding supervision to an existing unsupervised technique can improve performance, though not necessarily by much; 2. simple networks for supervision can be more effective that more sophisticated sequence-based networks for code search; 3. while it is common to use docstrings to carry out supervision, there is a sizeable gap between the effectiveness of docstrings and a more query-appropriate supervision corpus.</p>\n", "tags": ["search"], "tsne_embedding": [8.057950019836426, 0.8935347199440002]}, {"key": "campbell2014syntax", "year": "2014", "title": "Syntax Errors Just Aren\u2019t Natural: Improving Error Reporting with Language Models", "abstract": "<p>A frustrating aspect of software development is that compiler error messages often fail to locate the actual cause of a syntax error. An errant semicolon or brace can result in\nmany errors reported throughout the file. We seek to find the actual source of these syntax errors by relying on the consistency of software: valid source code is usually repetitive and unsurprising. We exploit this consistency by constructing a simple N-gram language model of lexed source code tokens. We implemented an automatic Java syntax-error locator using the corpus of the project itself and evaluated its performance on mutated source code from several projects. Our tool, trained on the past versions of a project, can effectively augment the syntax error locations produced by the native compiler. Thus we provide a methodology and tool that exploits the naturalness of software source code to detect syntax errors alongside the parser.</p>\n", "tags": ["repair", "language model"], "tsne_embedding": [-5.87691068649292, -0.8157102465629578]}, {"key": "cerulo2013hidden", "year": "2013", "title": "A Hidden Markov Model to Detect Coded Information Islands in Free Text", "abstract": "<p>Emails and issue reports capture useful knowledge about development practices, bug fixing, and change activities. Extracting such a content is challenging, due to the mix-up of\nsource code and natural language, unstructured text.</p>\n\n<p>In this paper we introduce an approach, based on Hidden Markov Models (HMMs), to extract coded information islands, such as source code, stack traces, and patches, from free text at a token level of granularity. We train a HMM for each category of information contained in the text, and adopt the Viterbi algorithm to recognize whether the sequence of tokens \u2014 e.g., words, language keywords, numbers, parentheses, punctuation marks, etc. \u2014 observed in a text switches among those HMMs. Although our implementation focuses on extracting source code from emails, the approach could be easily extended to include in principle any text-interleaved language.</p>\n\n<p>We evaluated our approach with respect to the state of art on a set of development emails and bug reports drawn from the software repositories of well known open source systems. Results indicate an accuracy between 82% and 99%, which is in line with existing approaches which, differently from ours, require the manual definition of regular expressions or parsers.</p>\n\n", "tags": ["information extraction"], "tsne_embedding": [-2.008971691131592, 5.936010837554932]}, {"key": "cerulo2015irish", "year": "2015", "title": "Irish: A Hidden Markov Model to detect coded information islands in free text", "abstract": "<p>Developers\u2019 communication, as contained in emails, issue trackers, and forums, is a precious source of information to support the development process. For example, it can\nbe used to capture knowledge about development practice or about a software project itself. Thus, extracting the content of developers\u2019 communication can be useful to support\nseveral software engineering tasks, such as program comprehension, source code analysis, and software analytics. However, automating the extraction process is challenging, due to the unstructured nature of free text, which mixes different coding languages (e.g., source code, stack dumps, and log traces) with natural language parts.</p>\n\n<p>We conduct an extensive evaluation of Irish (InfoRmation ISlands Hmm), an approach we proposed to extract islands of coded information from free text at token granularity, with respect to the state of art approaches based on island parsing or island parsing combined with machine learners. The evaluation considers a wide set of natural language documents (e.g., textbooks, forum discussions, and development emails) taken from different contexts and encompassing different coding languages. Results indicate an F-measure of Irish between 74% and 99%; this is in line with existing approaches which, differently from Irish, require specific expertise for the definition of regular expressions or grammars.</p>\n\n", "tags": ["information extraction"], "tsne_embedding": [-2.3163957595825195, 6.337530136108398]}, {"key": "chae2016automatically", "year": "2016", "title": "Automatically generating features for learning program analysis heuristics", "abstract": "<p>We present a technique for automatically generating features for data-driven program analyses. Recently data-driven approaches for building a program analysis have been proposed, which mine existing codebases and automatically learn heuristics for finding a cost-effective abstraction for a given analysis task. Such approaches reduce the burden of the analysis designers, but they do not remove it completely; they still leave the highly nontrivial task of designing so called features to the hands of the designers. Our technique automates this feature design process. The idea is to use programs as features after reducing and abstracting them. Our technique goes through selected program-query pairs in codebases, and it reduces and abstracts the program in each pair to a few lines of code, while ensuring that the analysis behaves similarly for the original and the new programs with respect to the query. Each reduced program serves as a boolean feature for program-query pairs. This feature evaluates to true for a given program-query pair when (as a program) it is included in the program part of the pair. We have implemented our approach for three real-world program analyses. Our experimental evaluation shows that these analyses with automatically-generated features perform comparably to those with manually crafted features.</p>\n", "tags": ["representation"], "tsne_embedding": [-2.1027636528015137, -1.918088436126709]}, {"key": "chakraborty2018tree2tree", "year": "2018", "title": "CODIT: Code Editing with Tree-Based Neural Machine Translation", "abstract": "<p>The way developers edit day-to-day code tends to be repetitive, often using existing code elements. Many researchers have tried to automate repetitive code changes by learning from specific change templates which are applied to limited scope. The advancement of Neural Machine Translation (NMT) and the availability of vast open-source evolutionary data opens up the possibility of automatically learning those templates from the wild. However, unlike natural languages, for which NMT techniques were originally devised, source code and its changes have certain properties. For instance, compared to natural language, source code vocabulary can be significantly larger. Further, good changes in code do not break its syntactic structure. Thus, deploying state-of-the-art NMT models without adapting the methods to the source code domain yields sub-optimal results. To this end, we propose a novel Tree based NMT system to model source code changes and learn code change patterns from the wild. We realize our model with a change suggestion engine: CODIT and train the model with more than 30k real-world changes and evaluate it on 6k patches. Our evaluation shows the effectiveness of CODIT in learning and suggesting patches.CODIT also shows promise generating bug fix patches.</p>\n", "tags": ["grammar", "AST", "repair", "generation"], "tsne_embedding": [-10.746634483337402, 4.033938407897949]}, {"key": "chen2019capturing", "year": "2019", "title": "Capturing source code semantics via tree-based convolution over API-enhanced AST", "abstract": "<p>When deep learning meets big code, a key question is how to efficiently learn a distributed representation for source code that can capture its semantics effectively. We propose to use tree-based convolution over API-enhanced AST. To demonstrate the effectiveness of our approach, we apply it to detect semantic clones\u2014code fragments with similar semantics but dissimilar syntax. Experiment results show that our approach outperforms an existing state-of-the-art approach that uses tree-based LSTM, with an increase of 0.39 and 0.12 in F1-score on OJClone and BigCloneBench respectively. We further propose architectures that incorporate our approach for code search and code summarization.</p>\n", "tags": ["AST", "representation"], "tsne_embedding": [5.44939661026001, 8.158015251159668]}, {"key": "chen2019literature", "year": "2019", "title": "A Literature Study of Embeddings on Source Code", "abstract": "<p>Natural language processing has improved tremendously after the success of word embedding techniques such as word2vec. Recently, the same idea has been applied on source code with encouraging results. In this survey, we aim to collect and discuss the usage of word embedding techniques on programs and source code. The articles in this survey have been collected by asking authors of related work and with an extensive search on Google Scholar. Each article is categorized into five categories: 1. embedding of tokens 2. embedding of functions or methods 3. embedding of sequences or sets of method calls 4. embedding of binary code 5. other embeddings. We also provide links to experimental data and show some remarkable visualization of code embeddings. In summary, word embedding has been successfully applied on different granularities of source code. With access to countless open-source repositories, we see a great potential of applying other data-driven natural language processing techniques on source code in the future.</p>\n", "tags": ["representation"], "tsne_embedding": [7.666304111480713, 3.959378480911255]}, {"key": "chen2019mining", "year": "2019", "title": "Mining Likely Analogical APIs across Third-Party Libraries via Large-Scale Unsupervised API Semantics Embedding", "abstract": "<p>Establishing API mappings between third-party libraries is a prerequisite step for library migration tasks. Manually establishing API mappings is tedious due to the large number of APIs to be examined. Having an automatic technique to create a database of likely API mappings can significantly ease the task. Unfortunately, existing techniques either adopt supervised learning mechanism that requires already-ported or functionality similar applications across major programming languages or platforms, which are difficult to come by for an arbitrary pair of third-party libraries, or cannot deal with lexical gap in the API descriptions of different libraries. To overcome these limitations, we present an unsupervised deep learning based approach to embed both API usage semantics and API description (name and document) semantics into vector space for inferring likely analogical API mappings between libraries. Based on deep learning models trained using tens of millions of API call sequences, method names and comments of 2.8 millions of methods from 135,127 GitHub projects, our approach significantly outperforms other deep learning or traditional information retrieval (IR) methods for inferring likely analogical APIs. We implement a proof-of-concept website which can recommend analogical APIs for 583,501 APIs of 111 pairs of analogical Java libraries with diverse functionalities. This scale of third-party analogical-API database has never been achieved before.</p>\n", "tags": ["API", "representation"], "tsne_embedding": [1.7785229682922363, 6.939713954925537]}, {"key": "chen2019sequencer", "year": "2019", "title": "SequenceR: Sequence-to-Sequence Learning for End-to-End Program Repair", "abstract": "<p>This paper presents a novel end-to-end approach to program repair based on sequence-to-sequence learning. We devise, implement, and evaluate a system, called SequenceR, for fixing bugs based on sequence-to-sequence learning on source code. This approach uses the copy mechanism to overcome the unlimited vocabulary problem that occurs with big code. Our system is data-driven; we train it on 35,578 commits, carefully curated from open-source repositories. We evaluate it on 4,711 independent real bug fixes, as well on the Defects4J benchmark used in program repair research. SequenceR is able to perfectly predict the fixed line for 950/4711 testing samples. It captures a wide range of repair operators without any domain-specific top-down design.</p>\n", "tags": ["repair", "generation"], "tsne_embedding": [-5.066516876220703, -2.513179302215576]}, {"key": "chibotaru2019scalable", "year": "2019", "title": "Scalable Taint Specification Inference with Big Code", "abstract": "<p>We present a new scalable, semi-supervised method for inferring\ntaint analysis specifications by learning from a large dataset of programs.\nTaint specifications capture the role of library APIs (source, sink, sanitizer)\nand are a critical ingredient of any taint analyzer that aims to detect\nsecurity violations based on information flow.</p>\n\n<p>The core idea of our method\nis to formulate the taint specification learning problem as a linear\noptimization task over a large set of information flow constraints.\nThe resulting constraint system can then be efficiently solved with\nstate-of-the-art solvers. Thanks to its scalability, our method can infer\nmany new and interesting taint specifications by simultaneously learning from\na large dataset of programs (e.g., as found on GitHub), while requiring \nfew manual annotations.</p>\n\n<p>We implemented our method in an end-to-end system,\ncalled Seldon, targeting Python, a language where static specification\ninference is particularly hard due to lack of typing information.\nWe show that Seldon is practically effective: it learned almost 7,000 API\nroles from over 210,000 candidate APIs with very little supervision\n(less than 300 annotations) and with high estimated precision (67%).\nFurther,using the learned specifications, our taint analyzer flagged more than\n20,000 violations in open source projects, 97% of which were\nundetectable without the inferred specifications.</p>\n", "tags": ["defect", "program analysis"], "tsne_embedding": [1.0197831392288208, 6.7178568840026855]}, {"key": "ciurumelea2020suggesting", "year": "2020", "title": "Suggesting Comment Completions for Python using Neural Language Models", "abstract": "<p>Source-code comments are an important communication medium between developers to better understand and maintain software. Current research focuses on auto-generating comments by summarizing the code. However, good comments contain additional details, like important design decisions or required trade-offs, and only developers can decide on the proper comment content. Automated summarization techniques cannot include information that does not exist in the code, therefore fully-automated approaches while helpful, will be of limited use. In our work, we propose to empower developers through a semi-automated system instead. We investigate the feasibility of using neural language models trained on a large corpus of Python documentation strings to generate completion suggestions and obtain promising results. By focusing on confident predictions, we can obtain a top-3 accuracy of over 70%, although this comes at the cost of lower suggestion frequency. Our models can be improved by leveraging context information like the signature and the full body of the method. Additionally, we are able to return good accuracy completions even for new projects, suggesting the generalizability of our approach.</p>\n", "tags": ["bimodal", "autocomplete", "documentation"], "tsne_embedding": [-3.5751078128814697, 0.10735377669334412]}, {"key": "clement2020pymt5", "year": "2020", "title": "PyMT5: multi-mode translation of natural language and Python code with transformers", "abstract": "<p>Simultaneously modeling source code and natural language has many exciting applications in automated software development and understanding. Pursuant to achieving such technology, we introduce PyMT5, the Python method text-to-text transfer transformer, which is trained to translate between all pairs of Python method feature combinations: a single model that can both predict whole methods from natural language documentation strings (docstrings) and summarize code into docstrings of any common style. We present an analysis and modeling effort of a large-scale parallel corpus of 26 million Python methods and 7.7 million method-docstring pairs, demonstrating that for docstring and method generation, PyMT5 outperforms similarly-sized auto-regressive language models (GPT2) which were English pre-trained or randomly initialized. On the CodeSearchNet test set, our best model predicts 92.1% syntactically correct method bodies, achieved a BLEU score of 8.59 for method generation and 16.3 for docstring generation (summarization), and achieved a ROUGE-L F-score of 24.8 for method generation and 36.7 for docstring generation.</p>\n", "tags": ["bimodal"], "tsne_embedding": [2.668463945388794, 1.9405900239944458]}, {"key": "commit2vec2019lozoya", "year": "2019", "title": "Commit2Vec: Learning Distributed Representations of Code Changes", "abstract": "<p>Deep learning methods, which have found successful applications in fields like image classification and natural language processing, have recently been applied to source code analysis too, due to the enormous amount of freely available source code (e.g., from open-source software repositories).</p>\n\n<p>In this work, we elaborate upon a state-of-the-art approach to the representation of source code that uses information about its syntactic structure, and we adapt it to represent source changes (i.e., commits). We use this representation to classify security-relevant commits.</p>\n\n<p>Because our method uses transfer learning (that is, we train a network on a \u201cpretext task\u201d for which abundant labeled data is available, and then we use such network for the target task of commit classification, for which fewer labeled instances are available), we studied the impact of pre-training the network using two different pretext tasks versus a randomly initialized model.</p>\n\n<p>Our results indicate that representations that leverage the structural information obtained through code syntax outperform token-based representations. Furthermore, the performance metrics obtained when pre-training on a loosely related pretext task with a very large dataset (&gt;10e6 samples) were surpassed when pretraining on a smaller dataset (&gt;10e4 samples) but for a pretext task that is more closely related to the target task.</p>\n", "tags": ["edit"], "tsne_embedding": [9.727092742919922, -0.37013715505599976]}, {"key": "compton2020embedding", "year": "2020", "title": "Embedding Java Classes with code2vec: Improvements from Variable Obfuscation", "abstract": "<p>Automatic source code analysis in key areas of software engineering, such as code security, can benefit from Machine Learning (ML). However, many standard ML approaches require a numeric representation of data and cannot be applied directly to source code. Thus, to enable ML, we need to embed source code into numeric feature vectors while maintaining the semantics of the code as much as possible. code2vec is a recently released embedding approach that uses the proxy task of method name prediction to map Java methods to feature vectors. However, experimentation with code2vec shows that it learns to rely on variable names for prediction, causing it to be easily fooled by typos or adversarial attacks. Moreover, it is only able to embed individual Java methods and cannot embed an entire collection of methods such as those present in a typical Java class, making it difficult to perform predictions at the class level (e.g., for the identification of malicious Java classes). Both shortcomings are addressed in the research presented in this paper. We investigate the effect of obfuscating variable names during the training of a code2vec model to force it to rely on the structure of the code rather than specific names and consider a simple approach to creating class-level embeddings by aggregating sets of method embeddings. Our results, obtained on a challenging new collection of source-code classification problems, indicate that obfuscating variable names produces an embedding model that is both impervious to variable naming and more accurately reflects code semantics. The datasets, models, and code are shared for further ML research on source code.</p>\n", "tags": ["naming", "adversarial"], "tsne_embedding": [-2.0343892574310303, 0.6203421950340271]}, {"key": "corley2015exploring", "year": "2015", "title": "Exploring the Use of Deep Learning for Feature Location", "abstract": "<p>Deep learning models are a class of neural networks. Relative to n-gram models, deep learning models can capture more complex statistical patterns based on smaller training corpora. In this paper we explore the use of a particular deep learning model, document vectors (DVs), for feature location. DVs seem well suited to use with source code, because they both capture the influence of context on each term in a corpus and map terms into a continuous semantic space that encodes semantic relationships such as synonymy. We present preliminary results that show that a feature location technique (FLT) based on DVs can outperform an analogous FLT based on latent Dirichlet allocation (LDA) and then suggest several directions for future work on the use of deep learning models to improve developer effectiveness in feature location.</p>\n", "tags": ["feature location", "representation"], "tsne_embedding": [10.63902473449707, -0.5120478868484497]}, {"key": "cummins2017end", "year": "2017", "title": "End-to-end Deep Learning of Optimization Heuristics", "abstract": "<p>Accurate automatic optimization heuristics are necessary for dealing with the complexity and diversity of modern hardware and software. Machine learning is a proven technique for learning such heuristics, but its success is bound by the quality of the features used. These features must be hand crafted by developers through a combination of expert domain knowledge and trial and error. This makes the quality of the final model directly dependent on the skill and available time of the system architect.</p>\n\n<p>Our work introduces a better way for building heuristics. We develop a deep neural network that learns heuristics over raw code, entirely without using code features. The neural network simultaneously constructs appropriate representations of the code and learns how best to optimize, removing the need for manual feature creation. Further, we show that our neural nets can transfer learning from one optimization problem to another, improving the accuracy of new models, without the help of human experts.</p>\n\n<p>We compare the effectiveness of our automatically generated heuristics against ones with features hand-picked by experts. We examine two challenging tasks: predicting optimal mapping for heterogeneous parallelism and GPU thread coarsening factors. In 89% of the cases, the quality of our fully automatic heuristics matches or surpasses that of state-of-the-art predictive models using hand-crafted features, providing on average 14% and 12% more performance with no human effort expended on designing features.</p>\n", "tags": ["optimization"], "tsne_embedding": [-8.724081993103027, -2.723506212234497]}, {"key": "cummins2017synthesizing", "year": "2017", "title": "Synthesizing benchmarks for predictive modeling", "abstract": "<p>Predictive modeling using machine learning is an effective method for building compiler heuristics, but there is a shortage of benchmarks. Typical machine learning experiments outside of the compilation field train over thousands or millions of examples. In machine learning for compilers, however, there are typically only a few dozen common benchmarks available. This limits the quality of learned models, as they have very sparse training data for what are often high-dimensional feature spaces. What is needed is a way to generate an unbounded number of training programs that finely cover the feature space. At the same time the generated programs must be similar to the types of programs that human developers actually write, otherwise the learning will target the wrong parts of the feature space. We mine open source repositories for program fragments and apply deep learning techniques to automatically construct models for how humans write programs. We sample these models to generate an unbounded number of runnable training programs. The quality of the programs is such that even human developers struggle to distinguish our generated programs from hand-written code. We use our generator for OpenCL programs, CLgen, to automatically synthesize thousands of programs and show that learning over these improves the performance of a state of the art predictive model by 1.27x. In addition, the fine covering of the feature space automatically exposes weaknesses in the feature design which are invisible with the sparse training examples from existing benchmark suites. Correcting these weaknesses further increases performance by 4.30x.</p>\n", "tags": ["optimization", "generation"], "tsne_embedding": [-8.517828941345215, -4.564873218536377]}, {"key": "cummins2018compiler", "year": "2018", "title": "Compiler Fuzzing through Deep Learning", "abstract": "<p>Random program generation \u2014 fuzzing \u2014 is an effective technique\nfor discovering bugs in compilers but successful fuzzers require\nextensive development effort for every language supported by the\ncompiler, and often leave parts of the language space untested.</p>\n\n<p>We introduce DeepSmith, a novel machine learning approach\nto accelerating compiler validation through the inference of generative models for compiler inputs. Our approach\ninfers a learned\nmodel of the structure of real world code based on a large corpus of open source code. Then, it uses the model to automatically\ngenerate tens of thousands of realistic programs. Finally, we apply\nestablished differential testing methodologies on them to expose\nbugs in compilers. We apply our approach to the OpenCL programming language, automatically exposing bugs with little effort on our\nside. In 1,000 hours of automated testing of commercial and open\nsource compilers, we discover bugs in all of them, submitting 67\nbug reports. Our test cases are on average two orders of magnitude\nsmaller than the state-of-the-art, require 3.03\u00d7 less time to generate\nand evaluate, and expose bugs which the state-of-the-art cannot.\nOur random program generator, comprising only 500 lines of code,\ntook 12 hours to train for OpenCL versus the state-of-the-art taking\n9 man months to port from a generator for C and 50,000 lines of\ncode. With 18 lines of code we extended our program generator to\na second language, uncovering crashes in Solidity compilers in 12\nhours of automated testing.</p>\n", "tags": ["fuzzing", "generation"], "tsne_embedding": [-9.994404792785645, -3.2714691162109375]}, {"key": "cvitkovic2018open.markdown", "year": "2018", "title": "Open Vocabulary Learning on Source Code with a Graph-Structured Cache", "abstract": "<p>Machine learning models that take computer program source code as input typically use Natural Language Processing (NLP) techniques. However, a major challenge is that code is written using an open, rapidly changing vocabulary due to, e.g., the coinage of new variable and method names. Reasoning over such a vocabulary is not something for which most NLP methods are designed. We introduce a Graph-Structured Cache to address this problem; this cache contains a node for each new word the model encounters with edges connecting each word to its occurrences in the code. We find that combining this graph-structured cache strategy with recent Graph-Neural-Network-based models for supervised learning on code improves the models\u2019 performance on a code completion task and a variable naming task \u2014 with over 100% relative improvement on the latter \u2014 at the cost of a moderate increase in computation time.</p>\n", "tags": ["GNN", "variable misuse", "defect", "representation"], "tsne_embedding": [4.963636875152588, 9.031229972839355]}, {"key": "dam2016deep", "year": "2016", "title": "A deep language model for software code", "abstract": "<p>Existing language models such as n-grams for software code often fail to capture a long context where dependent code elements scatter far apart. In this paper, we propose a novel approach to build a language model for software code to address this particular issue. Our language model, partly inspired by human memory, is built upon the powerful deep learning-based Long Short Term Memory architecture that is capable of learning long-term dependencies which occur frequently in software code. Results from our intrinsic evaluation on a corpus of Java projects have demonstrated the effectiveness of our language model. This work contributes to realizing our vision for DeepSoft, an end-to-end, generic deep learning-based framework for modeling software and its development process.</p>\n", "tags": ["language model", "generation"], "tsne_embedding": [-0.09289375692605972, -0.24225012958049774]}, {"key": "dash2018refinym", "year": "2018", "title": "RefiNym: Using Names to Refine Types", "abstract": "<p>Source code is bimodal: it combines a formal algorithmic channel and a natural language channel of identifiers and comments. In this work, we model the bimodality of code with name lows, an assignment low graph augmented to track identiier names. Conceptual types are logically distinct types that do not always coincide with program types. Passwords and URLs are example conceptual types that can share the program type string. Our tool, RefiNym, is an unsupervised method that mines a lattice of conceptual types from name lows and reiies them into distinct nominal types. For string, RefiNym inds and splits conceptual types originally merged into a single type, reducing the number of same-type variables per scope from 8.7 to 2.2 while eliminating 21.9% of scopes that have more than one same-type variable in scope. This makes the code more self-documenting and frees the type system to prevent a developer from inadvertently assigning data across conceptual types.</p>\n", "tags": ["program analysis", "types"], "tsne_embedding": [-0.7690889239311218, 6.228710174560547]}, {"key": "david2019neural", "year": "2019", "title": "Neural Reverse Engineering of Stripped Binaries", "abstract": "<p>We address the problem of predicting procedure names in stripped executables which contain no debug information.\nPredicting procedure names can dramatically ease the task of reverse engineering, saving precious time and human effort. \nWe present a novel approach that leverages static analysis of binaries with encoder-decoder-based neural networks.\nThe main idea is to use static analysis to obtain enriched representations of API call sites; encode a set of sequences\nof these call sites; and finally, attend to the encoded sequences while decoding the target name token-by-token. \nWe evaluate our model by predicting procedure names over 60,000 procedures in 10,000 stripped executables.\nOur model achieves 81.70 precision and 80.12 recall in predicting procedure names within GNU packages, and 55.48\nprecision and 51.31 recall in a diverse, cross-package, dataset. Comparing to previous approaches,\nthe predictions made by our model are much more accurate and informative.</p>\n", "tags": ["naming", "deobfuscation"], "tsne_embedding": [4.20082426071167, -8.46806812286377]}, {"key": "defreez2018path", "year": "2018", "title": "Path-Based Function Embedding and its Application to Specification Mining", "abstract": "<p>Identifying the relationships among program elements is useful\nfor program understanding, debugging, and analysis. One such\nrelationship is synonymy. Function synonyms are functions that\nplay a similar role in code, e.g. functions that perform initialization\nfor different device drivers, or functions that implement different\nsymmetric-key encryption schemes. Function synonyms are not\nnecessarily semantically equivalent and can be syntactically dissimilar; consequently, approaches for identifying code clones or\nfunctional equivalence cannot be used to identify them. This paper presents <code class=\"language-plaintext highlighter-rouge\">func2vec</code>, an algorithm that maps each function to a vector in a vector space such that function synonyms are grouped\ntogether. We compute the function embedding by training a neu-\nral network on sentences generated from random walks over an\nencoding of the program as a labeled pushdown system (\u2113-PDS).\nWe demonstrate that <code class=\"language-plaintext highlighter-rouge\">func2vec</code>\nis effective at identifying function\nsynonyms in the Linux kernel. Furthermore, we show how function\nsynonyms enable mining error-handling specifications with high\nsupport in Linux file systems and drivers.</p>\n", "tags": ["program analysis", "representation"], "tsne_embedding": [-0.5304922461509705, 5.695520401000977]}, {"key": "derezendemartins2020concra", "year": "2020", "title": "CoNCRA: A Convolutional Neural Network Code Retrieval Approach", "abstract": "<p>Software developers routinely search for code using general-purpose search engines. However, these search engines cannot find code semantically unless it has an accompanying description. We propose a technique for semantic code search: A Convolutional Neural Network approach to code retrieval (CoNCRA). Our technique aims to find the code snippet that most closely matches the developer\u2019s intent, expressed in natural language. We evaluated our approach\u2019s efficacy on a dataset composed of questions and code snippets collected from Stack Overflow. Our preliminary results showed that our technique, which prioritizes local interactions (words nearby), improved the state-of-the-art (SOTA) by 5% on average, retrieving the most relevant code snippets in the top 3 (three) positions by almost 80% of the time. Therefore, our technique is promising and can improve the efficacy of semantic code retrieval.</p>\n\n", "tags": ["retrieval"], "tsne_embedding": [-2.1205835342407227, 11.766629219055176]}, {"key": "devanbu2020deep", "year": "2020", "title": "Deep Learning & Software Engineering: State of Research and Future Directions", "abstract": "<p>Given the current transformative potential of research that sits at the intersection of Deep Learning (DL) and Software Engineering (SE), an NSF-sponsored community workshop was conducted in co-location with the 34th IEEE/ACM International Conference on Automated Software Engineering (ASE\u201919) in San Diego, California. The goal of this workshop was to outline high priority areas for cross-cutting research. While a multitude of exciting directions for future work were identified, this report provides a general summary of the research areas representing the areas of highest priority which were discussed at the workshop. The intent of this report is to serve as a potential roadmap to guide future work that sits at the intersection of SE &amp; DL.</p>\n", "tags": ["survey"], "tsne_embedding": [2.2884390354156494, -6.72482442855835]}, {"key": "devlin2017semantic", "year": "2017", "title": "Semantic Code Repair using Neuro-Symbolic Transformation Networks", "abstract": "<p>We study the problem of semantic code repair, which can be broadly defined as automatically fixing\nnon-syntactic bugs in source code. The majority of past work in semantic code repair assumed access\nto unit tests against which candidate repairs could be validated. In contrast, the goal here is to\ndevelop a strong statistical model to accurately predict both bug locations and exact fixes without\naccess to information about the intended correct behavior of the program. Achieving such a goal\nrequires a robust contextual repair model, which we train on a large corpus of real-world source\ncode that has been augmented with synthetically injected bugs. Our framework adopts a two-stage\napproach where first a large set of repair candidates are generated by rule-based processors, and\nthen these candidates are scored by a statistical model using a novel neural network architecture\nwhich we refer to as Share, Specialize, and Compete. Specifically, the architecture (1) generates\na shared encoding of the source code using an RNN over the abstract syntax tree, \n(2) scores each candidate repair using specialized network modules, and (3) then normalizes these\nscores together so they can compete against one another in comparable probability space. We evaluate\nour model on a real-world test set gathered from GitHub containing four common categories of bugs.\nOur model is able to predict the exact correct repair 41% of the time with a single guess, compared\nto 13% accuracy for an attentional sequence-to-sequence model.</p>\n", "tags": ["repair"], "tsne_embedding": [-5.503091812133789, -3.318801164627075]}, {"key": "dinella2020hoppity", "year": "2020", "title": "Hoppity: Learning Bug Detection and Repair", "abstract": "<p>We present a learning-based approach to detect and fix a broad range of bugs in Javascript programs. We frame the problem in terms of learning a sequence of graph transformations: given a buggy program modeled by a graph structure, our model makes a sequence of predictions including the position of bug nodes and corresponding graph edits to produce a fix. Unlike previous works that use deep neural networks, our approach targets bugs that are more complex and semantic in nature (i.e.~bugs that require adding or deleting statements to fix). We have realized our approach in a tool called HOPPITY. By training on 338,877 Javascript code change commits on Github, HOPPITY correctly detects and fixes bugs in 9,612 out of 42,365 programs in an end-to-end fashion. Given the bug location and type of the fix, HOPPITY also outperforms the baseline approach by a wide margin.</p>\n", "tags": ["edit", "repair"], "tsne_embedding": [3.776405096054077, 13.139229774475098]}, {"key": "ding2019asm2vec", "year": "2019", "title": "Asm2Vec: Boosting Static Representation Robustness for Binary Clone Search against Code Obfuscation and Compiler Optimization", "abstract": "<p>Reverse engineering is a manually intensive but necessary technique for understanding the inner workings of new malware, finding vulnerabilities in existing systems, and detecting patent infringements in released software. An assembly clone search engine facilitates the work of reverse engineers by identifying those duplicated or known parts. However, it is challenging to design a robust clone search engine, since there exist various compiler optimization options and code obfuscation techniques that make logically similar assembly functions appear to be very different. A practical clone search engine relies on a robust vector representation of assembly code. However, the existing clone search approaches, which rely on a manual feature engineering process to form a feature vector for an assembly function, fail to consider the relationships between features and identify those unique patterns that can statistically distinguish assembly functions. To address this problem, we propose to jointly learn the lexical semantic relationships and the vector representation of assembly functions based on assembly code. We have developed an assembly code representation learning model \\emph{Asm2Vec}. It only needs assembly code as input and does not require any prior knowledge such as the correct mapping between assembly functions. It can find and incorporate rich semantic relationships among tokens appearing in assembly code. We conduct extensive experiments and benchmark the learning model with state-of-the-art static and dynamic clone search approaches. We show that the learned representation is more robust and significantly outperforms existing methods against changes introduced by obfuscation and optimizations.</p>\n", "tags": ["representation", "clone"], "tsne_embedding": [-3.925511121749878, -1.141000509262085]}, {"key": "edelmann2019neural", "year": "2019", "title": "Neural-Network Guided Expression Transformation", "abstract": "<p>Optimizing compilers, as well as other translator systems, often work by rewriting expressions according to equivalence preserving rules. Given an input expression and its optimized form, finding the sequence of rules that were applied is a non-trivial task. Most of the time, the tools provide no proof, of any kind, of the equivalence between the original expression and its optimized form. In this work, we propose to reconstruct proofs of equivalence of simple mathematical expressions, after the fact, by finding paths of equivalence preserving transformations between expressions. We propose to find those sequences of transformations using a search algorithm, guided by a neural network heuristic. Using a Tree-LSTM recursive neural network, we learn a distributed representation of expressions where the Manhattan distance between vectors approximately corresponds to the rewrite distance between expressions. We then show how the neural network can be efficiently used to search for transformation paths, leading to substantial gain in speed compared to an uninformed exhaustive search. In one of our experiments, our neural-network guided search algorithm is able to solve more instances with a 2 seconds timeout per instance than breadth-first search does with a 5 minutes timeout per instance.</p>\n", "tags": ["optimization", "grammar"], "tsne_embedding": [2.3399105072021484, 11.205150604248047]}, {"key": "ederhardt2019unsupervised", "year": "2019", "title": "Unsupervised Learning of API Aliasing Specifications", "abstract": "<p>Real world applications make heavy use of powerful libraries\nand frameworks, posing a significant challenge for static analysis\nas the library implementation may be very complex or unavailable.\nThus, obtaining specifications that summarize the behaviors of\nthe library is important as it enables static analyzers to precisely\ntrack the effects of APIs on the client program, without requiring\nthe actual API implementation.</p>\n\n<p>In this work, we propose a novel method\nfor discovering aliasing specifications of APIs by learning from a large\ndataset of programs. Unlike prior work, our method does not require\nmanual annotation, access to the library\u2019s source code or ability to\nrun its APIs. Instead, it learns specifications in a fully unsupervised manner,\nby statically observing usages of APIs in the dataset. The core idea is to\nlearn a probabilistic model of interactions between API methods and aliasing\nobjects, enabling identification of additional likely aliasing relations,\nand to then infer aliasing specifications ofAPIs that explain these relations.\nThe learned specifications are then used to augment an API-aware points-to analysis.</p>\n\n<p>We implemented our approach in a tool called USpec and used it to automatically\nlearn aliasing specifications from millions of source code files.\nUSpec learned over 2000 specifications of various Java and Python APIs, in the process\nimproving the results of the points-to analysis and its clients.</p>\n", "tags": ["API", "program analysis"], "tsne_embedding": [1.1075741052627563, 6.82570219039917]}, {"key": "efstathiou2019semantic", "year": "2019", "title": "Semantic Source Code Models Using Identifier Embeddings", "abstract": "<p>The emergence of online open source repositories in the recent years has led to an explosion in the volume of openly available source code, coupled with metadata that relate to a variety of software development activities. As an effect, in line with recent advances in machine learning research, software maintenance activities are switching from symbolic formal methods to data-driven methods. In this context, the rich semantics hidden in source code identifiers provide opportunities for building semantic representations of code which can assist tasks of code search and reuse. To this end, we deliver in the form of pretrained vector space models, distributed code representations for six popular programming languages, namely, Java, Python, PHP, C, C++, and C#. The models are produced using fastText, a state-of-the-art library for learning word representations. Each model is trained on data from a single programming language; the code mined for producing all models amounts to over 13.000 repositories. We indicate dissimilarities between natural language and source code, as well as variations in coding conventions in between the different programming languages we processed. We describe how these heterogeneities guided the data preprocessing decisions we took and the selection of the training parameters in the released models. Finally, we propose potential applications of the models and discuss limitations of the models.</p>\n", "tags": ["representation"], "tsne_embedding": [3.1067543029785156, -3.9724202156066895]}, {"key": "feng2020codebert", "year": "2020", "title": "CodeBERT: A Pre-Trained Model for Programming and Natural Languages", "abstract": "<p>We present CodeBERT, a bimodal pre-trained model for programming language (PL) and nat-ural language (NL). CodeBERT learns general-purpose representations that support downstream NL-PL applications such as natural language codesearch, code documentation generation, etc. We develop CodeBERT with Transformer-based neural architecture, and train it with a hybrid objective function that incorporates the pre-training task of replaced token detection, which is to detect plausible alternatives sampled from generators. This enables us to utilize both bimodal data of NL-PL pairs and unimodal data, where the former provides input tokens for model training while the latter helps to learn better generators. We evaluate CodeBERT on two NL-PL applications by fine-tuning model parameters. Results show that CodeBERT achieves state-of-the-art performance on both natural language code search and code documentation generation tasks. Furthermore, to investigate what type of knowledge is learned in CodeBERT, we construct a dataset for NL-PL probing, and evaluate in a zero-shot setting where parameters of pre-trained models are fixed. Results show that CodeBERT performs better than previous pre-trained models on NL-PL probing.</p>\n", "tags": ["pretraining"], "tsne_embedding": [7.469375133514404, 1.482279658317566]}, {"key": "fernandes2019structured", "year": "2019", "title": "Structured Neural Summarization", "abstract": "<p>Summarization of long sequences into a concise statement is a core problem in natural language processing, requiring non-trivial understanding of the input. Based on the promising results of graph neural networks on highly structured data, we develop a framework to extend existing sequence encoders with a graph component that can reason about long-distance relationships in weakly structured data such as text. In an extensive evaluation, we show that the resulting hybrid sequence-graph models outperform both pure sequence models as well as pure graph models on a range of summarization tasks.</p>\n", "tags": ["summarization", "GNN", "documentation"], "tsne_embedding": [6.266458988189697, 10.367452621459961]}, {"key": "fowkes2016parameter", "year": "2016", "title": "Parameter-Free Probabilistic API Mining across GitHub", "abstract": "<p>Existing API mining algorithms can be difficult to use as they require expensive parameter tuning and the returned set of API calls can be large, highly redundant and difficult to understand. To address this, we present PAM (Probabilistic API Miner), a near parameter-free probabilistic algorithm for mining the most interesting API call patterns. We show that PAM significantly outperforms both MAPO and UPMiner, achieving 69% test-set precision, at retrieving relevant API call sequences from GitHub. Moreover, we focus on libraries for which the developers have explicitly provided code examples, yielding over 300,000 LOC of hand-written API example code from the 967 client projects in the data set. This evaluation suggests that the hand-written examples actually have limited coverage of real API usages.</p>\n\n", "tags": ["API", "pattern mining"], "tsne_embedding": [10.023992538452148, -5.7071123123168945]}, {"key": "fowkes2017autofolding", "year": "2017", "title": "Autofolding for Source Code Summarization", "abstract": "<p>Developers spend much of their time reading and browsing source code, raising new opportunities for summarization methods. Indeed, modern code editors provide code folding, which allows one to selectively hide blocks of code. However this is impractical to use as folding decisions must be made manually or based on simple rules. We introduce the\nautofolding problem, which is to automatically create a code summary by folding less informative code regions. We present a novel solution by formulating the problem as a sequence of AST folding decisions, leveraging a scoped topic model for code tokens. On an annotated set of popular open source projects, we show that our summarizer outperforms simpler baselines, yielding a 28% error reduction. Furthermore, we find through a case study that our summarizer is strongly preferred by experienced developers. More broadly, we hope this work will aid program comprehension by turning code folding into a usable and valuable tool.</p>\n", "tags": ["summarization"], "tsne_embedding": [-4.474667549133301, 0.9808286428451538]}, {"key": "franks2015cacheca", "year": "2015", "title": "CACHECA: A Cache Language Model Based Code Suggestion Tool", "abstract": "<p>Nearly every Integrated Development Environment includes a form of code completion. The suggested completions (\u201csuggestions\u201d) are typically based on information available at compile time, such as type signatures and variables in scope. A statistical approach, based on estimated models of code patterns in large code corpora, has been demonstrated to be effective at predicting tokens given a context. In this demo, we present CACHECA, an Eclipse plugin that combines the native suggestions with a statistical suggestion regime. We demonstrate that a combination of the two approaches more than doubles Eclipse\u2019s suggestion accuracy. A video demonstration is available at <a href=\"https://www.youtube.com/watch?v=3INk0N3JNtc\">https://www.youtube.com/watch?v=3INk0N3JNtc</a>.</p>\n", "tags": ["language model"], "tsne_embedding": [6.823866367340088, -7.301554203033447]}, {"key": "fu2019coda", "year": "2019", "title": "Coda: An End-to-End Neural Program Decompiler", "abstract": "<p>Reverse engineering of binary executables is a critical problem in the computer security domain. On the one hand, malicious parties may recover interpretable source codes from the software products to gain commercial advantages. On the other hand, binary decompilation can be leveraged for code vulnerability analysis and malware detection. However, efficient binary decompilation is challenging. Conventional decompilers have the following major limitations: (i) they are only applicable to specific source-target language pair, hence incurs undesired development cost for new language tasks; (ii) their output high-level code cannot effectively preserve the correct functionality of the input binary; (iii) their output program does not capture the semantics of the input and the reversed program is hard to interpret. To address the above problems, we propose Coda1, the first end-to-end neural-based framework for code decompilation. Coda decomposes the decompilation task into of two key phases: First, Coda employs an instruction type-aware encoder and a tree decoder for generating an abstract syntax tree (AST) with attention feeding during the code sketch generation stage. Second, Coda then updates the code sketch using an iterative error correction machine guided by an ensembled neural error predictor. By finding a good approximate candidate and then fixing it towards perfect, Coda achieves superior with performance compared to baseline approaches. We assess Coda\u2019s performance with extensive experiments on various benchmarks. Evaluation results show that Coda achieves an average of 82% program recovery accuracy on unseen binary samples, where the state-of-the-art decompilers yield 0% accuracy. Furthermore, Coda outperforms the sequence-to-sequence model with attention by a margin of 70% program accuracy. Our work reveals the vulnerability of binary executables and imposes a new threat to the protection of Intellectual Property (IP) for software development.</p>\n", "tags": ["decompilation"], "tsne_embedding": [-4.594737529754639, -8.565577507019043]}, {"key": "gao2019neural", "year": "2019", "title": "A Neural Model for Method Name Generation from Functional Description", "abstract": "<p>The names of software artifacts, e.g., method names, are important for software understanding and maintenance, as good names can help developers easily understand others\u2019 code. However, the existing naming guidelines are difficult for developers, especially novices, to come up with meaningful, concise and compact names for the variables, methods, classes and files. With the popularity of open source, an enormous amount of project source code can be accessed, and the exhaustiveness and instability of manually naming methods could now be relieved by automatically learning a naming model from a large code repository. Nevertheless, building a comprehensive naming system is still challenging, due to the gap between natural language functional descriptions and method names. Specifically, there are three challenges: how to model the relationship between the functional descriptions and formal method names, how to handle the explosion of vocabulary when dealing with large repositories, and how to leverage the knowledge learned from large repositories to a specific project. To answer these questions, we propose a neural network to directly generate readable method names from natural language description. The proposed method is built upon the encoder-decoder framework with the attention and copying mechanisms. Our experiments show that our method can generate meaningful and accurate method names and achieve significant improvement over the state-of-the-art baseline models. We also address the cold-start problem using a training trick to utilize big data in GitHub for specific projects.</p>\n", "tags": ["naming", "summarization"], "tsne_embedding": [1.7925437688827515, -2.155947208404541]}, {"key": "glassman2015overcode", "year": "2015", "title": "OverCode: visualizing variation in student solutions to programming problems at scale", "abstract": "<p>In MOOCs, a single programming exercise may produce thousands of solutions from learners. Understanding solution variation is important for providing appropriate feedback to students at scale. The wide variation among these solutions can be a source of pedagogically valuable examples and can be used to refine the autograder for the exercise by exposing corner cases. We present OverCode, a system for visualizing and exploring thousands of programming solutions. OverCode uses both static and dynamic analysis to cluster similar solutions, and lets teachers further filter and cluster solutions based on different criteria. We evaluated OverCode against a nonclustering baseline in a within-subjects study with 24 teaching assistants and found that the OverCode interface allows teachers to more quickly develop a high-level view of students\u2019 understanding and misconceptions, and to provide feedback that is relevant to more students\u2019 solutions.</p>\n", "tags": ["repair"], "tsne_embedding": [-9.54443359375, -8.174431800842285]}, {"key": "goens2019case", "year": "2019", "title": "A case study on machine learning for synthesizing benchmarks", "abstract": "<p>Good benchmarks are hard to find because they require a substantial effort to keep them representative for the constantly changing challenges of a particular field. Synthetic benchmarks are a common approach to deal with this, and methods from machine learning are natural candidates for synthetic benchmark generation. In this paper we investigate the usefulness of machine learning in the prominent CLgen benchmark generator. We re-evaluate CLgen by comparing the benchmarks generated by the model with the raw data used to train it. This re-evaluation indicates that, for the use case considered, machine learning did not yield additional benefit over a simpler method using the raw data. We investigate the reasons for this and provide further insights into the challenges the problem could pose for potential future generators.</p>\n", "tags": ["generation"], "tsne_embedding": [2.0254719257354736, -1.6124862432479858]}, {"key": "gros2020code", "year": "2020", "title": "Code to Comment \"Translation\": Data, Metrics, Baselining & Evaluation", "abstract": "<p>The relationship of comments to code, and in particular, the task of generating useful comments given the code, has long been of interest. The earliest approaches have been based on strong syntactic theories of comment-structures, and relied on textual templates. More recently, researchers have applied deep learning methods to this task, and specifically, trainable generative translation models which are known to work very well for Natural Language translation (e.g., from German to English). We carefully examine the underlying assumption here: that the task of generating comments sufficiently resembles the task of translating between natural languages, and so similar models and evaluation metrics could be used. We analyze several recent code-comment datasets for this task: CodeNN, DeepCom, FunCom, and DocString. We compare them with WMT19, a standard dataset frequently used to train state of the art natural language translators. We found some interesting differences between the code-comment data and the WMT19 natural language data. Next, we describe and conduct some studies to calibrate BLEU (which is commonly used as a measure of comment quality). using \u201caffinity pairs\u201d of methods, from different projects, in the same project, in the same class, etc; Our study suggests that the current performance on some datasets might need to be improved substantially. We also argue that fairly naive information retrieval (IR) methods do well enough at this task to be considered a reasonable baseline. Finally, we make some suggestions on how our findings might be used in future research in this area.</p>\n", "tags": ["bimodal", "documentation"], "tsne_embedding": [11.808099746704102, 2.321502447128296]}, {"key": "gu2016deep", "year": "2016", "title": "Deep API Learning", "abstract": "<p>Developers often wonder how to implement a certain functionality (e.g., how to parse XML files) using APIs. Obtaining an API usage sequence based on an API-related natural language query is very helpful in this regard. Given a query, existing approaches utilize information retrieval models to search for matching API sequences. These approaches treat queries and APIs as bag-of-words (i.e., keyword matching or word-to-word alignment) and lack a deep understanding of the semantics of the query.</p>\n\n<p>We propose DeepAPI, a deep learning based approach to generate API usage sequences for a given natural language query. Instead of a bags-of-words assumption, it learns the\nsequence of words in a query and the sequence of associated APIs. DeepAPI adapts a neural language model named RNN Encoder-Decoder. It encodes a word sequence (user query) into a fixed-length context vector, and generates an API sequence based on the context vector. We also augment the RNN Encoder-Decoder by considering the importance of individual APIs. We empirically evaluate our approach with more than 7 million annotated code snippets collected from GitHub. The results show that our approach generates largely accurate API sequences and outperforms the related approaches.</p>\n\n", "tags": ["API", "search"], "tsne_embedding": [3.4996726512908936, 5.701164722442627]}, {"key": "gu2017deepam", "year": "2017", "title": "DeepAM: Migrate APIs with Multi-modal Sequence to Sequence Learning", "abstract": "<p>Computer programs written in one language are often required to be ported to other languages to support multiple devices and environments. When programs use language specific APIs (Application Programming Interfaces), it is very challenging to migrate these APIs to the corresponding APIs written in other languages. Existing approaches mine API mappings from projects that have corresponding versions in two languages. They rely on the sparse availability of bilingual projects, thus producing a limited number of API mappings. In this paper, we propose an intelligent system called DeepAM for automatically mining API mappings from a large-scale code corpus without bilingual projects. The key component of DeepAM is based on the multimodal sequence to sequence learning architecture that aims to learn joint semantic representations of bilingual API sequences from big source code data. Experimental results indicate that DeepAM significantly increases the accuracy of API mappings as well as the number of API mappings, when compared with the state-of-the-art approaches.</p>\n", "tags": ["API"], "tsne_embedding": [4.693747520446777, 5.551417350769043]}, {"key": "gu2018deep", "year": "2018", "title": "Deep Code Search", "abstract": "<p>To implement a program functionality, developers can reuse previously written code snippets by searching through a large-scale codebase. Over the years, many code search tools have been proposed to help developers. The existing approaches often treat source code as textual documents and utilize information retrieval models to retrieve relevant code snippets that match a given query. These approaches mainly rely on the textual similarity between source code and natural language query. They lack a deep understanding of the semantics of queries and source code.</p>\n\n<p>In this paper, we propose a novel deep neural network named CODEnn (Code-Description Embedding Neural Network). Instead of matching text similarity, CODEnn jointly embeds code snippets and natural language descriptions into a high-dimensional vector space, in such a way that code snippet and its corresponding description have similar vectors. Using the unified vector representation, code snippets related to a natural language query can be retrieved according to their vectors. Semantically related words can also be recognized and irrelevant/noisy keywords in queries can be handled.</p>\n\n<p>As a proof-of-concept application, we implement a code search tool named DeepCS using the proposed CODEnn model. We empirically evaluate DeepCS on a large scale codebase collected from GitHub. The experimental results show that our approach can effectively retrieve relevant code snippets and outperforms previous techniques.</p>\n\n", "tags": ["search"], "tsne_embedding": [2.9643003940582275, 5.274204254150391]}, {"key": "gulwani2014nlyze", "year": "2014", "title": "NLyze: Interactive Programming by Natural Language for SpreadSheet Data Analysis and Manipulation", "abstract": "<p>Millions of computer end users need to perform tasks over tabular spreadsheet data, yet lack the programming knowledge to do such tasks automatically. This paper describes\nthe design and implementation of a robust natural language\nbased interface to spreadsheet programming. Our methodology involves designing a typed domain-specific language\n(DSL) that supports an expressive algebra of map, filter, reduce, join, and formatting capabilities at a level of abstraction appropriate for non-expert users. The key algorithmic\ncomponent of our methodology is a translation algorithm\nfor converting a natural language specification in the context of a given spreadsheet to a ranked set of likely programs\nin the DSL. The translation algorithm leverages the spreadsheet spatial and temporal context to assign interpretations\nto specifications with implicit references, and is thus robust\nto a variety of ways in which end users can express the same\ntask. The translation algorithm builds over ideas from keyword programming and semantic parsing to achieve both\nhigh precision and high recall. We implemented the system\nas an Excel add-in called NLyze that supports a rich user\ninteraction model including annotating the user\u2019s natural\nlanguage specification and explaining the synthesized DSL\nprograms by paraphrasing them into structured English. We\ncollected a total of 3570 English descriptions for 40 spreadsheet tasks and our system was able to generate the intended\ninterpretation as the top candidate for 94% (97% for the top\n3) of those instances.</p>\n\n", "tags": ["generation", "bimodal", "synthesis"], "tsne_embedding": [-0.17455953359603882, 3.4667775630950928]}, {"key": "guo2017semantically", "year": "2017", "title": "Semantically enhanced software traceability using deep learning techniques", "abstract": "<p>In most safety-critical domains the need for traceability is prescribed by certifying bodies. Trace links are generally created among requirements, design, source code, test cases and other artifacts; however, creating such links manually is time consuming and error prone. Automated solutions use information retrieval and machine learning techniques to generate trace links; however, current techniques fail to understand semantics of the software artifacts or to integrate domain knowledge into the tracing process and therefore tend to deliver imprecise and inaccurate results. In this paper, we present a solution that uses deep learning to incorporate requirements artifact semantics and domain knowledge into the tracing solution. We propose a tracing network architecture that utilizes Word Embedding and Recurrent Neural Network (RNN) models to generate trace links. Word embedding learns word vectors that represent knowledge of the domain corpus and RNN uses these word vectors to learn the sentence semantics of requirements artifacts. We trained 360 different configurations of the tracing network using existing trace links in the Positive Train Control domain and identified the Bidirectional Gated Recurrent Unit (BI-GRU) as the best model for the tracing task. BI-GRU significantly out-performed state-of-the-art tracing methods including the Vector Space Model and Latent Semantic Indexing.</p>\n", "tags": ["traceability", "representation"], "tsne_embedding": [8.452722549438477, 1.1348261833190918]}, {"key": "guo2020graphcodebert", "year": "2020", "title": "GraphCodeBERT: Pre-training Code Representations with Data Flow", "abstract": "<p>Pre-trained models for programming language have achieved dramatic empirical improvements on a variety of code-related tasks such as code search, code completion, code summarization, etc. However, existing pre-trained models regard a code snippet as a sequence of tokens, while ignoring the inherent structure of code, which provides crucial code semantics and would enhance the code understanding process. We present GraphCodeBERT, a pre-trained model for programming language that considers the inherent structure of code. Instead of taking syntactic-level structure of code like abstract syntax tree (AST), we use data flow in the pre-training stage, which is a semantic-level structure of code that encodes the relation of \u201cwhere-the-value-comes-from\u201d between variables. Such a semantic-level structure is neat and does not bring an unnecessarily deep hierarchy of AST, the property of which makes the model more efficient. We develop GraphCodeBERT based on Transformer. In addition to using the task of masked language modeling, we introduce two structure-aware pre-training tasks. One is to predict code structure edges, and the other is to align representations between source code and code structure. We implement the model in an efficient way with a graph-guided masked attention function to incorporate the code structure. We evaluate our model on four tasks, including code search, clone detection, code translation, and code refinement. Results show that code structure and newly introduced pre-training tasks can improve GraphCodeBERT and achieves state-of-the-art performance on the four downstream tasks. We further show that the model prefers structure-level attentions over token-level attentions in the task of code search.</p>\n", "tags": ["pretraining"], "tsne_embedding": [4.058384895324707, 0.667143702507019]}, {"key": "gupta2017deepfix", "year": "2017", "title": "DeepFix: Fixing Common C Language Errors by Deep Learning", "abstract": "<p>The problem of automatically fixing programming errors is a\nvery active research topic in software engineering. This is a\nchallenging problem as fixing even a single error may require\nanalysis of the entire program. In practice, a number of errors\narise due to programmer\u2019s inexperience with the programming language or lack of attention to detail. We call these\ncommon programming errors. These are analogous to grammatical errors in natural languages. Compilers detect such errors, but their error messages are usually inaccurate. In this\nwork, we present an end-to-end solution, called DeepFix, that\ncan fix multiple such errors in a program without relying on\nany external tool to locate or fix them. At the heart of DeepFix\nis a multi-layered sequence-to-sequence neural network with\nattention which is trained to predict erroneous program locations along with the required correct statements. On a set of\n6971 erroneous C programs written by students for 93 programming tasks, DeepFix could fix 1881 (27%) programs\ncompletely and 1338 (19%) programs partially.</p>\n", "tags": ["repair", "generation"], "tsne_embedding": [-6.658241271972656, -5.19752836227417]}, {"key": "gupta2018deep", "year": "2018", "title": "Deep Reinforcement Learning for Programming Language Correction", "abstract": "Novice programmers often struggle with the formal\nsyntax of programming languages.  To assist them,\nwe design a novel programming language correction  framework  amenable  to  reinforcement  learning.  The framework allows an agent to mimic human  actions  for  text  navigation  and  editing.   We\ndemonstrate that the agent can be trained through\nself-exploration directly from the raw input, that is,\nprogram text itself, without any knowledge of the\nformal syntax of the programming language.   We\nleverage expert demonstrations for one tenth of the\ntraining data to accelerate training.  The proposed\ntechnique  is  evaluated  on 6975\nerroneous  C  programs with typographic errors, written by students\nduring an introductory programming course.  Our\ntechnique fixes 14%\nmore programs and 29% more\ncompiler error messages relative to those fixed by\na state-of-the-art tool, DeepFix, which uses a fully\nsupervised neural machine translation approach.\n", "tags": ["repair", "generation"], "tsne_embedding": [-8.82806396484375, -6.5134711265563965]}, {"key": "gupta2018intelligent", "year": "2018", "title": "Intelligent code reviews using deep learning", "abstract": "<p>Peer code review is a best practice in Software Engineering where source code is reviewed manually by one or more peers(reviewers) of the code author. It is widely acceptable both in industry and open-source software (OSS) systems as a process for early detection and reduction of software defects. A larger chunk of reviews given during peer reviews are related to common issues such as coding style, documentations, and best practices. This makes the code review process less effective as reviewers focus less on finding important defects. Hence, there is a need to automatically find such common issues and help reviewers perform focused code reviews. Some of this is solved by rule based systems called linters but they are rigid and needs a lot of manual effort to adapt them for a new issue.</p>\n\n<p>In this work, we present an automatic, flexible, and adaptive code analysis system called DeepCodeReviewer (DCR). DCR learns how to recommend code reviews related to common issues using historical peer reviews and deep learning. DCR uses deep learning to learn review relevance to a code snippet and recommend the right review from a repository of common reviews. DCR is trained on histroical peer reviews available from internal code repositories at Microsoft. Experiments demonstrate strong performance of developed deep learning model in classifying relevant and non-relevant reviews w.r.t to a code snippet, and ranking reviews given a code snippet. We have also evaluated DCR recommentations using a user study and survey. The results of our user study show good acceptance rate and answers of our survey questions are strongly correlated with our system\u2019s goal of making code reviews focused on finding defects.</p>\n", "tags": ["representation", "review"], "tsne_embedding": [-1.541824460029602, -2.992866039276123]}, {"key": "gupta2019neural", "year": "2019", "title": "Neural Attribution for Semantic Bug-Localization in Student Programs", "abstract": "<p>Providing feedback is an integral part of teaching. Most open online courses on programming make use of automated grading systems to support programming assignments and give real-time feedback. These systems usually rely on test results to quantify the programs\u2019 functional correctness. They return failing tests to the students as feedback. However, students may find it difficult to debug their programs if they receive no hints about where the bug is and how to fix it. In this work, we present NeuralBugLocator, a deep learning based technique, that can localize the bugs in a faulty program with respect to a failing test, without even running the program. At the heart of our technique is a novel tree convolutional neural network which is trained to predict whether a program passes or fails a given test. To localize the bugs, we analyze the trained network using a state-of-the-art neural prediction attribution technique and see which lines of the programs make it predict the test outcomes. Our experiments show that NeuralBugLocator is generally more accurate than two state-of-the-art program-spectrum based and one syntactic difference based bug-localization baselines.</p>\n", "tags": ["defect", "representation"], "tsne_embedding": [-6.301959037780762, -6.452098846435547]}, {"key": "gvero2015synthesizing", "year": "2015", "title": "Synthesizing Java expressions from free-form queries", "abstract": "<p>We present a new code assistance tool for integrated development environments. Our system accepts as input free-form queries containing a mixture of English and Java, and produces Java code expressions that take the query into account and respect syntax, types, and scoping rules of Java, as well as statistical usage patterns. In contrast to solutions based on code search, the results returned by our tool need not directly correspond to any previously seen code fragment. As part of our system we have constructed a probabilistic context free grammar for Java constructs and library invocations, as well as an algorithm that uses a customized natural language processing tool chain to extract information from free-form text queries. We present the results on a number of examples showing that our technique (1) often produces the expected code fragments, (2) tolerates much of the flexibility of natural language, and (3) can repair incorrect Java expressions that use, for example, the wrong syntax or missing arguments.</p>\n", "tags": ["synthesis", "generation", "bimodal"], "tsne_embedding": [1.2811837196350098, 3.1943655014038086]}, {"key": "habib2019neural", "year": "2019", "title": "Neural Bug Finding: A Study of Opportunities and Challenges", "abstract": "<p>Static analysis is one of the most widely adopted techniques to find software bugs before code is put in production. Designing and implementing effective and efficient static analyses is difficult and requires high expertise, which results in only a few experts able to write such analyses. This paper explores the opportunities and challenges of an alternative way of creating static bug detectors: neural bug finding. The basic idea is to formulate bug detection as a classification problem, and to address this problem with neural networks trained on examples of buggy and non-buggy code. We systematically study the effectiveness of this approach based on code examples labeled by a state-of-the-art, static bug detector. Our results show that neural bug finding is surprisingly effective for some bug patterns, sometimes reaching a precision and recall of over 80%, but also that it struggles to understand some program properties obvious to a traditional analysis. A qualitative analysis of the results provides insights into why neural bug finders sometimes work and sometimes do not work. We also identify pitfalls in selecting the code examples used to train and validate neural bug finders, and propose an algorithm for selecting effective training data.</p>\n", "tags": ["program analysis"], "tsne_embedding": [-4.8657002449035645, -6.371522426605225]}, {"key": "hajipour2019samplefix", "year": "2019", "title": "SampleFix: Learning to Correct Programs by Sampling Diverse Fixes", "abstract": "<p>Automatic program correction is an active topic of research, which holds the potential of dramatically improving productivity of programmers during the software development process and correctness of software in general. Recent advances in machine learning, deep learning and NLP have rekindled the hope to eventually fully automate the process of repairing programs. A key challenges is ambiguity, as multiple codes \u2013 or fixes \u2013 can implement the same functionality. In addition, dataset by nature fail to capture the variance introduced by such ambiguities. Therefore, we propose a deep generative model to automatically correct programming errors by learning a distribution of potential fixes. Our model is formulated as a deep conditional variational autoencoder that samples diverse fixes for the given erroneous programs. In order to account for ambiguity and inherent lack of representative datasets, we propose a novel regularizer to encourage the model to generate diverse fixes. Our evaluations on common programming errors show for the first time the generation of diverse fixes and strong improvements over the state-of-the-art approaches by fixing up to 61% of the mistakes.</p>\n", "tags": ["repair", "generation"], "tsne_embedding": [-6.386914253234863, -4.445453643798828]}, {"key": "haque2020improved", "year": "2020", "title": "Improved Automatic Summarization of Subroutines via Attention to File Context", "abstract": "<p>Software documentation largely consists of short, natural language summaries of the subroutines in the software. These summaries help programmers quickly understand what a subroutine does without having to read the source code him or herself. The task of writing these descriptions is called \u201csource code summarization\u201d and has been a target of research for several years. Recently, AI-based approaches have superseded older, heuristic-based approaches. Yet, to date these AI-based approaches assume that all the content needed to predict summaries is inside subroutine itself. This assumption limits performance because many subroutines cannot be understood without surrounding context. In this paper, we present an approach that models the file context of subroutines (i.e. other subroutines in the same file) and uses an attention mechanism to find words and concepts to use in summaries. We show in an experiment that our approach extends and improves several recent baselines.</p>\n", "tags": ["summarization"], "tsne_embedding": [-1.4442389011383057, 0.3041035830974579]}, {"key": "harer2018learning", "year": "2018", "title": "Learning to Repair Software Vulnerabilities with Generative Adversarial Networks", "abstract": "<p>Motivated by the problem of automated repair of software vulnerabilities, we propose an adversarial learning approach that maps from one discrete source domain to another target domain without requiring paired labeled examples or source and target domains to be bijections. We demonstrate that the proposed adversarial learning approach is an effective technique for repairing software vulnerabilities, performing close to seq2seq approaches that require labeled pairs. The proposed Generative Adversarial Network approach is application-agnostic in that it can be applied to other problems similar to code repair, such as grammar correction or sentiment translation.</p>\n", "tags": ["repair", "generation"], "tsne_embedding": [8.104791641235352, -2.4968137741088867]}, {"key": "hashimoto2018retrieve", "year": "2018", "title": "A Retrieve-and-Edit Framework for Predicting Structured Outputs", "abstract": "<p>For the task of generating complex outputs such as source code, editing existing\noutputs can be easier than generating complex outputs from scratch.  With this\nmotivation, we propose an approach that first retrieves a training example based on\nthe input (e.g., natural language description) and then edits it to the desired output\n(e.g., code). Our contribution is a computationally efficient method for learning\na retrieval model that embeds the input in a task-dependent way without relying\non a hand-crafted metric or incurring the expense of jointly training the retriever\nwith the editor.  Our retrieve-and-edit framework can be applied on top of any\nbase model. We show that on a new autocomplete task for GitHub Python code\nand the Hearthstone cards benchmark, retrieve-and-edit significantly boosts the\nperformance of a vanilla sequence-to-sequence model on both tasks.</p>\n", "tags": ["bimodal", "search", "generation"], "tsne_embedding": [4.544684410095215, 0.13524365425109863]}, {"key": "hata2018learning", "year": "2018", "title": "Learning to Generate Corrective Patches using Neural Machine Translation", "abstract": "<p>Bug fixing is generally a manually-intensive task. However, recent work has proposed the idea of automated program repair, which aims to repair (at least a subset of) bugs in different ways such as code mutation, etc. Following in the same line of work as automated bug repair, in this paper we aim to leverage past fixes to propose fixes of current/future bugs. Specifically, we propose Ratchet, a corrective patch generation system using neural machine translation. By learning corresponding pre-correction and post-correction code in past fixes with a neural sequence-to-sequence model, Ratchet is able to generate a fix code for a given bug-prone code query. We perform an empirical study with five open source projects, namely Ambari, Camel, Hadoop, Jetty and Wicket, to evaluate the effectiveness of Ratchet. Our findings show that Ratchet can generate syntactically valid statements 98.7% of the time, and achieve an F1-measure between 0.41-0.83 with respect to the actual fixes adopted in the code base. In addition, we perform a qualitative validation using 20 participants to see whether the generated statements can be helpful in correcting bugs. Our survey showed that Ratchet\u2019s output was considered to be helpful in fixing the bugs on many occasions, even if fix was not 100% correct.</p>\n", "tags": ["repair", "generation"], "tsne_embedding": [-6.411299705505371, -3.077070951461792]}, {"key": "he2019learning", "year": "2019", "title": "Learning to Fuzz from Symbolic Execution with Application to Smart Contracts", "abstract": "<p>Fuzzing and symbolic execution are two complementary techniques for discovering software vulnerabilities. Fuzzing is fast and scalable, but can be ineffective when it fails to randomly select the right inputs. Symbolic execution is thorough but slow and often does not scale to deep program paths with complex path conditions. In this work, we propose to learn an effective and fast fuzzer from symbolic execution, by phrasing the learning task in the framework of imitation learning. During learning, a symbolic execution expert generates a large number of quality inputs improving coverage on thousands of programs. Then, a fuzzing policy, represented with a suitable architecture of neural networks, is trained on the generated dataset. The learned policy can then be used to fuzz new programs. We instantiate our approach to the problem of fuzzing smart contracts, a domain where contracts often implement similar functionality (facilitating learning) and security is of utmost importance. We present an end-to-end system, ILF (for Imitation Learning based Fuzzer), and an extensive evaluation over &gt;18K contracts. Our results show that ILF is effective: (i) it is fast, generating 148 transactions per second, (ii) it outperforms existing fuzzers (e.g., achieving 33% more coverage), and (iii) it detects more vulnerabilities than existing fuzzing and symbolic execution tools for Ethereum.</p>\n", "tags": ["fuzzing", "GNN"], "tsne_embedding": [-3.6857502460479736, -9.225523948669434]}, {"key": "hellendoorn2015will", "year": "2015", "title": "Will they like this? Evaluating Code Contributions With Language Models", "abstract": "<p>Popular open-source software projects receive and\nreview contributions from a diverse array of developers, many\nof whom have little to no prior involvement with the project. A\nrecent survey reported that reviewers consider conformance to\nthe project\u2019s code style to be one of the top priorities when evaluating code contributions on Github. We propose to quantitatively\nevaluate the existence and effects of this phenomenon. To this aim\nwe use language models, which were shown to accurately capture\nstylistic aspects of code. We find that rejected changesets do\ncontain code significantly less similar to the project than accepted\nones; furthermore, the less similar changesets are more likely\nto be subject to thorough review. Armed with these results we\nfurther investigate whether new contributors learn to conform to\nthe project style and find that experience is positively correlated\nwith conformance to the project\u2019s code style.</p>\n", "tags": ["code review", "language model"], "tsne_embedding": [8.668661117553711, -4.621565341949463]}, {"key": "hellendoorn2017deep", "year": "2017", "title": "Are Deep Neural Networks the Best Choice for Modeling Source Code?", "abstract": "<p>Current statistical language modeling techniques, including deep-learning based models, have proven to be quite effective for source\ncode. We argue here that the special properties of source code can\nbe exploited for further improvements. In this work, we enhance\nestablished language modeling approaches to handle the special\nchallenges of modeling source code, such as: frequent changes,\nlarger, changing vocabularies, deeply nested scopes, etc. We present\na fast, nested language modeling toolkit specifically designed for\nsoftware, with the ability to add &amp; remove text, and mix &amp; swap out\nmany models. Specifically, we improve upon prior cache-modeling\nwork and present a model with a much more expansive, multi-level\nnotion of locality that we show to be well-suited for modeling\nsoftware. We present results on varying corpora in comparison\nwith traditional N -gram, as well as RNN, and LSTM deep-learning\nlanguage models, and release all our source code for public use.\nOur evaluations suggest that carefully adapting N-gram models for\nsource code can yield performance that surpasses even RNN and\nLSTM based deep-learning models.</p>\n", "tags": ["language model"], "tsne_embedding": [5.3545098304748535, -0.7152472734451294]}, {"key": "hellendoorn2018deep", "year": "2018", "title": "Deep Learning Type Inference", "abstract": "<p>Dynamically typed languages such as JavaScript and Python are\nincreasingly popular, yet static typing has not been totally eclipsed:\nPython now supports type annotations and languages like TypeScript offer a middle-ground for JavaScript: a strict superset of\nJavaScript, to which it transpiles, coupled with a type system that\npermits partially typed programs. However, static typing has a cost:\nadding annotations, reading the added syntax, and wrestling with\nthe type system to fix type errors. Type inference can ease the\ntransition to more statically typed code and unlock the benefits of\nricher compile-time information, but is limited in languages like\nJavaScript as it cannot soundly handle duck-typing or runtime evaluation\nvia eval. We propose DeepTyper, a deep learning model\nthat understands which types naturally occur in certain contexts\nand relations and can provide type suggestions, which can often\nbe verified by the type checker, even if it could not infer the type\ninitially. DeepTyper, leverages an automatically aligned corpus\nof tokens and types to accurately predict thousands of variable\nand function type annotations. Furthermore, we demonstrate that\ncontext is key in accurately assigning these types and introduce a\ntechnique to reduce overfitting on local cues while highlighting the\nneed for further improvements. Finally, we show that our model\ncan interact with a compiler to provide more than 4,000 additional\ntype annotations with over 95% precision that could not be inferred\nwithout the aid of DeepTyper.</p>\n", "tags": ["representation", "types"], "tsne_embedding": [-1.6154321432113647, 3.3852591514587402]}, {"key": "hellendoorn2020global", "year": "2020", "title": "Global Relational Models of Source Code", "abstract": "<p>Models of code can learn distributed representations of a program\u2019s syntax and semantics to predict many non-trivial properties of a program. Recent state-of-the-art models leverage highly structured representations of programs, such as trees, graphs and paths therein (e.g. data-flow relations), which are precise and abundantly available for code. This provides a strong inductive bias towards semantically meaningful relations, yielding more generalizable representations than classical sequence-based models. Unfortunately, these models primarily rely on graph-based message passing to represent relations in code, which makes them de facto local due to the high cost of message-passing steps, quite in contrast to modern, global sequence-based models, such as the Transformer. In this work, we bridge this divide between global and structured models by introducing two new hybrid model families that are both global and incorporate structural bias: Graph Sandwiches, which wrap traditional (gated) graph message-passing layers in sequential message-passing layers; and Graph Relational Embedding Attention Transformers (GREAT for short), which bias traditional Transformers with relational information from graph edge types. By studying a popular, non-trivial program repair task, variable-misuse identification, we explore the relative merits of traditional and hybrid model families for code representation. Starting with a  graph-based model that already improves upon the prior state-of-the-art for this task by 20%, we show that our proposed hybrid models improve an additional 10-15%, while training both faster and using fewer parameters.</p>\n", "tags": ["variable misuse", "defect", "GNN"], "tsne_embedding": [3.5307655334472656, 10.232120513916016]}, {"key": "heyman2020neural", "year": "2020", "title": "Neural Code Search Revisited: Enhancing Code Snippet Retrieval through Natural Language Intent", "abstract": "<p>In this work, we propose and study annotated code search: the retrieval of code snippets paired with brief descriptions of their intent using natural language queries. On three benchmark datasets, we investigate how code retrieval systems can be improved by leveraging descriptions to better capture the intents of code snippets. Building on recent progress in transfer learning and natural language processing, we create a domain-specific retrieval model for code annotated with a natural language description. We find that our model yields significantly more relevant search results (with absolute gains up to 20.6% in mean reciprocal rank) compared to state-of-the-art code retrieval methods that do not use descriptions but attempt to compute the intent of snippets solely from unannotated code.</p>\n", "tags": ["search"], "tsne_embedding": [7.771642684936523, 3.118178606033325]}, {"key": "hindle2012naturalness", "year": "2012", "title": "On the Naturalness of Software", "abstract": "<p>Natural languages like English are rich, complex,\nand powerful. The highly creative and graceful use of languages\nlike English and Tamil, by masters like Shakespeare and\nAvvaiyar, can certainly delight and inspire. But in practice,\ngiven cognitive constraints and the exigencies of daily life, most\nhuman utterances are far simpler and much more repetitive\nand predictable. In fact, these utterances can be very usefully\nmodeled using modern statistical methods. This fact has led\nto the phenomenal success of statistical approaches to speech\nrecognition, natural language translation, question-answering,\nand text mining and comprehension.</p>\n\n<p>We begin with the conjecture that most software is also\nnatural, in the sense that it is created by humans at work,\nwith all the attendant constraints and limitations\u2014and thus,\nlike natural language, it is also likely to be repetitive and\npredictable. We then proceed to ask whether a) code can\nbe usefully modeled by statistical language models and b)\nsuch models can be leveraged to support software engineers.\nUsing the widely adopted n-gram model, we provide empirical\nevidence supportive of a positive answer to both these questions.\nWe show that code is also very repetitive, and in fact even more\nso than natural languages. As an example use of the model,\nwe have developed a simple code completion engine for Java\nthat, despite its simplicity, already improves Eclipse\u2019s built-in\ncompletion capability. We conclude the paper by laying out a\nvision for future research in this area.</p>\n\n", "tags": ["language model", "autocomplete"], "tsne_embedding": [-7.790687561035156, 4.994271755218506]}, {"key": "hoang2020cc2vec", "year": "2020", "title": "CC2Vec: Distributed Representations of Code Changes", "abstract": "<p>Existing work on software patches often use features specific to a single task. These works often rely on manually identified features, and human effort is required to identify these features for each task. In this work, we propose CC2Vec, a neural network model that learns a representation of code changes guided by their accompanying log messages, which represent the semantic intent of the code changes. CC2Vec models the hierarchical structure of a code change with the help of the attention mechanism and uses multiple comparison functions to identify the differences between the removed and added code.</p>\n\n<p>To evaluate if CC2Vec can produce a distributed representation of code changes that is general and useful for multiple tasks on software patches, we use the vectors produced by CC2Vec for three tasks: log message generation, bug fixing patch identification, and just-in-time defect prediction. In all tasks, the models using CC2Vec outperform the state-of-the-art techniques.</p>\n", "tags": ["edit"], "tsne_embedding": [0.6844382286071777, 0.9932029843330383]}, {"key": "hsiao2014using", "year": "2014", "title": "Using Web Corpus Statistics for Program Analysis", "abstract": "<p>Several program analysis tools\u2014such as plagiarism detection and bug finding\u2014rely on knowing a piece of code\u2019s\nrelative semantic importance. For example, a plagiarism detector should not bother reporting two programs that have\nan identical simple loop counter test, but should report programs that share more distinctive code. Traditional program\nanalysis techniques (e.g., finding data and control dependencies) are useful, but do not say how surprising or common\na line of code is. Natural language processing researchers\nhave encountered a similar problem and addressed it using\nan n-gram model of text frequency, derived from statistics\ncomputed over text corpora.</p>\n\n<p>We propose and compute an n-gram model for programming languages, computed over a corpus of 2.8 million\nJavaScript programs we downloaded from the Web. In contrast to previous techniques, we describe a code n-gram as\na subgraph of the program dependence graph that contains\nall nodes and edges reachable in n steps from the statement.\nWe can count n-grams in a program and count the frequency\nof n-grams in the corpus, enabling us to compute tf-idf-style\nmeasures that capture the differing importance of different\nlines of code. We demonstrate the power of this approach by\nimplementing a plagiarism detector with accuracy that beats\nprevious techniques, and a bug-finding tool that discovered\nover a dozen previously unknown bugs in a collection of real\ndeployed programs.</p>\n", "tags": ["defect"], "tsne_embedding": [0.2187025398015976, 5.107087135314941]}, {"key": "hu2017codesum", "year": "2017", "title": "CodeSum: Translate Program Language to Natural Language", "abstract": "<p>During software maintenance, programmers spend a lot of time on code comprehension. Reading comments is an effective way for programmers to reduce the reading and navigating time when comprehending source code. Therefore, as a critical task in software engineering, code summarization aims to generate brief natural language descriptions for source code. In this paper, we propose a new code summarization model named CodeSum. CodeSum exploits the attention-based sequence-to-sequence (Seq2Seq) neural network with Structure-based Traversal (SBT) of Abstract Syntax Trees (AST). The AST sequences generated by SBT can better present the structure of ASTs and keep unambiguous. We conduct experiments on three large-scale corpora in different program languages, i.e., Java, C#, and SQL, in which Java corpus is our new proposed industry code extracted from Github. Experimental results show that our method CodeSum outperforms the state-of-the-art significantly.</p>\n", "tags": ["bimodal", "summarization"], "tsne_embedding": [-0.5161733627319336, 0.5609686374664307]}, {"key": "husain2019codesearchnet", "year": "2019", "title": "CodeSearchNet Challenge: Evaluating the State of Semantic Code Search", "abstract": "<p>Semantic code search is the task of retrieving relevant code given a natural language query. While related to other information retrieval tasks, it requires bridging the gap between the language used in code (often abbreviated and highly technical) and natural language more suitable to describe vague concepts and ideas.</p>\n\n<p>To enable evaluation of progress on code search, we are releasing the CodeSearchNet Corpus and are presenting the CodeSearchNet Challenge, which consists of 99 natural language queries with about 4k expert relevance annotations of likely results from CodeSearchNet Corpus. The corpus contains about 6 million functions from open-source code spanning six programming languages (Go, Java, JavaScript, PHP, Python, and Ruby). The CodeSearchNet Corpus also contains automatically generated query-like natural language for 2 million functions, obtained from mechanically scraping and preprocessing associated function documentation. In this article, we describe the methodology used to obtain the corpus and expert labels, as well as a number of simple baseline solutions for the task.</p>\n\n<p>We hope that CodeSearchNet Challenge encourages researchers and practitioners to study this interesting task further and will host a competition and leaderboard to track the progress on the challenge. We are also keen on extending CodeSearchNet Challenge to more queries and programming languages in the future.</p>\n", "tags": ["dataset", "retrieval"], "tsne_embedding": [9.153377532958984, 3.6775975227355957]}, {"key": "hussain2019deep", "year": "2019", "title": "Deep Transfer Learning for Source Code Modeling", "abstract": "<p>In recent years, deep learning models have shown great potential in source code modeling and analysis. Generally, deep learning-based approaches are problem-specific and data-hungry. A challenging issue of these approaches is that they require training from starch for a different related problem. In this work, we propose a transfer learning-based approach that significantly improves the performance of deep learning-based source code models. In contrast to traditional learning paradigms, transfer learning can transfer the knowledge learned in solving one problem into another related problem. First, we present two recurrent neural network-based models RNN and GRU for the purpose of transfer learning in the domain of source code modeling. Next, via transfer learning, these pre-trained (RNN and GRU) models are used as feature extractors. Then, these extracted features are combined into attention learner for different downstream tasks. The attention learner leverages from the learned knowledge of pre-trained models and fine-tunes them for a specific downstream task. We evaluate the performance of the proposed approach with extensive experiments with the source code suggestion task. The results indicate that the proposed approach outperforms the state-of-the-art models in terms of accuracy, precision, recall, and F-measure without training the models from scratch.</p>\n", "tags": ["pretraining"], "tsne_embedding": [10.075787544250488, -0.36944758892059326]}, {"key": "iyer2016summarizing", "year": "2016", "title": "Summarizing Source Code using a Neural Attention Model", "abstract": "<p>High quality source code is often paired\nwith high level summaries of the computation it performs, for example in code\ndocumentation or in descriptions posted\nin online forums. Such summaries are\nextremely useful for applications such as\ncode search but are expensive to manually\nauthor, hence only done for a small fraction of all code that is produced. In this\npaper, we present the first completely data-driven approach for generating high level\nsummaries of source code. Our model,\nCODE-NN , uses Long Short Term Memory (LSTM) networks with attention to\nproduce sentences that describe C# code\nsnippets and SQL queries. CODE-NN\nis trained on a new corpus that is automatically collected from StackOverflow,\nwhich we release. Experiments demonstrate strong performance on two tasks:\n(1) code summarization, where we establish the first end-to-end learning results\nand outperform strong baselines, and (2)\ncode retrieval, where our learned model\nimproves the state of the art on a recently\nintroduced C# benchmark by a large margin.</p>\n", "tags": ["summarization", "bimodal"], "tsne_embedding": [3.8183765411376953, -4.107456207275391]}, {"key": "iyer2018mapping", "year": "2018", "title": "Mapping Language to Code in Programmatic Context", "abstract": "<p>Source code is rarely written in isolation. It depends significantly on the programmatic context, such as the class that the code would reside in. To study this phenomenon, we introduce the task of generating class member functions given English documentation and the programmatic context provided by the rest of the class. This task is challenging because the desired code can vary greatly depending on the functionality the class provides (e.g., a sort function may or may not be available when we are asked to \u201creturn the smallest element\u201d in a particular member variable list). We introduce CONCODE, a new large dataset with over 100,000 examples consisting of Java classes from online code repositories, and develop a new encoder-decoder architecture that models the interaction between the method documentation and the class environment. We also present a detailed error analysis suggesting that there is significant room for future work on this task.</p>\n", "tags": ["bimodal", "generation"], "tsne_embedding": [0.25601354241371155, -6.775166988372803]}, {"key": "iyer2019learning", "year": "2019", "title": "Learning Programmatic Idioms for Scalable Semantic Parsing", "abstract": "<p>Programmers typically organize executable source code using high-level coding patterns or idiomatic structures such as nested loops, exception handlers and recursive blocks, rather than as individual code tokens. In contrast, state of the art semantic parsers still map natural language instructions to source code by building the code syntax tree one node at a time. In this paper, we introduce an iterative method to extract code idioms from large source code corpora by repeatedly collapsing most-frequent depth-2 subtrees of their syntax trees, and we train semantic parsers to apply these idioms during decoding. We apply this idiom-based code generation to a recent context-dependent semantic parsing task, and improve the state of the art by 2.2% BLEU score while reducing training time by more than 50%. This improved speed enables us to scale up the model by training on an extended training set that is 5x times larger, to further move up the state of the art by an additional 2.3% BLEU and 0.9% exact match.</p>\n", "tags": ["idiom", "generation", "AST"], "tsne_embedding": [-2.366824150085449, 10.453641891479492]}, {"key": "jain2020contrastive", "year": "2020", "title": "Contrastive Code Representation Learning", "abstract": "<p>Machine-aided programming tools such as type predictors and code summarizers\nare increasingly learning-based. However, most code representation learning approaches rely on supervised learning with task-specific annotated datasets. We propose Contrastive Code Representation Learning (ContraCode), a self-supervised\nalgorithm for learning task-agnostic semantic representations of programs via contrastive learning. Our approach uses no human-provided labels, relying only on\nthe raw text of programs. In particular, we design an unsupervised pretext task by\ngenerating textually divergent copies of source functions via automated source-tosource compiler transforms that preserve semantics. We train a neural model to\nidentify variants of an anchor program within a large batch of negatives. To solve\nthis task, the network must extract program features representing the functionality,\nnot form, of the program. This is the first application of instance discrimination\nto code representation learning to our knowledge. We pre-train models over 1.8m\nunannotated JavaScript methods mined from GitHub. ContraCode pre-training\nimproves code summarization accuracy by 7.9% over supervised approaches and\n4.8% over RoBERTa pre-training. Moreover, our approach is agnostic to model architecture; for a type inference task, contrastive pre-training consistently improves\nthe accuracy of existing baselines.</p>\n", "tags": ["representation", "pretraining"], "tsne_embedding": [7.240370273590088, -0.23948486149311066]}, {"key": "jayasundara2019treecaps", "year": "2019", "title": "TreeCaps: Tree-Structured Capsule Networks for Program Source Code Processing", "abstract": "<p>Program comprehension is a fundamental task in software development and maintenance processes. Software developers often need to understand a large amount of existing code before they can develop new features or fix bugs in existing programs. Being able to process programming language code automatically and provide summaries of code functionality accurately can significantly help developers to reduce time spent in code navigation and understanding, and thus increase productivity. Different from natural language articles, source code in programming languages often follows rigid syntactical structures and there can exist dependencies among code elements that are located far away from each other through complex control flows and data flows. Existing studies on tree-based convolutional neural networks (TBCNN) and gated graph neural networks (GGNN) are not able to capture essential semantic dependencies among code elements accurately. In this paper, we propose novel tree-based capsule networks (TreeCaps) and relevant techniques for processing program code in an automated way that encodes code syntactical structures and captures code dependencies more accurately. Based on evaluation on programs written in different programming languages, we show that our TreeCaps-based approach can outperform other approaches in classifying the functionalities of many programs.</p>\n", "tags": ["representation"], "tsne_embedding": [2.839568853378296, 8.849115371704102]}, {"key": "jiang2017automatically", "year": "2017", "title": "Automatically Generating Commit Messages from Diffs using Neural Machine Translation", "abstract": "<p>Commit messages are a valuable resource in comprehension of software evolution, since they provide a record of changes such as feature additions and bug repairs. Unfortunately, programmers often neglect to write good commit messages. Different techniques have been proposed to help programmers by automatically writing these messages. These techniques are effective at describing what changed, but are often verbose and lack context for understanding the rationale behind a change. In contrast, humans write messages that are short and summarize the high level rationale. In this paper, we adapt Neural Machine Translation (NMT) to automatically \u201ctranslate\u201d diffs into commit messages. We trained an NMT algorithm using a corpus of diffs and human-written commit messages from the top 1k Github projects. We designed a filter to help ensure that we only trained the algorithm on higher-quality commit messages. Our evaluation uncovered a pattern in which the messages we generate tend to be either very high or very low quality. Therefore, we created a quality-assurance filter to detect cases in which we are unable to produce good messages, and return a warning instead.</p>\n", "tags": ["edit", "bimodal"], "tsne_embedding": [-8.373428344726562, -0.9524554014205933]}, {"key": "johnson2020learning", "year": "2020", "title": "Learning Graph Structure With A Finite-State Automaton Layer", "abstract": "<p>Graph-based neural network models are producing strong results in a number of domains, in part because graphs provide flexibility to encode domain knowledge in the form of relational structure (edges) between nodes in the graph. In practice, edges are used both to represent intrinsic structure (e.g., abstract syntax trees of programs) and more abstract relations that aid reasoning for a downstream task (e.g., results of relevant program analyses). In this work, we study the problem of learning to derive abstract relations from the intrinsic graph structure. Motivated by their power in program analyses, we consider relations defined by paths on the base graph accepted by a finite-state automaton. We show how to learn these relations end-to-end by relaxing the problem into learning finite-state automata policies on a graph-based POMDP and then training these policies using implicit differentiation. The result is a differentiable Graph Finite-State Automaton (GFSA) layer that adds a new edge type (expressed as a weighted adjacency matrix) to a base graph. We demonstrate that this layer can find shortcuts in grid-world graphs and reproduce simple static analyses on Python programs. Additionally, we combine the GFSA layer with a larger graph-based model trained end-to-end on the variable misuse program understanding task, and find that using the GFSA layer leads to better performance than using hand-engineered semantic edges or other baseline methods for adding learned edge types.</p>\n", "tags": ["GNN", "program analysis"], "tsne_embedding": [7.2495527267456055, 11.309124946594238]}, {"key": "kacmajor2019automatic", "year": "2019", "title": "Automatic Acquisition of Annotated Training Corpora for Test-Code Generation ", "abstract": "<p>Open software repositories make large amounts of source code publicly available. Potentially, this source code could be used as training data to develop new, machine learning-based programming tools. For many applications, however, raw code scraped from online repositories does not constitute an adequate training dataset. Building on the recent and rapid improvements in machine translation (MT), one possibly very interesting application is code generation from natural language descriptions. One of the bottlenecks in developing these MT-inspired systems is the acquisition of parallel text-code corpora required for training code-generative models. This paper addresses the problem of automatically synthetizing parallel text-code corpora in the software testing domain. Our approach is based on the observation that self-documentation through descriptive method names is widely adopted in test automation, in particular for unit testing. Therefore, we propose synthesizing parallel corpora comprised of parsed test function names serving as code descriptions, aligned with the corresponding function bodies. We present the results of applying one of the state-of-the-art MT methods on such a generated dataset. Our experiments show that a neural MT model trained on our dataset can generate syntactically correct and semantically relevant short Java functions from quasi-natural language descriptions of functionality.</p>\n", "tags": [], "tsne_embedding": [1.8204368352890015, -2.825223922729492]}, {"key": "kanade2020pretrained", "year": "2020", "title": "Pre-trained Contextual Embedding of Source Code", "abstract": "<p>The source code of a program not only serves as a formal description of an executable task, but it also serves to communicate developer intent in a human-readable form. To facilitate this, developers use meaningful identifier names and natural-language documentation. This makes it possible to successfully apply sequence-modeling approaches, shown to be effective in natural-language processing, to source code. A major advancement in natural-language understanding has been the use of pre-trained token embeddings; BERT and other works have further shown that pre-trained contextual embeddings can be extremely powerful and can be fine-tuned effectively for a variety of downstream supervised tasks. Inspired by these developments, we present the first attempt to replicate this success on source code. We curate a massive corpus of Python programs from GitHub to pre-train a BERT model, which we call Code Understanding BERT (CuBERT). We also pre-train Word2Vec embeddings on the same dataset. We create a benchmark of five classification tasks and compare fine-tuned CuBERT against sequence models trained with and without the Word2Vec embeddings. Our results show that CuBERT outperforms the baseline methods by a margin of 2.9-22%. We also show its superiority when fine-tuned with smaller datasets, and over fewer epochs. We further evaluate CuBERT\u2019s effectiveness on a joint classification, localization and repair task involving prediction of two pointers.</p>\n", "tags": ["pretraining"], "tsne_embedding": [3.168217420578003, 1.5002981424331665]}, {"key": "karaivanov2014phrase", "year": "2014", "title": "Phrase-Based Statistical Translation of Programming Languages", "abstract": "<p>Phrase-based statistical machine translation approaches have been\nhighly successful in translating between natural languages and are\nheavily used by commercial systems (e.g. Google Translate).</p>\n\n<p>The main objective of this work is to investigate the applicability of\nthese approaches for translating between programming languages.\nTowards that, we investigated several variants of the phrase-based\ntranslation approach: i) a direct application of the approach to\nprogramming languages, ii) a novel modification of the approach\nto incorporate the grammatical structure of the target programming\nlanguage (so to avoid generating target programs which do not\nparse), and iii) a combination of ii) with custom rules added to\nimprove the quality of the translation.</p>\n\n<p>To experiment with the above systems, we investigated machine\ntranslation from C# to Java. For the training, which takes about\n60 hours, we used a parallel corpus of 20, 499 C#-to-Java method\ntranslations. We then evaluated each of the three systems above by\ntranslating 1,000 C# methods. Our experimental results indicate\nthat with the most advanced system, about 60% of the translated\nmethods compile (the top ranked) and out of a random sample of 50\ncorrectly compiled methods, 68% (34 methods) were semantically\nequivalent to the reference solution.</p>\n", "tags": ["migration", "generation"], "tsne_embedding": [2.2316110134124756, 3.0552713871002197]}, {"key": "karampatsis2019deep", "year": "2019", "title": "Maybe Deep Neural Networks are the Best Choice for Modeling Source Code", "abstract": "<p>Statistical language modeling techniques have successfully been applied to source code, yielding a variety of new software development tools, such as tools for code suggestion and improving readability. A major issue with these techniques is that code introduces new vocabulary at a far higher rate than natural language, as new identifier names proliferate. But traditional language models limit the vocabulary to a fixed set of common words. For code, this strong assumption has been shown to have a significant negative effect on predictive performance. But the open vocabulary version of the neural network language models for code have not been introduced in the literature. We present a new open-vocabulary neural language model for code that is not limited to a fixed vocabulary of identifier names. We employ a segmentation into subword units, subsequences of tokens chosen based on a compression criterion, following previous work in machine translation. Our network achieves best in class performance, outperforming even the state-of-the-art methods of Hellendoorn and Devanbu that are designed specifically to model code. Furthermore, we present a simple method for dynamically adapting the model to a new test project, resulting in increased performance. We showcase our methodology on code corpora in three different languages of over a billion tokens each, hundreds of times larger than in previous work. To our knowledge, this is the largest neural language model for code that has been reported.</p>\n", "tags": ["language model"], "tsne_embedding": [5.444231986999512, -4.107242584228516]}, {"key": "karampatsis2020", "year": "2020", "title": "Big Code != Big Vocabulary: Open-Vocabulary Models for Source Code", "abstract": "<p>Statistical language modeling techniques have successfully been applied to large source code corpora, yielding a variety of new software development tools, such as tools for code suggestion, improving readability, and API migration. A major issue with these techniques is that code introduces new vocabulary at a far higher rate than natural language, as new identifier names proliferate. Both large vocabularies and out-of-vocabulary issues severely affect Neural Language Models (NLMs) of source code, degrading their performance and rendering them unable to scale. In this paper, we address this issue by: 1) studying how various modelling choices impact the resulting vocabulary on a large-scale corpus of 13,362 projects; 2) presenting an open vocabulary source code NLM that can scale to such a corpus, 100 times larger than in previous work; and 3) showing that such models outperform the state of the art on three distinct code corpora (Java, C, Python). To our knowledge, these are the largest NLMs for code that have been reported.</p>\n", "tags": ["language model"], "tsne_embedding": [5.687978744506836, -4.716332912445068]}, {"key": "karampatsis2020scelmo", "year": "2020", "title": "SCELMo: Source Code Embeddings from Language Models", "abstract": "<p>Continuous embeddings of tokens in computer programs have been used to support a variety of software development tools, including readability, code search, and program repair. Contextual embeddings are common in natural language processing but have not been previously applied in software engineering. We introduce a new set of deep contextualized word representations for computer programs based on language models. We train a set of embeddings using the ELMo (embeddings from language models) framework of Peters et al (2018). We investigate whether these embeddings are effective when fine-tuned for the downstream task of bug detection. We show that even a low-dimensional embedding trained on a relatively small corpus of programs can improve a state-of-the-art machine learning system for bug detection.</p>\n", "tags": ["pretraining", "defect"], "tsne_embedding": [6.506962299346924, 1.6124098300933838]}, {"key": "karpathy2015visualizing", "year": "2015", "title": "Visualizing and Understanding Recurrent Networks", "abstract": "<p>Recurrent Neural Networks (RNNs), and specifically a variant with Long Short-Term Memory (LSTM), are enjoying renewed interest as a result of successful\napplications in a wide range of machine learning problems that involve sequential\ndata. However, while LSTMs provide exceptional results in practice, the source\nof their performance and their limitations remain rather poorly understood. Using character-level language models as an interpretable testbed, we aim to bridge\nthis gap by providing an analysis of their representations, predictions and error\ntypes. In particular, our experiments reveal the existence of interpretable cells that\nkeep track of long-range dependencies such as line lengths, quotes and brackets.\nMoreover, our comparative analysis with finite horizon n-gram models traces the\nsource of the LSTM improvements to long-range structural dependencies. Finally,\nwe provide analysis of the remaining errors and suggests areas for further study.</p>\n\n", "tags": ["language model", "generation"], "tsne_embedding": [0.619678258895874, 10.317524909973145]}, {"key": "katz2019towards", "year": "2019", "title": "Towards Neural Decompilation", "abstract": "<p>We address the problem of automatic decompilation, converting a program in low-level representation back to a higher-level human-readable programming language. The problem of decompilation is extremely important for security researchers. Finding vulnerabilities and understanding how malware operates is much easier when done over source code.</p>\n\n<p>The importance of decompilation has motivated the construction of hand-crafted rule-based decompilers. Such decompilers have been designed by experts to detect specific control-flow structures and idioms in low-level code and lift them to source level. The cost of supporting additional languages or new language features in these models is very high.</p>\n\n<p>We present a novel approach to decompilation based on neural machine translation. The main idea is to automatically learn a decompiler from a given compiler. Given a compiler from a source language S to a target language T , our approach automatically trains a decompiler that can translate (decompile) T back to S . We used our framework to decompile both LLVM IR and x86 assembly to C code with high success rates. Using our LLVM and x86 instantiations, we were able to successfully decompile over 97% and 88% of our benchmarks respectively.</p>\n", "tags": ["decompilation"], "tsne_embedding": [-10.399311065673828, -2.362212896347046]}, {"key": "kim2020code", "year": "2020", "title": "Code Prediction by Feeding Trees to Transformers", "abstract": "<p>In this paper, we describe how to leverage Transformer, a recent neural architecture for learning from sequential data (such as text), for code completion. As in the realm of natural language processing, Transformers surpass the prediction accuracy achievable by RNNs; we provide an experimental confirmation of this over a Python dataset.</p>\n\n<p>Furthermore, we show that the way to obtain even better accuracy from Transformers is to expose the syntactic structure of code, which is easily recovered by parsing, to the neural network. This works significantly better than presenting the code as a linear token sequence, which is how Transformers were originally intended to be used.</p>\n\n<p>To accomplish this, we propose a novel enhancement to the self-attention mechanism of the Transformer. We enable the mechanism to learn weights\u2014that is, how much to focus on each preceding token in the input\u2014not only on the basis of a token\u2019s value, but also on the basis of the spatial relationships, as in their positions in the abstract syntax tree, between each pair of tokens.</p>\n\n<p>We provide comprehensive experimental evaluation of our proposal, along with alternative design choices, on a standard Python dataset, as well as on a Python corpus internal to Facebook.</p>\n", "tags": ["autocompletion"], "tsne_embedding": [6.338015079498291, 3.0258004665374756]}, {"key": "koc2017learning", "year": "2017", "title": "Learning a Classifier for False Positive Error Reports Emitted by Static Code Analysis Tools", "abstract": "<p>The large scale and high complexity of modern software systems\nmake perfectly precise static code analysis (SCA) infeasible. Therefore SCA tools often over-approximate, so not to miss any real\nproblems. This, however, comes at the expense of raising false\nalarms, which, in practice, reduces the usability of these tools.</p>\n\n<p>To partially address this problem, we propose a novel learning\nprocess whose goal is to discover program structures that cause\na given SCA tool to emit false error reports, and then to use this\ninformation to predict whether a new error report is likely to be a\nfalse positive as well. To do this, we first preprocess code to isolate\nthe locations that are related to the error report. Then, we apply\nmachine learning techniques to the preprocessed code to discover\ncorrelations and to learn a classifier.</p>\n\n<p>We evaluated this approach in an initial case study of a widely-used SCA tool for Java. Our results showed that for our dataset\nwe could accurately classify a large majority of false positive error\nreports. Moreover, we identified some common coding patterns that\nled to false positive errors. We believe that SCA developers may be\nable to redesign their methods to address these patterns and reduce\nfalse positive error reports.</p>\n", "tags": ["static analysis"], "tsne_embedding": [-4.393186569213867, -4.220827102661133]}, {"key": "kovalenko2019pathminer", "year": "2019", "title": "PathMiner : A Library for Mining of Path-Based Representations of Code", "abstract": "<p>One recent, significant advance in modeling source code for machine learning algorithms has been the introduction of path-based representation \u2013 an approach consisting in representing a snippet of code as a collection of paths from its syntax tree. Such representation efficiently captures the structure of code, which, in turn, carries its semantics and other information.\nBuilding the path-based representation involves parsing the code and extracting the paths from its syntax tree; these steps build up to a substantial technical job. With no common reusable toolkit existing for this task, the burden of mining diverts the focus of researchers from the essential work and hinders newcomers in the field of machine learning on code.</p>\n\n<p>In this paper, we present PathMiner \u2013 an open-source library for mining path-based representations of code. PathMiner is fast, flexible, well-tested, and easily extensible to support input code in any common programming language. Preprint [https://doi.org/10.5281/zenodo.2595271]; released tool [https://doi.org/10.5281/zenodo.2595257].</p>\n", "tags": ["representation", "AST"], "tsne_embedding": [3.085360527038574, -4.141651153564453]}, {"key": "kremenek2007factor", "year": "2007", "title": "A Factor Graph Model for Software Bug Finding", "abstract": "<p>Automatic tools for finding software errors require\nknowledge of the rules a program must obey, or\n\u201cspecifications,\u201d before they can identify bugs. We\npresent a method that combines factor graphs and\nstatic program analysis to automatically infer specifications directly from programs. We illustrate the\napproach on inferring functions in C programs that\nallocate and release resources, and evaluate the approach on three codebases: SDL, OpenSSH, and\nthe OS kernel for Mac OS X (XNU). The inferred\nspecifications are highly accurate and with them we\nhave discovered numerous bugs.</p>\n\n", "tags": ["program analysis"], "tsne_embedding": [-2.711261749267578, -5.661379337310791]}, {"key": "kulal2019spoc", "year": "2019", "title": "SPoC: Search-based Pseudocode to Code", "abstract": "<p>We consider the task of mapping pseudocode to long programs that are functionally correct. Given test cases as a mechanism to validate programs, we search over the space of possible translations of the pseudocode to find a program that passes the validation. However, without proper credit assignment to localize the sources of program failures, it is difficult to guide search toward more promising programs. We propose to perform credit assignment based on signals from compilation errors, which constitute 88.7% of program failures. Concretely, we treat the translation of each pseudocode line as a discrete portion of the program, and whenever a synthesized program fails to compile, an error localization method tries to identify the portion of the program responsible for the failure. We then focus search over alternative translations of the pseudocode for those portions. For evaluation, we collected the SPoC dataset (Search-based Pseudocode to Code) containing 18,356 programs with human-authored pseudocode and test cases. Under a budget of 100 program compilations, performing search improves the synthesis success rate over using the top-one translation of the pseudocode from 25.6% to 44.7%.</p>\n", "tags": ["bimodal", "synthesis"], "tsne_embedding": [-5.967674255371094, -2.117685317993164]}, {"key": "kurbatova2020recommendation", "year": "2020", "title": "Recommendation of Move Method Refactoring Using Path-Based Representation of Code", "abstract": "<p>Software refactoring plays an important role in increasing code quality. One of the most popular refactoring types is the Move Method refactoring. It is usually applied when a method depends more on members of other classes than on its own original class. Several approaches have been proposed to recommend Move Method refactoring automatically. Most of them are based on heuristics and have certain limitations (e.g., they depend on the selection of metrics and manually-defined thresholds). In this paper, we propose an approach to recommend Move Method refactoring based on a path-based representation of code called code2vec that is able to capture the syntactic structure and semantic information of a code fragment. We use this code representation to train a machine learning classifier suggesting to move methods to more appropriate classes. We evaluate the approach on two publicly available datasets: a manually compiled dataset of well-known open-source projects and a synthetic dataset with automatically injected code smell instances. The results show that our approach is capable of recommending accurate refactoring opportunities and outperforms JDeodorant and JMove, which are state of the art tools in this field.</p>\n", "tags": ["refactoring"], "tsne_embedding": [4.0552263259887695, -0.542734682559967]}, {"key": "kushman2013using", "year": "2013", "title": "Using Semantic Unification to Generate Regular Expressions from Natural Language", "abstract": "<p>We consider the problem of translating natural language text queries into regular expressions which represent their meaning. The mismatch in the level of abstraction between the natural language representation and the regular expression representation make this a novel and challenging problem. However, a given regular expression can be written in many semantically equivalent forms, and we exploit this flexibility to facilitate translation by finding a form which more directly corresponds to the natural language. We evaluate our technique on a set of natural language queries and their associated regular expressions which we gathered from Amazon Mechanical Turk. Our model substantially outperforms a state-of-the-art semantic parsing baseline, yielding a 29% absolute improvement in accuracy.</p>\n", "tags": ["bimodal", "generation"], "tsne_embedding": [3.706298828125, 6.580367565155029]}, {"key": "lachaux2020unsupervised", "year": "2020", "title": "Unsupervised Translation of Programming Languages", "abstract": "<p>A transcompiler, also known as source-to-source translator, is a system that converts source code from a high-level programming language (such as C++ or Python) to another. Transcompilers are primarily used for interoperability, and to port codebases written in an obsolete or deprecated language (e.g. COBOL, Python 2) to a modern one. They typically rely on handcrafted rewrite rules, applied to the source code abstract syntax tree. Unfortunately, the resulting translations often lack readability, fail to respect the target language conventions, and require manual modifications in order to work properly. The overall translation process is timeconsuming and requires expertise in both the source and target languages, making code-translation projects expensive. Although neural models significantly outperform their rule-based counterparts in the context of natural language translation, their applications to transcompilation have been limited due to the scarcity of parallel data in this domain. In this paper, we propose to leverage recent approaches in unsupervised machine translation to train a fully unsupervised neural transcompiler. We train our model on source code from open source GitHub projects, and show that it can translate functions between C++, Java, and Python with high accuracy. Our method relies exclusively on monolingual source code, requires no expertise in the source or target languages, and can easily be generalized to other programming languages. We also build and release a test set composed of 852 parallel functions, along with unit tests to check the correctness of translations. We show that our model outperforms rule-based commercial baselines by a significant margin.</p>\n", "tags": ["migration"], "tsne_embedding": [3.0499396324157715, 6.803936004638672]}, {"key": "lacomis2019neural", "year": "2019", "title": "A Neural Approach to Decompiled Identifier Renaming", "abstract": "<p>The decompiler is one of the most common tools for examining binaries without corresponding source code. It transforms binaries into high-level code, reversing the compilation process. However, compilation loses information contained within the original source code (e.g. structure, type information, and variable names). Semantically meaningful variable names are known to increase code understandability, but they generally cannot be recovered by decompilers. We propose the Decompiled Identifier Renaming Engine (DIRE), a novel probabilistic technique for variable name recovery that uses both lexical and structural information. We also present a technique for generating corpora suitable for training and evaluating models of decompiled code renaming, which we use to create a corpus of 164,632 unique x86-64 binaries generated from C projects mined from GitHub. Our results show that on this corpus DIRE can predict variable names identical to the names in the original source code up to 74.3% of the time.</p>\n", "tags": ["deobfuscation", "naming", "compilation"], "tsne_embedding": [-4.985156059265137, 4.0008063316345215]}, {"key": "lanchantin2018exploring", "year": "2018", "title": "Exploring the Naturalness of Buggy Code with Recurrent Neural Network", "abstract": "<p>Statistical   language   models   are   powerful   tools\nwhich  have  been  used  for  many  tasks  within  natural language processing. Recently, they have been\nused for other sequential data such as source code.\n(Ray et al., 2015) showed that it is possible train an\nn-gram\nsource code language mode,  and use it to\npredict buggy lines in code by determining \u201cunnatural\u201d lines via entropy with respect to the language\nmodel.  In this work, we propose using a more advanced language modeling technique, Long Short-term Memory recurrent neural networks, to model\nsource code and classify buggy lines based on entropy.   We  show  that  our  method  slightly  outperforms an\nn-gram model in the buggy line classification task using AUC</p>\n", "tags": ["language model", "defect"], "tsne_embedding": [-4.578525066375732, 10.497478485107422]}, {"key": "leclair2019neural", "year": "2019", "title": "A Neural Model for Generating Natural Language Summaries of Program Subroutines", "abstract": "<p>Source code summarization \u2013 creating natural language descriptions of source code behavior \u2013 is a rapidly-growing research topic with applications to automatic documentation generation, program comprehension, and software maintenance. Traditional techniques relied on heuristics and templates built manually by human experts. Recently, data-driven approaches based on neural machine translation have largely overtaken template-based systems. But nearly all of these techniques rely almost entirely on programs having good internal documentation; without clear identifier names, the models fail to create good summaries. In this paper, we present a neural model that combines words from code with code structure from an AST. Unlike previous approaches, our model processes each data source as a separate input, which allows the model to learn code structure independent of the text in code. This process helps our approach provide coherent summaries in many cases even when zero internal documentation is provided. We evaluate our technique with a dataset we created from 2.1m Java methods. We find improvement over two baseline techniques from SE literature and one from NLP literature.</p>\n", "tags": ["summarization", "documentation"], "tsne_embedding": [-1.492997407913208, 0.409051775932312]}, {"key": "leclair2019recommendations", "year": "2019", "title": "Recommendations for Datasets for Source Code Summarization", "abstract": "<p>Source Code Summarization is the task of writing short, natural language descriptions of source code. The main use for these descriptions is in software documentation e.g. the one-sentence Java method descriptions in JavaDocs. Code summarization is rapidly becoming a popular research problem, but progress is restrained due to a lack of suitable datasets. In addition, a lack of community standards for creating datasets leads to confusing and unreproducible research results \u2013 we observe swings in performance of more than 33% due only to changes in dataset design. In this paper, we make recommendations for these standards from experimental results. We release a dataset based on prior work of over 2.1m pairs of Java methods and one sentence method descriptions from over 28k Java projects. We describe the dataset and point out key differences from natural language data, to guide and support future researchers.</p>\n", "tags": ["summarization", "dataset"], "tsne_embedding": [-3.3965487480163574, 1.6984025239944458]}, {"key": "leclair2020improved", "year": "2020", "title": "Improved Code Summarization via a Graph Neural Network", "abstract": "<p>Automatic source code summarization is the task of generating natural language descriptions for source code. Automatic code summarization is a rapidly expanding research area, especially as the community has taken greater advantage of advances in neural network and AI technologies. In general, source code summarization techniques use the source code as input and outputs a natural language description. Yet a strong consensus is developing that using structural information as input leads to improved performance. The first approaches to use structural information flattened the AST into a sequence. Recently, more complex approaches based on random AST paths or graph neural networks have improved on the models using flattened ASTs. However, the literature still does not describe the using a graph neural network together with source code sequence as separate inputs to a model. Therefore, in this paper, we present an approach that uses a graph-based neural architecture that better matches the default structure of the AST to generate these summaries. We evaluate our technique using a data set of 2.1 million Java method-comment pairs and show improvement over four baseline techniques, two from the software engineering literature, and two from machine learning literature.</p>\n", "tags": ["summarization"], "tsne_embedding": [4.941564559936523, 9.868270874023438]}, {"key": "lee2020montage", "year": "2020", "title": "Montage: A Neural Network Language Model-Guided JavaScript Engine Fuzzer", "abstract": "<p>JavaScript (JS) engine vulnerabilities pose significant security threats affecting billions of web browsers. While fuzzing is a prevalent technique for finding such vulnerabilities, there have been few studies that leverage the recent advances in neural network language models (NNLMs). In this paper, we present Montage, the first NNLM-guided fuzzer for finding JS engine vulnerabilities. The key aspect of our technique is to transform a JS abstract syntax tree (AST) into a sequence of AST subtrees that can directly train prevailing NNLMs. We demonstrate that Montage is capable of generating valid JS tests, and show that it outperforms previous studies in terms of finding vulnerabilities. Montage found 37 real-world bugs, including three CVEs, in the latest JS engines, demonstrating its efficacy in finding JS engine bugs.</p>\n", "tags": ["fuzzing", "language model"], "tsne_embedding": [-1.630055546760559, -8.246121406555176]}, {"key": "levy2017learning", "year": "2017", "title": "Learning to Align the Source Code to the Compiled Object Code", "abstract": "<p>We propose a new neural network architecture\nand use it for the task of statement-by-statement\nalignment of source code and its compiled object code. Our architecture learns the alignment\nbetween the two sequences \u2013 one being the translation of the other \u2013 by mapping each statement\nto a context-dependent representation vector and\naligning such vectors using a grid of the two sequence domains. Our experiments include short\nC functions, both artificial and human-written,\nand show that our neural network architecture\nis able to predict the alignment with high accuracy, outperforming known baselines. We also\ndemonstrate that our model is general and can\nlearn to solve graph problems such as the Traveling Salesman Problem.</p>\n", "tags": ["decompilation"], "tsne_embedding": [7.6009345054626465, 9.7302885055542]}, {"key": "li2016gated", "year": "2016", "title": "Gated Graph Sequence Neural Networks", "abstract": "<p>Graph-structured data appears frequently in domains including chemistry, natural\nlanguage semantics, social networks, and knowledge bases. In this work, we study\nfeature learning techniques for graph-structured inputs. Our starting point is previous work on Graph Neural Networks (Scarselli et al., 2009), which we modify\nto use gated recurrent units and modern optimization techniques and then extend\nto output sequences. The result is a flexible and broadly useful class of neural network models that has favorable inductive biases relative to purely sequence-based\nmodels (e.g., LSTMs) when the problem is graph-structured. We demonstrate the\ncapabilities on some simple AI (bAbI) and graph algorithm learning tasks. We\nthen show it achieves state-of-the-art performance on a problem from program\nverification, in which subgraphs need to be described as abstract data structures.</p>\n\n", "tags": ["GNN", "program analysis"], "tsne_embedding": [7.542778015136719, 10.562477111816406]}, {"key": "li2017code", "year": "2017", "title": "Code Completion with Neural Attention and Pointer Networks", "abstract": "<p>Intelligent code completion has become an essential tool to accelerate modern software development. To facilitate effective code completion for dynamically-typed programming languages, we apply neural language models by learning from large codebases, and investigate the effectiveness of attention mechanism on the code completion task. However, standard neural language models even with attention mechanism cannot correctly predict out-of-vocabulary (OoV) words thus restrict the code completion performance. In this paper, inspired by the prevalence of locally repeated terms in program source code, and the recently proposed pointer networks which can reproduce words from local context, we propose a pointer mixture network for better predicting OoV words in code completion. Based on the context, the pointer mixture network learns to either generate a within-vocabulary word through an RNN component, or copy an OoV word from local context through a pointer component. Experiments on two benchmarked datasets demonstrate the effectiveness of our attention mechanism and pointer mixture network on the code completion task.</p>\n\n", "tags": ["language model", "autocomplete"], "tsne_embedding": [5.568307876586914, 1.9858214855194092]}, {"key": "li2017software", "year": "2017", "title": "Software Defect Prediction via Convolutional Neural Network", "abstract": "<p>To improve software reliability, software defect prediction is utilized to assist developers in finding potential bugs\nand allocating their testing efforts. Traditional defect prediction\nstudies mainly focus on designing hand-crafted features, which\nare input into machine learning classifiers to identify defective\ncode. However, these hand-crafted features often fail to capture\nthe semantic and structural information of programs. Such\ninformation is important in modeling program functionality and\ncan lead to more accurate defect prediction.\nIn this paper, we propose a framework called Defect Prediction\nvia Convolutional Neural Network (DP-CNN), which leverages\ndeep learning for effective feature generation. Specifically, based\non the programs\u2019 Abstract Syntax Trees (ASTs), we first extract\ntoken vectors, which are then encoded as numerical vectors\nvia mapping and word embedding. We feed the numerical\nvectors into Convolutional Neural Network to automatically\nlearn semantic and structural features of programs. After that,\nwe combine the learned features with traditional hand-crafted\nfeatures, for accurate software defect prediction. We evaluate our\nmethod on seven open source projects in terms of F-measure in\ndefect prediction. The experimental results show that in average,\nDP-CNN improves the state-of-the-art method by 12%.</p>\n\n", "tags": ["defect"], "tsne_embedding": [-4.501266002655029, -3.630295515060425]}, {"key": "li2019improving", "year": "2019", "title": "Improving Bug Detection via Context-Based Code Representation Learning and Attention-Based Neural Networks", "abstract": "<p>Bug detection has been shown to be an effective way to help developers in detecting bugs early, thus, saving much effort and time in software development process. Recently, deep learning-based bug detection approaches have gained successes over the traditional machine learning-based approaches, the rule-based program analysis approaches, and mining-based approaches. However, they are still limited in detecting bugs that involve multiple methods and suffer high rate of false positives. In this paper, we propose a combination approach with the use of contexts and attention neural network to overcome those limitations. We propose to use as the global context the Program Dependence Graph (PDG) and Data Flow Graph (DFG) to connect the method under investigation with the other relevant methods that might contribute to the buggy code. The global context is complemented by the local context extracted from the path on the AST built from the method\u2019s body. The use of PDG and DFG enables our model to reduce the false positive rate, while to complement for the potential reduction in recall, we make use of the attention neural network mechanism to put more weights on the buggy paths in the source code. That is, the paths that are similar to the buggy paths will be ranked higher, thus, improving the recall of our model. We have conducted several experiments to evaluate our approach on a very large dataset with +4.973M methods in 92 different project versions. The results show that our tool can have a relative improvement up to 160% on F-score when comparing with the state-of-the-art bug detection approaches. Our tool can detect 48 true bugs in the list of top 100 reported bugs, which is 24 more true bugs when comparing with the baseline approaches. We also reported that our representation is better suitable for bug detection and relatively improves over the other representations up to 206% in accuracy.</p>\n", "tags": ["representation", "defect"], "tsne_embedding": [-7.063248634338379, -2.4357786178588867]}, {"key": "li2019neural", "year": "2019", "title": "Neural Code Search Evaluation Dataset", "abstract": "<p>There has been an increase of interest in code search using natural language. Assessing the performance of such code search models can be difficult without a readily available evaluation suite. In this paper, we present an evaluation dataset consisting of natural language query and code snippet pairs, with the hope that future work in this area can use this dataset as a common benchmark. We also provide the results of two code search models ([1] and [6]) from recent work.</p>\n", "tags": ["dataset", "search"], "tsne_embedding": [8.630499839782715, 3.714440107345581]}, {"key": "li2019using", "year": "2019", "title": "Using GGNN to recommend log statement level", "abstract": "<p>In software engineering, log statement is an important part because programmers can\u2019t access to users\u2019 program and they can only rely on log message to find the root of bugs. The mechanism of \u201clog level\u201d allows developers and users to specify the appropriate amount of logs to print during the execution of the software. And 26\\% of the log statement modification is to modify the level. We tried to use ML method to predict the suitable level of log statement. The specific model is GGNN(gated graph neural network) and we have drawn lessons from Microsoft\u2019s research. In this work, we apply Graph Neural Networks to predict the usage of log statement level of some open source java projects from github. Given the good performance of GGNN in this task, we are confident that GGNN is an excellent choice for processing source code. We envision this model can play an important role in applying AI/ML technique for Software Development Life Cycle more broadly.</p>\n", "tags": ["GNN", "logging"], "tsne_embedding": [0.35528483986854553, 1.2744441032409668]}, {"key": "li2020dlfix", "year": "2020", "title": "DLFix: Context-based Code Transformation Learning for Automated Program Repair", "abstract": "<p>Automated Program Repair (APR) is very useful in helping developers in the process of software development and maintenance. Despite recent advances in deep learning (DL), the DL-based APR approaches still have limitations in learning bug-fixing code changes and the context of the surrounding source code of the bug-fixing code changes. These limitations lead to incorrect fixing locations or fixes. In this paper, we introduce DLFix, a two-tier DL model that treats APR as code transformation learning from the prior bug fixes and the surrounding code contexts of the fixes. The first layer is a tree-based RNN model that learns the contexts of bug fixes and its result is used as an additional weighting input for the second layer designed to learn the bug-fixing code transformations.</p>\n\n<p>We conducted several experiments to evaluate DLFix in two benchmarks: Defect4J and Bugs.jar, and a newly built bug datasets with a total of +20K real-world bugs in eight projects. We compared DLFix against a total of 13 state-of-the-art pattern-based APR tools. Our results show that DLFix can auto-fix more bugs than 11 of them, and is comparable and complementary to the top two pattern-based APR tools in which there are 7 and 11 unique bugs that they cannot detect, respectively, but we can. Importantly, DLFix is fully automated and data-driven, and does not require hard-coding of bug-fixing patterns as in those tools. We compared DLFix against 4 state-of-the-art deep learning based APR models. DLFix is able to fix 2.5 times more bugs than the best performing~baseline.</p>\n", "tags": ["edit", "repair", "AST"], "tsne_embedding": [-6.210779190063477, -3.539968490600586]}, {"key": "lin2017program", "year": "2017", "title": "Program Synthesis from Natural Language Using Recurrent Neural Networks", "abstract": "<p>Oftentimes, a programmer may have difficulty implementing a\ndesired operation. Even when the programmer can describe her\ngoal in English, it can be difficult to translate into code. Existing\nresources, such as question-and-answer websites, tabulate specific\noperations that someone has wanted to perform in the past, but\nthey are not effective in generalizing to new tasks, to compound\ntasks that require combining previous questions, or sometimes even\nto variations of listed tasks.</p>\n\n<p>Our goal is to make programming easier and more productive by\nletting programmers use their own words and concepts to express\nthe intended operation, rather than forcing them to accommodate\nthe machine by memorizing its grammar. We have built a system\nthat lets a programmer describe a desired operation in natural language, then automatically translates it to a programming language\nfor review and approval by the programmer. Our system, Tellina,\ndoes the translation using recurrent neural networks (RNNs), a\nstate-of-the-art natural language processing technique that we augmented with slot (argument) filling and other enhancements.</p>\n\n<p>We evaluated Tellina in the context of shell scripting. We trained\nTellina\u2019s RNNs on textual descriptions of file system operations\nand bash one-liners, scraped from the web. Although recovering\ncompletely correct commands is challenging, Tellina achieves top-3\naccuracy of 80% for producing the correct command structure. In a\ncontrolled study, programmers who had access to Tellina outperformed those who did not, even when Tellina\u2019s predictions were\nnot completely correct, to a statistically significant degree.</p>\n", "tags": ["bimodal", "generation"], "tsne_embedding": [-8.989612579345703, 1.9346362352371216]}, {"key": "lin2018nl2bash", "year": "2018", "title": "NL2Bash: A Corpus and Semantic Parser for Natural Language Interface to the Linux Operating System.", "abstract": "<p>We present new data and semantic parsing methods for the problem of mapping english sentences to Bash commands (NL2Bash). Our long-term goal is to enable any user to easily solve otherwise repetitive tasks (such as file manipulation, search, and application-specific scripting) by simply stating their intents in English. We take a first step in this domain, by providing a large new dataset of challenging but commonly used commands paired with their English descriptions, along with the baseline methods to establish performance levels on this task.</p>\n", "tags": ["bimodal", "generation"], "tsne_embedding": [0.42019936442375183, 3.0356781482696533]}, {"key": "lin2019impact", "year": "2019", "title": "On the Impact of Refactoring Operations on Code Naturalness", "abstract": "<p>Recent studies have demonstrated that software is natural, that is, its source code is highly repetitive and predictable like human languages. Also, previous studies suggested the existence of a relationship between code quality and its naturalness, presenting empirical evidence showing that buggy code is \u201cless natural\u201d than non-buggy code. We conjecture that this qualitynaturalness relationship could be exploited to support refactoring activities (e.g., to locate source code areas in need of refactoring). We perform a first step in this direction by analyzing whether refactoring can improve the naturalness of code. We use state-of-the-art tools to mine a large dataset of refactoring operations performed in open source systems. Then, we investigate the impact of different types of refactoring operations on the naturalness of the impacted code. We found that (i) code refactoring does not necessarily increase the naturalness of the refactored code; and (ii) the impact on the code naturalness strongly depends on the type of refactoring operations.</p>\n", "tags": ["language model", "refactoring"], "tsne_embedding": [-7.354689598083496, 4.379967212677002]}, {"key": "ling2016latent", "year": "2016", "title": "Latent Predictor Networks for Code Generation", "abstract": "<p>Many  language  generation  tasks  require\nthe production of text conditioned on both\nstructured  and  unstructured  inputs.\nWe present  a  novel  neural  network  architecture  which  generates  an  output  sequence\nconditioned on an arbitrary number of input  functions.\nCrucially,  our  approach\nallows  both  the  choice  of  conditioning\ncontext and the granularity of generation,\nfor  example  characters  or  tokens,  to  be\nmarginalised, thus permitting scalable and\neffective training.  Using this framework,\nwe address the problem of generating programming code from a mixed natural language  and  structured  specification.\nWe create two new data sets for this paradigm\nderived  from  the  collectible  trading  card\ngames  Magic  the  Gathering  and  Hearthstone.   On  these,  and  a  third  preexisting\ncorpus,  we  demonstrate  that  marginalising multiple predictors allows our model\nto outperform strong benchmarks.</p>\n\n", "tags": ["bimodal", "generation"], "tsne_embedding": [9.919455528259277, -2.1435463428497314]}, {"key": "liu2016towards", "year": "2016", "title": "Towards Better Program Obfuscation: Optimization via Language Models", "abstract": "<p>As a common practice in software development, program\nobfuscation aims at deterring reverse engineering and malicious attacks on released source or binary code. Owning ample obfuscation techniques, we have relatively little\nknowledge on how to most effectively use them. The biggest\nchallenge lies in identifying the most useful combination of\nthese techniques. We propose a unified framework to automatically generate and optimize obfuscation based on an\nobscurity language model and a Monte Carlo Markov Chain\n(MCMC) based search algorithm. We further instantiate it\nfor JavaScript programs and developed the Closure tool.\nCompared to the well-known Google Closure Compiler, Closure outperforms its default setting by 26%. For programs\nwhich have already been well obfuscated, Closure can still\noutperform by 22%.</p>\n", "tags": ["deobfuscation"], "tsne_embedding": [-4.905086517333984, 1.485192894935608]}, {"key": "liu2018neural", "year": "2018", "title": "Neural-Machine-Translation-Based Commit Message Generation: How Far Are We?", "abstract": "<p>Commit messages can be regarded as the documentation of software changes. These messages describe the content and purposes of changes, hence are useful for program comprehension and software maintenance. However, due to the lack of time and direct motivation, commit messages sometimes are neglected by developers. To address this problem, Jiang et al. proposed an approach (we refer to it as NMT), which leverages a neural machine translation algorithm to automatically generate short commit messages from code. The reported performance of their approach is promising, however, they did not explore why their approach performs well. Thus, in this paper, we first perform an in-depth analysis of their experimental results. We find that (1) Most of the test &lt;pre&gt;diffs&lt;/pre&gt; from which NMT can generate high-quality messages are similar to one or more training &lt;pre&gt;diffs&lt;/pre&gt; at the token level. (2) About 16% of the commit messages in Jiang et al.\u2019s dataset are noisy due to being automatically generated or due to them describing repetitive trivial changes. (3) The performance of NMT declines by a large amount after removing such noisy commit messages. In addition, NMT is complicated and time-consuming. Inspired by our first finding, we proposed a simpler and faster approach, named NNGen (Nearest Neighbor Generator), to generate concise commit messages using the nearest neighbor algorithm. Our experimental results show that NNGen is over 2,600 times faster than NMT, and outperforms NMT in terms of BLEU (an accuracy measure that is widely used to evaluate machine translation systems) by 21%. Finally, we also discuss some observations for the road ahead for automated commit message generation to inspire other researchers.</p>\n", "tags": ["edit", "summarization"], "tsne_embedding": [-8.560309410095215, -0.9320430755615234]}, {"key": "liu2019deepfuzz", "year": "2019", "title": "DeepFuzz: Automatic Generation of Syntax Valid C Programs for Fuzz Testing", "abstract": "<p>Compilers  are among  the  most  fundamental  programming\ntools for building software. However, production compilers\nremain  buggy.  Fuzz  testing  is  often  leveraged  with  newly-generated,\nor  mutated  inputs  in  order  to  find  new  bugs  or security vulnerabilities.\nIn this paper, we propose a grammar-based fuzzing tool called DeepFuzz. Based on a generative\nSequence-to-Sequence model, DeepFuzz automatically and continuously generates well-formed\nC programs. We use this set of new C programs to fuzz off-the-shelf C compilers, e.g. GCC and Clang/LLVM.\nWe present a detailed case study to analyze  the  success  rate  and  coverage  improvement  of  the\ngenerated C programs for fuzz testing. We analyze the performance of DeepFuzz with three types of sampling\nmethods  as  well  as  three  types  of  generation  strategies.  Consequently, DeepFuzz \nimproved the testing efficacy in regards to the line, function, and branch coverage. In our preliminary\nstudy, we found and reported 8 bugs of GCC, all of which are actively being addressed by developers.</p>\n", "tags": ["fuzzing", "generation"], "tsne_embedding": [-10.6587553024292, -2.591090679168701]}, {"key": "liu2019generating", "year": "2019", "title": "Generating commit messages from diffs using pointer-generator network", "abstract": "<p>The commit messages in source code repositories are valuable but not easy to be generated manually in time for tracking issues, reporting bugs, and understanding codes. Recently published works indicated that the deep neural machine translation approaches have drawn considerable attentions on automatic generation of commit messages. However, they could not deal with out-of-vocabulary (OOV) words, which are essential context-specific identifiers such as class names and method names in code diffs. In this paper, we propose PtrGNCMsg, a novel approach which is based on an improved sequence-to-sequence model with the pointer-generator network to translate code diffs into commit messages. By searching the smallest identifier set with the highest probability, PtrGNCMsg outperforms recent approaches based on neural machine translation, and first enables the prediction of OOV words. The experimental results based on the corpus of diffs and manual commit messages from the top 2,000 Java projects in GitHub show that PtrGNCMsg outperforms the state-of-the-art approach with improved BLEU by 1.02, ROUGE-1 by 4.00 and ROUGE-L by 3.78, respectively.</p>\n", "tags": ["edit"], "tsne_embedding": [-8.661376953125, 0.029763784259557724]}, {"key": "liu2019learning", "year": "2019", "title": "Learning to Sport and Refactor Inconsistent Method Names", "abstract": "<p>To ensure code readability and facilitate software maintenance, program methods must be named properly. In particular, method names must be consistent with the corresponding method implementations. Debugging method names remains an important topic in the literature, where various approaches analyze commonalities among method names in a large dataset to detect inconsistent method names and suggest better ones. We note that the state-of-the-art does not analyze the implemented code itself to assess consistency. We thus propose a novel automated approach to debugging method names based on the analysis of consistency between method names and method code. The approach leverages deep feature representation techniques adapted to the nature of each artifact. Experimental results on over 2.1 million Java methods show that we can achieve up to 15 percentage points improvement over the state-of-the-art, establishing a record performance of 67.9% F1-measure in identifying inconsistent method names. We further demonstrate that our approach yields up to 25% accuracy in suggesting full names, while the state-of-the-art lags far behind at 1.1% accuracy. Finally, we report on our success in fixing 66 inconsistent method names in a live study on projects in the wild.</p>\n", "tags": ["naming"], "tsne_embedding": [-5.300167560577393, -0.47036612033843994]}, {"key": "liu2019neural", "year": "2019", "title": "Neural query expansion for code search", "abstract": "<p>Searching repositories of existing source code for code snippets is a key task in software engineering. Over the years, many approaches to this problem have been proposed. One recent tool called NCS, takes in a natural language query and outputs relevant code snippets, often being able to correctly answer Stack Overflow questions. But what happens when the developer doesn\u2019t provide a query with a clear intent? What if shorter queries are used to demonstrate a more vague intent?</p>\n\n<p>We find that the performance of NCS regresses with shorter queries. Furthermore, data from developers\u2019 code search history logs shows that shorter queries have a less successful code search session: there are more query reformulations and more time is spent browsing the results. These observations lead us to believe that using NCS alone with short queries may not be productive enough.</p>\n\n<p>In this paper, we explore an additional way of using neural networks in code search: the automatic expansion of queries. We present NQE, a neural model that takes in a set of keywords and predicts a set of keywords to expand the query to NCS. NQE learns to predict keywords that co-occur with the query keywords in the underlying corpus, which helps expand the query in a productive way. Our results show that with query expansion, NQE + NCS is able to perform better than using NCS alone.</p>\n", "tags": ["search"], "tsne_embedding": [2.7370364665985107, 6.220909595489502]}, {"key": "louis2018deep", "year": "2018", "title": "Deep Learning to Detect Redundant Method Comments", "abstract": "<p>Comments in software are critical for maintenance and reuse. But apart from prescriptive advice, there is little practical support or quantitative understanding of what makes a comment useful. In this paper, we introduce the task of identifying comments which are uninformative about the code they are meant to document. To address this problem, we introduce the notion of comment entailment from code, high entailment indicating that a comment\u2019s natural language semantics can be inferred directly from the code. Although not all entailed comments are low quality, comments that are too easily inferred, for example, comments that restate the code, are widely discouraged by authorities on software style. Based on this, we develop a tool called CRAIC which scores method-level comments for redundancy. Highly redundant comments can then be expanded or alternately removed by the developer. CRAIC uses deep language models to exploit large software corpora without requiring expensive manual annotations of entailment. We show that CRAIC can perform the comment entailment task with good agreement with human judgements. Our findings also have implications for documentation tools. For example, we find that common tags in Javadoc are at least two times more predictable from code than non-Javadoc sentences, suggesting that Javadoc tags are less informative than more free-form comments</p>\n", "tags": ["bimodal", "documentation"], "tsne_embedding": [-2.2754530906677246, -0.7014720439910889]}, {"key": "louis2020where", "year": "2020", "title": "Where should I comment my code? A dataset and model for predicting locations that need comments", "abstract": "<p>Programmers should write code comments, but not on every line\nof code. We have created a machine learning model that suggests\nlocations where a programmer should write a code comment. We\ntrained it on existing commented code to learn locations that are\nchosen by developers. Once trained, the model can predict locations\nin new code. Our models achieved precision of 74% and recall of\n13% in identifying comment-worthy locations. This first success\nopens the door to future work, both in the new where-to-comment\nproblem and in guiding comment generation.</p>\n", "tags": ["bimodal", "documentation"], "tsne_embedding": [0.3227636218070984, -5.293636798858643]}, {"key": "loyola2017neural", "year": "2017", "title": "A Neural Architecture for Generating Natural Language Descriptions from Source Code Changes", "abstract": "<p>We propose a model to automatically describe changes introduced in the source code of a program using natural language. Our method receives as input a set of code commits, which contains both the modifications and message introduced by an user. These two modalities are used to train an encoder-decoder architecture. We evaluated our approach on twelve real world open source projects from four different programming languages. Quantitative and qualitative results showed that the proposed approach can generate feasible and semantically sound descriptions not only in standard in-project settings, but also in a cross-project setting.</p>\n", "tags": ["edit", "summarization"], "tsne_embedding": [8.550076484680176, 5.657169342041016]}, {"key": "loyola2018content", "year": "2018", "title": "Content Aware Source Code Change Description Generation", "abstract": "<p>We propose to study the generation of descriptions from source code changes by integrating  the  messages  included  on  code\ncommits and the intra-code documentation\ninside the source in the form of docstrings.\nOur hypothesis is that although both types\nof descriptions are not directly aligned in\nsemantic terms \u2014one explaining a change\nand  the  other  the  actual  functionality  of\nthe code being modified\u2014 there could be\ncertain common ground that is useful for\nthe  generation.   To  this  end,  we  propose\nan architecture that uses the source code-docstring relationship to guide the description generation.  We discuss the results of\nthe approach comparing against a baseline\nbased  on  a  sequence-to-sequence  model,\nusing standard automatic natural language\ngeneration metrics as well as with a human\nstudy, thus offering a comprehensive view\nof the feasibility of the approach.</p>\n", "tags": ["edit", "summarization"], "tsne_embedding": [9.100845336914062, 5.685065269470215]}, {"key": "lu2019program", "year": "2019", "title": "Program Classification Using Gated Graph Attention Neural Network for Online Programming Service", "abstract": "<p>The online programing services, such as Github, TopCoder, and EduCoder, have promoted a lot of social interactions among the service users. However, the existing social interactions is rather limited and inefficient due to the rapid increasing of source-code repositories, which is difficult to explore manually. The emergence of source-code mining provides a promising way to analyze those source codes, so that those source codes can be relatively easy to understand and share among those service users. Among all the source-code mining attempts,program classification lays a foundation for various tasks related to source-code understanding, because it is impossible for a machine to understand a computer program if it cannot classify the program correctly. Although numerous machine learning models, such as the Natural Language Processing (NLP) based models and the Abstract Syntax Tree (AST) based models, have been proposed to classify computer programs based on their corresponding source codes, the existing works cannot fully characterize the source codes from the perspective of both the syntax and semantic information. To address this problem, we proposed a Graph Neural Network (GNN) based model, which integrates data flow and function call information to the AST,and applies an improved GNN model to the integrated graph, so as to achieve the state-of-art program classification accuracy. The experiment results have shown that the proposed work can classify programs with accuracy over 97%.</p>\n", "tags": ["GNN", "representation"], "tsne_embedding": [1.2876774072647095, 8.514429092407227]}, {"key": "luan2019aroma", "year": "2015", "title": "Aroma: code recommendation via structural code search", "abstract": "<p>Programmers often write code that has similarity to existing code written somewhere. A tool that could help programmers to search such similar code would be immensely useful. Such a tool could help programmers to extend partially written code snippets to completely implement necessary functionality, help to discover extensions to the partial code which are commonly included by other programmers, help to cross-check against similar code written by other programmers, or help to add extra code which would fix common mistakes and errors. We propose Aroma, a tool and technique for code recommendation via structural code search. Aroma indexes a huge code corpus including thousands of open-source projects, takes a partial code snippet as input, searches the corpus for method bodies containing the partial code snippet, and clusters and intersects the results of the search to recommend a small set of succinct code snippets which both contain the query snippet and appear as part of several methods in the corpus. We evaluated Aroma on 2000 randomly selected queries created from the corpus, as well as 64 queries derived from code snippets obtained from Stack Overflow, a popular website for discussing code. We implemented Aroma for 4 different languages, and developed an IDE plugin for Aroma. Furthermore, we conducted a study where we asked 12 programmers to complete programming tasks using Aroma, and collected their feedback. Our results indicate that Aroma is capable of retrieving and recommending relevant code snippets efficiently.</p>\n", "tags": ["retrieval"], "tsne_embedding": [1.667495608329773, -8.894811630249023]}, {"key": "maddison2014structured", "year": "2014", "title": "Structured Generative Models of Natural Source Code", "abstract": "<p>We study the problem of building generative\nmodels of natural source code (NSC); that is,\nsource code written by humans and meant to\nbe understood by humans. Our primary con-\ntribution is to describe new generative models\nthat are tailored to NSC. The models are based\non probabilistic context free grammars (PCFGs)\nand neuro-probabilistic language models (Mnih\n&amp; Teh, 2012), which are extended to incorporate\nadditional source code-specific structure. These\nmodels can be efficiently trained on a corpus\nof source code and outperform a variety of less\nstructured baselines in terms of predictive log\nlikelihoods on held-out data.</p>\n\n", "tags": ["language model", "generation", "grammar", "AST"], "tsne_embedding": [8.315439224243164, 6.125748634338379]}, {"key": "malik2019nl2type", "year": "2019", "title": "NL2Type: Inferring JavaScript Function Types from Natural Language Information", "abstract": "<p>JavaScript is dynamically typed and hence lacks thetype safety  of  statically  typed  languages,\nleading  to  suboptimal IDE support, difficult to understand APIs, and unexpected run-time behavior.\nSeveral gradual type systems have been proposed, e.g., Flow and TypeScript, but they rely on developers\nto annotatecode with types. This paper presents NL2Type, a learning-based approach for predicting likely\ntype signatures of JavaScript functions. The key idea is to exploit natural language information in\nsource code, such as comments, function names, and parameternames,  a  rich  source  of  knowledge\nthat  is  typically  ignored by  type  inference  algorithms.  We  formulate  the  problem  of predicting\ntypes as a classification problem and train a recurrent, LSTM-based neural model that, after learning\nfrom an annotatedcode  base,  predicts  function  types  for  unannotated  code.  We evaluate   the \napproach   with   a   corpus   of   162,673   JavaScript files  from  real-world  projects. \nNL2Type  predicts  types  with  aprecision of 84.1% and a recall of 78.9% when considering only\nthe  top-most  suggestion,  and  with  a  precision  of  95.5%  and  arecall  of  89.6%  when\nconsidering  the  top-5  suggestions.  The\napproach  outperforms  both  JSNice,  a  state-of-the-art  approach that  analyzes  implementations \nof  functions  instead  of  natural language  information,  and  DeepTyper,  a  recent  type  prediction\napproach that is also based on deep learning. Beyond predicting types,  NL2Type  serves  as  a\nconsistency  checker  for  existing type  annotations.  We  show  that  it  discovers  39  inconsistencies\nthat  deserve  developer  attention  (from  a  manual  analysis  of  50 warnings), most of which \nare due to incorrect type annotations.</p>\n", "tags": ["bimodal", "types"], "tsne_embedding": [-1.9417260885238647, 2.3170061111450195]}, {"key": "mammadli2020static", "year": "2020", "title": "Static Neural Compiler Optimization via Deep Reinforcement Learning", "abstract": "<p>The phase-ordering problem of modern compilers has received a lot of attention from the research community over the years, yet remains largely unsolved. Various optimization sequences exposed to the user are manually designed by compiler developers. In designing such a sequence developers have to choose the set of optimization passes, their parameters and ordering within a sequence. Resulting sequences usually fall short of achieving optimal runtime for a given source code and may sometimes even degrade the performance when compared to unoptimized version. In this paper, we employ a deep reinforcement learning approach to the phase-ordering problem. Provided with sub-sequences constituting LLVM\u2019s O3 sequence, our agent learns to outperform the O3 sequence on the set of source codes used for training and achieves competitive performance on the validation set, gaining up to 1.32x speedup on previously-unseen programs. Notably, our approach differs from autotuning methods by not depending on one or more test runs of the program for making successful optimization decisions. It has no dependence on any dynamic feature, but only on the statically-attainable intermediate representation of the source code. We believe that the models trained using our approach can be integrated into modern compilers as neural optimization agents, at first to complement, and eventually replace the hand-crafted optimization sequences.</p>\n", "tags": ["compilation"], "tsne_embedding": [-8.25218677520752, -3.5516343116760254]}, {"key": "mangal2015user", "year": "2015", "title": "A User-Guided Approach to Program Analysis", "abstract": "<p>Program analysis tools often produce undesirable output\ndue to various approximations. We present an approach\nand a system Eugene that allows user feedback to guide\nsuch approximations towards producing the desired output.\nWe formulate the problem of user-guided program analysis in terms of solving a combination of hard rules and soft\nrules: hard rules capture soundness while soft rules capture\ndegrees of approximations and preferences of users. Our\ntechnique solves the rules using an off-the-shelf solver in a\nmanner that is sound (satisfies all hard rules), optimal (maximally satisfies soft rules), and scales to real-world analy-\nses and programs. We evaluate Eugene on two different\nanalyses with labeled output on a suite of seven Java pro-\ngrams of size 131\u2013198 KLOC. We also report upon a user\nstudy involving nine users who employ Eugene to guide an\ninformation-flow analysis on three Java micro-benchmarks.\nIn our experiments, Eugene significantly reduces misclassified reports upon providing limited amounts of feedback.</p>\n", "tags": ["program analysis"], "tsne_embedding": [-12.006375312805176, -4.370397567749023]}, {"key": "markovtsev2017topic", "year": "2017", "title": "Topic modeling of public repositories at scale using names in source code", "abstract": "<p>Programming languages themselves have a limited number of reserved keywords and character based tokens that\ndefine the language specification. However, programmers have a rich use of natural language within their code\nthrough comments, text literals and naming entities. The programmer defined names that can be found in source\ncode are a rich source of information to build a high level understanding of the project. The goal of this paper\nis to apply topic modeling to names used in over 13.6 million repositories and perceive the inferred topics.\nOne of the problems in such a study is the occurrence of duplicate repositories not officially marked as forks (obscure forks).\nWe show how to address it using the same identifiers which are extracted for topic modeling.</p>\n\n<p>We open with a discussion on naming in source code, we then elaborate on our approach to remove exact duplicate\nand fuzzy duplicate repositories using Locality Sensitive Hashing on the bag-of-words model and then discuss our work\non topic modeling; and finally present the results from our data analysis together with open-access to the source code,\ntools and datasets.</p>\n", "tags": ["topic modeling", "pattern mining"], "tsne_embedding": [1.6709953546524048, -8.533795356750488]}, {"key": "markovtsev2018public", "year": "2018", "title": "Public Git Archive: a Big Code dataset for all", "abstract": "<p>The number of open source software projects has been growing exponentially. The major online software repository host, GitHub, has accumulated tens of millions of publicly available Git version-controlled repositories. Although the research potential enabled by the available open source code is clearly substantial, no significant large-scale open source code datasets exist. In this paper, we present the Public Git Archive \u2013 dataset of 182,014 top-bookmarked Git repositories from GitHub. We describe the novel data retrieval pipeline to reproduce it. We also elaborate on the strategy for performing dataset updates and legal issues. The Public Git Archive occupies 3.0 TB on disk and is an order of magnitude larger than the current source code datasets. The dataset is made available through HTTP and provides the source code of the projects, the related metadata, and development history. The data retrieval pipeline employs an optimized worker queue model and an optimized archive format to efficiently store forked Git repositories, reducing the amount of data to download and persist. Public Git Archive aims to open a myriad of new opportunities for Big Code research.</p>\n", "tags": ["dataset"], "tsne_embedding": [4.610107898712158, -6.048895359039307]}, {"key": "markovtsev2019style", "year": "2019", "title": "STYLE-ANALYZER: fixing code style inconsistencies with interpretable unsupervised algorithms", "abstract": "<p>Source code reviews are manual, time-consuming, and expensive. Human involvement should be focused on analyzing the most relevant aspects of the program, such as logic and maintainability, rather than amending style, syntax, or formatting defects. Some tools with linting capabilities can format code automatically and report various stylistic violations for supported programming languages. They are based on rules written by domain experts, hence, their configuration is often tedious, and it is impractical for the given set of rules to cover all possible corner cases. Some machine learning-based solutions exist, but they remain uninterpretable black boxes. This paper introduces STYLE-ANALYZER, a new open source tool to automatically fix code formatting violations using the decision tree forest model which adapts to each codebase and is fully unsupervised. STYLE-ANALYZER is built on top of our novel assisted code review framework, Lookout. It accurately mines the formatting style of each analyzed Git repository and expresses the found format patterns with compact human-readable rules. STYLE-ANALYZER can then suggest style inconsistency fixes in the form of code review comments. We evaluate the output quality and practical relevance of STYLE-ANALYZER by demonstrating that it can reproduce the original style with high precision, measured on 19 popular JavaScript projects, and by showing that it yields promising results in fixing real style mistakes. STYLE-ANALYZER includes a web application to visualize how the rules are triggered. We release STYLE-ANALYZER as a reusable and extendable open source software package on GitHub for the benefit of the community.</p>\n", "tags": ["style"], "tsne_embedding": [-1.492753505706787, -3.1234021186828613]}, {"key": "menon2013machine", "year": "2013", "title": "A Machine Learning Framework for Programming by Example", "abstract": "<p>Learning programs is a timely and interesting challenge. In Programming by Example\n(PBE), a system attempts to infer a program\nfrom input and output examples alone, by\nsearching for a composition of some set of\nbase functions. We show how machine learning can be used to speed up this seemingly\nhopeless search problem, by learning weights\nthat relate textual features describing the\nprovided input-output examples to plausible\nsub-components of a program. This generic\nlearning framework lets us address problems\nbeyond the scope of earlier PBE systems.\nExperiments on a prototype implementation\nshow that learning improves search and ranking on a variety of text processing tasks found\non help forums.</p>\n", "tags": ["generation"], "tsne_embedding": [5.846199989318848, 0.5836147665977478]}, {"key": "mesbah2019deepdelta", "year": "2019", "title": "DeepDelta: Learning to Repair Compilation Errors", "abstract": "<p>Programmers spend a substantial amount of time manually repairing\ncode that does not compile. We observe that the repairs for\nany particular error class typically follow a pattern and are highly\nmechanical. We propose a novel approach that automatically learns\nthese patterns with a deep neural network and suggests program\nrepairs for the most costly classes of build-time compilation failures.\nWe describe how we collect all build errors and the human-authored,\nin-progress code changes that cause those failing builds to transition\nto successful builds at Google. We generate an AST diff from the\ntextual code changes and transform it into a domain-specific\nlanguage called Delta that encodes the change that must be made\nto make the code compile. We then feed the compiler diagnostic\ninformation (as source) and the Delta changes that resolved the\ndiagnostic (as target) into a Neural Machine Translation network for\ntraining. For the two most prevalent and costly classes of Java compilation errors,\nnamely missing symbols and mismatched methodsignatures, our system called DeepDelta,\ngenerates the correct repair changes for 19,314 out of 38,788 (50%) of unseen compilation\nerrors. The correct changes are in the top three suggested axes 86% of the time on average.</p>\n", "tags": ["repair", "edit", "compilation"], "tsne_embedding": [-6.070162296295166, -5.136356353759766]}, {"key": "mou2014building", "year": "2014", "title": "Building Program Vector Representations for Deep Learning", "abstract": "<p>Deep learning has made significant breakthroughs\nin various fields of artificial intelligence. Advantages of deep\nlearning include the ability to capture highly complicated features, weak involvement of human engineering, etc. However,\nit is still virtually impossible to use deep learning to analyze\nprograms since deep architectures cannot be trained effectively\nwith pure back propagation. In this pioneering paper, we propose\nthe \u201ccoding criterion\u201d to build program vector representations,\nwhich are the premise of deep learning for program analysis. Our\nrepresentation learning approach directly makes deep learning a\nreality in this new field. We evaluate the learned vector representations both qualitatively and quantitatively. We conclude, based\non the experiments, the coding criterion is successful in building\nprogram representations. To evaluate whether deep learning\nis beneficial for program analysis, we feed the representations\nto deep neural networks, and achieve higher accuracy in the\nprogram classification task than \u201cshallow\u201d methods, such as\nlogistic regression and the support vector machine. This result\nconfirms the feasibility of deep learning to analyze programs. It\nalso gives primary evidence of its success in this new field. We\nbelieve deep learning will become an outstanding technique for\nprogram analysis in the near future.</p>\n\n", "tags": ["representation", "AST"], "tsne_embedding": [1.7523106336593628, 9.783618927001953]}, {"key": "mou2016convolutional", "year": "2016", "title": "Convolutional Neural Networks over Tree Structures for Programming Language Processing", "abstract": "<p>Programming language processing (similar to natural language processing) is a hot research topic in the field of software engineering; it has also aroused growing interest in the\nartificial intelligence community. However, different from a\nnatural language sentence, a program contains rich, explicit,\nand complicated structural information. Hence, traditional\nNLP models may be inappropriate for programs. In this paper, we propose a novel tree-based convolutional neural network (TBCNN) for programming language processing, in\nwhich a convolution kernel is designed over programs\u2019 abstract syntax trees to capture structural information. TBCNN\nis a generic architecture for programming language processing; our experiments show its effectiveness in two different program analysis tasks: classifying programs according\nto functionality, and detecting code snippets of certain patterns. TBCNN outperforms baseline methods, including several neural models for NLP.</p>\n", "tags": ["representation", "AST"], "tsne_embedding": [3.6540944576263428, 7.957285404205322]}, {"key": "movshovitz2013natural", "year": "2013", "title": "Natural Language Models for Predicting Programming Comments", "abstract": "<p>Statistical language models have successfully been used to describe and analyze\nnatural language documents. Recent work\napplying language models to programming languages is focused on the task\nof predicting code, while mainly ignoring\nthe prediction of programmer comments.\nIn this work, we predict comments from\nJAVA source files of open source projects,\nusing topic models and n-grams, and we\nanalyze the performance of the models\ngiven varying amounts of background data\non the project being predicted. We evaluate models on their comment-completion\ncapability in a setting similar to code completion tools built into standard code\neditors, and show that using a comment\ncompletion tool can save up to 47% of the\ncomment typing.</p>\n\n", "tags": ["bimodal", "documentation", "summarization"], "tsne_embedding": [-0.7507320046424866, 1.3261492252349854]}, {"key": "movshovitz2015kb", "year": "2015", "title": "KB-LDA: Jointly Learning a Knowledge Base of Hierarchy, Relations, and Facts", "abstract": "<p>Many existing knowledge bases (KBs), including Freebase, Yago, and NELL, rely\non a fixed ontology, given as an input\nto the system, which defines the data to\nbe cataloged in the KB, i.e., a hierarchy of categories and relations between\nthem. The system then extracts facts that\nmatch the predefined ontology. We propose an unsupervised model that jointly\nlearns a latent ontological structure of an\ninput corpus, and identifies facts from the\ncorpus that match the learned structure.\nOur approach combines mixed membership stochastic block models and topic\nmodels to infer a structure by jointly modeling text, a latent concept hierarchy, and\nlatent semantic relationships among the\nentities mentioned in the text. As a case\nstudy, we apply the model to a corpus\nof Web documents from the software domain, and evaluate the accuracy of the various components of the learned ontology.</p>\n", "tags": ["pattern mining"], "tsne_embedding": [9.760451316833496, 6.893518924713135]}, {"key": "mukherjee2020searching", "year": "2020", "title": "Searching a Database of Source Codes Using Contextualized Code Search", "abstract": "<p>We assume a database containing a large set of program source codes and consider the problem of contextualized code search over that database. A programmer has written some part of a program, but has left part of the program (such as a method or a function body) incomplete. The goal is to use the context surrounding the missing code to automatically \u2018figure out\u2019 which of the codes in the database would be useful to the programmer in order to help complete the missing code, in the sense that the programmer could either re-purpose the retrieved code and use the re-purposed code to fill the missing spot in the program. Or, the user could use the retrieved code as a model for implementing the missing code. The search is \u2018contextualized\u2019 in the sense that the search engine should use clues in the partially-completed code to figure out which database code is most useful. The user should not be required to formulate an explicit query.</p>\n\n<p>We cast contextualized code search as a learning problem, where the goal is to learn a distribution function computing the likelihood that each database code completes the program, and propose a neural model for predicting which database code is likely to be most useful. Because it will be prohibitively expensive to apply a neural model to each code in a database of millions or billions of codes at search time, one of our key technical concerns is ensuring a speedy search. We address this by learning a \u2018reverse encoder\u2019 that can be used to reduce the problem of evaluating each database code to computing a convolution of two normal distributions, making it possible to search a large database of codes in a reasonable time.</p>\n", "tags": ["search", "representation"], "tsne_embedding": [-3.2312991619110107, -3.4507319927215576]}, {"key": "murali2017bayesian", "year": "2017", "title": "Bayesian Sketch Learning for Program Synthesis", "abstract": "<p>We present a Bayesian statistical approach to the problem of automatic program synthesis. Our synthesizer starts\nby learning, offline and from an existing corpus, a probabilistic model of real-world programs. During synthesis,\nit is provided some ambiguous and incomplete evidence about the nature of the programming task that the user\nwants automated, for example sets of API calls or data types that are relevant for the task. Given this input, the\nsynthesizer infers a posterior distribution over type-safe programs that assigns higher likelihood to programs\nthat, according to the learned model, are more likely to match the evidence.</p>\n\n<p>We realize this approach using two key ideas. First, our learning techniques operate not over code but\nsyntactic abstractions, or sketches, of programs. During synthesis, we infer a posterior distribution over sketches,\nthen concretize samples from this distribution into type-safe programs using combinatorial techniques. Second,\nour statistical model explicitly models the full intent behind a synthesis task as a latent variable. To infer\nsketches, we first estimate a posterior distribution on the intent, then use samples from this posterior to generate\na distribution over possible sketches. We show that our model can be implemented effectively using the new\nneural architecture of Bayesian encoder-decoders, which can be trained with stochastic gradient descent and\nyields a simple inference procedure.</p>\n\n<p>We implement our ideas in a system, called BAYOU , for the synthesis of API-heavy Java methods. We train\nBAYOU on a large corpus of Android apps, and find that the trained system can often synthesize complex\nmethods given just a few API method names or data types as evidence. The experiments also justify the design\nchoice of using a latent intent variable and the levels of abstraction at which sketches and evidence are defined.</p>\n", "tags": ["generation", "API"], "tsne_embedding": [-7.10477352142334, 1.3092120885849]}, {"key": "murali2017finding", "year": "2017", "title": "Finding Likely Errors with Bayesian Specifications", "abstract": "<p>We present a Bayesian framework for learning probabilistic specifications from large, unstructured code corpora, and\na method to use this framework to statically detect anomalous, hence likely buggy, program behavior. The distinctive\ninsight here is to build a statistical model that correlates all\nspecifications hidden inside a corpus with the syntax and\nobserved behavior of programs that implement these specifications. During the analysis of a particular program, this\nmodel is conditioned into a posterior distribution that prioritizes specifications that are relevant to this program. This\nallows accurate program analysis even if the corpus is highly\nheterogeneous. The problem of finding anomalies is now\nframed quantitatively, as a problem of computing a distance\nbetween a \u201creference distribution\u201d over program behaviors\nthat our model expects from the program, and the distribution over behaviors that the program actually produces.</p>\n\n<p>We present a concrete embodiment of our framework that\ncombines a topic model and a neural network model to learn\nspecifications, and queries the learned models to compute\nanomaly scores. We evaluate this implementation on the\ntask of detecting anomalous usage of Android APIs. Our\nencouraging experimental results show that the method can\nautomatically discover subtle errors in Android applications\nin the wild, and has high precision and recall compared to\ncompeting probabilistic approaches.</p>\n", "tags": ["program analysis", "API"], "tsne_embedding": [-6.799287796020508, 0.16358213126659393]}, {"key": "nair2020funcgnn", "year": "2020", "title": "funcGNN: A Graph Neural Network Approach to Program Similarity", "abstract": "<p>Program similarity is a fundamental concept, central to the solution of software engineering tasks such as software plagiarism, clone identification, code refactoring and code search. Accurate similarity estimation between programs requires an in-depth understanding of their structure, semantics and flow. A control flow graph (CFG), is a graphical representation of a program which captures its logical control flow and hence its semantics. A common approach is to estimate program similarity by analysing CFGs using graph similarity measures, e.g. graph edit distance (GED). However, graph edit distance is an NP-hard problem and computationally expensive, making the application of graph similarity techniques to complex software programs impractical. This study intends to examine the effectiveness of graph neural networks to estimate program similarity, by analysing the associated control flow graphs. We introduce funcGNN, which is a graph neural network trained on labeled CFG pairs to predict the GED between unseen program pairs by utilizing an effective embedding vector. To our knowledge, this is the first time graph neural networks have been applied on labeled CFGs for estimating the similarity between high-level language programs. Results: We demonstrate the effectiveness of funcGNN to estimate the GED between programs and our experimental analysis demonstrates how it achieves a lower error rate (0.00194), with faster (23 times faster than the quickest traditional GED approximation method) and better scalability compared with the state of the art methods. funcGNN posses the inductive learning ability to infer program structure and generalise to unseen programs. The graph embedding of a program proposed by our methodology could be applied to several related software engineering problems (such as code plagiarism and clone identification) thus opening multiple research directions.</p>\n", "tags": ["GNN", "clone"], "tsne_embedding": [4.2021894454956055, 10.935905456542969]}, {"key": "nguyen2013lexical", "year": "2013", "title": "Lexical Statistical Machine Translation for Language Migration", "abstract": "<p>Prior research has shown that source code also exhibits naturalness, i.e. it is written by humans and is likely to be\nrepetitive. The researchers also showed that the n-gram language model is useful in predicting the next token in a source\nfile given a large corpus of existing source code. In this paper, we investigate how well statistical machine translation\n(SMT) models for natural languages could help in migrating source code from one programming language to another.\nWe treat source code as a sequence of lexical tokens and\napply a phrase-based SMT model on the lexemes of those\ntokens. Our empirical evaluation on migrating two Java\nprojects into C# showed that lexical, phrase-based SMT\ncould achieve high lexical translation accuracy ( BLEU from\n81.3-82.6%). Users would have to manually edit only 11.9-15.8% of the total number of tokens in the resulting code to\ncorrect it. However, a high percentage of total translation\nmethods (49.5-58.6%) is syntactically incorrect. Therefore,\nour result calls for a more program-oriented SMT model that\nis capable of better integrating the syntactic and semantic\ninformation of a program to support language migration.</p>\n", "tags": ["migration", "API"], "tsne_embedding": [-5.993564128875732, 6.684049129486084]}, {"key": "nguyen2013statistical", "year": "2013", "title": "A Statistical Semantic Language Model for Source Code", "abstract": "<p>Recent research has successfully applied the statistical n-gram language model to show that source code exhibits a\ngood level of repetition. The n-gram model is shown to have\ngood predictability in supporting code suggestion and completion. However, the state-of-the-art n-gram approach to\ncapture source code regularities/patterns is based only on\nthe lexical information in a local context of the code units.\nTo improve predictability, we introduce SLAMC, a novel statistical semantic language model for source code. It incorporates semantic information into code tokens and models the\nregularities/patterns of such semantic annotations, called sememes, rather than their lexemes. It combines the local context in semantic n-grams with the global technical concerns/functionality into an n-gram topic model, together with pairwise associations of program elements. Based on SLAMC,\nwe developed a new code suggestion method, which is empirically evaluated on several projects to have relatively 18\u201368%\nhigher accuracy than the state-of-the-art approach.</p>\n\n", "tags": ["language model"], "tsne_embedding": [-5.639259338378906, 5.305298805236816]}, {"key": "nguyen2013study", "year": "2013", "title": "A Study of Repetitiveness of Code Changes in Software Evolution", "abstract": "<p>In this paper, we present a large-scale study of\nrepetitiveness of code changes in software evolution. We collected\na large data set of 2,841 Java projects, with 1.7 billion source lines\nof code (SLOC) at the latest revisions, 1.8 million code change\nrevisions (0.4 million fixes), 6.2 million changed files, and 2.5\nbillion changed SLOCs. A change is considered repeated within\nor cross-project if it matches another change having occurred\nin the history of the project or another project, respectively. We\nreport the following important findings. First, repetitiveness of\nchanges could be as high as 70\u2013100% at small sizes and decreases\nexponentially as size increases. Second, repetitiveness is higher\nand more stable in the cross-project setting than in the project-within one. Third, fixing changes repeat similarly to general\nchanges. Importantly, learning code changes and recommending\nthem in software evolution is beneficial with accuracy for top-1\nrecommendation of over 30% and top-3 of nearly 35%. Repeated\nfixing changes could also be useful for automatic program repair.</p>\n\n", "tags": ["edit"], "tsne_embedding": [-12.011974334716797, -1.4164717197418213]}, {"key": "nguyen2014statistical", "year": "2014", "title": "Statistical Learning Approach for Mining API Usage Mappings for Code Migration", "abstract": "<p>The same software product nowadays could appear in multiple platforms and devices. To address business needs, software companies\ndevelop a software product in a programming language and then\nmigrate it to another one. To support that process, semi-automatic\nmigration tools have been proposed. However, they require users\nto manually define the mappings between the respective APIs of\nthe libraries used in two languages. To reduce such manual effort,\nwe introduce StaMiner, a novel data-driven approach that statistically learns the mappings between APIs from the corpus of the\ncorresponding client code of the APIs in two languages Java and\nC#. Instead of using heuristics on the textual or structural similarity\nbetween APIs in two languages to map API methods and classes\nas in existing mining approaches, StaMiner is based on a statistical\nmodel that learns the mappings in such a corpus and provides mappings for APIs with all possible arities. Our empirical evaluation\non several projects shows that StaMiner can detect API usage mappings with higher accuracy than a state-of-the-art approach. With\nthe resulting API mappings mined by StaMiner, Java2CSharp, an\nexisting migration tool, could achieve a higher level of accuracy.</p>\n", "tags": ["migration", "API"], "tsne_embedding": [5.316665172576904, 6.019731521606445]}, {"key": "nguyen2015divide", "year": "2014", "title": "Divide-and-Conquer Approach for Multi-phase Statistical Migration for Source Code", "abstract": "<p>Prior research shows that directly applying phrase-based SMT on lexical tokens to migrate Java to C# produces\nmuch semantically incorrect code. A key limitation is the use of\nsequences in phrase-based SMT to model and translate source\ncode with well-formed structures. We propose mppSMT, a divideand-conquer technique to address that with novel training and migration algorithms using phrase-based SMT in three phases. First,\nmppSMT treats a program as a sequence of syntactic units and\nmaps/translates such sequences in two languages to one another.\nSecond, with a syntax-directed fashion, it deals with the tokens\nwithin syntactic units by encoding them with semantic symbols to\nrepresent their data and token types. This encoding via semantic\nsymbols helps better migration of API usages. Third, the lexical\ntokens corresponding to each sememe are mapped or migrated.\nThe resulting sequences of tokens are merged together to form\nthe final migrated code. Such divide-and-conquer and syntax-direction strategies enable phrase-based SMT to adapt well to\nsyntactical structures in source code, thus, improving migration\naccuracy. Our empirical evaluation on several real-world systems\nshows that 84.8\u201397.9% and 70\u201383% of the migrated methods are\nsyntactically and semantically correct, respectively. 26.3\u201351.2%\nof total migrated methods are exactly matched to the human-written C# code in the oracle. Compared to Java2CSharp, a rule-based migration tool, it achieves higher semantic accuracy from\n6.6\u201357.7% relatively. Importantly, it does not require manual\nlabeling for training data or manual definition of rules.</p>\n", "tags": ["migration"], "tsne_embedding": [-5.827243804931641, 6.852531909942627]}, {"key": "nguyen2015graph", "year": "2015", "title": "Graph-based Statistical Language Model for Code", "abstract": "<p>n-gram statistical language model has been successfully applied to capture programming patterns to support code\ncompletion and suggestion. However, the approaches using n-gram face challenges in capturing the patterns at higher levels\nof abstraction due to the mismatch between the sequence nature\nin n-grams and the structure nature of syntax and semantics\nin source code. This paper presents GraLan, a graph-based\nstatistical language model and its application in code suggestion. GraLan can learn from a source code corpus and compute\nthe appearance probabilities of any graphs given the observed\n(sub)graphs. We use GraLan to develop an API suggestion\nengine and an AST-based language model, ASTLan. ASTLan\nsupports the suggestion of the next valid syntactic template\nand the detection of common syntactic templates. Our empirical\nevaluation on a large corpus of open-source projects has shown\nthat our engine is more accurate in API code suggestion than\nthe state-of-the-art approaches, and in 75% of the cases, it can\ncorrectly suggest the API with only five candidates. ASTLan also\nhas high accuracy in suggesting the next syntactic template and\nis able to detect many useful and common syntactic templates.</p>\n", "tags": ["representation", "language model", "autocomplete"], "tsne_embedding": [7.295590877532959, -4.295980453491211]}, {"key": "nguyen2016learning", "year": "2016", "title": "Learning API Usages from Bytecode: A Statistical Approach", "abstract": "<p>Mobile app developers rely heavily on standard API frameworks and libraries. However, learning API usages is often challenging due to the fast-changing nature of API frameworks for mobile systems and the insufficiency of API documentation and source code examples. In this paper, we propose a novel approach to learn API usages from bytecode of Android mobile apps. Our core contributions include HAPI, a statistical model of API usages and three algorithms to extract method call sequences from apps\u2019 bytecode, to train HAPI based on those sequences, and to recommend method calls in code completion using the trained HAPIs. Our empirical evaluation shows that our prototype tool can effectively learn API usages from 200 thousand apps containing 350 million method sequences. It recommends next method calls with top-3 accuracy of 90% and outperforms baseline approaches on average 10-20%.</p>\n", "tags": ["representation", "API"], "tsne_embedding": [7.000164985656738, -5.962887763977051]}, {"key": "nguyen2016mapping", "year": "2016", "title": "Mapping API Elements for Code Migration with Vector Representations", "abstract": "\n", "tags": ["migration", "API"], "tsne_embedding": [10.197901725769043, 7.600400924682617]}, {"key": "nguyen2017exploring", "year": "2017", "title": "Exploring API Embedding for API Usages and Applications", "abstract": "<p>Word2Vec is a class of neural network models that\nas being trained from a large corpus of texts, they can produce for\neach unique word a corresponding vector in a continuous space in\nwhich linguistic contexts of words can be observed. In this work,\nwe study the characteristics of Word2Vec vectors, called API 2 VEC\nor API embeddings, for the API elements within the API sequences in source code. Our empirical study shows that the close\nproximity of the API 2 VEC vectors for API elements reflects the\nsimilar usage contexts containing the surrounding APIs of those\nAPI elements. Moreover, API 2 VEC can capture several similar\nsemantic relations between API elements in API usages via vector\noffsets. We demonstrate the usefulness of API 2 VEC vectors for\nAPI elements in three applications. First, we build a tool that mines the pairs of API elements that share the same usage relations\namong them. The other applications are in the code migration\ndomain. We develop API 2 API , a tool to automatically learn the\nAPI mappings between Java and C# using a characteristic of the\nAPI 2 VEC vectors for API elements in the two languages: semantic\nrelations among API elements in their usages are observed in the\ntwo vector spaces for the two languages as similar geometric\narrangements among their API 2 VEC vectors. Our empirical\nevaluation shows that API 2 API relatively improves 22.6% and\n40.1% top-1 and top-5 accuracy over a state-of-the-art mining\napproach for API mappings. Finally, as another application in\ncode migration, we are able to migrate equivalent API usages\nfrom Java to C# with up to 90.6% recall and 87.2% precision.</p>\n", "tags": ["API", "representation"], "tsne_embedding": [6.080808162689209, 5.322513580322266]}, {"key": "nguyen2019graph", "year": "2019", "title": "Graph-based Mining of In-the-Wild, Fine-grained, Semantic Code Change Patterns", "abstract": "<p>Existing approaches for detecting repetitive code changes relying on syntactic similarity cannot effectively detect semantic change patterns. In this work, we introduce a novel graph-based mining approach, CPatMiner, which is capable of detecting semantic code change patterns from a large number of open-source repositories by capturing dependencies between fine-grained change elements. We evaluated CPatMiner by mining change patterns in a diverse corpus of 5,000+ open-source projects from GitHub with 170,000+ developers. We use three complementary methods. First, we sent the mined patterns to the authors and received 108 responses. 70% of respondents recognized those patterns as their meaningful frequent changes. 79% of respondents even named the patterns, and 44% wanted IDEs to automate such repetitive changes. The mined patterns belong to various activities: adaptive (9%), perfective (20%), corrective (35%) and preventive (36%). Second, we compared CPatMiner with the state-of-the-art, AST-based technique, and reported that CPatMiner detects 2.1x more meaningful patterns. Third, we used CPatMiner to search for patterns in a corpus of 88 GitHub projects with longer histories consisting of 164M SLOCs. It constructed 322K fine-grained change graphs containing 3M nodes, and detected 17K change patterns which provide unique insights on the practice of change patterns among individuals and teams. We found that a large percentage (75%) of the patterns from individual developers are commonly shared with others, and this holds true for teams. Moreover, we found that the patterns spread widely over time. Thus, we call for a community-based change pattern database to provide important resources in novel applications.</p>\n", "tags": ["edit", "pattern mining"], "tsne_embedding": [-12.147212982177734, -1.2149431705474854]}, {"key": "nguyen2020suggesting", "year": "2020", "title": "Suggesting Natural Method Names to Check Name Consistencies", "abstract": "<p>Misleading names of the methods in a project or the APIs in a software library confuse developers about program functionality\nand API usages, leading to API misuses and defects. In this paper,we introduce MNire, a machine learning approach to check the\nconsistency between the name of a given method and its implementation. MNire first generates a candidate name and compares the\ncurrent name against it. If the two names are sufficiently similar, we consider the method as consistent. To generate the method name,\nwe draw our ideas and intuition from an empirical study on the nature of method names in a large dataset. Our key finding is that\nhigh proportions of the tokens of method names can be found in the three contexts of a given method including its body,\nthe interface (the method\u2019s parameter types and return type), and the enclosing class\u2019 name. Even when such tokens are not there,\nMNire uses the contexts to predict the tokens due to the high likelihoods of their co-occurrences. Our unique idea is to treat\nthe name generation as an abstract summarization on the tokens collected from the names of the program entities in the three\nabove contexts.</p>\n\n<p>We conducted several experiments to evaluate MNire in method name consistency checking and in method name\nrecommending on large datasets with +14M methods. In detecting inconsistency method names, MNire improves the state-of-the-art\napproach by 10.4% and 11% relatively in recall and precision, respectively. In method name recommendation, MNire improves relatively\nover the state-of-the-art technique, code2vec, in both recall (18.2% higher) and precision (11.1% higher). To assess MNire\u2019s usefulness,\nwe used it to detect inconsistent methods and suggest new names in several active, GitHub projects. We made 50 pull requests (PRs) and received\n42 responses. Among them, five PRs were merged into the main branch, and 13 were approved for later merging. In total, in 31/42 cases,\nthe developer teams agree that our suggested names are more meaningful than the current names, showing MNire\u2019s usefulness.</p>\n", "tags": ["naming"], "tsne_embedding": [-4.243479251861572, 7.644274711608887]}, {"key": "oda2015learning", "year": "2015", "title": "Learning to Generate Pseudo-code from Source Code using Statistical Machine Translation", "abstract": "<p>Pseudo-code written in natural language can aid\nthe comprehension of source code in unfamiliar programming\nlanguages. However, the great majority of source code has no\ncorresponding pseudo-code, because pseudo-code is redundant\nand laborious to create. If pseudo-code could be generated\nautomatically and instantly from given source code, we could\nallow for on-demand production of pseudo-code without human\neffort. In this paper, we propose a method to automatically\ngenerate pseudo-code from source code, specifically adopting the\nstatistical machine translation (SMT) framework. SMT, which\nwas originally designed to translate between two natural languages, allows us to automatically learn the relationship between\nsource code/pseudo-code pairs, making it possible to create a\npseudo-code generator with less human effort. In experiments,\nwe generated English or Japanese pseudo-code from Python\nstatements using SMT, and find that the generated pseudo-code\nis largely accurate, and aids code understanding.</p>\n", "tags": ["representation", "bimodal", "AST"], "tsne_embedding": [-8.3002347946167, 5.734035968780518]}, {"key": "oh2015learning", "year": "2015", "title": "Learning a Strategy for Adapting a Program Analysis via Bayesian Optimisation", "abstract": "<p>Building a cost-effective static analyser for real-world programs is still regarded an art. One key contributor to this\ngrim reputation is the difficulty in balancing the cost and the\nprecision of an analyser. An ideal analyser should be adap-\ntive to a given analysis task, and avoid using techniques that\nunnecessarily improve precision and increase analysis cost.\nHowever, achieving this ideal is highly nontrivial, and it requires a large amount of engineering efforts.</p>\n\n<p>In this paper we present a new approach for building\nan adaptive static analyser. In our approach, the analyser\nincludes a sophisticated parameterised strategy that decides, for each part of a given program, whether to apply\na precision-improving technique to that part or not. We\npresent a method for learning a good parameter for such\na strategy from an existing codebase via Bayesian optimisation. The learnt strategy is then used for new, unseen programs. Using our approach, we developed partially flow-\nand context-sensitive variants of a realistic C static analyser.\nThe experimental results demonstrate that using Bayesian\noptimisation is crucial for learning from an existing codebase. Also, they show that among all program queries that\nrequire flow- or context-sensitivity, our partially flow- and\ncontext-sensitive analysis answers the 75% of them, while\nincreasing the analysis cost only by 3.3x of the baseline\nflow- and context-insensitive analysis, rather than 40x or\nmore of the fully sensitive version.</p>\n", "tags": ["program analysis"], "tsne_embedding": [-3.6711103916168213, -7.303323268890381]}, {"key": "omar2013structured", "year": "2013", "title": "Structured Statistical Syntax Tree Prediction", "abstract": "<p>Statistical models of source code can be used to improve\ncode completion systems, assistive interfaces, and code\ncompression engines. We are developing a statistical model\nwhere programs are represented as syntax trees, rather than\nsimply a stream of tokens. Our model, initially for the Java\nlanguage, combines corpus data with information about syntax, types and the program context. We tested this model\nusing open source code corpuses and find that our model\nis significantly more accurate than the current state of the\nart, providing initial evidence for our claim that combining\nstructural and statistical information is a fruitful strategy.</p>\n", "tags": ["language model", "AST"], "tsne_embedding": [5.756682872772217, -2.123929500579834]}, {"key": "ott2018deep", "year": "2018", "title": "A Deep Learning Approach to Identifying Source Code in Images and Video", "abstract": "<p>While substantial progress has been made in mining code on an\nInternet scale, efforts to date have been overwhelmingly focused on\ndata sets where source code is represented natively as text. Large\nvolumes of source code available online and embedded in technical\nvideos have remained largely unexplored, due in part to the complexity of extraction when code is represented with images. Existing\napproaches to code extraction and indexing in this environment rely\nheavily on computationally intense optical character recognition.\nTo improve the ease and efficiency of identifying this embedded\ncode, as well as identifying similar code examples, we develop a\ndeep learning solution based on convolutional neural networks and\nautoencoders. Focusing on Java for proof of concept, our technique\nis able to identify the presence of typeset and handwritten source\ncode in thousands of video images with 85.6%-98.6% accuracy based\non syntactic and contextual features learned through deep architectures. When combined with traditional approaches, this provides\na more scalable basis for video indexing that can be incorporated\ninto existing software search and mining tools.</p>\n", "tags": ["information extraction"], "tsne_embedding": [3.8294808864593506, -5.306793689727783]}, {"key": "pandi2020opttyper", "year": "2020", "title": "OptTyper: Probabilistic Type Inference by Optimising Logical and Natural Constraints", "abstract": "<p>We present a new approach to the type inference problem for dynamic languages. Our goal is to combine logical constraints, that is, deterministic information from a type system, with natural constraints, uncertain information about types from sources like identifier names. To this end, we introduce a framework for probabilistic type inference that combines logic and learning: logical constraints on the types are extracted from the program, and deep learning is applied to predict types from surface-level code properties that are statistically associated, such as variable names. The main insight of our method is to constrain the predictions from the learning procedure to respect the logical constraints, which we achieve by relaxing the logical inference problem of type prediction into a continuous optimisation problem. To evaluate the idea, we built a tool called OptTyper to predict a TypeScript declaration file for a JavaScript library. OptTyper combines a continuous interpretation of logical constraints derived by a simple program transformation and static analysis of the JavaScript code, with natural constraints obtained from a deep learning model, which learns naming conventions for types from a large codebase. We evaluate OptTyper on a data set of 5,800 open-source JavaScript projects that have type annotations in the well-known DefinitelyTyped repository. We find that combining logical and natural constraints yields a large improvement in performance over either kind of information individually, and produces 50% fewer incorrect type predictions than previous approaches.</p>\n", "tags": ["types", "bimodal"], "tsne_embedding": [-1.147017002105713, 3.259377956390381]}, {"key": "panthaplackel2020associating", "year": "2020", "title": "Associating Natural Language Comment and Source Code Entities", "abstract": "<p>Comments are an integral part of software development; they are natural language descriptions associated with source code elements. Understanding explicit associations can be useful in improving code comprehensibility and maintaining the consistency between code and comments. As an initial step towards this larger goal, we address the task of associating entities in Javadoc comments with elements in Java source code. We propose an approach for automatically extracting supervised data using revision histories of open source projects and present a manually annotated evaluation dataset for this task. We develop a binary classifier and a sequence labeling model by crafting a rich feature set which encompasses various aspects of code, comments, and the relationships between them. Experiments show that our systems outperform several baselines learning from the proposed supervision.</p>\n", "tags": ["dataset", "bimodal"], "tsne_embedding": [8.67605972290039, 5.644862174987793]}, {"key": "panthaplackel2020copy", "year": "2020", "title": "Copy that! Editing Sequences by Copying Spans", "abstract": "<p>Neural sequence-to-sequence models are finding increasing use in editing of documents, for example in correcting a text document or repairing source code. In this paper, we argue that common seq2seq models (with a facility to copy single tokens) are not a natural fit for such tasks, as they have to explicitly copy each unchanged token. We present an extension of seq2seq models capable of copying entire spans of the input to the output in one step, greatly reducing the number of decisions required during inference. This extension means that there are now many ways of generating the same output, which we handle by deriving a new objective for training and a variation of beam search for inference that explicitly handle this problem.</p>\n\n<p>In our experiments on a range of editing tasks of natural language and source code, we show that our new model consistently outperforms simpler baselines.</p>\n", "tags": ["edit"], "tsne_embedding": [13.100953102111816, 1.2296022176742554]}, {"key": "panthaplackel2020deep", "year": "2020", "title": "Deep Just-In-Time Inconsistency Detection Between Comments and Source Code", "abstract": "<p>Natural language comments convey key aspects of source code such as implementation, usage, and pre- and post-conditions. Failure to update comments accordingly when the corresponding code is modified introduces inconsistencies, which is known to lead to confusion and software bugs. In this paper, we aim to detect whether a comment becomes inconsistent as a result of changes to the corresponding body of code, in order to catch potential inconsistencies just-in-time, i.e., before they are committed to a version control system. To achieve this, we develop a deep-learning approach that learns to correlate a comment with code changes. By evaluating on a large corpus of comment/code pairs spanning various comment types, we show that our model outperforms multiple baselines by significant margins. For extrinsic evaluation, we show the usefulness of our approach by combining it with a comment update model to build a more comprehensive automatic comment maintenance system which can both detect and resolve inconsistent comments based on code changes.</p>\n", "tags": ["edit", "bimodal", "documentation"], "tsne_embedding": [-1.0693092346191406, -1.7091737985610962]}, {"key": "panthaplackel2020learning", "year": "2020", "title": "Learning to Update Natural Language Comments Based on Code Changes", "abstract": "<p>We formulate the novel task of automatically updating an existing natural language comment based on changes in the body of code it accompanies. We propose an approach that learns to correlate changes across two distinct language representations, to generate a sequence of edits that are applied to the existing comment to reflect the source code modifications. We train and evaluate our model using a dataset that we collected from commit histories of open-source software projects, with each example consisting of a concurrent update to a method and its corresponding comment. We compare our approach against multiple baselines using both automatic metrics and human evaluation. Results reflect the challenge of this task and that our model outperforms baselines with respect to making edits.</p>\n", "tags": ["bimodal", "edit", "documentation"], "tsne_embedding": [0.0409294068813324, -1.586874008178711]}, {"key": "parvez2018building", "year": "2018", "title": "Building Language Models for Text with Named Entities", "abstract": "<p>Text  in  many  domains  involves  a  significant amount of named entities.   Predicting the entity names is often challenging\nfor a language model as they appear less\nfrequent  on  the  training  corpus.   In  this\npaper,  we  propose  a  novel  and  effective\napproach to building a discriminative language  model  which  can  learn  the  entity\nnames by leveraging their entity type information.  We also introduce two benchmark  datasets  based  on  recipes  and  Java\nprogramming codes,  on which we evaluate the proposed model.  Experimental results show that our model achieves 52.2%\nbetter perplexity in recipe generation and\n22.06% on code generation than the state-of-the-art language models.</p>\n", "tags": ["language model"], "tsne_embedding": [-2.9256110191345215, 3.270113706588745]}, {"key": "patra2016learning", "year": "2016", "title": "Learning to Fuzz: Application-Independent Fuzz Testing with Probabilistic, Generative Models of Input Data", "abstract": "<p>Fuzzing is a popular technique to create test inputs for software that processes structured data. It has been successfully\napplied in various domains, ranging from compilers and interpreters over program analyses to rendering engines, image manipulation tools, and word processors. Existing fuzz\ntesting techniques are tailored for a particular purpose and\nrely on a carefully crafted model of the data to be generated.\nThis paper presents TreeFuzz, a generic approach for generating structured data without an a priori known model. The\nkey idea is to exploit a given corpus of example data to au-\ntomatically infer probabilistic, generative models that create\nnew data with properties similar to the corpus. To support a\nwide range of different properties, TreeFuzz is designed as a\nframework with an extensible set of techniques to infer generative models. We apply the idea to JavaScript programs\nand HTML documents and show that the approach generates mostly valid data for both of them: 96.3% of the generated JavaScript programs are syntactically valid and there are\nonly 2.06 validation errors per kilobyte of generated HTML.\nThe performance of both learning and generation scales linearly w.r.t. the size of the corpus. Using TreeFuzz-generated\nJavaScript programs for differential testing of JavaScript engines exposes various inconsistencies among browsers, including browser bugs and unimplemented language features.</p>\n", "tags": ["fuzzing"], "tsne_embedding": [1.1108518838882446, 3.9801113605499268]}, {"key": "piech2015learning", "year": "2015", "title": "Learning Program Embeddings to Propagate Feedback on Student Code", "abstract": "<p>Providing feedback, both assessing final work\nand giving hints to stuck students, is difficult\nfor open-ended assignments in massive online\nclasses which can range from thousands to millions of students. We introduce a neural network\nmethod to encode programs as a linear mapping\nfrom an embedded precondition space to an embedded postcondition space and propose an algorithm for feedback at scale using these linear maps as features. We apply our algorithm\nto assessments from the Code.org Hour of Code\nand Stanford University\u2019s CS1 course, where we\npropagate human comments on student assignments to orders of magnitude more submissions.</p>\n", "tags": ["representation", "repair", "education"], "tsne_embedding": [-9.69406795501709, -8.213947296142578]}, {"key": "pradel2017deep", "year": "2017", "title": "Deep Learning to Find Bugs", "abstract": "<p>Automated bug detection, e.g., through pattern-based static\nanalysis, is an increasingly popular technique to find programming errors and other code quality issues. Traditionally,\nbug detectors are program analyses that are manually written and carefully tuned by an analysis expert. Unfortunately,\nthe huge amount of possible bug patterns makes it difficult\nto cover more than a small fraction of all bugs. This paper\npresents a new approach toward creating bug detectors. The\nbasic idea is to replace manually writing a program analysis\nwith training a machine learning model that distinguishes\nbuggy from non-buggy code. To address the challenge that\neffective learning requires both positive and negative train-\ning examples, we use simple code transformations that create likely incorrect code from existing code examples. We\npresent a general framework, called DeepBugs, that extracts\npositive training examples from a code corpus, leverages\nsimple program transformations to create negative training\nexamples, trains a model to distinguish these two, and then\nuses the trained model for identifying programming mistakes in previously unseen code. As a proof of concept, we\ncreate four bug detectors for JavaScript that find a diverse set\nof programming mistakes, e.g., accidentally swapped function arguments, incorrect assignments, and incorrect binary\noperations. To find bugs, the trained models use information\nthat is usually discarded by program analyses, such as identifier names of variables and functions. Applying the approach\nto a corpus of 150,000 JavaScript files shows that learned bug\ndetectors have a high accuracy, are very efficient, and reveal\n132 programming mistakes in real-world code.</p>\n\n", "tags": ["defect", "program analysis"], "tsne_embedding": [-4.8090128898620605, -4.986487865447998]}, {"key": "pradel2019typewriter", "year": "2019", "title": "TypeWriter: Neural Type Prediction with Search-based Validation", "abstract": "<p>Maintaining large code bases written in dynamically typed languages, such as JavaScript or Python, can be challenging: simple data compatibility errors proliferate, IDE support is lacking and APIs are harder to comprehend. Recent work attempts to address those issues through either static analysis or probabilistic type inference. Unfortunately, static type inference for dynamic languages is inherently limited, while probabilistic approaches suffer from imprecision. This paper presents TypeWriter, the first combination of probabilistic prediction with search-based refinement of predicted types. TypeWriter\u2019s predictor learns to infer the return and argument types for functions from partially annotated code bases by combining the natural language properties of code with programming language-level information. To validate predicted types, TypeWriter invokes a gradual type checker with different combinations of the predicted types, while navigating the space of possible type combinations in a feedback-directed manner. We implement the TypeWriter approach for Python and evaluate it on two code corpora: a multi-million line code base at Facebook and a collection of 500 popular open-source projects. We show that TypeWriter\u2019s type predictor achieves a precision of 64% (91%) and a recall of 52% (68%) in the top-1 (top-5) predictions, and demonstrate that usage contexts are a helpful addition to neural type predictors. By combining predictions with search-based validation, TypeWriter can fully annotate between 42% to 64% of the files in a randomly selected corpus, while ensuring type correctness. A comparison with a static type inference tool shows that TypeWriter adds many more non-trivial types. Overall, TypeWriter provides developers with an effective way to help with the transition to fully type-annotated code.</p>\n", "tags": ["types", "bimodal"], "tsne_embedding": [-1.3531603813171387, 3.261017084121704]}, {"key": "proksch2015intelligent", "year": "2015", "title": "Intelligent Code Completion with Bayesian Networks", "abstract": "<p>Code completion is an integral part of modern Integrated Development Environments (IDEs). Developers\noften use it to explore Application Programming Interfaces (APIs). It is also useful to reduce the required\namount of typing and to help avoid typos. Traditional code completion systems propose all type-correct\nmethods to the developer. Such a list is often very long with many irrelevant items. More intelligent code\ncompletion systems have been proposed in prior work to reduce the list of proposed methods to relevant\nitems.</p>\n\n<p>This work extends one of these existing approaches, the Best Matching Neighbor (BMN) algorithm. We\nintroduce Bayesian networks as an alternative underlying model, use additional context information for\nmore precise recommendations, and apply clustering techniques to improve model sizes. We compare our\nnew approach, Pattern-based Bayesian Networks (PBN), to the existing BMN algorithm. We extend previously used evaluation methodologies and, in addition to prediction quality, we also evaluate model size and\ninference speed.</p>\n\n<p>Our results show that the additional context information we collect improves prediction quality, especially\nfor queries that do not contain method calls. We also show that PBN can obtain comparable prediction\nquality to BMN, while model size and inference speed scale better with large input sizes.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [5.0626220703125, 2.8017640113830566]}, {"key": "pu2016skp", "year": "2016", "title": "sk_p: a neural program corrector for MOOCs", "abstract": "<p>We present a novel technique for automatic program correction in MOOCs, capable of fixing both syntactic and semantic errors without manual, problem specific correction strategies. Given an incorrect student program, it generates candidate programs from a distribution of likely corrections, and checks each candidate for correctness against a test suite.</p>\n\n<p>The key observation is that in MOOCs many programs share similar code fragments, and the seq2seq neural network model, used in the natural-language processing task of machine translation, can be modified and trained to recover these fragments.</p>\n\n<p>Experiment shows our scheme can correct 29% of all incorrect submissions and out-performs state of the art approach which requires manual, problem specific correction strategies.</p>\n", "tags": ["repair"], "tsne_embedding": [-6.9592180252075195, -7.069322109222412]}, {"key": "rabin2020generalizability", "year": "2020", "title": "On the Generalizability of Neural Program Analyzers with respect to Semantic-Preserving Program Transformations", "abstract": "<p>With the prevalence of publicly available source code repositories to train deep neural network models, neural program analyzers can do well in source code analysis tasks such as predicting method names in given programs that cannot be easily done by traditional program analyzers. Although such analyzers have been tested on various existing datasets, the extent in which they generalize to unforeseen source code is largely unknown. Since it is impossible to test neural program analyzers on all unforeseen programs, in this paper, we propose to evaluate the generalizability of neural program analyzers with respect to semantic-preserving transformations: a generalizable neural program analyzer should perform equally well on programs that are of the same semantics but of different lexical appearances and syntactical structures. More specifically, we compare the results of various neural program analyzers for the method name prediction task on programs before and after automated semantic-preserving transformations. We use three Java datasets of different sizes and three state-of-the-art neural network models for code, namely code2vec, code2seq, and Gated Graph Neural Networks (GGNN), to build nine such neural program analyzers for evaluation. Our results show that even with small semantically preserving changes to the programs, these neural program analyzers often fail to generalize their performance. Our results also suggest that neural program analyzers based on data and control dependencies in programs generalize better than neural program analyzers based only on abstract syntax trees. On the positive side, we observe that as the size of training dataset grows and diversifies the generalizability of correct predictions produced by the analyzers can be improved too.</p>\n", "tags": ["adversarial", "GNN", "AST"], "tsne_embedding": [1.087080955505371, 10.09455394744873]}, {"key": "rabinovich2017abstract", "year": "2017", "title": "Abstract Syntax Networks for Code Generation and Semantic Parsing", "abstract": "<p>Tasks like code generation and semantic parsing require mapping unstructured (or partially structured) inputs to well-formed, executable outputs. We introduce abstract syntax networks, a modeling framework for these problems. The outputs are represented as abstract syntax trees (ASTs) and constructed by a decoder with a dynamically-determined modular structure paralleling the structure of the output tree. On the benchmark Hearthstone dataset for code generation, our model obtains 79.2 BLEU and 22.7% exact match accuracy, compared to previous state-of-the-art values of 67.1 and 6.1%. Furthermore, we perform competitively on the Atis, Jobs, and Geo semantic parsing datasets with no task-specific engineering.</p>\n", "tags": ["generation", "AST"], "tsne_embedding": [8.938491821289062, -7.318813323974609]}, {"key": "raghothaman2018user", "year": "2018", "title": "User-guided program reasoning using Bayesian inference", "abstract": "<p>Program analyses necessarily make approximations that often lead them to report true alarms interspersed with many false alarms. We propose a new approach to leverage user feedback to guide program analyses towards true alarms and away from false alarms. Our approach associates each alarm with a confidence value by performing Bayesian inference on a probabilistic model derived from the analysis rules. In each iteration, the user inspects the alarm with the highest confidence and labels its ground truth, and the approach recomputes the confidences of the remaining alarms given this feedback. It thereby maximizes the return on the effort by the user in inspecting each alarm. We have implemented our approach in a tool named Bingo for program analyses expressed in Datalog. Experiments with real users and two sophisticated analyses\u2014a static datarace analysis for Java programs and a static taint analysis for Android apps\u2014show significant improvements on a range of metrics, including false alarm rates and number of bugs found.</p>\n", "tags": ["program analysis"], "tsne_embedding": [-7.083058834075928, -1.6961519718170166]}, {"key": "rahman2019natural", "year": "2019", "title": "Natural Software Revisited", "abstract": "<p>Recent works have concluded that software is more repetitive and predictable, i.e. more natural, than English texts. These works included \u201csimple/artificial\u201d syntax rules in their language models. When we remove SyntaxTokens we find that code is still repetitive and predictable but only at levels slightly above English. Furthermore, previous works have compared individual Java programs to general English corpora, such as Gutenberg, which contains a historically large range of styles and subjects (e.g. Saint Augustine to Oscar Wilde). We perform an additional comparison of technical StackOverflow English discussions with source code and find that this restricted English is similarly repetitive to code. Although we find that code is less repetitive than previously thought, we suspect that API code element usage will be repetitive across software projects. For example a file is opened and closed in the same manner irrespective of domain. When we restrict our n-grams to those contained in the Java API we find that the entropy is significantly lower than the English corpora. Previous works have focused on sequential sequences of tokens. When we extract program graphs of size 2, 3, and 4 nodes we see that the abstract graph representation is much more concise and repetitive than the sequential representations of the same code. This suggests that future work should focus on statistical graph models that go beyond linear sequences of tokens. Our anonymous replication package makes our scripts and data available to future researchers and reviewers.</p>\n", "tags": [], "tsne_embedding": [-7.815003395080566, 4.0247416496276855]}, {"key": "ramakrishnan2020semantic", "year": "2020", "title": "Semantic Robustness of Models of Source Code", "abstract": "<p>Deep neural networks are vulnerable to adversarial examples - small input perturbations that result in incorrect predictions. We study this problem in the context of models of source code, where we want the network to be robust to source-code modifications that preserve code functionality. We define a natural notion of robustness, k-transformation robustness, in which an adversary performs up to k semantics-preserving transformations to an input program. We show how to train robust models using an adversarial training objective inspired by that of Madry et al. (2018) for continuous domains.</p>\n\n<p>We implement an extensible framework for adversarial training over source code, and conduct a thorough evaluation on a number of datasets and two different architectures. Our results show (1) the increase in robustness following adversarial training, (2) the ability of training on weak adversaries to provide robustness to attacks by stronger adversaries, and (3) the shift in attribution focus of adversarially trained models towards semantic vs. syntactic features.</p>\n", "tags": ["adversarial", "naming"], "tsne_embedding": [-3.2186450958251953, -9.697000503540039]}, {"key": "ray2015naturalness", "year": "2015", "title": "On the \u201cNaturalness\u201d of Buggy Code", "abstract": "<p>Real software, the kind working programmers produce by the kLOC\nto solve real-world problems, tends to be \u201cnatural\u201d, like speech or\nnatural language; it tends to be highly repetitive and predictable.\nResearchers have captured this naturalness of software through statistical models and used them to good effect in suggestion engines,\nporting tools, coding standards checkers, and idiom miners. This\nsuggests that code that appears improbable, or surprising, to a good\nstatistical language model is \u201cunnatural\u201d in some sense, and thus\npossibly suspicious. In this paper, we investigate this hypothesis. We consider a large corpus of bug fix commits (ca. 8,296),\nfrom 10 different Java projects, and we focus on its language statistics, evaluating the naturalness of buggy code and the corresponding fixes. We find that code with bugs tends to be more entropic\n(i.e. unnatural), becoming less so as bugs are fixed. Focusing on\nhighly entropic lines is similar in cost-effectiveness to some well-known static bug finders (PMD, FindBugs) and ordering warnings\nfrom these bug finders using an entropy measure improves the cost-effectiveness of inspecting code implicated in warnings. This suggests that entropy may be a valid language-independent and simple\nway to complement the effectiveness of PMD or FindBugs, and\nthat search-based bug-fixing methods may benefit from using entropy both for fault-localization and searching for fixes.</p>\n\n", "tags": ["defect"], "tsne_embedding": [-7.698670387268066, 4.046494483947754]}, {"key": "raychev2014code", "year": "2014", "title": "Code Completion with Statistical Language Models", "abstract": "<p>We address the problem of synthesizing code completions for programs using APIs. Given a program with holes, we synthesize completions for holes with the most likely sequences of method calls.</p>\n\n<p>Our main idea is to reduce the problem of code completion to\na natural-language processing problem of predicting probabilities\nof sentences. We design a simple and scalable static analysis that\nextracts sequences of method calls from a large codebase, and\nindex these into a statistical language model. We then employ\nthe language model to find the highest ranked sentences, and use\nthem to synthesize a code completion. Our approach is able to\nsynthesize sequences of calls across multiple objects together with\ntheir arguments.</p>\n\n<p>Experiments show that our approach is fast and effective. Virtually all computed completions typecheck, and the desired completion appears in the top 3 results in 90% of the cases.</p>\n", "tags": ["language model", "autocomplete", "generation"], "tsne_embedding": [6.086019515991211, -7.426797866821289]}, {"key": "raychev2015predicting", "year": "2015", "title": "Predicting Program Properties from \u201cBig Code\u201d", "abstract": "<p>We present a new approach for predicting program properties from\nmassive codebases (aka \u201cBig Code\u201d). Our approach first learns a\nprobabilistic model from existing data and then uses this model to\npredict properties of new, unseen programs.</p>\n\n<p>The key idea of our work is to transform the input program into\na representation which allows us to phrase the problem of inferring program properties as structured prediction in machine learning. This formulation enables us to leverage powerful probabilistic\ngraphical models such as conditional random fields (CRFs) in order\nto perform joint prediction of program properties.</p>\n\n<p>As an example of our approach, we built a scalable prediction\nengine called JSNICE 1 for solving two kinds of problems in the\ncontext of JavaScript: predicting (syntactic) names of identifiers\nand predicting (semantic) type annotations of variables. Experimentally, JSNICE predicts correct names for 63% of name identifiers and its type annotation predictions are correct in 81% of the\ncases. In the first week since its release, JSN ICE was used by more\nthan 30,000 developers and in only few months has become a popular tool in the JavaScript developer community.</p>\n\n<p>By formulating the problem of inferring program properties as\nstructured prediction and showing how to perform both learning\nand inference in this context, our work opens up new possibilities\nfor attacking a wide range of difficult problems in the context of\n\u201cBig Code\u201d including invariant generation, de-compilation, synthesis and others.</p>\n", "tags": ["program analysis", "naming", "types", "deobfuscation"], "tsne_embedding": [3.8316221237182617, -3.4076931476593018]}, {"key": "raychev2016learning", "year": "2016", "title": "Learning Programs from Noisy Data", "abstract": "<p>We present a new approach for learning programs from noisy\ndatasets. Our approach is based on two new concepts: a regularized\nprogram generator which produces a candidate program based on a\nsmall sample of the entire dataset while avoiding overfitting, and a\ndataset sampler which carefully samples the dataset by leveraging\nthe candidate program\u2019s score on that dataset. The two components\nare connected in a continuous feedback-directed loop.</p>\n\n<p>We show how to apply this approach to two settings: one where\nthe dataset has a bound on the noise, and another without a noise\nbound. The second setting leads to a new way of performing\napproximate empirical risk minimization on hypotheses classes\nformed by a discrete search space.</p>\n\n<p>We then present two new kinds of program synthesizers which\ntarget the two noise settings. First, we introduce a novel regularized\nbitstream synthesizer that successfully generates programs even in\nthe presence of incorrect examples. We show that the synthesizer\ncan detect errors in the examples while combating overfitting \u2013\na major problem in existing synthesis techniques. We also show\nhow the approach can be used in a setting where the dataset grows\ndynamically via new examples (e.g., provided by a human).</p>\n\n<p>Second, we present a novel technique for constructing statistical\ncode completion systems. These are systems trained on massive\ndatasets of open source programs, also known as \u201cBig Code\u201d. The\nkey idea is to introduce a domain specific language (DSL) over\ntrees and to learn functions in that DSL directly from the dataset.\nThese learned functions then condition the predictions made by the\nsystem. This is a flexible and powerful technique which generalizes\nseveral existing works as we no longer need to decide a priori on\nwhat the prediction should be conditioned (another benefit is that\nthe learned functions are a natural mechanism for explaining the\nprediction). As a result, our code completion system surpasses the\nprediction capabilities of existing, hard-wired systems.</p>\n", "tags": ["generation", "grammar"], "tsne_embedding": [-7.351530075073242, 1.46175217628479]}, {"key": "richardson2017code2text", "year": "2017", "title": "The Code2Text Challenge: Text Generation in Source Code Libraries", "abstract": "<p>We propose a new shared task for tactical data-to-text generation in the domain of source code libraries. Specifically, we focus on text generation of function descriptions from example software projects. Data is drawn from existing resources used for studying the related problem of semantic parser induction (Richardson and Kuhn, 2017b; Richardson and Kuhn, 2017a), and spans a wide variety of both natural languages and programming languages. In this paper, we describe these existing resources, which will serve as training and development data for the task, and discuss plans for building new independent test sets.</p>\n", "tags": ["bimodal"], "tsne_embedding": [10.17069149017334, 6.082834720611572]}, {"key": "richardson2017function", "year": "2017", "title": "Function Assistant: A Tool for NL Querying of APIs", "abstract": "<p>In this paper, we describe Function Assistant, a lightweight Python-based toolkit for querying and exploring source code repositories using natural language. The toolkit is designed to help end-users of a target API quickly find information about functions through high-level natural language queries and descriptions. For a given text query and background API, the tool finds candidate functions by performing a translation from the text to known representations in the API using the semantic parsing approach of Richardson and Kuhn (2017). Translations are automatically learned from example text-code pairs in example APIs. The toolkit includes features for building translation pipelines and query engines for arbitrary source code projects. To explore this last feature, we perform new experiments on 27 well-known Python projects hosted on Github.</p>\n", "tags": ["bimodal", "API"], "tsne_embedding": [11.86716079711914, 4.991846561431885]}, {"key": "richardson2017learning", "year": "2017", "title": "Learning Technical Correspondences in Technical Documentation", "abstract": "<p>We consider the problem of translating high-level textual descriptions to formal representations in technical documentation as part of an effort to model the meaning of such documentation. We focus specifically on the problem of learning translational correspondences between text descriptions and grounded representations in the target documentation, such as formal representation of functions or code templates. Our approach exploits the parallel nature of such documentation, or the tight coupling between high-level text and the low-level representations we aim to learn. Data is collected by mining technical documents for such parallel text-representation pairs, which we use to train a simple semantic parsing model. We report new baseline results on sixteen novel datasets, including the standard library documentation for nine popular programming languages across seven natural languages, and a small collection of Unix utility manuals.</p>\n", "tags": ["documentation", "API", "bimodal"], "tsne_embedding": [3.526536464691162, 4.236977577209473]}, {"key": "richardson2018polyglot", "year": "2018", "title": "Polyglot Semantic Parsing in APIs", "abstract": "<p>Traditional approaches to semantic parsing (SP) work by training individual models for each available parallel dataset of text-meaning pairs. In this paper, we explore the idea of polyglot semantic translation, or learning semantic parsing models that are trained on multiple datasets and natural languages. In particular, we focus on translating text to code signature representations using the software component datasets of Richardson and Kuhn (2017a,b). The advantage of such models is that they can be used for parsing a wide variety of input natural languages and output programming languages, or mixed input languages, using a single unified model. To facilitate modeling of this type, we develop a novel graph-based decoding framework that achieves state-of-the-art performance on the above datasets, and apply this method to two other benchmark SP tasks.</p>\n", "tags": ["bimodal", "API"], "tsne_embedding": [7.610068321228027, 9.330815315246582]}, {"key": "russell2018automated", "year": "2018", "title": "Automated Vulnerability Detection in Source Code Using Deep Representation Learning", "abstract": "<p>Increasing numbers of software vulnerabilities are discovered every year whether they are reported publicly or discovered internally in proprietary code. These vulnerabilities can pose serious risk of exploit and result in system compromise, information leaks, or denial of service. We leveraged the wealth of C and C++ open-source code available to develop a large-scale function-level vulnerability detection system using machine learning. To supplement existing labeled vulnerability datasets, we compiled a vast dataset of millions of open-source functions and labeled it with carefully-selected findings from three different static analyzers that indicate potential exploits. Using these datasets, we developed a fast and scalable vulnerability detection tool based on deep feature representation learning that directly interprets lexed source code. We evaluated our tool on code from both real software packages and the NIST SATE IV benchmark dataset. Our results demonstrate that deep feature representation learning on source code is a promising approach for automated software vulnerability detection.</p>\n", "tags": ["program analysis"], "tsne_embedding": [2.579535722732544, -5.291309833526611]}, {"key": "saini2018oreo", "year": "2018", "title": "Oreo: detection of clones in the twilight zone", "abstract": "<p>Source code clones are categorized into four types of increasing difficulty of detection, ranging from purely textual (Type-1) to purely semantic (Type-4). Most clone detectors reported in the literature work well up to Type-3, which accounts for syntactic differences. In between Type-3 and Type-4, however, there lies a spectrum of clones that, although still exhibiting some syntactic similarities, are extremely hard to detect \u2013 the Twilight Zone. Most clone detectors reported in the literature fail to operate in this zone. We present Oreo, a novel approach to source code clone detection that not only detects Type-1 to Type-3 clones accurately, but is also capable of detecting harder-to-detect clones in the Twilight Zone. Oreo is built using a combination of machine learning, information retrieval, and software metrics. We evaluate the recall of Oreo on BigCloneBench, and perform manual evaluation for precision. Oreo has both high recall and precision. More importantly, it pushes the boundary in detection of clones with moderate to weak syntactic similarity in a scalable manner.</p>\n", "tags": ["clone", "metrics"], "tsne_embedding": [-5.152721881866455, 2.965031623840332]}, {"key": "santos2018syntax", "year": "2018", "title": "Syntax and Sensibility: Using language models to detect and correct syntax errors", "abstract": "<p>Syntax errors are made by novice and experienced programmers alike; however, novice programmers lack the years of experience that help them quickly resolve these frustrating errors. Standard LR parsers are of little help, typically resolving syntax errors and their precise location poorly. We propose a methodology that locates where syntax errors occur, and suggests possible changes to the token stream that can fix the error identified. This methodology finds syntax errors by using language models trained on correct source code to find tokens that seem out of place. Fixes are synthesized by consulting the language models to determine what tokens are more likely at the estimated error location. We compare <em>n</em>-gram and LSTM (long short-term memory) language models for this task, each trained on a large corpus of Java code collected from GitHub. Unlike prior work, our methodology does not rely that the problem source code comes from the same domain as the training data. We evaluated against a repository of real student mistakes. Our tools are able to find a syntactically-valid fix within its top-2 suggestions, often producing the exact fix that the student used to resolve the error. The results show that this tool and methodology can locate and suggest corrections for syntax errors. Our methodology is of practical use to all programmers, but will be especially useful to novices frustrated with incomprehensible syntax errors.</p>\n", "tags": ["repair", "language model"], "tsne_embedding": [-7.862298965454102, -4.519407272338867]}, {"key": "saraiva2015products", "year": "2015", "title": "Products, Developers, and Milestones: How Should I Build My N-Gram Language Model", "abstract": "<p>Recent work has shown that although programming languages en-\nable source code to be rich and complex, most code tends to be\nrepetitive and predictable. The use of natural language processing\n(NLP) techniques applied to source code such as n-gram language\nmodels show great promise in areas such as code completion, aiding impaired developers, and code search. In this paper, we address\nthree questions related to different methods of constructing lan-\nguage models in an industrial context. Specifically, we ask: (1) Do\napplication specific, but smaller language models perform better\nthan language models across applications? (2) Are developer specific language models effective and do they differ depending on\nwhat parts of the codebase a developer is working in? (3) Finally,\ndo language models change over time, i.e., does a language model\nfrom early development model change later on in development?\nThe answers to these questions enable techniques that make use of\nprogramming language models in development to choose the model\ntraining corpus more effectively.</p>\n\n<p>We evaluate these questions by building 28 language models across\ndevelopers, time periods, and applications within Microsoft Office\nand present the results in this paper. We find that developer and\napplication specific language models perform better than models\nfrom the entire codebase, but that temporality has little to no effect\non language model performance.</p>\n", "tags": ["language model"], "tsne_embedding": [-3.897792100906372, 0.9714120626449585]}, {"key": "schrouff2019inferring", "year": "2019", "title": "Inferring Javascript types using Graph Neural Networks", "abstract": "<p>The recent use of `Big Code\u2019 with state-of-the-art deep learning methods offers promising avenues to ease program source code writing and correction. As a first step towards automatic code repair, we implemented a graph neural network model that predicts token types for Javascript programs. The predictions achieve an accuracy above 90%, which improves on previous similar work.</p>\n", "tags": ["GNN", "types", "program analysis"], "tsne_embedding": [6.355266571044922, -3.12945556640625]}, {"key": "sharma2015nirmal", "year": "2015", "title": "NIRMAL: Automatic Identification of Software Relevant Tweets Leveraging Language Model", "abstract": "<p>Twitter is one of the most widely used social media\nplatforms today. It enables users to share and view short 140-character messages called \u201ctweets\u201d. About 284 million active\nusers generate close to 500 million tweets per day. Such rapid\ngeneration of user generated content in large magnitudes results\nin the problem of information overload. Users who are interested\nin information related to a particular domain have limited means\nto filter out irrelevant tweets and tend to get lost in the huge\namount of data they encounter. A recent study by Singer et\nal. found that software developers use Twitter to stay aware of\nindustry trends, to learn from others, and to network with other\ndevelopers. However, Singer et al. also reported that developers\noften find Twitter streams to contain too much noise which is a\nbarrier to the adoption of Twitter. In this paper, to help developers\ncope with noise, we propose a novel approach named NIRMAL,\nwhich automatically identifies software relevant tweets from a\ncollection or stream of tweets. Our approach is based on language\nmodeling which learns a statistical model based on a training\ncorpus (i.e., set of documents). We make use of a subset of posts\nfrom StackOverflow, a programming question and answer site, as\na training corpus to learn a language model. A corpus of tweets\nwas then used to test the effectiveness of the trained language\nmodel. The tweets were sorted based on the rank the model\nassigned to each of the individual tweets. The top 200 tweets\nwere then manually analyzed to verify whether they are software\nrelated or not, and then an accuracy score was calculated. The\nresults show that decent accuracy scores can be achieved by\nvarious variants of NIRMAL, which indicates that NIRMAL can\neffectively identify software related tweets from a huge corpus of\ntweets.</p>\n", "tags": ["information extraction"], "tsne_embedding": [-9.316202163696289, -0.6895814538002014]}, {"key": "sharma2019feasibility", "year": "2019", "title": "On the Feasibility of Transfer-learning Code Smells using Deep Learning", "abstract": "<p><strong>Context</strong>: A substantial amount of work has been done to detect smells in source code using metrics-based and heuristics-based methods. Machine learning methods have been recently applied to detect source code smells; however, the current practices are considered far from mature.</p>\n\n<p><strong>Objective</strong>: First, explore the feasibility of applying deep learning models to detect smells without extensive feature engineering, just by feeding the source code in tokenized form. Second, investigate the possibility of applying transfer-learning in the context of deep learning models for smell detection.</p>\n\n<p><strong>Method</strong>: We use existing metric-based state-of-the-art methods for detecting three implementation smells and one design smell in C# code. Using these results as the annotated gold standard, we train smell detection models on three different deep learning architectures. These architectures use Convolution Neural Networks (CNNs) of one or two dimensions, or Recurrent Neural Networks (RNNs) as their principal hidden layers. For the first objective of our study, we perform training and evaluation on C# samples, whereas for the second objective, we train the models from C# code and evaluate the models over Java code samples. We perform the experiments with various combinations of hyper-parameters for each model.</p>\n\n<p><strong>Results</strong>: We find it feasible to detect smells using deep learning methods. Our comparative experiments find that there is no clearly superior method between CNN-1D and CNN-2D. We also observe that performance of the deep learning models is smell-specific. Our transfer-learning experiments show that transfer-learning is definitely feasible for implementation smells with performance comparable to that of direct-learning. This work opens up a new paradigm to detect code smells by transfer-learning especially for the programming languages where the comprehensive code smell detection tools are not available.</p>\n", "tags": ["representation", "program analysis"], "tsne_embedding": [-4.556332111358643, -10.613877296447754]}, {"key": "she2019neuzz", "year": "2019", "title": "NEUZZ: Efficient Fuzzing with Neural Program Smoothing", "abstract": "<p>Fuzzing has become the de facto standard technique for finding software vulnerabilities. However, even state-of-the-art fuzzers are not very efficient at finding hard-to-trigger software bugs. Most popular fuzzers use evolutionary guidance to generate inputs that can trigger different bugs. Such evolutionary algorithms, while fast and simple to implement, often get stuck in fruitless sequences of random mutations. Gradient-guided optimization presents a promising alternative to evolutionary guidance. Gradient-guided techniques have been shown to significantly outperform evolutionary algorithms at solving high-dimensional structured optimization problems in domains like machine learning by efficiently utilizing gradients or higher-order derivatives of the underlying function. However, gradient-guided approaches are not directly applicable to fuzzing as real-world program behaviors contain many discontinuities, plateaus, and ridges where the gradient-based methods often get stuck. We observe that this problem can be addressed by creating a smooth surrogate function approximating the discrete branching behavior of target program. In this paper, we propose a novel program smoothing technique using surrogate neural network models that can incrementally learn smooth approximations of a complex, real-world program\u2019s branching behaviors. We further demonstrate that such neural network models can be used together with gradient-guided input generation schemes to significantly improve the fuzzing efficiency. Our extensive evaluations demonstrate that NEUZZ significantly outperforms 10 state-of-the-art graybox fuzzers on 10 real-world programs both at finding new bugs and achieving higher edge coverage. NEUZZ found 31 unknown bugs that other fuzzers failed to find in 10 real world programs and achieved 3X more edge coverage than all of the tested graybox fuzzers for 24 hours running.</p>\n", "tags": ["fuzzing"], "tsne_embedding": [-4.237827301025391, -7.895079135894775]}, {"key": "shi2019learning", "year": "2019", "title": "Learning Execution through Neural Code Fusion", "abstract": "<p>As the performance of computer systems stagnates due to the end of Moore\u2019s Law, there is a need for new models that can understand and optimize the execution of general purpose code. While there is a growing body of work on using Graph Neural Networks (GNNs) to learn representations of source code, these representations do not understand how code dynamically executes. In this work, we propose a new approach to use GNNs to learn fused representations of general source code and its execution. Our approach defines a multi-task GNN over low-level representations of source code and program state (i.e., assembly code and dynamic memory states), converting complex source code constructs and complex data structures into a simpler, more uniform format. We show that this leads to improved performance over similar methods that do not use execution and it opens the door to applying GNN models to new tasks that would not be feasible from static code alone. As an illustration of this, we apply the new model to challenging dynamic tasks (branch prediction and prefetching) from the SPEC CPU benchmark suite, outperforming the state-of-the-art by 26% and 45% respectively. Moreover, we use the learned fused graph embeddings to demonstrate transfer learning with high performance on an indirectly related task (algorithm classification).</p>\n", "tags": ["representation"], "tsne_embedding": [3.966510772705078, 10.775814056396484]}, {"key": "shirani2018evaluation", "year": "2018", "title": "Evaluation of Type Inference with Textual Cues", "abstract": "<p>Type information plays an important role in the success of information retrieval and recommendation systems in software\nengineering. Thus, the absence of types in dynamically-typed\nlanguages poses a challenge to adapt these systems to support\ndynamic languages.</p>\n\n<p>In this paper, we explore the viability of type inference using\ntextual cues.  That is, we formulate the type inference problem as a classification problem which uses the textual features\nin  the  source  code  to  predict  the type  of  variables.   In  this\napproach, a classifier learns a model to distinguish between\ntypes of variables in a program.  The model is subsequently\nused to (approximately) infer the types of other variables.</p>\n\n<p>We  evaluate  the  feasibility  of  this  approach  on  four  Java\nprojects wherein type information is already available in the\nsource code and can be used to train and test a classifier. Our\nexperiments show this approach can predict the type of new\nvariables  with  relatively  high  accuracy  (80% F-measure).\nThese results suggest that textual cues can be\ncomplementary\ntools in inferring types for dynamic languages.</p>\n", "tags": ["information extraction"], "tsne_embedding": [-2.243830680847168, 1.4871612787246704]}, {"key": "shrivastava2020on-the-fly", "year": "2020", "title": "On-the-Fly Adaptation of Source Code Models using Meta-Learning", "abstract": "<p>The ability to adapt to unseen, local contexts is an important challenge that successful models of source code must overcome. One of the most popular approaches for the adaptation of such models is dynamic evaluation. With dynamic evaluation, when running a model on an unseen file, the model is updated immediately after having observed each token in that file. In this work, we propose instead to frame the problem of context adaptation as a meta-learning problem. We aim to train a base source code model that is best able to learn from information in a file to deliver improved predictions of missing tokens. Unlike dynamic evaluation, this formulation allows us to select more targeted information (support tokens) for adaptation, that is both before and after a target hole in a file. We consider an evaluation setting that we call line-level maintenance, designed to reflect the downstream task of code auto-completion in an IDE. Leveraging recent developments in meta-learning such as first-order MAML and Reptile, we demonstrate improved performance in experiments on a large scale Java GitHub corpus, compared to other adaptation baselines including dynamic evaluation. Moreover, our analysis shows that, compared to a non-adaptive baseline, our approach improves performance on identifiers and literals by 44% and 15%, respectively.</p>\n", "tags": ["language model", "autocomplete"], "tsne_embedding": [2.288151979446411, 0.20620734989643097]}, {"key": "si2018learning", "year": "2018", "title": "Learning Loop Invariants for Program Verification", "abstract": "<p>A fundamental problem in program verification concerns inferring loop invariants.\nThe problem is undecidable and even practical instances are challenging. Inspired\nby how human experts construct loop invariants, we propose a reasoning framework\nCODE2INV\nthat constructs the solution by multi-step decision making and querying\nan external program graph memory block. By training with reinforcement learning,\nCODE2INV\ncaptures rich program features and avoids the need for ground truth\nsolutions as supervision.  Compared to previous learning tasks in domains with\ngraph-structured data, it addresses unique challenges, such as a binary objective\nfunction and an extremely sparse reward that is given by an automated theorem\nprover only after the complete loop invariant is proposed. We evaluate\nCODE2INV on\na suite of 133 benchmark problems and compare it to three state-of-the-art systems.\nIt solves 106 problems compared to 73 by a stochastic search-based system, 77 by\na heuristic search-based system, and 100 by a decision tree learning-based system.\nMoreover, the strategy learned can be generalized to new programs: compared to\nsolving new instances from scratch, the pre-trained agent is more sample efficient\nin finding solutions.</p>\n", "tags": ["program analysis", "verification"], "tsne_embedding": [-9.505221366882324, -4.570441246032715]}, {"key": "singh2016question", "year": "2016", "title": "Question Independent Grading using Machine Learning: The Case of Computer Program Grading", "abstract": "<p>Learning supervised models to grade open-ended responses is an expensive process. A model has to be trained for every prompt/question separately, which in turn requires graded samples. In automatic programming evaluation specifically, the focus of this work, this issue is amplified. The models have to be trained not only for every question but also for every language the question is offered in. Moreover, the availability and time taken by experts to create a labeled set of programs for each question is a major bottleneck in scaling such a system. We address this issue by presenting a method to grade computer programs which requires no manually assigned labeled samples for grading responses to a new, unseen question. We extend our previous work (by Srikant, Aggarwal; KDD 2014) wherein we introduced a grammar of features to learn question specific models. In this work, we propose a method to transform those features into a set of features that maintain their structural relation with the labels across questions. Using these features we learn one supervised model, across questions for a given language, which can then be applied to an ungraded response to an unseen question. We show that our method rivals the performance of both, question specific models and the consensus among human experts while substantially outperforming extant ways of evaluating codes. We demonstrate the system single s value by deploying it to grade programs in a high stakes assessment. The learning from this work is transferable to other grading tasks such as math question grading and also provides a new variation to the supervised learning approach.</p>\n", "tags": ["education"], "tsne_embedding": [-9.388547897338867, -6.303786754608154]}, {"key": "siow2019core", "year": "2019", "title": "CORE: Automating Review Recommendation for Code Changes", "abstract": "<p>Code review is a common process that is used by developers, in which a reviewer provides useful comments or points out defects in the submitted source code changes via pull request. Code review has been widely used for both industry and open-source projects due to its capacity in early defect identification, project maintenance, and code improvement. With rapid updates on project developments, code review becomes a non-trivial and labor-intensive task for reviewers. Thus, an automated code review engine can be beneficial and useful for project development in practice. Although there exist prior studies on automating the code review process by adopting static analysis tools or deep learning techniques, they often require external sources such as partial or full source code for accurate review suggestion. In this paper, we aim at automating the code review process only based on code changes and the corresponding reviews but with better performance. The hinge of accurate code review suggestion is to learn good representations for both code changes and reviews. To achieve this with limited source, we design a multi-level embedding (i.e., word embedding and character embedding) approach to represent the semantics provided by code changes and reviews. The embeddings are then well trained through a proposed attentional deep learning model, as a whole named CORE. We evaluate the effectiveness of CORE on code changes and reviews collected from 19 popular Java projects hosted on Github. Experimental results show that our model CORE can achieve significantly better performance than the state-of-the-art model (DeepMem), with an increase of 131.03% in terms of Recall@10 and 150.69% in terms of Mean Reciprocal Rank. Qualitative general word analysis among project developers also demonstrates the performance of CORE in automating code review.</p>\n", "tags": ["review"], "tsne_embedding": [-1.3339107036590576, -2.780773401260376]}, {"key": "srikant2014system", "year": "2014", "title": "A system to grade computer programming skills using machine learning", "abstract": "<p>The automatic evaluation of computer programs is a nascent area of research with a potential for large-scale impact. Extant program assessment systems score mostly based on the number of test-cases passed, providing no insight into the competency of the programmer. In this paper, we present a system to grade computer programs automatically. In addition to grading a program on its programming practices and complexity, the key kernel of the system is a machine-learning based algorithm which determines closeness of the logic of the given program to a correct program. This algorithm uses a set of highly-informative features, derived from the abstract representations of a given program, that capture the program\u2019s functionality. These features are then used to learn a model to grade the programs, which are built against evaluations done by experts. We show that the regression models provide much better grading than the ubiquitous test-case-pass based grading and rivals the grading accuracy of other open-response problems such as essay grading . We also show that our novel features add significant value over and above basic keyword/expression count features. In addition to this, we propose a novel way of posing computer-program grading as a one-class modeling problem and report encouraging preliminary results. We show the value of the system through a case study in a real-world industrial deployment. To the best of the authors\u2019 knowledge, this is the first time a system using machine learning has been developed and used for grading programs. The work is timely with regard to the recent boom in Massively Online Open Courseware (MOOCs), which promises to produce a significant amount of hand-graded digitized data.</p>\n", "tags": ["education"], "tsne_embedding": [-8.916008949279785, -3.7143547534942627]}, {"key": "sun2019grammar", "year": "2019", "title": "A Grammar-Based Structural CNN Decoder for Code Generation", "abstract": "<p>Code  generation  maps  a  program  description  to  executable\nsource code in a programming language. Existing approaches\nmainly rely on a recurrent neural network (RNN) as the decoder. However, we find that a program contains significantly\nmore tokens than a natural language sentence, and thus it may\nbe inappropriate for RNN to capture such a long sequence. In\nthis paper, we propose a grammar-based structural convolutional neural network (CNN) for code generation. Our model\ngenerates a program by predicting the grammar rules of the\nprogramming language; we design several CNN modules, including the tree-based convolution and pre-order convolution,\nwhose information is further aggregated by dedicated attentive pooling layers. Experimental results on the HearthStone\nbenchmark dataset show that our CNN code generator significantly outperforms the previous state-of-the-art method by 5\npercentage points; additional experiments on several semantic parsing tasks demonstrate the robustness of our model. We\nalso conduct in-depth ablation test to better understand each\ncomponent of our model.</p>\n", "tags": ["generation", "grammar"], "tsne_embedding": [-0.7577072381973267, 11.666304588317871]}, {"key": "svyatkovskiy2019pythia", "year": "2019", "title": "Pythia: AI-assisted Code Completion System", "abstract": "<p>In this paper, we propose a novel end-to-end approach for AI-assisted code completion called Pythia. It generates ranked lists of method and API recommendations which can be used by software developers at edit time. The system is currently deployed as part of Intellicode extension in Visual Studio Code IDE. Pythia exploits state-of-the-art large-scale deep learning models trained on code contexts extracted from abstract syntax trees. It is designed to work at a high throughput predicting the best matching code completions on the order of 100 ms.</p>\n\n<p>We describe the architecture of the system, perform comparisons to frequency-based approach and invocation-based Markov Chain language model, and discuss challenges serving Pythia models on lightweight client devices.</p>\n\n<p>The offline evaluation results obtained on 2700 Python open source software GitHub repositories show a top-5 accuracy of 92%, surpassing the baseline models by 20% averaged over classes, for both intra and cross-project settings.</p>\n\n", "tags": ["autocomplete", "language model"], "tsne_embedding": [7.934932708740234, -6.925268650054932]}, {"key": "svyatkovskiy2020fast", "year": "2020", "title": "Fast and Memory-Efficient Neural Code Completion", "abstract": "<p>Code completion is one of the most widely used features of modern integrated development environments (IDEs). Deep learning has recently made significant progress in the statistical prediction of source code. However, state-of-the-art neural network models consume prohibitively large amounts of memory, causing computational burden to the development environment, especially when deployed in lightweight client devices.</p>\n\n<p>In this work, we reframe neural code completion from a generation task to a task of learning to rank the valid completion suggestions computed from static analyses. By doing so, we are able to design and test a variety of deep neural network model configurations. One of our best models consumes 6 MB of RAM, computes a single suggestion in 8 ms, and achieves 90% recall in its top five suggestions. Our models outperform standard language modeling code completion techniques in terms of predictive performance, computational speed, and memory efficiency. Furthermore, they learn about code semantics from the natural language aspects of the code (e.g. identifier names) and can generalize better to previously unseen code.</p>\n", "tags": ["autocompletion"], "tsne_embedding": [5.095145225524902, -3.691889524459839]}, {"key": "svyatkovskiy2020intellicode", "year": "2020", "title": "IntelliCode Compose: Code Generation Using Transformer", "abstract": "<p>In software development through integrated development environments (IDEs), code completion is one of the most widely used features. Nevertheless, majority of integrated development environments only support completion of methods and APIs, or arguments.</p>\n\n<p>In this paper, we introduce IntelliCode Compose \u2212 a general-purpose multilingual code completion tool which is capable of predicting sequences of code tokens of arbitrary types, generating up to entire lines of syntactically correct code. It leverages state-of-the-art generative transformer model trained on 1.2 billion lines of source code in Python, C#, JavaScript and TypeScript programming languages. IntelliCode Compose is deployed as a cloud-based web service. It makes use of client-side tree-based caching, efficient parallel implementation of the beam search decoder, and compute graph optimizations to meet edit-time completion suggestion requirements in the Visual Studio Code IDE and Azure Notebook.\nOur best model yields an average edit similarity of 86.7% and a perplexity of 1.82 for Python programming language.</p>\n", "tags": ["autocompletion"], "tsne_embedding": [8.224928855895996, -7.045719623565674]}, {"key": "tabassum2020code", "year": "2020", "title": "Code and Named Entity Recognition in StackOverflow", "abstract": "<p>There is an increasing interest in studying natural language and computer code together, as large corpora of programming texts become readily available on the Internet. For example, StackOverflow currently has over 15 million programming related questions written by 8.5 million users. Meanwhile, there is still a lack of fundamental NLP techniques for identifying code tokens or software-related named entities that appear within natural language sentences. In this paper, we introduce a new named entity recognition (NER) corpus for the computer programming domain, consisting of 15,372 sentences annotated with 20 fine-grained entity types. We also present the SoftNER model that combines contextual information with domain specific knowledge using an attention network. The code token recognizer combined with an entity segmentation model we proposed, consistently improves the performance of the named entity tagger. Our proposed SoftNER tagger outperforms the BiLSTM-CRF model with an absolute increase of +9.73 F-1 score on StackOverflow data.</p>\n", "tags": ["dataset", "information extraction"], "tsne_embedding": [1.540197491645813, 5.3245978355407715]}, {"key": "tarlow2019learning", "year": "2019", "title": "Learning to Fix Build Errors with Graph2Diff Neural Networks", "abstract": "<p>Professional software developers spend a significant amount oftime fixing builds, but this has received little attention as a prob-lem in automatic program repair. We present a new deep learningarchitecture, called Graph2Diff, for automatically localizing andfixing build errors. We represent source code, build configurationfiles, and compiler diagnostic messages as a graph, and then use aGraph Neural Network model to predict a diff. A diff specifies howto modify the code\u2019s abstract syntax tree, represented in the neuralnetwork as a sequence of tokens and of pointers to code locations.Our network is an instance of a more general abstraction which wecall Graph2Tocopo, which is potentially useful in any developmenttool for predicting source code changes. We evaluate the model ona dataset of over 500k real build errors and their resolutions fromprofessional developers. Compared to the approach of DeepDelta, our approach tackles the harder task of predicting a moreprecise diff but still achieves over double the accuracy.</p>\n", "tags": ["edit", "repair"], "tsne_embedding": [-1.7102760076522827, -4.84946346282959]}, {"key": "theeten2019import2vec", "year": "2019", "title": "Import2vec - Learning Embeddings for Software Libraries", "abstract": "<p>We consider the problem of developing suitable learning representations (embeddings) for library packages that capture semantic similarity among libraries. Such representations are known to improve the performance of downstream learning tasks (e.g. classification) or applications such as contextual search and analogical reasoning.</p>\n\n<p>We apply word embedding techniques from natural language processing (NLP) to train embeddings for library packages (\u201clibrary vectors\u201d). Library vectors represent libraries by similar context of use as determined by import statements present in source code. Experimental results obtained from training such embeddings on three large open source software corpora reveals that library vectors capture semantically meaningful relationships among software libraries, such as the relationship between frameworks and their plug-ins and libraries commonly used together within ecosystems such as big data infrastructure projects (in Java), front-end and back-end web development frameworks (in JavaScript) and data science toolkits (in Python).</p>\n", "tags": ["representation"], "tsne_embedding": [6.527828693389893, 7.127192497253418]}, {"key": "tomczak2019simulating", "year": "2019", "title": "Simulating Execution Time of Tensor Programs using Graph Neural Networks", "abstract": "<p>Optimizing the execution time of tensor program, e.g., a convolution, involves finding its optimal configuration. Searching the configuration space exhaustively is typically infeasible in practice. In line with recent research using TVM, we propose to learn a surrogate model to overcome this issue. The model is trained on an acyclic graph called an abstract syntax tree, and utilizes a graph convolutional network to exploit structure in the graph. We claim that a learnable graph-based data processing is a strong competitor to heuristic-based feature extraction. We present a new dataset of graphs corresponding to configurations and their execution time for various tensor programs. We provide baselines for a runtime prediction task.</p>\n", "tags": ["GNN"], "tsne_embedding": [7.330536842346191, 11.542481422424316]}, {"key": "tran2019recovering", "year": "2019", "title": "Recovering Variable Names for Minified Code with Usage Contexts", "abstract": "<p>In modern Web technology, JavaScript (JS) code plays an important role. To avoid the exposure of original source code, the variable names in JS code deployed in the wild are often replaced by short, meaningless names, thus making the code extremely difficult to manually understand and analysis. This paper presents JSNeat, an information retrieval (IR)-based approach to recover the variable names in minified JS code. JSNeat follows a data-driven approach to recover names by searching for them in a large corpus of open-source JS code. We use three types of contexts to match a variable in given minified code against the corpus including the context of properties and roles of the variable, the context of that variable and relations with other variables under recovery, and the context of the task of the function to which the variable contributes. We performed several empirical experiments to evaluate JSNeat on the dataset of more than 322K JS files with 1M functions, and 3.5M variables with 176K unique variable names. We found that JSNeat achieves a high accuracy of 69.1%, which is the relative improvements of 66.1% and 43% over two state-of-the-art approaches JSNice and JSNaughty, respectively. The time to recover for a file or for a variable with JSNeat is twice as fast as with JSNice and 4x as fast as with JNaughty, respectively.</p>\n", "tags": ["naming", "deobfuscation"], "tsne_embedding": [-3.076331853866577, 5.2634172439575195]}, {"key": "tu2014localness", "year": "2014", "title": "On the Localness of Software", "abstract": "<p>The n-gram language model, which has its roots in statistical natural\nlanguage processing, has been shown to successfully capture the\nrepetitive and predictable regularities (\u201cnaturalness\u201d) of source code,\nand help with tasks such as code suggestion, porting, and designing\nassistive coding devices. However, we show in this paper that this\nnatural-language-based model fails to exploit a special property of\nsource code: localness. We find that human-written programs are\nlocalized: they have useful local regularities that can be captured\nand exploited. We introduce a novel cache language model that\nconsists of both an n-gram and an added \u201ccache\u201d component to\nexploit localness. We show empirically that the additional cache\ncomponent greatly improves the n-gram approach by capturing\nthe localness of software, as measured by both cross-entropy and\nsuggestion accuracy. Our model\u2019s suggestion accuracy is actually\ncomparable to a state-of-the-art, semantically augmented language\nmodel; but it is simpler and easier to implement. Our cache language\nmodel requires nothing beyond lexicalization, and thus is applicable\nto all programming languages.</p>\n", "tags": ["language model"], "tsne_embedding": [-7.009236812591553, 4.658535480499268]}, {"key": "tufano2018deep", "year": "2018", "title": "Deep Learning Similarities from Different Representations of Source Code", "abstract": "<p>Assessing the similarity between code components plays a pivotal\nrole in a number of Software Engineering (SE) tasks, such as clone\ndetection, impact analysis, refactoring, <em>etc.</em> \nCode similarity is generally measured by relying on manually defined or hand-crafted\nfeatures,  e.g.,  by analyzing the overlap among identifiers or comparing the Abstract Syntax Trees of two code components. These\nfeatures represent a  best guess at what SE researchers can utilize to\nexploit and reliably assess code similarity for a given task. Recent\nwork has shown, when using a stream of identifiers to represent\nthe code, that Deep Learning (DL) can effectively replace manual\nfeature engineering for the task of clone detection. However, source\ncode can be represented at different levels of abstraction: identifiers, Abstract Syntax Trees, Control Flow Graphs, and Bytecode.\nWe conjecture that each code representation can provide a different,\nyet orthogonal view of the same code fragment, thus, enabling a\nmore reliable detection of similarities in code. In this paper, we\ndemonstrate how SE tasks can benefit from a DL-based approach,\nwhich can automatically learn code similarities from different representations.</p>\n", "tags": ["representation", "clone"], "tsne_embedding": [10.005350112915039, 2.4469542503356934]}, {"key": "tufano2018empirical", "year": "2018", "title": "An Empirical Study on Learning Bug-Fixing Patches in the Wild via Neural Machine Translation", "abstract": "<p>Millions of open-source projects with numerous bug fixes are available in code repositories. This proliferation of software development histories can be leveraged to learn how to fix common programming bugs. To explore such a potential, we perform an empirical study to assess the feasibility of using Neural Machine Translation techniques for learning bug-fixing patches for real defects. First, we mine millions of bug-fixes from the change histories of projects hosted on GitHub, in order to extract meaningful examples of such bug-fixes. Next, we abstract the buggy and corresponding fixed code, and use them to train an Encoder-Decoder model able to translate buggy code into its fixed version. In our empirical investigation we found that such a model is able to fix thousands of unique buggy methods in the wild. Overall, this model is capable of predicting fixed patches generated by developers in 9-50% of the cases, depending on the number of candidate patches we allow it to generate. Also, the model is able to emulate a variety of different Abstract Syntax Tree operations and generate candidate patches in a split second.</p>\n", "tags": ["repair"], "tsne_embedding": [-5.667093276977539, -4.147860527038574]}, {"key": "tufano2018learning", "year": "2018", "title": "Learning How to Mutate Source Code from Bug-Fixes", "abstract": "<p>Mutation testing has been widely accepted as an approach to guide test case generation or to assess the effectiveness of test suites. Empirical studies have shown that mutants are representative of real faults; yet they also indicated a clear need for better, possibly customized, mutation operators and strategies. While some recent papers have tried to devise domain-specific or general purpose mutator operators by manually analyzing real faults, such an activity is effort- (and error-) prone and does not deal with an important practical question as to how to really mutate a given source code element. We propose a novel approach to automatically learn mutants from faults in real programs. First, our approach processes bug fixing changes using fine-grained differencing, code abstraction, and change clustering. Then, it learns mutation models using a deep learning strategy. We have trained and evaluated our technique on a set of ~787k bugs mined from GitHub. Starting from code fixed by developers in the context of a bug-fix, our empirical evaluation showed that our models are able to predict mutants that resemble original fixed bugs in between 9% and 45% of the cases (depending on the model). Moreover, over 98% of the automatically generated mutants are lexically and syntactically correct.</p>\n", "tags": ["repair", "edit"], "tsne_embedding": [-5.7203450202941895, -4.280381679534912]}, {"key": "tufano2019learning", "year": "2019", "title": "On Learning Meaningful Code Changes via Neural Machine Translation", "abstract": "<p>Recent years have seen the rise of Deep Learning (DL) techniques applied to source code. Researchers have exploited DL to automate several development and maintenance tasks, such as writing commit messages, generating comments and detecting vulnerabilities among others. One of the long lasting dreams of applying DL to code is the possibility to automate non-trivial coding activities. While some steps in this direction have been taken (e.g., learning how to fix bugs), there is still a lack of empirical evidence on the types of code changes that can be learned and automatically applied by DL. Our goal is to make this first step by quantitatively and qualitatively investigating the ability of a Neural Machine Translation (NMT) model to learn how to automatically apply code changes implemented by developers during pull requests. We train and experiment with the NMT model on a set of 236k pairs of code components before and after the implementation of the changes provided in the pull requests. We show that, when applied in a narrow enough context (i.e., small/medium-sized pairs of methods before/after the pull request changes), NMT can automatically replicate the changes implemented by developers during pull requests in up to 36% of the cases. Moreover, our qualitative analysis shows that the model is capable of learning and replicating a wide variety of meaningful code changes, especially refactorings and bug-fixing activities. Our results pave the way to novel research in the area of DL on code, such as the automatic learning and applications of refactoring.</p>\n", "tags": ["repair", "edit"], "tsne_embedding": [0.38829919695854187, -4.0129523277282715]}, {"key": "vasic2019neural", "year": "2019", "title": "Neural Program Repair by Jointly Learning to Localize and Repair", "abstract": "<p>Due to its potential to improve programmer productivity and software quality, automated program repair has been an active topic of research. Newer techniques harness neural networks to learn directly from examples of buggy programs and their fixes. In this work, we consider a recently identified class of bugs called variable-misuse bugs. The state-of-the-art solution for variable misuse enumerates potential fixes for all possible bug locations in a program, before selecting the best prediction. We show that it is beneficial to train a model that jointly and directly localizes and repairs variable-misuse bugs. We present multi-headed pointer networks for this purpose, with one head each for localization and repair. The experimental results show that the joint model significantly outperforms an enumerative solution that uses a pointer based model for repair alone.</p>\n", "tags": ["repair", "program analysis", "variable misuse"], "tsne_embedding": [-6.67803430557251, -3.905240774154663]}, {"key": "vasilescu2017recovering", "year": "2017", "title": "Recovering Clear, Natural Identifiers from Obfuscated JS Names", "abstract": "<p>Well-chosen variable names are critical to source code readability, reusability, and maintainability. Unfortunately, in deployed JavaScript code (which is ubiquitous on the web) the identifier names are frequently minified and overloaded. This is done both for efficiency and also to protect potentially proprietary intellectual property. In this paper, we describe an approach based on statistical machine translation (SMT) that recovers some of the original names from the JavaScript programs minified by the very popular UglifyJS. This simple tool, Autonym, performs comparably to the best currently available deobfuscator for JavaScript, JSNice, which uses sophisticated static analysis. In fact, Autonym is quite complementary to JSNice, performing well when it does not, and vice versa. We also introduce a new tool, JSNaughty, which blends Autonym and JSNice, and significantly outperforms both at identifier name recovery, while remaining just as easy to use as JSNice. JSNaughty is available online at http://jsnaughty.org.</p>\n", "tags": ["deobfuscation", "naming"], "tsne_embedding": [-6.81843376159668, 4.513622760772705]}, {"key": "wan2018improving", "year": "2018", "title": "Improving Automatic Source Code Summarization via Deep Reinforcement Learning", "abstract": "<p>Code summarization provides a high level natural language description of the function performed by code, as it can benefit the software maintenance, code categorization and retrieval. To the best of our knowledge, most state-of-the-art approaches follow an encoder-decoder framework which encodes the code into a hidden space and then decode it into natural language space, suffering from two major drawbacks: a) Their encoders only consider the sequential content of code, ignoring the tree structure which is also critical for the task of code summarization; b) Their decoders are typically trained to predict the next word by maximizing the likelihood of next ground-truth word with previous ground-truth word given. However, it is expected to generate the entire sequence from scratch at test time. This discrepancy can cause an exposure bias issue, making the learnt decoder suboptimal. In this paper, we incorporate an abstract syntax tree structure as well as sequential content of code snippets into a deep reinforcement learning framework (i.e., actor-critic network). The actor network provides the confidence of predicting the next word according to current state. On the other hand, the critic network evaluates the reward value of all possible extensions of the current state and can provide global guidance for explorations. We employ an advantage reward composed of BLEU metric to train both networks. Comprehensive experiments on a real-world dataset show the effectiveness of our proposed model when compared with some state-of-the-art methods.</p>\n", "tags": ["summarization", "documentation"], "tsne_embedding": [-3.652395009994507, -3.0122995376586914]}, {"key": "wan2019multimodal", "year": "2019", "title": "Multi-Modal Attention Network Learning for Semantic Source Code Retrieval", "abstract": "<p>Code retrieval techniques and tools have been playing a key role in facilitating software developers to retrieve existing code fragments from available open-source repositories given a user query. Despite the existing efforts in improving the effectiveness of code retrieval, there are still two main issues hindering them from being used to accurately retrieve satisfiable code fragments from large-scale repositories when answering complicated queries. First, the existing approaches only consider shallow features of source code such as method names and code tokens, but ignoring structured features such as abstract syntax trees (ASTs) and control-flow graphs (CFGs) of source code, which contains rich and well-defined semantics of source code. Second, although the deep learning-based approach performs well on the representation of source code, it lacks the explainability, making it hard to interpret the retrieval results and almost impossible to understand which features of source code contribute more to the final results.</p>\n\n<p>To tackle the two aforementioned issues, this paper proposes MMAN, a novel Multi-Modal Attention Network for semantic source code retrieval. A comprehensive multi-modal representation is developed for representing unstructured and structured features of source code, with one LSTM for the sequential tokens of code, a Tree-LSTM for the AST of code and a GGNN (Gated Graph Neural Network) for the CFG of code. Furthermore, a multi-modal attention fusion layer is applied to assign weights to different parts of each modality of source code and then integrate them into a single hybrid representation. Comprehensive experiments and analysis on a large-scale real-world dataset show that our proposed model can accurately retrieve code snippets and outperforms the state-of-the-art methods.</p>\n", "tags": ["search"], "tsne_embedding": [0.3610190749168396, 8.239912986755371]}, {"key": "wang2016automatically", "year": "2016", "title": "Automatically Learning Semantic Features for Defect Prediction", "abstract": "<p>Software defect prediction, which predicts defective code regions, can help developers find bugs and prioritize their testing efforts. To build accurate prediction models, previous\nstudies focus on manually designing features that encode the\ncharacteristics of programs and exploring different machine\nlearning algorithms. Existing traditional features often fail\nto capture the semantic differences of programs, and such a\ncapability is needed for building accurate prediction models.</p>\n\n<p>To bridge the gap between programs\u2019 semantics and\ndefect prediction features, this paper proposes to leverage a\npowerful representation-learning algorithm, deep learning,\nto learn semantic representation of programs automatically\nfrom source code. Specifically, we leverage Deep Belief\nNetwork (DBN) to automatically learn semantic features\nfrom token vectors extracted from programs\u2019 Abstract\nSyntax Trees (ASTs).</p>\n\n<p>Our evaluation on ten open source projects shows that\nour automatically learned semantic features significantly improve both within-project defect prediction (WPDP) and\ncross-project defect prediction (CPDP) compared to traditional features. Our semantic features improve WPDP on\naverage by 14.7% in precision, 11.5% in recall, and 14.2%\nin F1. For CPDP, our semantic features based approach\noutperforms the state-of-the-art technique TCA+ with traditional features by 8.9% in F1.</p>\n", "tags": ["defect", "representation"], "tsne_embedding": [-4.519335746765137, -3.40141224861145]}, {"key": "wang2016bugram", "year": "2016", "title": "Bugram: bug detection with n-gram language models", "abstract": "<p>To improve software reliability, many rule-based techniques have been proposed to infer programming rules and detect violations of these rules as bugs. These rule-based approaches often rely on the highly frequent appearances of certain patterns in a project to infer rules. It is known that if a pattern does not appear frequently enough, rules are not learned, thus missing many bugs.</p>\n\n<p>In this paper, we propose a new approach\u2014Bugram\u2014that leverages n-gram language models instead of rules to detect bugs. Bugram models program tokens sequentially, using the n-gram language model. Token sequences from the program are then assessed according to their probability in the learned model, and low probability sequences are marked as potential bugs. The assumption is that low probability token sequences in a program are unusual, which may indicate bugs, bad practices, or unusual/special uses of code of which developers may want to be aware.</p>\n\n<p>We evaluate Bugram in two ways. First, we apply Bugram on the latest versions of 16 open source Java projects. Results show that Bugram detects 59 bugs, 42 of which are manually verified as correct, 25 of which are true bugs and 17 are code snippets that should be refactored. Among the 25 true bugs, 23 cannot be detected by PR-Miner. We have reported these bugs to developers, 7 of which have already been confirmed by developers (4 of them have already been fixed), while the rest await confirmation. Second, we further compare Bugram with three additional graph- and rule-based bug detection tools, i.e., JADET, Tikanga, and GrouMiner. We apply Bugram on 14 Java projects evaluated in these three studies. Bugram detects 21 true bugs, at least 10 of which cannot be detected by these three tools. Our results suggest that Bugram is complementary to existing rule-based bug detection approaches.</p>\n\n", "tags": ["defect", "representation"], "tsne_embedding": [-3.9224472045898438, -4.516724586486816]}, {"key": "wang2016neural", "year": "2016", "title": "Neural Code Completion", "abstract": "<p>Code completion, an essential part of modern software development, yet can be\nchallenging for dynamically typed programming languages. In this paper we explore the use of neural network techniques to automatically learn code completion\nfrom a large corpus of dynamically typed JavaScript code. We show different\nneural networks that leverage not only token level information but also structural\ninformation, and evaluate their performance on different prediction tasks. We\ndemonstrate that our models can outperform the state-of-the-art approach, which\nis based on decision tree techniques, on both next non-terminal and next terminal\nprediction tasks by 3.8 points and 0.5 points respectively. We believe that neural\nnetwork techniques can play a transformative role in helping software developers\nmanage the growing complexity of software systems, and we see this work as a\nfirst step in that direction.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [1.9281576871871948, -4.6796345710754395]}, {"key": "wang2019learning", "year": "2019", "title": "Learning Scalable and Precise Representation of Program Semantics", "abstract": "<p>Neural program embedding has shown potential in aiding the analysis of large-scale, complicated software. Newly proposed deep neural architectures pride themselves on learning program semantics rather than superficial syntactic features. However, by considering the source code only, the vast majority of neural networks do not capture a deep, precise representation of program semantics. In this paper, we present \\dypro, a novel deep neural network that learns from program execution traces. Compared to the prior dynamic models, not only is \\dypro capable of generalizing across multiple executions for learning a program\u2019s dynamic semantics in its entirety, but \\dypro is also more efficient when dealing with programs yielding long execution traces. For evaluation, we task \\dypro with semantic classification (i.e. categorizing programs based on their semantics) and compared it against two prominent static models: Gated Graph Neural Network and TreeLSTM. We find that \\dypro achieves the highest prediction accuracy among all models. To further reveal the capacity of all aforementioned deep neural architectures, we examine if the models can learn to detect deeper semantic properties of a program. In particular given a task of recognizing loop invariants, we show \\dypro beats all static models by a wide margin.</p>\n", "tags": ["representation", "dynamic"], "tsne_embedding": [2.407897472381592, 9.677176475524902]}, {"key": "wang2020blended", "year": "2020", "title": "Blended, precise semantic program embeddings", "abstract": "<p>Learning neural program embeddings is key to utilizing deep neural networks in program languages research \u2014 precise and efficient program representations enable the application of deep models to a wide range of program analysis tasks. Existing approaches predominately learn to embed programs from their source code, and, as a result, they do not capture deep, precise program semantics. On the other hand, models learned from runtime information critically depend on the quality of program executions, thus leading to trained models with highly variant quality. This paper tackles these inherent weaknesses of prior approaches by introducing a new deep neural network, Liger, which learns program representations from a mixture of symbolic and concrete execution traces. We have evaluated Liger on two tasks: method name prediction and semantics classification. Results show that Liger is significantly more accurate than the state-of-the-art static model code2seq in predicting method names, and requires on average around 10x fewer executions covering nearly 4x fewer paths than the state-of-the-art dynamic model DYPRO in both tasks. Liger offers a new, interesting design point in the space of neural program embeddings and opens up this new direction for exploration.</p>\n", "tags": ["dynamic"], "tsne_embedding": [1.9668991565704346, 9.636884689331055]}, {"key": "wang2020cocogum", "year": "2020", "title": "CoCoGUM: Contextual Code Summarization with Multi-Relational GNN on UMLs", "abstract": "<p>Code summaries are short natural language (NL) descriptions of code snippets that help developers better understand and maintain source code. Due to the pivotal role of code summaries in software development and maintenance, there is a surge of works on automatic code summarization to reduce the heavy burdens of developers. However, contemporary approaches only leverage the information within the boundary of the method being summarized (i.e., local context), and ignore that using broader context could assist with code summarization. In this paper, we explore two global context information, namely intra-class and inter-class context information, and propose the model CoCoGUM: Contextual Code Summarization with Multi-Relational Graph Neural Networks on UMLs. CoCoGUM first incorporates class names as the intra-class context, which is further fed to a Transformer-based sentence embedding model to extract the class lexical embeddings. Then, relevant Unified Modeling Language (UML) class diagrams are extracted as inter-class context and we use a Multi-Relational Graph Neural Network (MR-GNN) to encode the class relational embeddings. Class lexical embeddings and class relational embeddings, together with the outputs from code token encoder and AST encoder, are passed to the decoder armed with a two-level attention mechanism to generate high-quality context-aware code summaries. We conduct extensive experiments to evaluate our approach and compare it with other automatic code summarization models. The experimental results show that CoCoGUM outperforms state-of-the-art methods.</p>\n", "tags": ["summarization"], "tsne_embedding": [4.173803329467773, 1.994476079940796]}, {"key": "wang2020learning", "year": "2020", "title": "Learning Semantic Program Embeddings with Graph Interval Neural Network", "abstract": "<p>Learning distributed representations of source code has been a challenging task for machine learning models. Earlier works treated programs as text so that natural language methods can be readily applied. Unfortunately, such approaches do not capitalize on the rich structural information possessed by source code. Of late, Graph Neural Network (GNN) was proposed to learn embeddings of programs from their graph representations. Due to the homogeneous and expensive message-passing procedure, GNN can suffer from precision issues, especially when dealing with programs rendered into large graphs. In this paper, we present a new graph neural architecture, called Graph Interval Neural Network (GINN), to tackle the weaknesses of the existing GNN. Unlike the standard GNN, GINN generalizes from a curated graph representation obtained through an abstraction method designed to aid models to learn. In particular, GINN focuses exclusively on intervals for mining the feature representation of a program, furthermore, GINN operates on a hierarchy of intervals for scaling the learning to large graphs. We evaluate GINN for two popular downstream applications: variable misuse prediction and method name prediction. Results show in both cases GINN outperforms the state-of-the-art models by a comfortable margin. We have also created a neural bug detector based on GINN to catch null pointer deference bugs in Java code. While learning from the same 9,000 methods extracted from 64 projects, GINN-based bug detector significantly outperforms GNN-based bug detector on 13 unseen test projects. Next, we deploy our trained GINN-based bug detector and Facebook Infer to scan the codebase of 20 highly starred projects on GitHub. Through our manual inspection, we confirm 38 bugs out of 102 warnings raised by GINN-based bug detector compared to 34 bugs out of 129 warnings for Facebook Infer.</p>\n", "tags": ["GNN", "defect"], "tsne_embedding": [4.675192356109619, 10.989867210388184]}, {"key": "wang2020modular", "year": "2020", "title": "Modular Tree Network for Source Code Representation Learning", "abstract": "<p>Learning representation for source code is a foundation of many program analysis tasks. In recent years, neural networks have already shown success in this area, but most existing models did not make full use of the unique structural information of programs. Although abstract syntax tree (AST)-based neural models can handle the tree structure in the source code, they cannot capture the richness of different types of substructure in programs. In this article, we propose a modular tree network that dynamically composes different neural network units into tree structures based on the input AST. Different from previous tree-structural neural network models, a modular tree network can capture the semantic differences between types of AST substructures. We evaluate our model on two tasks: program classification and code clone detection. Our model achieves the best performance compared with state-of-the-art approaches in both tasks, showing the advantage of leveraging more elaborate structure information of the source code.</p>\n", "tags": ["AST", "representation"], "tsne_embedding": [2.8105876445770264, 9.141447067260742]}, {"key": "wang2020trans", "year": "2020", "title": "TranS^3: A Transformer-based Framework for Unifying Code Summarization and Code Search", "abstract": "<p>Code summarization and code search have been widely adopted in sofwaredevelopmentandmaintenance. However, fewstudieshave explored the efcacy of unifying them. In this paper, we propose TranS^3 , a transformer-based framework to integrate code summarization with code search. Specifcally, for code summarization,TranS^3 enables an actor-critic network, where in the actor network, we encode the collected code snippets via transformer- and tree-transformer-based encoder and decode the given code snippet to generate its comment. Meanwhile, we iteratively tune the actor network via the feedback from the critic network for enhancing the quality of the generated comments. Furthermore, we import the generated comments to code search for enhancing its accuracy. To evaluatetheefectivenessof TranS^3 , we conduct a set of experimental studies and case studies where the experimental results suggest that TranS^3 can signifcantly outperform multiple state-of-the-art approaches in both code summarization and code search and the study results further strengthen the efcacy of TranS^3 from the developers\u2019 points of view.</p>\n", "tags": ["retrieval", "documentation"], "tsne_embedding": [12.51086139678955, -1.8360872268676758]}, {"key": "waunakh2019evaluating", "year": "2019", "title": "Evaluating Semantic Representations of Source Code", "abstract": "<p>Learned representations of source code enable various software developer tools, e.g., to detect bugs or to predict program properties. At the core of code representations often are word embeddings of identifier names in source code, because identifiers account for the majority of source code vocabulary and convey important semantic information. Unfortunately, there currently is no generally accepted way of evaluating the quality of word embeddings of identifiers, and current evaluations are biased toward specific downstream tasks. This paper presents IdBench, the first benchmark for evaluating to what extent word embeddings of identifiers represent semantic relatedness and similarity. The benchmark is based on thousands of ratings gathered by surveying 500 software developers. We use IdBench to evaluate state-of-the-art embedding techniques proposed for natural language, an embedding technique specifically designed for source code, and lexical string distance functions, as these are often used in current developer tools. Our results show that the effectiveness of embeddings varies significantly across different embedding techniques and that the best available embeddings successfully represent semantic relatedness. On the downside, no existing embedding provides a satisfactory representation of semantic similarities, e.g., because embeddings consider identifiers with opposing meanings as similar, which may lead to fatal mistakes in downstream developer tools. IdBench provides a gold standard to guide the development of novel embeddings that address the current limitations.</p>\n", "tags": ["representation"], "tsne_embedding": [9.976641654968262, 2.563690662384033]}, {"key": "wei2019code", "year": "2019", "title": "Code Generation as a Dual Task of Code Summarization", "abstract": "<p>Code summarization (CS) and code generation (CG) are two crucial tasks in the field of automatic software development. Various neural network-based approaches are proposed to solve these two tasks separately. However, there exists a specific intuitive correlation between CS and CG, which have not been exploited in previous work. In this paper, we apply the relations between two tasks to improve the performance of both tasks. In other words, exploiting the duality between the two tasks, we propose a dual training framework to train the two tasks simultaneously. In this framework, we consider the dualities on probability and attention weights, and design corresponding regularization terms to constrain the duality. We evaluate our approach on two datasets collected from GitHub, and experimental results show that our dual framework can improve the performance of CS and CG tasks over baselines.</p>\n", "tags": ["generation", "summarization"], "tsne_embedding": [9.951895713806152, 1.143373727798462]}, {"key": "wei2020lambdanet", "year": "2020", "title": "LambdaNet: Probabilistic Type Inference using Graph Neural Networks", "abstract": "<p>As gradual typing becomes increasingly popular in languages like Python and TypeScript, there is a growing need to infer type annotations automatically. While type annotations help with tasks like code completion and static error catching, these annotations cannot be fully inferred by compilers and are tedious to annotate by hand. This paper proposes a probabilistic type inference scheme for TypeScript based on a graph neural network. Our approach first uses lightweight source code analysis to generate a program abstraction called a type dependency graph, which links type variables with logical constraints as well as name and usage information. Given this program abstraction, we then use a graph neural network to propagate information between related type variables and eventually make type predictions. Our neural architecture can predict both standard types, like number or string, as well as user-defined types that have not been encountered during training. Our experimental results show that our approach outperforms prior work in this space by 14% (absolute) on library types, while having the ability to make type predictions that are out of scope for existing techniques.</p>\n", "tags": ["GNN", "types"], "tsne_embedding": [5.935564994812012, 12.09492301940918]}, {"key": "white2015toward", "year": "2015", "title": "Toward Deep Learning Software Repositories", "abstract": "<p>Deep learning subsumes algorithms that automatically learn compositional representations. The ability of these\nmodels to generalize well has ushered in tremendous advances\nin many fields such as natural language processing (NLP).\nRecent research in the software engineering (SE) community\nhas demonstrated the usefulness of applying NLP techniques to\nsoftware corpora. Hence, we motivate deep learning for software\nlanguage modeling, highlighting fundamental differences between\nstate-of-the-practice software language models and connectionist\nmodels. Our deep learning models are applicable to source\ncode files (since they only require lexically analyzed source\ncode written in any programming language) and other types\nof artifacts. We show how a particular deep learning model\ncan remember its state to effectively model sequential data,\ne.g., streaming software tokens, and the state is shown to be\nmuch more expressive than discrete tokens in a prefix. Then we\ninstantiate deep learning models and show that deep learning\ninduces high-quality models compared to n-grams and cache-based n-grams on a corpus of Java projects. We experiment\nwith two of the models\u2019 hyperparameters, which govern their\ncapacity and the amount of context they use to inform predictions,\nbefore building several committees of software language models\nto aid generalization. Then we apply the deep learning models to\ncode suggestion and demonstrate their effectiveness at a real SE\ntask compared to state-of-the-practice models. Finally, we propose\navenues for future work, where deep learning can be brought to\nbear to support model-based testing, improve software lexicons,\nand conceptualize software artifacts. Thus, our work serves as\nthe first step toward deep learning software repositories.</p>\n", "tags": ["representation"], "tsne_embedding": [5.253114700317383, 0.7755225896835327]}, {"key": "white2016deep", "year": "2016", "title": "Deep Learning Code Fragments for Code Clone Detection", "abstract": "<p>Code clone detection is an important problem for software\nmaintenance and evolution. Many approaches consider either structure or identifiers, but none of the existing detection techniques model both sources of information. These\ntechniques also depend on generic, handcrafted features to\nrepresent code fragments. We introduce learning-based detection techniques where everything for representing terms\nand fragments in source code is mined from the repository.\nOur code analysis supports a framework, which relies on\ndeep learning, for automatically linking patterns mined at\nthe lexical level with patterns mined at the syntactic level.\nWe evaluated our novel learning-based approach for code\nclone detection with respect to feasibility from the point\nof view of software maintainers. We sampled and manually\nevaluated 398 file- and 480 method-level pairs across eight\nreal-world Java systems; 93% of the file- and method-level\nsamples were evaluated to be true positives. Among the true\npositives, we found pairs mapping to all four clone types. We\ncompared our approach to a traditional structure-oriented\ntechnique and found that our learning-based approach detected clones that were either undetected or suboptimally\nreported by the prominent tool Deckard. Our results affirm\nthat our learning-based approach is suitable for clone detection and a tenable technique for researchers.</p>\n", "tags": ["clone"], "tsne_embedding": [-4.622109413146973, -1.7893556356430054]}, {"key": "white2017sorting", "year": "2017", "title": "Sorting and Transforming Program Repair Ingredients via Deep Learning Code Similarities", "abstract": "<p>In  the  field  of  automated  program  repair,  the  redundancy  assumption  claims  large  programs  contain  the  seeds\nof  their  own  repair.  However,  most  redundancy-based  program\nrepair  techniques  do  not  reason  about  the  repair  ingredients\u2014the code that is reused to craft a patch. We aim to reason about\nthe repair ingredients by using code similarities to prioritize and\ntransform  statements  in  a  codebase  for  patch  generation.  Our\napproach,  DeepRepair,  relies  on  deep  learning  to  reason  about\ncode  similarities.  Code  fragments  at  well-defined  levels  of  granularity in a codebase can be sorted according to their similarity\nto suspicious elements (i.e., code elements that contain suspicious\nstatements) and statements can be transformed by mapping out-of-scope  identifiers  to  similar  identifiers  in  scope.  We  examined\nthese new search strategies for patch generation with respect to\neffectiveness  from  the  viewpoint  of  a  software  maintainer.  Our\ncomparative experiments were executed on six open-source Java\nprojects  including  374  buggy  program  revisions  and  consisted\nof  19,949  trials  spanning  2,616  days  of  computation  time.  DeepRepair\u2019s  search  strategy  using  code  similarities  generally  found\ncompilable  ingredients  faster  than  the  baseline,  jGenProg,  but\nthis improvement neither yielded test-adequate patches in fewer\nattempts (on average) nor found significantly more patches than\nthe  baseline.  Although  the  patch  counts  were  not  statistically\ndifferent,  there  were  notable  differences  between  the  nature  of\nDeepRepair  patches  and  baseline  patches.  The  results  demonstrate that our learning-based approach finds patches that cannot\nbe  found  by  existing  redundancy-based  repair  techniques</p>\n", "tags": ["repair"], "tsne_embedding": [-5.8146138191223145, -3.445312738418579]}, {"key": "xu2019commit", "year": "2019", "title": "Commit Message Generation for Source Code Changes", "abstract": "<p>Commit  messages,  which  summarize  the  source\ncode changes in natural language, are essential for\nprogram comprehension and software evolution understanding.  Unfortunately, due to the lack of direct\nmotivation,  commit  messages  are  sometimes neglected  by  developers,  making  it  necessary  to\nautomatically  generate  such  messages.    State-of-the-art  adopts  learning  based  approaches  such  as\nneural machine translation models for the commitmessage generation problem.  However, they tend\nto  ignore  the  code  structure  information  and  suffer from the out-of-vocabulary issue.\nIn this paper, we  propose  CODISUM to  address  the  above  two limitations. In particular,\nwe first extract both code structure and code semantics from the source code changes, and then\njointly model these two sources of  information  so  as  to  better  learn  the  representations\n of  the  code  changes.   Moreover,  we  augment  the  model  with  copying  mechanism  to  further\nmitigate  the  out-of-vocabulary  issue.   Experimental  evaluations  on  real  data  demonstrate  that\nthe  proposed  approach  significantly  outperforms the state-of-the-art in terms of accurately generating the commit messages.</p>\n", "tags": ["edit", "summarization"], "tsne_embedding": [-3.1774189472198486, -1.9810210466384888]}, {"key": "xu2019method", "year": "2019", "title": "Method name suggestion with hierarchical attention networks", "abstract": "<p>Method Rename has been a widely used refactoring operation that improves program comprehension and maintenance. Descriptive method names that summarize functionalities of source code can facilitate program comprehension. Much research has been done to suggest method names through source code summarization. However, unlike natural language, a code snippet consists of basic blocks organized by complicated structures. In this work, we observe a hierarchical structure \u2014 tokens form basic blocks and basic blocks form a code snippet. Based on this observation, we exploit a hierarchical attention network to learn the representation of methods. Specifically, we apply two-level attention mechanism to learn the importance of each token in a basic block and that of a basic block in a method respectively. We evaluated our approach on 10 open source repositories and compared it against three state-of-the-art approaches. The results on these open-source data show the superiority of our hierarchical attention networks in terms of effectiveness.</p>\n", "tags": ["naming"], "tsne_embedding": [3.667161226272583, 0.1924637258052826]}, {"key": "xu2020incorporating", "year": "2020", "title": "Incorporating External Knowledge through Pre-training for Natural Language to Code Generation", "abstract": "<p>Open-domain code generation aims to generate code in a general-purpose programming language (such as Python) from natural language (NL) intents. Motivated by the intuition that developers usually retrieve resources on the web when writing code, we explore the effectiveness of incorporating two varieties of external knowledge into NL-to-code generation: automatically mined NL-code pairs from the online programming QA forum StackOverflow and programming language API documentation. Our evaluations show that combining the two sources with data augmentation and retrieval-based data re-sampling improves the current state-of-the-art by up to 2.2% absolute BLEU score on the code generation testbed CoNaLa. The code and resources are available at [Open-domain code generation aims to generate code in a general-purpose programming language (such as Python) from natural language (NL) intents. Motivated by the intuition that developers usually retrieve resources on the web when writing code, we explore the effectiveness of incorporating two varieties of external knowledge into NL-to-code generation: automatically mined NL-code pairs from the online programming QA forum StackOverflow and programming language API documentation. Our evaluations show that combining the two sources with data augmentation and retrieval-based data re-sampling improves the current state-of-the-art by up to 2.2% absolute BLEU score on the code generation testbed CoNaLa. The code and resources are available at <a href=\"https://github.com/neulab/external-knowledge-codegen\">https://github.com/neulab/external-knowledge-codegen</a>.</p>\n", "tags": ["bimodal", "generation"], "tsne_embedding": [10.888079643249512, 4.217898845672607]}, {"key": "yadid2016extracting", "year": "2016", "title": "Extracting Code from Programming Tutorial Videos", "abstract": "<p>The number of programming tutorial videos on the web\nincreases daily. Video hosting sites such as YouTube host\nmillions of video lectures, with many programming tutorials for various languages and platforms. These videos contain a wealth of valuable information, including code that\nmay be of interest. However, two main challenges have so\nfar prevented the effective indexing of programming tutorial\nvideos: (i) code in tutorials is typically written on-the-fly,\nwith only parts of the code visible in each frame, and (ii) optical character recognition (OCR) is not precise enough to\nproduce quality results from videos.</p>\n\n<p>We present a novel approach for extracting code from\nvideos that is based on: (i) consolidating code across frames,\nand (ii) statistical language models for applying corrections\nat different levels, allowing us to make corrections by choosing the most likely token, combination of tokens that form a\nlikely line structure, and combination of lines that lead to\na likely code fragment in a particular language. We implemented our approach in a tool called ACE , and used it to extract code from 40 Android video tutorials on YouTube . Our\nevaluation shows that ACE extracts code with high accuracy,\nenabling deep indexing of video tutorials.</p>\n", "tags": ["information extraction"], "tsne_embedding": [-0.0023189145140349865, -4.3416056632995605]}, {"key": "yang2017language", "year": "2017", "title": "A Language Model for Statements of Software Code", "abstract": "<p>Building language models for source code enables a large set of improvements on traditional software engineering tasks. One promising application is automatic code completion. State-of-the-art techniques capture code regularities at token level with lexical information. Such language models are more suitable for predicting short token sequences, but become less effective with respect to long statement level predictions. In this paper, we have proposed PCC to optimize the token level based language modeling. Specifically, PCC introduced an intermediate representation (IR) for source code, which puts tokens into groups using lexeme and variable relative order. In this way, PCC is able to handle long token sequences, i.e., group sequences, to suggest a complete statement with the precise synthesizer. Further more, PCC employed a fuzzy matching technique which combined genetic and longest common sub-sequence algorithms to make the prediction more accurate. We have implemented a code completion plugin for Eclipse and evaluated it on open-source Java projects. The results have demonstrated the potential of PCC in generating precise long statement level predictions. In 30%-60% of the cases, it can correctly suggest the complete statement with only six candidates, and 40%-90% of the cases with ten candidates.</p>\n", "tags": ["language model"], "tsne_embedding": [6.118125915527344, 3.84028697013855]}, {"key": "yao2018staqc", "year": "2018", "title": "StaQC: A Systematically Mined Question-Code Dataset from Stack Overflow", "abstract": "<p>Stack Overflow (SO) has been a great source of natural language questions and their code solutions (i.e., question-code pairs), which are critical for many tasks including code retrieval and annotation. In most existing research, question-code pairs were collected heuristically and tend to have low quality. In this paper, we investigate a new problem of systematically mining question-code pairs from Stack Overflow (in contrast to heuristically collecting them). It is formulated as predicting whether or not a code snippet is a standalone solution to a question. We propose a novel Bi-View Hierarchical Neural Network which can capture both the programming content and the textual context of a code snippet (i.e., two views) to make a prediction. On two manually annotated datasets in Python and SQL domain, our framework substantially outperforms heuristic methods with at least 15% higher F1 and accuracy. Furthermore, we present StaQC (Stack Overflow Question-Code pairs), the largest dataset to date of \u223c148K Python and \u223c120K SQL question-code pairs, automatically mined from SO using our framework. Under various case studies, we demonstrate that StaQC can greatly help develop data-hungry models for associating natural language with programming language.</p>\n", "tags": ["dataset"], "tsne_embedding": [0.8052591681480408, 5.226826190948486]}, {"key": "yao2019coacor", "year": "2019", "title": "CoaCor: Code Annotation for Code Retrieval with Reinforcement Learning", "abstract": "<p>To accelerate software development, much research has been performed\nto help people understand and reuse the huge amount of available code\nresources. Two important tasks have been widely studied: code retrieval,\nwhich aims to retrieve code snippets relevant to a given natural language\nquery from a code base, and code annotation, where the goal is to annotate a \ncode snippet with anatural language description. Despite their advancement in recent\nyears, the two tasks are mostly explored separately. In this work, we\ninvestigate a novel perspective of Code annotation for Code retrieval \n(hence called \u201cCoaCor\u201d), where a code annotation model is trained\nto generate a natural language annotation that can represent the\nsemantic meaning of a given code snippet and can be leveraged by\na code retrieval model to better distinguish relevant code snippets\nfrom others. To this end, we propose an effective framework based\non reinforcement learning, which explicitly encourages the code\nannotation model to generate annotations that can be used for the\nretrieval task. Through extensive experiments, we show that code\nannotations generated by our framework are much more detailed\nand more useful for code retrieval, and they can further improve\nthe performance of existing code retrieval models significantly.</p>\n", "tags": ["search"], "tsne_embedding": [7.485098361968994, 2.9927587509155273]}, {"key": "yasunaga2020graph", "year": "2020", "title": "Graph-based, Self-Supervised Program Repair from Diagnostic Feedback", "abstract": "<p>We consider the problem of learning to repair programs from diagnostic feedback (e.g., compiler error messages). Program repair is challenging for two reasons: First, it requires reasoning and tracking symbols across source code and diagnostic feedback. Second, labeled datasets available for program repair are relatively small. In this work, we propose novel solutions to these two challenges. First, we introduce a program-feedback graph, which connects symbols relevant to program repair in source code and diagnostic feedback, and then apply a graph neural network on top to model the reasoning process. Second, we present a self-supervised learning paradigm for program repair that leverages unlabeled programs available online to create a large amount of extra program repair examples, which we use to pre-train our models. We evaluate our proposed approach on two applications: correcting introductory programming assignments (DeepFix dataset) and correcting the outputs of program synthesis (SPoC dataset). Our final system, DrRepair, significantly outperforms prior work, achieving 66.1% full repair rate on DeepFix (+20.8% over the prior best), and 48.0% synthesis success rate on SPoC (+3.3% over the prior best).</p>\n", "tags": ["repair", "edit", "GNN"], "tsne_embedding": [-7.374709129333496, -5.557778835296631]}, {"key": "ye2020misim", "year": "2020", "title": "MISIM: An End-to-End Neural Code Similarity System", "abstract": "<p>Code similarity systems are integral to a range of applications from code recommendation to automated construction of software tests and defect mitigation. In this paper, we present Machine Inferred Code Similarity (MISIM), a novel end-to-end code similarity system that consists of two core components. First, MISIM uses a novel context-aware similarity structure, which is designed to aid in lifting semantic meaning from code syntax. Second, MISIM provides a neural-based code similarity scoring system, which can be implemented with various neural network algorithms and topologies with learned parameters. We compare MISIM to three other state-of-the-art code similarity systems: (i) code2vec, (ii) Neural Code Comprehension, and (iii) Aroma. In our experimental evaluation across 45,780 programs, MISIM consistently outperformed all three systems, often by a large factor (upwards of 40.6x).</p>\n", "tags": ["code similarity"], "tsne_embedding": [-4.189184665679932, 7.993039131164551]}, {"key": "yefet2019adversarial", "year": "2019", "title": "Adversarial Examples for Models of Code", "abstract": "<p>Neural models of code have shown impressive performance for tasks such as predicting method names and identifying certain kinds of bugs. In this paper, we show that these models are vulnerable to adversarial examples, and introduce a novel approach for attacking trained models of code with adversarial examples. The main idea is to force a given trained model to make an incorrect prediction as specified by the adversary by introducing small perturbations that do not change the program\u2019s semantics. To find such perturbations, we present a new technique for Discrete Adversarial Manipulation of Programs (DAMP). DAMP works by deriving the desired prediction with respect to the model\u2019s inputs while holding the model weights constant and following the gradients to slightly modify the code.</p>\n\n<p>To defend a model against such attacks, we propose placing a defensive model (Anti-DAMP) in front of it. Anti-DAMP detects unlikely mutations and masks them before feeding the input to the downstream model.</p>\n\n<p>We show that our DAMP attack is effective across three neural architectures: code2vec, GGNN, and GNN-FiLM, in both Java and C#. We show that DAMP has up to 89% success rate in changing a prediction to the adversary\u2019s choice (\u201ctargeted attack\u201d), and a success rate of up to 94% in changing a given prediction to any incorrect prediction (\u201cnon-targeted attack\u201d). By using Anti-DAMP, the success rate of the attack drops drastically for both targeted and non-targeted attacks, with a minor penalty of 2% relative degradation in accuracy while not performing under attack.</p>\n", "tags": ["adversarial"], "tsne_embedding": [-3.4920578002929688, -9.552812576293945]}, {"key": "yin2017syntactic", "year": "2017", "title": "A Syntactic Neural Model for General-Purpose Code Generation", "abstract": "<p>We consider the problem of parsing natural language descriptions into source code\nwritten in a general-purpose programming\nlanguage like Python. Existing data-driven methods treat this problem as a language generation task without considering\nthe underlying syntax of the target programming language. Informed by previous work in semantic parsing, in this paper we propose a novel neural architecture\npowered by a grammar model to explicitly\ncapture the target syntax as prior knowledge. Experiments find this an effective\nway to scale up to generation of complex\nprograms from natural language descriptions, achieving state-of-the-art results that\nwell outperform previous code generation\nand semantic parsing approaches.</p>\n", "tags": ["generation", "AST", "bimodal"], "tsne_embedding": [11.966678619384766, 4.992164134979248]}, {"key": "yin2018mining", "year": "2018", "title": "Learning to Mine Aligned Code and Natural Language Pairs from Stack Overflow", "abstract": "<p>For tasks like code synthesis from natural language, code retrieval, and code summarization, data-driven models have shown great promise. However, creating these models require parallel data between natural language (NL) and code with fine-grained alignments. Stack Overflow (SO) is a promising source to create such a data set: the questions are diverse and most of them have corresponding answers with high-quality code snippets. However, existing heuristic methods (e.g., pairing the title of a post with the code in the accepted answer) are limited both in their coverage and the correctness of the NL-code pairs obtained. In this paper, we propose a novel method to mine high-quality aligned data from SO using two sets of features: hand-crafted features considering the structure of the extracted snippets, and correspondence features obtained by training a probabilistic model to capture the correlation between NL and code using neural networks. These features are fed into a classifier that determines the quality of mined NL-code pairs. Experiments using Python and Java as test beds show that the proposed method greatly expands coverage and accuracy over existing mining methods, even when using only a small number of labeled examples. Further, we find that reasonable results are achieved even when training the classifier on one language and testing on another, showing promise for scaling NL-code mining to a wide variety of programming languages beyond those for which we are able to annotate data.</p>\n\n", "tags": ["dataset"], "tsne_embedding": [4.006424903869629, 3.418877124786377]}, {"key": "yin2019learning", "year": "2019", "title": "Learning to Represent Edits", "abstract": "<p>We introduce the problem of learning distributed representations of edits. By combining a\n\u201cneural editor\u201d with an \u201cedit encoder\u201d, our models learn to represent the salient\ninformation of an edit and can be used to apply edits to new inputs.\nWe experiment on natural language and source code edit data. Our evaluation yields\npromising results that suggest that our neural network models learn to capture\nthe structure and semantics of edits. We hope that this interesting task and\ndata source will inspire other researchers to work further on this problem.</p>\n", "tags": ["edit"], "tsne_embedding": [11.365571022033691, 0.07237410545349121]}, {"key": "yonai2019mercem", "year": "2019", "title": "Mercem: Method Name Recommendation Based on Call Graph Embedding", "abstract": "<p>Comprehensibility of source code is strongly affected by identifier names, therefore software developers need to give good (e.g. meaningful but short) names to identifiers. On the other hand, giving a good name is sometimes a difficult and time-consuming task even for experienced developers. To support naming identifiers, several techniques for recommending identifier name candidates have been proposed. These techniques, however, still have challenges on the goodness of suggested candidates and limitations on applicable situations. This paper proposes a new approach to recommending method names by applying graph embedding techniques to the method call graph. The evaluation experiment confirms that the proposed technique can suggest more appropriate method name candidates in difficult situations than the state of the art approach.</p>\n", "tags": ["naming", "representation", "refactoring"], "tsne_embedding": [-1.6584314107894897, 8.512330055236816]}, {"key": "yuan2017abridging", "year": "2017", "title": "Abridging Source Code", "abstract": "<p>In this paper, we consider the problem of source code abridgment, where the goal is to remove statements from a source code in order to display the source code in a small space, while at the same time leaving the ``important\u2019\u2019 parts of the source code intact, so that an engineer can read the code and quickly understand purpose of the code. To this end, we develop an algorithm that looks at a number of examples, human-created source code abridgments, and learns how to remove lines from the code in order to mimic the human abridger. The learning algorithm takes into account syntactic features of the code, as well as semantic features such as control flow and data dependencies. Through a comprehensive user study, we show that the abridgments that our system produces can decrease the time that a user must look at code in order to understand its functionality, as well as increase the accuracy of the assessment, while displaying the code in a greatly reduced area.</p>\n", "tags": ["summarization"], "tsne_embedding": [-2.0418245792388916, -1.9252392053604126]}, {"key": "zaremba2014learning", "year": "2014", "title": "Learning to Execute", "abstract": "<p>Recurrent Neural Networks (RNNs) with Long Short-Term Memory units (LSTM) are widely used because they are expressive and are easy to train. Our interest lies in empirically evaluating the expressiveness and the learnability of LSTMs in the sequence-to-sequence regime by training them to evaluate short computer programs, a domain that has traditionally been seen as too complex for neural networks. We consider a simple class of programs that can be evaluated with a single left-to-right pass using constant memory. Our main result is that LSTMs can learn to map the character-level representations of such programs to their correct outputs. Notably, it was necessary to use curriculum learning, and while conventional curriculum learning proved ineffective, we developed a new variant of curriculum learning that improved our networks\u2019 performance in all experimental conditions. The improved curriculum had a dramatic impact on an addition problem, making it possible to train an LSTM to add two 9-digit numbers with 99% accuracy.</p>\n", "tags": ["representation"], "tsne_embedding": [-8.371418952941895, -8.72393798828125]}, {"key": "zhang2019learning", "year": "2019", "title": "Learning Uniform Semantic Features for Natural Language and Programming Language Globally, Locally and Sequentially", "abstract": "<p>Semantic feature learning for natural language and programming language is a preliminary step in addressing many software mining tasks. Many existing methods leverage\ninformation in lexicon and syntax to learn features for textual data.\nHowever, such information is inadequate to represent the entire semantics in either text sentence or code snippet. This\nmotivates us to propose a new approach to learn semantic\nfeatures for both languages, through extracting three levels of\ninformation, namely global, local and sequential information,\nfrom textual data. For tasks involving both modalities, we\nproject the data of both types into a uniform feature space so\nthat the complementary knowledge in between can be utilized\nin their representation. In this paper, we build a novel and\ngeneral-purpose feature learning framework called UniEmbed, to uniformly learn comprehensive semantic representation for both natural language and programming language.\nExperimental results on three real-world software mining\ntasks show that UniEmbed outperforms state-of-the-art models in feature learning and prove the capacity and effectiveness of our model.</p>\n", "tags": ["representation", "bimodal"], "tsne_embedding": [2.965466022491455, 3.7600507736206055]}, {"key": "zhang2019novel", "year": "2019", "title": "A Novel Neural Source Code Representation based on Abstract Syntax Tree", "abstract": "<p>Exploiting machine learning techniques for analyzing programs has attracted much attention. One key problem is how to represent code fragments well for follow-up analysis. Traditional information retrieval based methods often treat programs as natural language texts, which could miss important semantic information of source code. Recently, state-of-the-art studies demonstrate that abstract syntax tree (AST) based neural models can better represent source code. However, the sizes of ASTs are usually large and the existing models are prone to the long-term dependency problem. In this paper, we propose a novel AST-based Neural Network (ASTNN) for source code representation. Unlike existing models that work on entire ASTs, ASTNN splits each large AST into a sequence of small statement trees, and encodes the statement trees to vectors by capturing the lexical and syntactical knowledge of statements. Based on the sequence of statement vectors, a bidirectional RNN model is used to leverage the naturalness of statements and finally produce the vector representation of a code fragment. We have applied our neural network based source code representation method to two common program comprehension tasks: source code classification and code clone detection. Experimental results on the two tasks indicate that our model is superior to state-of-the-art approaches.</p>\n", "tags": ["representation", "AST"], "tsne_embedding": [2.323158025741577, 4.889178276062012]}, {"key": "zhang2020generating", "year": "2020", "title": "Generating Adversarial Examples for Holding Robustness of Source Code Processing Models", "abstract": "<p>Automated  processing,  analysis,  and  generation  of  source code are among the key activities\nin software and system life-cycle. To this end, while deep learning (DL) exhibits a certain level\nof capability in handling these tasks, the current state-of-the-art DL models still suffer from\nnon-robust issues and can be easily fooled by adversarial attacks.</p>\n\n<p>Different  from  adversarial \nattacks  for  image,  audio,  andnatural  languages,  the  structured  nature  of  programming\nlanguages  brings  new  challenges.  In  this  paper,  we  propose a Metropolis-Hastings\nsampling-based identifier renaming technique, named Metropolis-Hastings Modifier (MHM),\nwhich  generates  adversarial  examples  for  DL  models  specialized for source code processing.\nOur in-depth evaluation on a functionality classification benchmark demonstrates the\neffectiveness  of  MHM  in  generating  adversarial  examples of source code. The higher robustness\nand performance enhanced through our  adversarial training with MHM further confirms the usefulness\nof DL models-based method for future fully automated source code processing.</p>\n", "tags": ["adversarial"], "tsne_embedding": [0.02233881875872612, 8.320502281188965]}, {"key": "zhao2018neural", "year": "2018", "title": "Neural-Augumented Static Analysis of Android Communication", "abstract": "<p>We address the problem of discovering communication links between applications in the popular Android mobile operating system, an important problem for security and privacy in Android. Any scalable static analysis in this complex setting is bound to produce an excessive amount of false-positives, rendering it impractical. To improve precision, we propose to augment static analysis with a trained neural-network model that estimates the probability that a communication link truly exists. We describe a neural-network architecture that encodes abstractions of communicating objects in two applications and estimates the probability with which a link indeed exists. At the heart of our architecture are type-directed encoders (TDE), a general framework for elegantly constructing encoders of a compound data type by recursively composing encoders for its constituent types. We evaluate our approach on a large corpus of Android applications, and demonstrate that it achieves very high accuracy. Further, we conduct thorough interpretability studies to understand the internals of the learned neural networks.</p>\n", "tags": ["program analysis"], "tsne_embedding": [-1.1468956470489502, -9.436555862426758]}, {"key": "zhao2019neural", "year": "2019", "title": "Neural Networks for Modeling Source Code Edits", "abstract": "<p>Programming languages are emerging as a challenging and interesting domain for machine learning. A core task, which has received significant attention in recent years, is building generative models of source code. However, to our knowledge, previous generative models have always been framed in terms of generating static snapshots of code. In this work, we instead treat source code as a dynamic object and tackle the problem of modeling the edits that software developers make to source code files. This requires extracting intent from previous edits and leveraging it to generate subsequent edits. We develop several neural networks and use synthetic data to test their ability to learn challenging edit patterns that require strong generalization. We then collect and train our models on a large-scale dataset of Google source code, consisting of millions of fine-grained edits from thousands of Python developers. From the modeling perspective, our main conclusion is that a new composition of attentional and pointer network components provides the best overall performance and scalability. From the application perspective, our results provide preliminary evidence of the feasibility of developing tools that learn to predict future edits.</p>\n", "tags": ["edit"], "tsne_embedding": [1.8445444107055664, -4.099130630493164]}, {"key": "zhong2018generating", "year": "2018", "title": "Generating Regular Expressions from Natural Language Specifications: Are We There Yet?", "abstract": "<p>Recent  state-of-the-art  approaches  automatically  generate\nregular  expressions  from  natural  language  specifications.\nGiven that these approaches use only synthetic data in both\ntraining datasets and validation/test datasets, a natural question arises: are these approaches effective to address various\nreal-world  situations?  To  explore  this  question,  in  this  paper, we conduct a characteristic study on comparing two synthetic datasets used by the recent research and a real-world\ndataset  collected  from  the  Internet,  and  conduct  an  experimental study on applying a state-of-the-art approach on the\nreal-world dataset. Our study results suggest the existence of\ndistinct characteristics between the synthetic datasets and the\nreal-world  dataset,  and  the  state-of-the-art  approach  (based\non  a  model  trained  from  a  synthetic  dataset)  achieves  extremely low effectiveness when evaluated on real-world data,\nmuch lower than the effectiveness when evaluated on the synthetic  dataset.  We  also  provide  initial  analysis  on  some  of\nthose challenging cases and discuss future directions.</p>\n", "tags": ["bimodal", "generation"], "tsne_embedding": [-8.258543968200684, 7.82042121887207]}, {"key": "zhong2020semantic", "year": "2020", "title": "Semantic Scaffolds for Pseudocode-to-Code Generation", "abstract": "<p>We propose a method for program generation based on semantic scaffolds, lightweight structures representing the high-level semantic and syntactic composition of a program. By first searching over plausible scaffolds then using these as constraints for a beam search over programs, we achieve better coverage of the search space when compared with existing techniques. We apply our hierarchical search method to the SPoC dataset for pseudocode-to-code generation, in which we are given line-level natural language pseudocode annotations and aim to produce a program satisfying execution-based test cases. By using semantic scaffolds during inference, we achieve a 10% absolute improvement in top-100 accuracy over the previous state-of-the-art. Additionally, we require only 11 candidates to reach the top-3000 performance of the previous best approach when tested against unseen problems, demonstrating a substantial improvement in efficiency.</p>\n", "tags": ["generation", "synthesis"], "tsne_embedding": [4.523197650909424, -8.696361541748047]}, {"key": "zhou2019devign", "year": "2020", "title": "Devign: Effective Vulnerability Identification by Learning Comprehensive Program Semantics via Graph Neural Networks", "abstract": "<p>Vulnerability identification is crucial to protect the software systems from attacks for cyber security. It is especially important to localize the vulnerable functions among the source code to facilitate the fix. However, it is a challenging and tedious process, and also requires specialized security expertise. Inspired by the work on manually-defined patterns of vulnerabilities from various code representation graphs and the recent advance on graph neural networks, we propose Devign, a general graph neural network based model for graph-level classification through learning on a rich set of code semantic representations. It includes a novel Conv module to efficiently extract useful features in the learned rich node representations for graph-level classification. The model is trained over manually labeled datasets built on 4 diversified large-scale open-source C projects that incorporate high complexity and variety of real source code instead of synthesis code used in previous works. The results of the extensive evaluation on the datasets demonstrate that Devign outperforms the state of the arts significantly with an average of 10.51% higher accuracy and 8.68% F1 score, increases averagely 4.66% accuracy and 6.37% F1 by the Conv module.</p>\n", "tags": ["GNN", "static analysis"], "tsne_embedding": [3.4323909282684326, 12.85871696472168]}]
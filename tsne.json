[{"key": "abdelaziz2020graph4code", "year": "2020", "title": "Graph4Code: A Machine Interpretable Knowledge Graph for Code", "abstract": "<p>Knowledge graphs have proven extremely useful in powering diverse applications in semantic search and natural language understanding. Graph4Code is a knowledge graph about program code that can similarly power diverse applications such as program search, code understanding, refactoring, bug detection, and code automation. The graph uses generic techniques to capture the semantics of Python code: the key nodes in the graph are classes, functions and methods in popular Python modules. Edges indicate function usage (e.g., how data flows through function calls, as derived from program analysis of real code), and documentation about functions (e.g., code documentation, usage documentation, or forum discussions such as StackOverflow). We make extensive use of named graphs in RDF to make the knowledge graph extensible by the community. We describe a set of generic extraction techniques that we applied to over 1.3M Python files drawn from GitHub, over 2,300 Python modules, as well as 47M forum posts to generate a graph with over 2 billion triples. We also provide a number of initial use cases of the knowledge graph in code assistance, enforcing best practices, debugging and type inference. The graph and all its artifacts are available to the community for use.</p>\n", "tags": ["dataset"], "tsne_embedding": [-8.24397087097168, 11.31399917602539]}, {"key": "agashe2019julce", "year": "2019", "title": "JuICe: A Large Scale Distantly Supervised Dataset for Open Domain Context-based Code Generation", "abstract": "<p>Interactive programming with interleaved code snippet cells and natural language markdown is recently gaining popularity in the form of Jupyter notebooks, which accelerate prototyping and collaboration. To study code generation conditioned on a long context history, we present JuICe, a corpus of 1.5 million examples with a curated test set of 3.7K instances based on online programming assignments. Compared with existing contextual code generation datasets, JuICe provides refined human-curated data, open-domain code, and an order of magnitude more training data. Using JuICe, we train models for two tasks: (1) generation of the API call sequence in a code cell, and (2) full code cell generation, both conditioned on the NL-Code history up to a particular code cell. Experiments using current baseline code generation models show that both context and distant supervision aid in generation, and that the dataset is challenging for current systems.</p>\n", "tags": ["dataset", "bimodal"], "tsne_embedding": [13.988862991333008, 3.2904765605926514]}, {"key": "aggarwal2015using", "year": "2015", "title": "Using Machine Translation for Converting Python 2 to Python 3 Code", "abstract": "<p>In this paper, we have tried to use Statistical machine translation in order to convert Python 2 code to Python 3 code. We use data from two projects and achieve a high BLEU score. We also investigate the cross-project training and testing to analyze the errors so as to ascertain differences with previous case. We have described a pilot study on modeling programming languages as natural language to build translation models on the lines of natural languages. This can be further worked on to translate between versions of a programming language or cross-programming-languages code translation.</p>\n", "tags": ["migration"], "tsne_embedding": [10.965917587280273, 3.6188361644744873]}, {"key": "ahmad2020transformer", "year": "2020", "title": "A Transformer-based Approach for Source Code Summarization", "abstract": "<p>Generating a readable summary that describes the functionality of a program is known as source code summarization. In this task, learning code representation by modeling the pairwise relationship between code tokens to capture their long-range dependencies is crucial. To learn code representation for summarization, we explore the Transformer model that uses a self-attention mechanism and has shown to be effective in capturing long-range dependencies. In this work, we show that despite the approach is simple, it outperforms the state-of-the-art techniques by a significant margin. We perform extensive analysis and ablation studies that reveal several important findings, e.g., the absolute encoding of source code tokens\u2019 position hinders, while relative encoding significantly improves the summarization performance. We have made our code publicly available to facilitate future research.</p>\n", "tags": ["summarization"], "tsne_embedding": [5.653352737426758, -7.422213077545166]}, {"key": "ahmad2021unified", "year": "2021", "title": "Unified Pre-training for Program Understanding and Generation", "abstract": "<p>Code summarization and generation empower conversion between programming language (PL) and natural language (NL), while code translation avails the migration of legacy code from one PL to another. This paper introduces PLBART, a sequence-to-sequence model capable of performing a broad spectrum of program and language understanding and generation tasks. PLBART is pre-trained on an extensive collection of Java and Python functions and associated NL text via denoising autoencoding. Experiments on language generation tasks, including code summarization, generation, translation in seven programming languages show that PLBART outperforms or rivals state-of-the-art models. Moreover, experiments on discriminative tasks, e.g., program repair, clone detection, and vulnerable code detection demonstrate PLBART\u2019s effectiveness in program understanding. Furthermore, analysis reveals that PLBART learns program syntax, style (e.g., identifier naming convention), logical flow (e.g., if block inside an else block is equivalent to else if block) that are crucial to program semantics and thus excels even with limited annotations.</p>\n", "tags": ["pretraining", "Transformer"], "tsne_embedding": [11.153802871704102, 5.251238822937012]}, {"key": "ahmed2019learning", "year": "2019", "title": "Learning Lenient Parsing & Typing via Indirect Supervision", "abstract": "<p>Both professional coders and teachers frequently deal with imperfect (fragmentary, incomplete, ill-formed) code. Such fragments are common in StackOverflow; students also frequently produce ill-formed code, for which instructors, TAs (or students themselves) must find repairs. In either case, the developer experience could be greatly improved if such code could somehow be parsed &amp; typed; this makes them more amenable to use within IDEs and allows early detection and repair of potential errors. We introduce a lenient parser, which can parse &amp; type fragments, even ones with simple errors. Training a machine learner to leniently parse &amp; type imperfect code requires a large training set of pairs of imperfect code and its repair (and/or type information); such training sets are limited by human effort and curation. In this paper, we present a novel indirectly supervised approach to train a lenient parser, without access to such human-curated training data. We leverage the huge corpus of mostly correct code available on Github, and the massive, efficient learning capacity of Transformer-based NN architectures. Using GitHub data, we first create a large dataset of fragments of code and corresponding tree fragments and type annotations; we then randomly corrupt the input fragments (while requiring correct output) by seeding errors that mimic corruptions found in StackOverflow and student data. Using this data, we train high-capacity transformer models to overcome both fragmentation and corruption. With this novel approach, we can achieve reasonable performance on parsing &amp; typing StackOverflow fragments; we also demonstrate that our approach achieves best-in-class performance on a large dataset of student errors.</p>\n", "tags": ["types"], "tsne_embedding": [-5.303423881530762, -15.691132545471191]}, {"key": "ahmed2022learning", "year": "2022", "title": "Learning code summarization from a small and local dataset", "abstract": "<p>Foundation models (e.g., CodeBERT, GraphCodeBERT, CodeT5) work well for many software engineering tasks. These models are pre-trained (using self-supervision) with billions of code tokens, and then fine-tuned with hundreds of thousands of labeled examples, typically drawn from many projects. However, software phenomena can be very project-specific. Vocabulary, and other phenomena vary substantially with each project. Thus, training on project-specific data, and testing on the same project, is a promising idea. This hypothesis has to be evaluated carefully, e.g., in a time-series setting, to prevent training-test leakage. We compare several models and training approaches, including same-project training, cross-project training, training a model especially designed to be sample efficient (and thus prima facie well-suited for learning in a limited-sample same-project setting) and a maximalist hybrid approach, fine-tuning first on many projects in many languages and then training on the same-project. We find that the maximalist hybrid setting provides consistent, substantial gains over the state-of-the-art, on many different projects in both Java and Python.</p>\n", "tags": ["Transformer", "summarization"], "tsne_embedding": [16.329879760742188, 5.626744270324707]}, {"key": "ahmed2033improving", "year": "2023", "title": "Improving Few-Shot Prompts with Relevant Static Analysis Products", "abstract": "<p>Large Language Models (LLM) are a new class of computation engines, \u201cprogrammed\u201d via prompt engineering. We are still learning how to best \u201cprogram\u201d these LLMs to help developers. We start with the intuition that developers tend to consciously and unconsciously have a collection of semantics facts in mind when working on coding tasks. Mostly these are shallow, simple facts arising from a quick read. For a function, examples of facts might include parameter and local variable names, return expressions, simple pre- and post-conditions, and basic control and data flow, etc.</p>\n\n<p>One might assume that the powerful multi-layer architecture of transformer-style LLMs makes them inherently capable of doing this simple level of \u201ccode analysis\u201d and extracting such information, implicitly, while processing code: but are they, really? If they aren\u2019t, could explicitly adding this information help? Our goal here is to investigate this question, using the code summarization task and evaluate whether automatically augmenting an LLM\u2019s prompt with semantic facts explicitly, actually helps.</p>\n\n<p>Prior work shows that LLM performance on code summarization benefits from few-shot samples drawn either from the same-project or from examples found via information retrieval methods (such as BM25). While summarization performance has steadily increased since the early days, there is still room for improvement: LLM performance on code summarization still lags its performance on natural-language tasks like translation and text summarization.</p>\n\n<p>We find that adding semantic facts actually does help! This approach improves performance in several different settings suggested by prior work, including for two different Large Language Models. In most cases, improvement nears or exceeds 2 BLEU; for the PHP language in the challenging CodeSearchNet dataset, this augmentation actually yields performance surpassing 30 BLEU.</p>\n", "tags": ["summarization", "Transformer"], "tsne_embedding": [6.5484938621521, 3.869236469268799]}, {"key": "alet2021largescale", "year": "2021", "title": "A large-scale benchmark for few-shot program induction and synthesis", "abstract": "<p>A landmark challenge for AI is to learn flexible, powerful representations from small numbers of examples. \nOn an important class of tasks, hypotheses in the form of programs provide extreme generalization capabilities from surprisingly few examples. However, whereas large natural few-shot learning image benchmarks have spurred progress in meta-learning for deep networks, there is no comparably big, natural program-synthesis dataset that can play a similar role. This is because, whereas images are relatively easy to label from internet meta-data or annotated by non-experts, generating meaningful input-output examples for program induction has proven hard to scale. In this work, we propose a new way of leveraging unit tests and natural inputs for small programs as meaningful input-output examples for each sub-program of the overall program. This allows us to create a large-scale naturalistic few-shot program-induction benchmark and propose new challenges in this domain. The evaluation of multiple program induction and synthesis algorithms points to shortcomings of current methods and suggests multiple avenues for future work.</p>\n", "tags": ["dataset", "synthesis"], "tsne_embedding": [16.745216369628906, 17.437206268310547]}, {"key": "allal2022santacoder", "year": "2022", "title": "SantaCoder: don\u2019t reach for the stars!", "abstract": "<p>The BigCode project is an open-scientific collaboration working on the responsible development of large language models for code.1 This tech report describes the progress of the collaboration until December 2022, outlining the current state of the Personally Identifiable Information (PII)\nredaction pipeline, the experiments conducted to de-risk the model architecture, and the experiments investigating better preprocessing methods for the training data. We train 1.1B parameter models on the Java,\nJavaScript, and Python subsets of The Stack (Kocetkov et al., 2022) and\nevaluate the models on MultiPL-E (Cassano et al., 2022), a text2code\nbenchmark available in 18 programming languages. We find that more\naggressive filtering of near-duplicates can further boost performance and,\nsurprisingly, that selecting files from repositories with 5+ GitHub stars\ndeteriorates performance significantly. Our best model outperforms previous open-source multilingual code generation models (InCoder-6.7B and\nCodeGen-Multi-2.7B) in both left-to-right generation and infilling on the\nJava, JavaScript, and Python portions of MultiPL-E, despite being a substantially smaller model. All models are released under an OpenRAIL\nlicense at https://hf.co/bigcode</p>\n", "tags": ["Transformer"], "tsne_embedding": [9.632884979248047, 10.88297176361084]}, {"key": "allamanis2013mining", "year": "2013", "title": "Mining Source Code Repositories at Massive Scale Using Language Modeling ", "abstract": "<p>The tens of thousands of high-quality open source software projects on the Internet raise the exciting possibility of studying software development by finding patterns across truly large source code repositories. This could enable new tools for developing code, encouraging reuse, and navigating large projects. In this paper, we build the first giga-token probabilistic language model of source code, based on 352 million lines of Java. This is 100 times the scale of the pioneering work by Hindle et al. The giga-token model is significantly better at the code suggestion task than previous models. More broadly, our approach provides a new \u201clens\u201d for analyzing software projects, enabling new complexity metrics based on statistical analysis of large corpora. We call these metrics data-driven complexity metrics. We propose new metrics that measure the complexity of a code module and the topical centrality of a module to a software project. In particular, it is possible to distinguish reusable utility classes from classes that are part of a program\u2019s core logic based solely on general information theoretic criteria.</p>\n", "tags": ["language model"], "tsne_embedding": [-5.114915370941162, 10.378588676452637]}, {"key": "allamanis2014learning", "year": "2014", "title": "Learning Natural Coding Conventions", "abstract": "<p>Every programmer has a characteristic style, ranging from preferences\nabout identifier naming to preferences about object relationships and\ndesign patterns. Coding conventions define a consistent syntactic style,\nfostering readability and hence maintainability. When collaborating,\nprogrammers strive to obey a project\u2019s coding conventions. However,\none third of reviews of changes contain feedback about coding conventions,\nindicating that programmers do not always follow them and that project\nmembers care deeply about adherence. Unfortunately, programmers are\noften unaware of coding conventions because inferring them requires a\nglobal view, one that aggregates the many local decisions programmers\nmake and identifies emergent consensus on style. We present Naturalize,\na framework that learns the style of a codebase, and suggests revisions\nto improve stylistic consistency. Naturalize builds on recent work in\napplying statistical natural language processing to source code. We\napply Naturalize to suggest natural identifier names and formatting\nconventions. We present four tools focused on ensuring natural code\nduring development and release management, including code review.\nNaturalize achieves 94% accuracy in its top suggestions for identifier\nnames. We used Naturalize to generate 18 patches for 5 open source\nprojects: 14 were accepted.</p>\n", "tags": ["naming", "language model", "style"], "tsne_embedding": [-19.526411056518555, -19.028533935546875]}, {"key": "allamanis2014mining", "year": "2014", "title": "Mining Idioms from Source Code", "abstract": "<p>We present the first method for automatically mining code idioms from a corpus of previously written, idiomatic software projects. We take the view that a code idiom is a syntactic fragment that recurs across projects and has a single semantic purpose. Idioms may have metavariables, such as the body of a for loop. Modern IDEs commonly provide facilities for manually defining idioms and inserting them on demand, but this does not help programmers to write idiomatic code in languages or using libraries with which they are unfamiliar. We present Haggis, a system for mining code idioms that builds on recent advanced techniques from statistical natural language processing, namely, nonparametric Bayesian probabilistic tree substitution grammars. We apply Haggis to several of the most popular open source projects from GitHub. We present a wide range of evidence that the resulting idioms are semantically meaningful, demonstrating that they do indeed recur across software projects and that they occur more frequently in illustrative code examples collected from a Q&amp;A site. Manual examination of the most common idioms indicate that they describe important program concepts, including object creation, exception handling, and resource management.</p>\n", "tags": ["pattern mining", "grammar", "grammar"], "tsne_embedding": [-5.849415302276611, 11.78262710571289]}, {"key": "allamanis2015bimodal", "year": "2015", "title": "A Bimodal Modelling of Source Code and Natural Language", "abstract": "<p>We consider the problem of building probabilistic models that jointly \nmodel short natural language utterances and source code snippets. The\naim is to bring together recent work on statistical modelling of source\ncode and work on bimodal models of images and natural language. The\nresulting models are useful for a variety of tasks that involve natural\nlanguage and source code. We demonstrate their performance on two\nretrieval tasks: retrieving source code snippets given a natural language\nquery, and retrieving natural language descriptions given a source code\nquery (i.e., source code captioning). Experiments show there to be\npromise in this direction, and that modelling the structure of source\ncode improves performance.</p>\n", "tags": ["search", "grammar", "grammar", "bimodal"], "tsne_embedding": [-18.55028533935547, 1.9757791757583618]}, {"key": "allamanis2015suggesting", "year": "2015", "title": "Suggesting Accurate Method and Class Names", "abstract": "<p>Descriptive names are a vital part of readable, and hence maintainable, code. Recent progress on automatically suggesting names for local variables tantalizes with the prospect of replicating that success with method and class names.  However, suggesting names for methods and classes is much more difficult. This is because good method and class names need to be functionally descriptive, but suggesting such names requires that the model goes beyond local context. We introduce a neural probabilistic language model for source code that is specifically designed for the method naming problem. Our model learns which names are semantically similar by assigning them to locations, called embeddings, in a high-dimensional continuous space, in such a way that names with similar embeddings tend to be used in similar contexts. These embeddings seem to contain semantic information about tokens, even though they are learned only from statistical co-occurrences of tokens.  Furthermore, we introduce a variant of our model\nthat is, to our knowledge, the first that can propose neologisms, names that have not appeared in the training corpus. We obtain state of the art results on the method, class, and even the simpler variable naming tasks. More broadly, the continuous embeddings that are learned by our model have the potential for wide application within software engineering.</p>\n\n", "tags": ["naming"], "tsne_embedding": [-5.07648229598999, 1.2809261083602905]}, {"key": "allamanis2016convolutional", "year": "2016", "title": "A Convolutional Attention Network for Extreme Summarization of Source Code", "abstract": "<p>Attention mechanisms in neural networks have proved useful for problems in which\nthe input and output do not have fixed dimension. Often there exist features that\nare locally translation invariant and would be valuable for directing the model\u2019s attention,\nbut previous attentional architectures are not constructed to learn such features specifically.\nWe introduce an attentional neural network that employs convolution on the input tokens to detect\nlocal time-invariant and long-range topical attention features in a context-dependent way. We\napply this architecture to the problem of extreme summarization of source code snippets into short,\ndescriptive function name-like summaries. Using those features, the model sequentially generates a\nsummary by marginalizing over two attention mechanisms: one that predicts the next summary token based \nn the attention weights of the input tokens and another that is able to copy a code token as-is directly\ninto the summary. We demonstrate our convolutional attention neural network\u2019s performance on 10 popular Java\nprojects showing that it achieves better performance compared to previous attentional mechanisms.</p>\n", "tags": ["naming", "summarization"], "tsne_embedding": [9.995718955993652, -8.935596466064453]}, {"key": "allamanis2017mining", "year": "2017", "title": "Mining Semantic Loop Idioms from Big Code", "abstract": "<p>During maintenance, developers spend a lot of time transforming existing code: refactoring, optimizing, and adding checks to make it more robust. Much of this work is the drudgery of identifying and replacing specific patterns, yet it resists automation, because of meaningful patterns are hard to automatically find. We present a technique for mining loop idioms, surprisingly probable semantic patterns that occur in loops, from big code to find meaningful patterns. First, we show that automatically identifiable patterns exist, in great numbers, with a large scale empirical study of loop over 25 MLOC. We find that loops in this corpus are simple and predictable: 90% of them have fewer than 15LOC and 90% have no nesting and very simple control structure. Encouraged by this result, we coil loops to abstract away syntactic diversity to define information rich loop idioms. We show that only 50 loop idioms cover 50% of the concrete loops. We show how loop idioms can help a tool developers identify and prioritize refactorings. We also show how our framework opens the door to data-driven tool and language design discovering opportunities to introduce new API calls and language constructs: loop idioms show that LINQ would benefit from an Enumerate operator, a result confirmed by the fact that precisely this feature is one of the most requested features on StackOverflow with 197 votes and 95k views.</p>\n", "tags": ["pattern mining", "grammar"], "tsne_embedding": [-6.0912628173828125, 12.592105865478516]}, {"key": "allamanis2017smartpaste", "year": "2017", "title": "SmartPaste: Learning to Adapt Source Code", "abstract": "<p>Deep Neural Networks have been shown to succeed at a range of natural\nlanguage tasks such as machine translation and text summarization.\nWhile tasks on source code (ie, formal languages) have been considered\nrecently, most work in this area does not attempt to capitalize on the\nunique opportunities offered by its known syntax and structure. In this\nwork, we introduce SmartPaste, a first task that requires to use such\ninformation. The task is a variant of the program repair problem that\nrequires to adapt a given (pasted) snippet of code to surrounding,\nexisting source code. As first solutions, we design a set of deep\nneural models that learn to represent the context of each variable\nlocation and variable usage in a data flow-sensitive way. Our\nevaluation suggests that our models can learn to solve the SmartPaste\ntask in many cases, achieving 58.6% accuracy, while learning meaningful\nrepresentation of variable usages.</p>\n", "tags": ["representation", "variable misuse"], "tsne_embedding": [10.327452659606934, -5.767183780670166]}, {"key": "allamanis2018learning", "year": "2018", "title": "Learning to Represent Programs with Graphs", "abstract": "<p>Learning tasks on source code (i.e., formal languages) have been considered recently, but most work has tried to transfer natural language methods and does not capitalize on the unique opportunities offered by code\u2019s known syntax. For example, long-range dependencies induced by using the same variable or function in distant locations are often not considered. We propose to use graphs to represent both the syntactic and semantic structure of code and use graph-based deep learning methods to learn to reason over program structures.</p>\n\n<p>In this work, we present how to construct graphs from source code and how to scale Gated Graph Neural Networks training to such large graphs. We evaluate our method on two tasks: VarNaming, in which a network attempts to predict the name of a variable given its usage, and VarMisuse, in which the network learns to reason about selecting the correct variable that should be used at a given program location. Our comparison to methods that use less structured program representations shows the advantages of modeling known structure, and suggests that our models learn to infer meaningful names and to solve the VarMisuse task in many cases. Additionally, our testing showed that VarMisuse identifies a number of bugs in mature open-source projects.</p>\n", "tags": ["naming", "GNN", "representation", "variable misuse", "defect"], "tsne_embedding": [-6.526073455810547, -7.733102321624756]}, {"key": "allamanis2019adverse", "year": "2019", "title": "The Adverse Effects of Code Duplication in Machine Learning Models of Code", "abstract": "<p>The field of big code relies on mining large corpora of code to perform some learning task. A significant threat to this approach has been recently identified by Lopes et al. (2017) who found a large amount of code duplication on GitHub. However, the impact of code duplication has not been noticed by researchers devising machine learning models for source code. In this article, we study the effect of code duplication to machine learning models showing that reported metrics are sometimes inflated by up to 100% when testing on duplicated code corpora compared to the performance on de-duplicated corpora which more accurately represent how machine learning models of code are used by software engineers. We present an \u201cerrata\u201d for widely used datasets, list best practices for collecting code corpora and evaluating machine learning models on them, and release tools to help the community avoid this problem in future research.</p>\n", "tags": ["dataset", "evaluation"], "tsne_embedding": [-14.017894744873047, -1.17864990234375]}, {"key": "allamanis2020typilus", "year": "2020", "title": "Typilus: Neural Type Hints", "abstract": "<p>Type inference over partial contexts in dynamically typed languages is challenging. In this work, we present a graph neural network model that predicts types by probabilistically reasoning over a program\u2019s structure, names, and patterns. The network uses deep similarity learning to learn a TypeSpace \u2013 a continuous relaxation of the discrete space of types \u2013 and how to embed the type properties of a symbol (i.e. identifier) into it. Importantly, our model can employ one-shot learning to predict an open vocabulary of types, including rare and user-defined ones. We realise our approach in Typilus for Python that combines the TypeSpace with an optional type checker. We show that Typilus accurately predicts types. Typilus confidently predicts types for 70% of all annotatable symbols; when it predicts a type, that type optionally type checks 95% of the time. Typilus can also find incorrect type annotations; two important and popular open source libraries, fairseq and allennlp, accepted our pull requests that fixed the annotation errors Typilus discovered.</p>\n", "tags": ["types", "GNN"], "tsne_embedding": [-4.124502658843994, 25.06646728515625]}, {"key": "allamanis2021self", "year": "2021", "title": "Self-Supervised Bug Detection and Repair", "abstract": "<p>Machine learning-based program analyses have recently shown the promise of integrating formal and probabilistic reasoning towards aiding software development. However, in the absence of large annotated corpora, training these analyses is challenging. Towards addressing this, we present BugLab, an approach for self-supervised learning of bug detection and repair. BugLab co-trains two models: (1) a detector model that learns to detect and repair bugs in code, (2) a selector model that learns to create buggy code for the detector to use as training data. A Python implementation of BugLab improves by up to 30% upon baseline methods on a test dataset of 2374 real-life bugs and finds 19 previously unknown bugs in open-source software.</p>\n", "tags": ["GNN", "Transformer", "defect", "repair"], "tsne_embedding": [-9.249433517456055, -22.4495849609375]}, {"key": "alon2018code2seq", "year": "2019", "title": "code2seq: Generating Sequences from Structured Representations of Code", "abstract": "<p>The ability to generate natural language sequences from source code snippets has a variety of applications such as code summarization, documentation, and retrieval. Sequence-to-sequence (seq2seq) models, adopted from neural machine translation (NMT), have achieved state-of-the-art performance on these tasks by treating source code as a sequence of tokens. We present code2seq: an alternative approach that leverages the syntactic structure of programming languages to better encode source code. Our model represents a code snippet as the set of compositional paths in its abstract syntax tree (AST) and uses attention to select the relevant paths while decoding.</p>\n\n<p>We demonstrate the effectiveness of our approach for two tasks, two programming languages, and four datasets of up to 16M examples. Our model significantly outperforms previous models that were specifically designed for programming languages, as well as general state-of-the-art NMT models. An interactive online demo of our model is available at http://code2seq.org.</p>\n", "tags": ["naming", "summarization", "representation"], "tsne_embedding": [9.4737548828125, -6.865270614624023]}, {"key": "alon2018general", "year": "2018", "title": "A General Path-Based Representation for Predicting Program Properties", "abstract": "<p>Predicting program properties such as names or expression types has a wide range of applications. It can ease the task of programming and increase programmer productivity. A major challenge when learning from programs is how to represent programs in a way that facilitates effective learning. \nWe present a general path-based representation for learning from programs. Our representation is purely syntactic and extracted automatically. The main idea is to represent a program using paths in its abstract syntax tree (AST). This allows a learning model to leverage the structured nature of code rather than treating it as a flat sequence of tokens. \nWe show that this representation is general and can: (i) cover different prediction tasks, (ii) drive different learning algorithms (for both generative and discriminative models), and (iii) work across different programming languages. \nWe evaluate our approach on the tasks of predicting variable names, method names, and full types. We use our representation to drive both CRF-based and word2vec-based learning, for programs of four languages: JavaScript, Java, Python and C#. Our evaluation shows that our approach obtains better results than task-specific handcrafted representations across different tasks and programming languages.</p>\n", "tags": ["naming", "representation"], "tsne_embedding": [-3.506366014480591, 16.72275733947754]}, {"key": "alon2019code2vec", "year": "2019", "title": "code2vec: Learning Distributed Representations of Code", "abstract": "<p>We present a neural model for representing snippets of code as continuous distributed vectors (\u201ccode embeddings\u201d).\n The main idea is to represent a code snippet as a single fixed-length\ncode vector, which can be used to\npredict semantic properties of the snippet. To this end, code is first decomposed to a collection of paths in its\nabstract syntax tree. Then, the network learns the atomic representation of each path while\nsimultaneously\nlearning how to aggregate a set of them.</p>\n\n<p>We demonstrate the effectiveness of our approach by using it to predict a method\u2019s name from the vector\nrepresentation of its body. We evaluate our approach by training a model on a dataset of 12M methods. We\nshow that code vectors trained on this dataset can predict method names from files that were unobserved\nduring training. Furthermore, we show that our model learns useful method name vectors that capture\nsemantic similarities, combinations, and analogies.</p>\n\n<p>A comparison of our approach to previous techniques over the same dataset shows an improvement of\nmore than 75%, making it the first to successfully predict method names based on a large, cross-project\ncorpus. Our trained model, visualizations and vector similarities are available as an interactive online demo at\nhttp://code2vec.org. The code, data and trained models are available at\nhttps://github.com/tech-srl/code2vec.</p>\n", "tags": ["naming", "summarization", "representation"], "tsne_embedding": [-6.482593536376953, 1.1690601110458374]}, {"key": "alon2019structural", "year": "2019", "title": "Structural Language Models for Any-Code Generation", "abstract": "<p>We address the problem of Any-Code Generation (AnyGen) - generating code without any restriction on the vocabulary or structure. The state-of-the-art in this problem is the sequence-to-sequence (seq2seq) approach, which treats code as a sequence and does not leverage any structural information. We introduce a new approach to AnyGen that leverages the strict syntax of programming languages to model a code snippet as a tree - structural language modeling (SLM). SLM estimates the probability of the program\u2019s abstract syntax tree (AST) by decomposing it into a product of conditional probabilities over its nodes. We present a neural model that computes these conditional probabilities by considering all AST paths leading to a target node. Unlike previous structural techniques that have severely restricted the kinds of expressions that can be generated, our approach can generate arbitrary expressions in any programming language. Our model significantly outperforms both seq2seq and a variety of existing structured approaches in generating Java and C# code. We make our code, datasets, and models available online.</p>\n", "tags": ["code generation"], "tsne_embedding": [16.945661544799805, -5.0952959060668945]}, {"key": "amodio2017neural", "year": "2017", "title": "Neural Attribute Machines for Program Generation", "abstract": "<p>Recurrent neural networks have achieved remarkable success at generating sequences with complex structures, thanks to advances that include richer embeddings of input and cures for vanishing gradients. Trained only on sequences from a known grammar, though, they can still struggle to learn rules and constraints of the grammar. Neural Attribute Machines (NAMs) are equipped with a logical machine that represents the underlying grammar, which is used to teach the constraints to the neural machine by (i) augmenting the input sequence, and (ii) optimizing a custom loss function. Unlike traditional RNNs, NAMs are exposed to the grammar, as well as samples from the language of the grammar. During generation, NAMs make significantly fewer violations of the constraints of the underlying grammar than RNNs trained only on samples from the language of the grammar.</p>\n\n", "tags": ["grammar", "code generation", "representation"], "tsne_embedding": [17.372926712036133, -10.208023071289062]}, {"key": "arakelyan2020towards", "year": "2020", "title": "Towards Learning Representations of Binary Executable Files for Security Tasks", "abstract": "<p>Tackling binary analysis problems has traditionally implied manually defining rules and heuristics. As an alternative, we are suggesting using machine learning models for learning distributed representations of binaries that can be applicable for a number of downstream tasks. We construct a computational graph from the binary executable and use it with a graph convolutional neural network to learn a high dimensional representation of the program. We show the versatility of this approach by using our representations to solve two semantically different binary analysis tasks \u2013 algorithm classification and vulnerability discovery. We compare the proposed approach to our own strong baseline as well as published results and demonstrate improvement on the state of the art methods for both tasks.</p>\n", "tags": ["GNN", "representation"], "tsne_embedding": [-16.450105667114258, -8.991332054138184]}, {"key": "ashwath2020predicting", "year": "2020", "title": "Predicting Vulnerability in Large Codebases With Deep Code Representation", "abstract": "<p>Currently, while software engineers write code for various modules, quite often, various types of errors - coding, logic, semantic, and others (most of which are not caught by compilation and other tools) get introduced. Some of these bugs might be found in the later stage of testing, and many times it is reported by customers on production code. Companies have to spend many resources, both money and time in finding and fixing the bugs which would have been avoided if coding was done right. Also, concealed flaws in software can lead to security vulnerabilities that potentially allow attackers to compromise systems and applications. Interestingly, same or similar issues/bugs, which were fixed in the past (although in different modules), tend to get introduced in production code again.\nWe developed a novel AI-based system which uses the deep representation of Abstract Syntax Tree (AST) created from the source code and also the active feedback loop to identify and alert the potential bugs that could be caused at the time of development itself i.e. as the developer is writing new code (logic and/or function). This tool integrated with IDE as a plugin would work in the background, point out existing similar functions/code-segments and any associated bugs in those functions. The tool would enable the developer to incorporate suggestions right at the time of development, rather than waiting for UT/QA/customer to raise a defect.\nWe assessed our tool on both open-source code and also on Cisco codebase for C and C++ programing language. Our results confirm that deep representation of source code and the active feedback loop is an assuring approach for predicting security and other vulnerabilities present in the code.</p>\n", "tags": ["grammar", "program analysis", "static analysis"], "tsne_embedding": [-11.999220848083496, -11.245452880859375]}, {"key": "aye2020learning", "year": "2020", "title": "Learning Autocompletion from Real-World Datasets", "abstract": "<p>Code completion is a popular software development tool integrated into all major IDEs. Many neural language models have achieved promising results in completion suggestion prediction on synthetic benchmarks. However, a recent study When Code Completion Fails: a Case Study on Real-World Completions demonstrates that these results may not translate to improvements in real-world performance. To combat this effect, we train models on real-world code completion examples and find that these models outperform models trained on committed source code and working version snapshots by 12.8% and 13.8% accuracy respectively. We observe this improvement across modeling technologies and show through A/B testing that it corresponds to a 6.2% increase in programmers\u2019 actual autocompletion usage. Furthermore, our study characterizes a large corpus of logged autocompletion usages to investigate why training on real-world examples leads to stronger models.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [5.247249126434326, 12.485578536987305]}, {"key": "aye2020sequence", "year": "2020", "title": "Sequence Model Design for Code Completion in the Modern IDE", "abstract": "<p>Code completion plays a prominent role in modern integrated development environments (IDEs). Machine learning has become ubiquitous in analogous natural language writing and search software, surfacing more relevant autocompletions and search suggestions in fewer keystrokes. Prior research has reported training high-accuracy, deep neural networks for modeling source code, but little attention has been given to the practical constraints imposed by interactive developer tools. In particular, neural language models for source code modeling like the one described in Maybe Deep Neural Networks are the Best Choice for Modeling Source Code are framed around code completion, but only report accuracy of next-token prediction. However, in order for a language model (LM) to work well within real-world code completion systems, it must also always make suggestions that produce valid code that typechecks to support code completion\u2019s role in correctness-checking; return instantaneous results to help programmers code more efficiently in fewer keystrokes; and be small enough to fit comfortably on disk and in memory on developer workstations, since virtually all modern IDEs run locally and support offline usage. To meet these additional requirements, we propose a novel design for predicting top-k next tokens that combines static analysis\u2019 ability to enumerate all valid keywords and in-scope identifiers with the ability of a language model to place a probability distribution over them. Our model mixes character-level input representation with token output to represent out-of-vocabulary (OOV) tokens meaningfully and minimize prediction latency. OOV tokens can be predicted through detection of local repetition common in software. This design achieves state-of-art accuracy in source code modeling and fits the constraints imposed by real-world code completion implementations in modern IDEs.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [3.6241273880004883, 9.500320434570312]}, {"key": "bai2021jointly", "year": "2021", "title": "Jointly Learning to Repair Code and Generate Commit Message", "abstract": "<p>We propose a novel task of jointly repairing program codes and generating commit messages. Code repair and commit message generation are two essential and related tasks for software development. However, existing work usually performs the two tasks independently. We construct a multilingual triple dataset including buggy code, fixed code, and commit messages for this novel task. We provide the cascaded models as baseline, which are enhanced with different training approaches, including the teacher-student method, the multi-task method, and the back-translation method. To deal with the error propagation problem of the cascaded method, the joint model is proposed that can both repair the code and generate the commit message in a unified framework. Experimental results show that the enhanced cascaded model with teacher-student method and multitask-learning method achieves the best score on different metrics of automated code repair, and the joint model behaves better than the cascaded model on commit message generation.</p>\n", "tags": ["edit", "Transformer"], "tsne_embedding": [-3.0408079624176025, -21.072673797607422]}, {"key": "bareiss2022code", "year": "2022", "title": "Code Generation Tools (Almost) for Free? A Study of Few-Shot, Pre-Trained Language Models on Code", "abstract": "<p>Few-shot learning with large-scale, pre-trained language models is a powerful way to answer questions about code, e.g., how to complete a given code example, or even generate code snippets from scratch. The success of these models raises the question whether they could serve as a basis for building a wide range code generation tools. Traditionally, such tools are built manually and separately for each task. Instead, few-shot learning may allow to obtain different tools from a single pre-trained language model by simply providing a few examples or a natural language description of the expected tool behavior. This paper studies to what extent a state-of-the-art, pre-trained language model of code, Codex, may serve this purpose. We consider three code manipulation and code generation tasks targeted by a range of traditional tools: (i) code mutation; (ii) test oracle generation from natural language documentation; and (iii) test case generation. For each task, we compare few-shot learning to a manually built tool. Our results show that the model-based tools complement (code mutation), are on par (test oracle generation), or even outperform their respective traditionally built tool (test case generation), while imposing far less effort to develop them. By comparing the effectiveness of different variants of the model-based tools, we provide insights on how to design an appropriate input (\u201cprompt\u201d) to the model and what influence the size of the model has. For example, we find that providing a small natural language description of the code generation task is an easy way to improve predictions. Overall, we conclude that few-shot language models are surprisingly effective, yet there is still more work to be done, such as exploring more diverse ways of prompting and tackling even more involved tasks.</p>\n", "tags": ["Transformer"], "tsne_embedding": [14.237060546875, 9.1867036819458]}, {"key": "barke2022grounded", "year": "2022", "title": "Grounded Copilot: How Programmers Interact with Code-Generating Models", "abstract": "<p>Powered by recent advances in code-generating models, AI assistants like Github Copilot promise to change the face of programming forever. But what is this new face of programming? We present the first grounded theory analysis of how programmers interact with Copilot, based on observing 20 participants\u2013with a range of prior experience using the assistant\u2013as they solve diverse programming tasks across four languages. Our main finding is that interactions with programming assistants are bimodal: in acceleration mode, the programmer knows what to do next and uses Copilot to get there faster; in exploration mode, the programmer is unsure how to proceed and uses Copilot to explore their options. Based on our theory, we provide recommendations for improving the usability of future AI programming assistants.</p>\n", "tags": ["human evaluation", "synthesis"], "tsne_embedding": [19.178878784179688, 11.428035736083984]}, {"key": "barone2017parallel", "year": "2017", "title": "A parallel corpus of Python functions and documentation strings for automated code documentation and code generation", "abstract": "<p>Automated documentation of programming source code and automated code generation from natural language are challenging tasks of both practical and scientific interest. Progress in these areas has been limited by the low availability of parallel corpora of code and natural language descriptions, which tend to be small and constrained to specific domains.</p>\n\n<p>In this work we introduce a large and diverse parallel corpus of a hundred thousands Python functions with their documentation strings (\u201cdocstrings\u201d) generated by scraping open source repositories on GitHub. We describe baseline results for the code documentation and code generation tasks obtained by neural machine translation. We also experiment with \ndata augmentation techniques to further increase the amount of training data.</p>\n\n<p>We release our datasets and processing scripts in order to stimulate research in these areas.</p>\n\n", "tags": ["documentation", "summarization", "dataset"], "tsne_embedding": [13.303842544555664, 1.5196739435195923]}, {"key": "bavarian2022efficient", "year": "2022", "title": "Efficient Training of Language Models to Fill in the Middle", "abstract": "<p>We show that autoregressive language models can learn to infill text after we apply a straightforward transformation to the dataset, which simply moves a span of text from the middle of a document to its end. While this data augmentation has garnered much interest in recent years, we provide extensive evidence that training models with a large fraction of data transformed in this way does not harm the original left-to-right generative capability, as measured by perplexity and sampling evaluations across a wide range of scales. Given the usefulness, simplicity, and efficiency of training models to fill-in-the-middle (FIM), we suggest that future autoregressive language models be trained with FIM by default. To this end, we run a series of ablations on key hyperparameters, such as the data transformation frequency, the structure of the transformation, and the method of selecting the infill span. We use these ablations to prescribe strong default settings and best practices to train FIM models. We have released our best infilling model trained with best practices in our API, and release our infilling benchmarks to aid future research.</p>\n", "tags": ["Transformer", "language model"], "tsne_embedding": [9.94312858581543, -1.7411004304885864]}, {"key": "bavishi2017context2name", "year": "2017", "title": "Context2Name: A Deep Learning-Based Approach to Infer Natural Variable Names from Usage Contexts", "abstract": "<p>Most of the JavaScript code deployed in the wild has been minified, a process in which identifier names are replaced\nwith short, arbitrary and meaningless names. Minified code occupies less space, but also makes the code extremely difficult to manually inspect and understand. This paper presents Context2Name, a deep learning-based technique that partially reverses the effect of minification by predicting natural\nidentifier names for minified names. The core idea is to predict from the usage context of a variable a name that captures\nthe meaning of the variable. The approach combines a lightweight, token-based static analysis with an auto-encoder\nneural network that summarizes usage contexts and a recurrent neural network that predict natural names for a given\nusage context. We evaluate Context2Name\nwith a large corpus of real-world JavaScript code and show that it successfully predicts 60.4% of all minified identifiers. A comparison\nwith the state-of-the-art tools JSNice and JSNaughty shows\nthat our approach predicts 17% and 43% more names than the\nbest existing approaches, while taking only 2.6 milliseconds\nto predict a name, on average.</p>\n", "tags": ["naming"], "tsne_embedding": [-17.185691833496094, 19.144168853759766]}, {"key": "bavishi2019autopandas", "year": "2019", "title": "AutoPandas: neural-backed generators for program synthesis", "abstract": "<p>Developers nowadays have to contend with a growing number of APIs. While in the long-term they are very useful to developers, many modern APIs have an incredibly steep learning curve, due to their hundreds of functions handling many arguments, obscure documentation, and frequently changing semantics. For APIs that perform data transformations, novices can often provide an I/O example demonstrating the desired transformation, but may be stuck on how to translate it to the API. A programming-by-example synthesis engine that takes such I/O examples and directly produces programs in the target API could help such novices. Such an engine presents unique challenges due to the breadth of real-world APIs, and the often-complex constraints over function arguments. We present a generator-based synthesis approach to contend with these problems. This approach uses a program candidate generator, which encodes basic constraints on the space of programs. We introduce neural-backed operators which can be seamlessly integrated into the program generator. To improve the efficiency of the search, we simply use these operators at non-deterministic decision points, instead of relying on domain-specific heuristics. We implement this technique for the Python pandas library in AutoPandas. AutoPandas supports 119 pandas dataframe transformation functions. We evaluate AutoPandas on 26 real-world benchmarks and find it solves 17 of them.</p>\n", "tags": ["synthesis", "GNN", "API"], "tsne_embedding": [14.158720016479492, 13.803019523620605]}, {"key": "beltramelli2017pix2code", "year": "2017", "title": "pix2code: Generating Code from a Graphical User Interface Screenshot", "abstract": "<p>Transforming a graphical user interface screenshot created by a designer into computer code is a typical task conducted by a developer in order to build customized software, websites and mobile applications. In this paper, we show that Deep Learning techniques can be leveraged to automatically generate code given a graphical user interface screenshot as input. Our model is able to generate code targeting three different platforms (i.e. iOS, Android and web-based technologies) from a single input image with over 77% of accuracy.</p>\n\n", "tags": ["code generation", "bimodal"], "tsne_embedding": [18.374723434448242, 15.853754043579102]}, {"key": "bennun2018neural", "year": "2018", "title": "Neural Code Comprehension: A Learnable Representation of Code Semantics", "abstract": "<p>With the recent success of embeddings in natural language processing, research has been conducted into applying similar methods to code analysis. Most works attempt to process the code directly or use a syntactic tree representation, treating it like sentences written in a natural language. However, none of the existing methods are sufficient to comprehend program semantics robustly, due to structural features such as function calls, branching, and interchangeable order of statements. In this paper, we propose a novel processing technique to learn code semantics, and apply it to a variety of program analysis tasks. In particular, we stipulate that a robust distributional hypothesis of code applies to both human- and machine-generated programs. Following this hypothesis, we define an embedding space, inst2vec, based on an Intermediate Representation (IR) of the code that is independent of the source programming language. We provide a novel definition of contextual flow for this IR, leveraging both the underlying data- and control-flow of the program. We then analyze the embeddings qualitatively using analogies and clustering, and evaluate the learned representation on three different high-level tasks. We show that with a single RNN architecture and pre-trained fixed embeddings, inst2vec outperforms specialized approaches for performance prediction (compute device mapping, optimal thread coarsening); and algorithm classification from raw code (104 classes), where we set a new state-of-the-art.</p>\n", "tags": ["representation"], "tsne_embedding": [-4.161384105682373, -2.2002298831939697]}, {"key": "berabi2021tfix", "year": "2021", "title": "TFix: Learning to Fix Coding Errors with a Text-to-Text Transformer", "abstract": "<p>The problem of fixing errors in programs has attracted substantial interest over the years. The\nkey challenge for building an effective code fixing tool is to capture a wide range of errors and\nmeanwhile maintain high accuracy. In this paper, we address this challenge and present a new\nlearning-based system, called TFix. TFix works\ndirectly on program text and phrases the problem of code fixing as a text-to-text task. In turn,\nthis enables it to leverage a powerful Transformer\nbased model pre-trained on natural language and\nfine-tuned to generate code fixes (via a large, high-quality dataset obtained from GitHub commits).\nTFix is not specific to a particular programming\nlanguage or class of defects and, in fact, improved\nits precision by simultaneously fine-tuning on 52\ndifferent error types reported by a popular static\nanalyzer. Our evaluation on a massive dataset of\nJavaScript programs shows that TFix is practically\neffective: it is able to synthesize code that fixes\nthe error in \u223c67 percent of cases and significantly\noutperforms existing learning-based approaches.</p>\n", "tags": ["repair"], "tsne_embedding": [-6.791419506072998, -16.442243576049805]}, {"key": "bhatia2016automated", "year": "2016", "title": "Automated Correction for Syntax Errors in Programming Assignments using Recurrent Neural Networks", "abstract": "<p>We present a method for automatically generating repair feedback for syntax errors for introductory programming problems. Syntax errors constitute one of the largest classes of errors (34%) in our dataset of student submissions obtained from a MOOC course on edX. The previous techniques for generating automated feedback on programming assignments have focused on functional correctness and style considerations of student programs. These techniques analyze the program AST of the program and then perform some dynamic and symbolic analyses to compute repair feedback. Unfortunately, it is not possible to generate ASTs for student programs with syntax errors and therefore the previous feedback techniques are not applicable in repairing syntax errors. We present a technique for providing feedback on syntax errors that uses Recurrent neural networks (RNNs) to model syntactically valid token sequences. Our approach is inspired from the recent work on learning language models from Big Code (large code corpus). For a given programming assignment, we first learn an RNN to model all valid token sequences using the set of syntactically correct student submissions. Then, for a student submission with\nsyntax errors, we query the learnt RNN model with the prefix token sequence to predict token sequences that can fix the error by either replacing or inserting the predicted token sequence at the error location. We evaluate our technique on over 14, 000 student submissions with syntax errors. Our technique can completely repair 31.69% (4501/14203) of submissions with syntax errors and in addition partially correct 6.39% (908/14203) of the submissions.</p>\n", "tags": ["repair"], "tsne_embedding": [-3.8180558681488037, -24.787765502929688]}, {"key": "bhatia2018neurosymbolic", "year": "2018", "title": "Neuro-symbolic program corrector for introductory programming assignments", "abstract": "<p>Automatic correction of programs is a challenging problem with numerous real world applications in security, verification, and education. One application that is becoming increasingly important is the correction of student submissions in online courses for providing feedback. Most existing program repair techniques analyze Abstract Syntax Trees (ASTs) of programs, which are unfortunately unavailable for programs with syntax errors. In this paper, we propose a novel Neuro-symbolic approach that combines neural networks with constraint-based reasoning. Specifically, our method first uses a Recurrent Neural Network (RNN) to perform syntax repairs for the buggy programs; subsequently, the resulting syntactically-fixed programs are repaired using constraint-based techniques to ensure functional correctness. The RNNs are trained using a corpus of syntactically correct submissions for a given programming assignment, and are then queried to fix syntax errors in an incorrect programming submission by replacing or inserting the predicted tokens at the error location. We evaluate our technique on a dataset comprising of over 14,500 student submissions with syntax errors. Our method is able to repair syntax errors in 60% (8689) of submissions, and finds functionally correct repairs for 23.8% (3455) submissions.</p>\n", "tags": ["repair"], "tsne_embedding": [-3.9109089374542236, -24.809425354003906]}, {"key": "bhoopchand2016learning", "year": "2016", "title": "Learning Python Code Suggestion with a Sparse Pointer Network", "abstract": "<p>To enhance developer productivity, all modern integrated development environments (IDEs) include code suggestion functionality that proposes likely next tokens at the cursor. While current IDEs work well for statically-typed languages, their reliance on type annotations means that they do not provide the same level of support for dynamic programming languages as for statically-typed languages. Moreover, suggestion engines in modern IDEs do not propose expressions or multi-statement idiomatic code. Recent work has shown that language models can improve code suggestion systems by learning from software repositories. This paper introduces a neural language model with a sparse pointer network aimed at capturing very long-range dependencies. We release a large-scale code suggestion corpus of 41M lines of Python code crawled from GitHub. On this corpus, we found standard neural language models to perform well at suggesting local phenomena, but struggle to refer to identifiers that are introduced many tokens in the past. By augmenting a neural language model with a pointer network specialized in referring to predefined classes of identifiers, we obtain a much lower perplexity and a 5 percentage points increase in accuracy for code suggestion compared to an LSTM baseline. In fact, this increase in code suggestion accuracy is due to a 13 times more accurate prediction of identifiers. Furthermore, a qualitative analysis shows this model indeed captures interesting long-range dependencies, like referring to a class member defined over 60 tokens in the past.</p>\n", "tags": ["language model", "autocomplete"], "tsne_embedding": [3.5242087841033936, 7.45303201675415]}, {"key": "bian2020sinkfinder", "year": "2020", "title": "SinkFinder: harvesting hundreds of unknown interesting function pairs with just one seed", "abstract": "<p>Mastering the knowledge about security-sensitive functions that can potentially result in bugs is valuable to detect them. However, identifying this kind of functions is not a trivial task. Introducing machine learning-based techniques to do the task is a natural choice. Unfortunately, the approach also requires considerable prior knowledge, e.g., sufficient labelled training samples. In practice, the requirement is often hard to meet.</p>\n\n<p>In this paper, to solve the problem, we propose a novel and practical method called SinkFinder to automatically discover function pairs that we are interested in, which only requires very limited prior knowledge. SinkFinder first takes just one pair of well-known interesting functions as the initial seed to infer enough positive and negative training samples by means of sub-word word embedding. By using these samples, a support vector machine classifier is trained to identify more interesting function pairs. Finally, checkers equipped with the obtained knowledge can be easily developed to detect bugs in target systems. The experiments demonstrate that SinkFinder can successfully discover hundreds of interesting functions and detect dozens of previously unknown bugs from large-scale systems, such as Linux, OpenSSL and PostgreSQL.</p>\n", "tags": ["program analysis"], "tsne_embedding": [-14.687337875366211, -13.71343994140625]}, {"key": "bibaev2022all", "year": "2022", "title": "All You Need Is Logs: Improving Code Completion by Learning from Anonymous IDE Usage Logs", "abstract": "<p>We propose an approach for collecting completion usage logs from the users in an IDE and using them to train a machine learning based model for ranking completion candidates.\nWe developed a set of features that describe completion candidates and their context, and deployed their anonymized collection in the Early Access Program of IntelliJ-based IDEs.\nWe used the logs to collect a dataset of code completions from users, and employed it to train a ranking CatBoost model.\nThen, we evaluated it in two settings: on a held-out set of the collected completions and in a separate A/B test on two different groups of users in the IDE.\nOur evaluation shows that using a simple ranking model trained on the past user behavior logs significantly improved code completion experience.\nCompared to the default heuristics-based ranking, our model demonstrated a decrease in the number of typing actions necessary to perform the completion in the IDE from 2.073 to 1.832.\nThe approach adheres to privacy requirements and legal constraints, since it does not require collecting personal information, performing all the necessary anonymization on the client\u2019s side.\nImportantly, it can be improved continuously: implementing new features, collecting new data, and evaluating new models - this way, we have been using it in production since the end of 2020.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [2.506526231765747, 14.420841217041016]}, {"key": "bichsel2016statistical", "year": "2016", "title": "Statistical Deobfuscation of Android Applications", "abstract": "<p>This work presents a new approach for deobfuscating Android APKs based on probabilistic learning of large code bases (termed \u201cBig Code\u201d). The key idea is to learn a probabilistic model over thousands of non-obfuscated Android applications and to use this probabilistic model to deobfuscate new, unseen Android APKs. The concrete focus of the paper is on reversing layout obfuscation, a popular transformation which renames key program elements such as classes, packages, and methods, thus making it difficult to understand what the program does. Concretely, the paper: (i) phrases the layout deobfuscation problem of Android APKs as structured prediction in a probabilistic graphical model, (ii) instantiates this model with a rich set of features and constraints that capture the Android setting, ensuring both semantic equivalence and high prediction accuracy, and (iii) shows how to leverage powerful inference and learning algorithms to achieve overall precision and scalability of the probabilistic predictions.</p>\n\n<p>We implemented our approach in a tool called DeGuard and used it to: (i) reverse the layout obfuscation performed by the popular ProGuard system on benign, open-source applications, (ii) predict third-party libraries imported by benign APKs (also obfuscated by ProGuard), and (iii) rename obfuscated program elements of Android malware. The experimental results indicate that DeGuard is practically effective: it recovers 79.1% of the program element names obfuscated with ProGuard, it predicts third-party libraries with accuracy of 91.3%, and it reveals string decoders and classes that handle sensitive data in Android malware.</p>\n\n", "tags": ["deobfuscation", "naming"], "tsne_embedding": [-11.852192878723145, 18.09430694580078]}, {"key": "bieber2020learning", "year": "2020", "title": "Learning to Execute Programs with Instruction Pointer Attention Graph Neural Networks", "abstract": "<p>Graph neural networks (GNNs) have emerged as a powerful tool for learning software engineering tasks including code completion, bug finding, and program repair. They benefit from leveraging program structure like control flow graphs, but they are not well-suited to tasks like program execution that require far more sequential reasoning steps than number of GNN propagation steps. Recurrent neural networks (RNNs), on the other hand, are well-suited to long sequential chains of reasoning, but they do not naturally incorporate program structure and generally perform worse on the above tasks. Our aim is to achieve the best of both worlds, and we do so by introducing a novel GNN architecture, the Instruction Pointer Attention Graph Neural Networks (IPA-GNN), which achieves improved systematic generalization on the task of learning to execute programs using control flow graphs. The model arises by considering RNNs operating on program traces with branch decisions as latent variables. The IPA-GNN can be seen either as a continuous relaxation of the RNN model or as a GNN variant more tailored to execution. To test the models, we propose evaluating systematic generalization on learning to execute using control flow graphs, which tests sequential reasoning and use of program structure. More practically, we evaluate these models on the task of learning to execute partial programs, as might arise if using the model as a heuristic function in program synthesis. Results show that the IPA-GNN outperforms a variety of RNN and GNN baselines on both tasks.</p>\n", "tags": ["representation", "dynamic"], "tsne_embedding": [-3.601217269897461, -9.009220123291016]}, {"key": "bieber2022static", "year": "2022", "title": "Static Prediction of Runtime Errors by Learning to Execute Programs with External Resource Descriptions", "abstract": "<p>The execution behavior of a program often depends on external resources, such as program inputs or file contents, and so cannot be run in isolation. Nevertheless, software developers benefit from fast iteration loops where automated tools identify errors as early as possible, even before programs can be compiled and run. This presents an interesting machine learning challenge: can we predict runtime errors in a \u201cstatic\u201d setting, where program execution is not possible? Here, we introduce a real-world dataset and task for predicting runtime errors, which we show is difficult for generic models like Transformers. We approach this task by developing an interpreter-inspired architecture with an inductive bias towards mimicking program executions, which models exception handling and \u201clearns to execute\u201d descriptions of the contents of external resources. Surprisingly, we show that the model can also predict the location of the error, despite being trained only on labels indicating the presence/absence and kind of error. In total, we present a practical and difficult-yet-approachable challenge problem related to learning program execution and we demonstrate promising new capabilities of interpreter-inspired machine learning models for code.</p>\n", "tags": ["dataset", "defect"], "tsne_embedding": [9.95969295501709, 15.764411926269531]}, {"key": "bielik2016phog", "year": "2016", "title": "PHOG: Probabilistic Model for Code", "abstract": "<p>We introduce a new generative model for code called probabilistic higher order grammar (PHOG). PHOG generalizes probabilistic context free grammars (PCFGs) by allowing conditioning of a production rule beyond the parent non-terminal, thus capturing rich contexts relevant to programs. Even though PHOG is more powerful than a PCFG, it can be learned from data just as efficiently. We trained a PHOG model on a large JavaScript code corpus and show that it is more precise than existing models, while similarly fast. As a result, PHOG can immediately benefit existing programming tools based on probabilistic models of code.</p>\n", "tags": ["grammar", "code generation", "language model"], "tsne_embedding": [17.141061782836914, -5.816046237945557]}, {"key": "bielik2020adversarial", "year": "2020", "title": "Adversarial Robustness for Code", "abstract": "<p>We propose a novel technique which addresses the challenge of learning accurate and robust models of code in a principled way. Our method consists of three key components: (i) learning to abstain from making a prediction if uncertain, (ii) adversarial training, and (iii) representation refinement which learns the program parts relevant for the prediction and abstracts the rest. These components are used to iteratively train multiple models, each of which learns a suitable program representation necessary to make robust predictions on a different subset of the dataset. We instantiated our approach to the task of type inference for dynamically typed languages and demonstrate its effectiveness by learning a model that achieves 88% accuracy and 84% robustness. Further, our evaluation shows that using the combination of all three components is key to obtaining accurate and robust models.</p>\n", "tags": ["adversarial", "types"], "tsne_embedding": [-1.2847709655761719, 23.038127899169922]}, {"key": "bouzenia2023tracefixer", "year": "2023", "title": "TraceFixer: Execution Trace-Driven Program Repair", "abstract": "<p>When debugging unintended program behavior, developers can often identify the point in the execution where the actual behavior diverges from the desired behavior. For example, a variable may get assigned a wrong value, which then negatively influences the remaining computation. Once a developer identifies such a divergence, how to fix the code so that it provides the desired behavior? This paper presents TraceFixer, a technique for predicting how to edit source code so that it does not diverge from the expected behavior anymore. The key idea is to train a neural program repair model that not only learns from source code edits but also exploits excerpts of runtime traces. The input to the model is a partial execution trace of the incorrect code, which can be obtained automatically through code instrumentation, and the correct state that the program should reach at the divergence point, which the user provides, e.g., in an interactive debugger. Our approach fundamentally differs from current program repair techniques, which share a similar goal but exploit neither execution traces nor information about the desired program state. We evaluate TraceFixer on single-line mistakes in Python code. After training the model on hundreds of thousands of code edits created by a neural model that mimics real-world bugs, we find that exploiting execution traces improves the bug-fixing ability by 13% to 20% (depending on the dataset, within the top-10 predictions) compared to a baseline that learns from source code edits only. Applying TraceFixer to 20 real-world Python bugs shows that the approach successfully fixes 10 of them.</p>\n", "tags": ["Transformer", "repair", "dynamic"], "tsne_embedding": [-10.407431602478027, -20.604459762573242]}, {"key": "brauckmann2020compiler", "year": "2020", "title": "Compiler-based graph representations for deep learning models of code", "abstract": "<p>In natural language processing, novel methods in deep learning, like recurrent neural networks (RNNs) on sequences of words, have been very successful. These methods have also been used recently for tasks in compiler optimization, like heterogeneous mapping of OpenCL kernels or predicting thread coarsening factors for optimal execution times. In contrast to natural languages, programming languages usually have a well-defined structure. This structure is what enables compilers to reason about programs on the foundations of graphs, such as abstract syntax trees (ASTs) or control-data flow graphs (CDFGs).\nIn this paper, we argue that we should use these graph structures instead of word sequences for learning compiler optimization tasks. To this end we apply recently proposed graph neural networks (GNNs) for learning predictive compiler tasks on two representations based on ASTs and CDFGs. Experimental results show how these representations improve upon the accuracy of the state-of-the-art in the task of heterogeneous OpenCL mapping, while providing orders of magnitude faster inference times, which are crucial for compiler optimizations. When testing on benchmark suites not included for training, our graph-based methods significantly outperform the state-of-the art by 12 percentage points in terms of accuracy, and are the only ones to perform better than a random mapping. When testing on the task of predicting thread coarsening factors, we expose current limitations of deep learning in compilers. We show how all of the deep learning approaches proposed so far, including our graph-based models, fail to produce an overall speedup with their predictions.</p>\n", "tags": ["representation", "compilation", "optimization", "GNN"], "tsne_embedding": [-3.0127789974212646, -8.132380485534668]}, {"key": "brauckmann2020compy", "year": "2020", "title": "ComPy-Learn: A toolbox for exploring machine learning representations for compilers", "abstract": "<p>Deep Learning methods have not only shown to improve software performance in compiler heuristics, but also e.g. to improve security in vulnerability prediction or to boost developer productivity in software engineering tools. A key to the success of such methods across these use cases is the expressiveness of the representation used to abstract from the program code. Recent work has shown that different such representations have unique advantages in terms of performance. However, determining the best-performing one for a given task is often not obvious and requires empirical evaluation.\nTherefore, we present ComPy-Learn, a toolbox for conveniently defining, extracting, and exploring representations of program code. With syntax-level language information from the Clang compiler frontend and low-level information from the LLVM compiler backend, the tool supports the construction of linear and graph representations and enables an efficient search for the best-performing representation and model for tasks on program code.</p>\n", "tags": ["representation", "compilation", "optimization", "GNN"], "tsne_embedding": [-2.297595262527466, -6.810116767883301]}, {"key": "briem2020offside", "year": "2020", "title": "OffSide: Learning to Identify Mistakes in Boundary Conditions", "abstract": "<p>Mistakes in boundary conditions are the cause of many bugs in software.\nThese mistakes happen when, e.g., developers make use of <code class=\"language-plaintext highlighter-rouge\">&lt;</code> or <code class=\"language-plaintext highlighter-rouge\">&gt;</code> in cases\nwhere they should have used <code class=\"language-plaintext highlighter-rouge\">&lt;=</code> or <code class=\"language-plaintext highlighter-rouge\">&gt;=</code>. Mistakes in boundary conditions\nare often hard to find and manually detecting them might be very time-consuming\nfor developers. While researchers have been proposing techniques to cope with\nmistakes in the boundaries for a long time, the automated detection of such bugs still\nremains a challenge. We conjecture that, for a tool to be able to precisely identify mistakes\nin boundary conditions, it should be able to capture the overall context of the source code\nunder analysis. In this work, we propose a deep learning model that learn mistakes in boundary\nconditions and, later, is able to identifythem in unseen code snippets. We train and test a\nmodel on over 1.5 million code snippets, with and without mistakes in different boundary conditions.\nOur model shows an accuracy from 55% up to 87%. The model is also able to detect 24 out of 41\nreal-world bugs;however, with a high false positive rate. The existing state-of-the-practice linter\ntools are not able to detect any of the bugs. We hope this paper can pave the road towards deep\nlearning models that will be able to support developers in detecting mistakes in boundary conditions.</p>\n", "tags": ["defect"], "tsne_embedding": [-8.169302940368652, -15.267882347106934]}, {"key": "brockschmidt2019generative", "year": "2019", "title": "Generative Code Modeling with Graphs", "abstract": "<p>Generative models forsource code are an interesting structured prediction problem, requiring to reason about both hard syntactic and semantic constraints as well as about natural, likely programs. We present a novel model for this problem that uses a graph to represent the intermediate state of the generated output. Our model generates code by interleaving grammar-driven expansion steps with graph augmentation and neural message passing steps. An experimental evaluation shows that our new model can generate semantically meaningful expressions, outperforming a range of strong baselines.</p>\n", "tags": ["grammar", "code generation", "GNN"], "tsne_embedding": [15.284296035766602, -5.661606311798096]}, {"key": "brody2020structural", "year": "2020", "title": "A Structural Model for Contextual Code Changes", "abstract": "<p>We address the problem of predicting edit completions based on a learned model that was trained on past edits. Given a code snippet that is partially edited, our goal is to predict a completion of the edit for the rest of the snippet. We refer to this task as the EditCompletion task and present a novel approach for tackling it. The main idea is to directly represent structural edits. This allows us to model the likelihood of the edit itself, rather than learning the likelihood of the edited code. We represent an edit operation as a path in the program\u2019s Abstract Syntax Tree (AST), originating from the source of the edit to the target of the edit. Using this representation, we present a powerful and lightweight neural model for the EditCompletion task. We conduct a thorough evaluation, comparing our approach to a variety of representation and modeling approaches that are driven by multiple strong models such as LSTMs, Transformers, and neural CRFs. Our experiments show that our model achieves 28% relative gain over state-of-the-art sequential models and 2\u00d7 higher accuracy than syntactic models that learn to generate the edited code instead of modeling the edits directly. Our code, dataset, and trained models are publicly available at https://github.com/tech-srl/c3po/ .</p>\n", "tags": ["edit", "grammar", "autocomplete"], "tsne_embedding": [5.704249382019043, -15.58992862701416]}, {"key": "bruch2009learning", "year": "2009", "title": "Learning from Examples to Improve Code Completion Systems", "abstract": "<p>The suggestions made by current IDE\u2019s code completion features are based exclusively on static type system of the programming language. As a result, often proposals are made which are irrelevant for a particular working context. Also, these suggestions are ordered alphabetically rather than by their relevance in a particular context. In this paper, we present intelligent code completion systems that learn from existing code repositories. We have implemented three such systems, each using the information contained in\nrepositories in a different way. We perform a large-scale quantitative evaluation of these systems, integrate the best performing one into Eclipse, and evaluate the latter also by a user study. Our experiments give evidence that intelligent code completion systems which learn from examples significantly outperform mainstream code completion systems in terms of the relevance of their suggestions and thus have the potential to enhance developers\u2019 productivity.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [2.161097526550293, 12.45935344696045]}, {"key": "buech2019learning", "year": "2019", "title": "Learning-based Recursive Aggregation of Abstract Syntax Trees for Code Clone Detection", "abstract": "<p>Code clone detection remains a crucial challenge in maintaining software projects. Many classic approaches rely on handcrafted aggregation schemes, while recent work uses supervised or unsupervised learning. In this work, we study several aspects of aggregation schemes for code clone detection based on supervised learning. To this aim, we implement an AST-based Recursive Neural Network. Firstly, our ablation study shows the influence of model choices and hyperparameters. We introduce error scaling as a way to effectively and efficiently address the class imbalance problem arising in code clone detection. Secondly, we study the influence of pretrained embeddings representing nodes in ASTs. We show that simply averaging all node vectors of a given AST yields strong baseline aggregation scheme. Further, learned AST aggregation schemes greatly benefit from pretrained node embeddings. Finally, we show the importance of carefully separating training and test data by clone clusters, to reliably measure generalization of models learned with supervision.</p>\n", "tags": ["grammar", "grammar", "clone"], "tsne_embedding": [-11.669685363769531, -3.155369758605957]}, {"key": "bui2018bilateral", "year": "2018", "title": "Bilateral Dependency Neural Networks for Cross-Language Algorithm Classification", "abstract": "<p>Algorithm  classification  is  to  automatically  identify\nthe  classes  of  a  program  based  on  the  algorithm(s)  and/or  data\nstructure(s)  implemented  in  the  program.  It  can  be  useful  for\nvarious tasks, such as code reuse, code theft detection, and malware detection. Code similarity metrics, on the basis of features\nextracted from syntax and semantics, have been used to classify\nprograms.  Such  features,  however,  often  need  manual  selection\neffort  and  are  specific  to  individual  programming  languages,\nlimiting  the  classifiers  to  programs  in  the  same  language.\nTo recognize the similarities and differences among algorithms\nimplemented   in   different   languages,   this   paper   describes   a\nframework  of  Bilateral  Neural  Networks  (Bi-NN)  that  builds  a\nneural  network  on  top  of  two  underlying  sub-networks,  each  of\nwhich encodes syntax and semantics of code in one language. A\nwhole  Bi-NN  can  be  trained  with  bilateral  programs  that  implement the same algorithms and/or data structures in different\nlanguages  and  then  be  applied  to  recognize  algorithm  classes\nacross  languages.</p>\n\n<p>We  have  instantiated  the  framework  with  several  kinds  of\ntoken-,  tree-  and  graph-based  neural  networks  that  encode  and\nlearn  various  kinds  of  information  in  code.  We  have  applied\nthe  instances  of  the  framework  to  a  code  corpus  collected  from\nGitHub containing thousands of Java and C++ programs imple-\nmenting 50 different algorithms and data structures. Our evalua-\ntion results show that the use of Bi-NN indeed produces promising\nalgorithm  classification  results  both  within  one  language  and\nacross  languages,  and  the  encoding  of  dependencies  from  code\ninto  the  underlying  neural  networks  helps  improve  algorithm\nclassification  accuracy  further.  In  particular,  our  custom-built\ndependency trees with tree-based convolutional neural networks\nachieve  the  highest  classification  accuracy  among  the  different\ninstances  of  the  framework  that  we  have  evaluated.  Our  study\npoints  to  a  possible  future  research  direction  to  tailor  bilateral\nand  multilateral  neural  networks  that  encode  more  relevant\nsemantics  for  code  learning,  mining  and  analysis  tasks</p>\n", "tags": ["representation"], "tsne_embedding": [-11.062864303588867, -6.01593017578125]}, {"key": "bui2018cross", "year": "2018", "title": "Cross-Language Learning for Program Classification using Bilateral Tree-Based Convolutional Neural Networks", "abstract": "<p>Towards the vision of translating code that implements an algorithm from one programming language into another, this\npaper  proposes  an  approach  for  automated  program  classification using\nbilateral tree-based convolutional neural networks\n(BiTBCNNs).  It  is  layered  on  top  of  two  tree-based\nconvolutional neural networks (TBCNNs), each of which recognizes the algorithm of code written in an individual programming language. The combination layer of the networks\nrecognizes the similarities and differences among code in different programming languages. The BiTBCNNs are trained\nusing  the  source  code  in  different  languages  but  known  to\nimplement  the  same  algorithms  and/or  functionalities.  For\na  preliminary  evaluation,  we  use  3591  Java  and  3534  C++\ncode snippets from 6 algorithms we crawled systematically\nfrom GitHub. We obtained over 90% accuracy in the cross-language binary classification task to tell whether any given\ntwo code snippets implement a same algorithm. Also, for the\nalgorithm classification task, i.e., to predict which one of the\nsix algorithm labels is implemented by an arbitrary C++ code\nsnippet, we achieved over 80% precision.</p>\n", "tags": ["representation", "grammar"], "tsne_embedding": [-10.731250762939453, -5.90678071975708]}, {"key": "bui2018hierarchical", "year": "2018", "title": "Hierarchical Learning of Cross-Language Mappings through Distributed Vector Representations for Code", "abstract": "<p>Translating a program written in one programming language to another can be useful for software development tasks that need functionality implementations in different languages. Although past studies have considered this problem, they may be either specific to the language grammars, or specific to certain kinds of code elements (e.g., tokens, phrases, API uses). This paper proposes a new approach to automatically learn cross-language representations for various kinds of structural code elements that may be used for program translation. Our key idea is two folded: First, we normalize and enrich code token streams with additional structural and semantic information, and train cross-language vector representations for the tokens (a.k.a. shared embeddings based on word2vec, a neural-network-based technique for producing word embeddings; Second, hierarchically from bottom up, we construct shared embeddings for code elements of higher levels of granularity (e.g., expressions, statements, methods) from the embeddings for their constituents, and then build mappings among code elements across languages based on similarities among embeddings. \nOur preliminary evaluations on about 40,000 Java and C# source files from 9 software projects show that our approach can automatically learn shared embeddings for various code elements in different languages and identify their cross-language mappings with reasonable Mean Average Precision scores. When compared with an existing tool for mapping library API methods, our approach identifies many more mappings accurately. The mapping results and code can be accessed at this https URL. We believe that our idea for learning cross-language vector representations with code structural information can be a useful step towards automated program translation.</p>\n", "tags": ["representation"], "tsne_embedding": [-7.597141265869141, 5.657055377960205]}, {"key": "bui2019learning", "year": "2019", "title": "SAR: Learning Cross-Language API Mappings with Little Knowledge", "abstract": "<p>To save manual effort, developers often translate programs from one programming language to another, instead of implementing it from scratch. Translating application program interfaces (APIs) used in one language to functionally equivalent ones available in another language is an important aspect of program translation. Existing approaches facilitate the translation by automatically identifying the API mappings across programming languages. However, all these approaches still require large amount of manual effort in preparing parallel program corpora, ranging from pairs of APIs, to manually identified code in different languages that are considered as functionally equivalent. To minimize the manual effort in identifying parallel program corpora and API mappings, this paper aims at an automated approach to map APIs across languages with much less knowledge a priori needed than other existing approaches. The approach is based on an realization of the notion of domain adaption combined with code embedding, which can better align two vector spaces: taking as input large sets of programs, our approach first generates numeric vector representations of the programs, especially the APIs used in each language, and it adapts generative adversarial networks (GAN) to align the vectors from the spaces of two languages. For a better alignment, we initialize the GAN with parameters derived from optional API mapping seeds that can be identified accurately with a simple automatic signature-based matching heuristic. Then the cross-language API mappings can be identified via nearest-neighbors queries in the aligned vector spaces.</p>\n", "tags": ["representation", "API"], "tsne_embedding": [-7.82545280456543, 6.062716960906982]}, {"key": "bui2021efficient", "year": "2021", "title": "Self-Supervised Contrastive Learning for Code Retrieval and Summarization via Semantic-Preserving Transformations", "abstract": "<p>We propose Corder, a self-supervised contrastive learning framework for source code model. Corder is designed to alleviate the need of labeled data for code retrieval and code summarization tasks. The pre-trained model of Corder can be used in two ways: (1) it can produce vector representation of code which can be applied to code retrieval tasks that do not have labeled data; (2) it can be used in a fine-tuning process for tasks that might still require label data such as code summarization. The key innovation is that we train the source code model by asking it to recognize similar and dissimilar code snippets through a contrastive learning objective. To do so, we use a set of semantic-preserving transformation operators to generate code snippets that are syntactically diverse but semantically equivalent. Through extensive experiments, we have shown that the code models pretrained by Corder substantially outperform the other baselines for code-to-code retrieval, text-to-code retrieval, and code-to-text summarization tasks.</p>\n", "tags": ["pretraining", "search"], "tsne_embedding": [4.434858322143555, -5.3677544593811035]}, {"key": "bui2021infercode", "year": "2021", "title": "InferCode: Self-Supervised Learning of Code Representations by Predicting Subtrees", "abstract": "<p>Building deep learning models on source code has found many successful software engineering applications, such as code search, code comment generation, bug detection, code migration, and so on. Current learning techniques, however, have a major drawback that these models are mostly trained on datasets labeled for particular downstream tasks, and code representations may not be suitable for other tasks. While some techniques produce representations from unlabeled code, they are far from satisfactory when applied to downstream tasks. Although certain techniques generate representations from unlabeled code when applied to downstream tasks they are far from satisfactory. This paper proposes InferCode to overcome the limitation by adapting the self-supervised learning mechanism to build source code model. The key novelty lies in training code representations by predicting automatically identified subtrees from the context of the ASTs. Subtrees in ASTs are treated with InferCode as the labels for training code representations without any human labeling effort or the overhead of expensive graph construction, and the trained representations are no longer tied to any specific downstream tasks or code units. We trained an InferCode model instance using the Tree-based CNN as the encoder of a large set of Java code and applied it to downstream unsupervised tasks such as code clustering, code clone detection, cross-language code search or reused under a transfer learning scheme to continue training the model weights for supervised tasks such as code classification and method name prediction. Compared to previous code learning techniques applied to the same downstream tasks, such as Code2Vec, Code2Seq, ASTNN, higher performance results are achieved using our pre-trained InferCode model with a significant margin for most tasks including those involving different programming languages.</p>\n", "tags": ["representation"], "tsne_embedding": [-6.61716365814209, -1.9502599239349365]}, {"key": "cai2020tag", "year": "2020", "title": "TAG : Type Auxiliary Guiding for Code Comment Generation", "abstract": "<p>Existing leading code comment generation approaches with the structure-to-sequence framework ignores the type information of the interpretation of the code, e.g., operator, string, etc. However, introducing the type information into the existing framework is non-trivial due to the hierarchical dependence among the type information. In order to address the issues above, we propose a Type Auxiliary Guiding encoder-decoder framework for the code comment generation task which considers the source code as an N-ary tree with type information associated with each node. Specifically, our framework is featured with a Type-associated Encoder and a Type-restricted Decoder which enables adaptive summarization of the source code. We further propose a hierarchical reinforcement learning method to resolve the training difficulties of our proposed framework. Extensive evaluations demonstrate the state-of-the-art performance of our framework with both the auto-evaluated metrics and case studies.</p>\n", "tags": ["bimodal", "documentation"], "tsne_embedding": [7.323176860809326, -7.216378688812256]}, {"key": "cambronero2019deep", "year": "2019", "title": "When Deep Learning Met Code Search", "abstract": "<p>There have been multiple recent proposals on using deep neural networks for code search using natural language. Common across these proposals is the idea of embedding code and natural language queries, into real vectors and then using vector distance to approximate semantic correlation between code and the query. Multiple approaches exist for learning these embeddings, including unsupervised techniques, which rely only on a corpus of code examples, and supervised techniques, which use an aligned corpus of paired code and natural language descriptions. The goal of this supervision is to produce embeddings that are more similar for a query and the corresponding desired code snippet.</p>\n\n<p>Clearly, there are choices in whether to use supervised techniques at all, and if one does, what sort of network and training to use for supervision. This paper is the first to evaluate these choices systematically. To this end, we assembled implementations of state-of-the-art techniques to run on a common platform, training and evaluation corpora. To explore the design space in network complexity, we also introduced a new design point that is a minimal supervision extension to an existing unsupervised technique.</p>\n\n<p>Our evaluation shows that: 1. adding supervision to an existing unsupervised technique can improve performance, though not necessarily by much; 2. simple networks for supervision can be more effective that more sophisticated sequence-based networks for code search; 3. while it is common to use docstrings to carry out supervision, there is a sizeable gap between the effectiveness of docstrings and a more query-appropriate supervision corpus.</p>\n", "tags": ["search"], "tsne_embedding": [-15.95206069946289, 6.220815658569336]}, {"key": "campbell2014syntax", "year": "2014", "title": "Syntax Errors Just Aren\u2019t Natural: Improving Error Reporting with Language Models", "abstract": "<p>A frustrating aspect of software development is that compiler error messages often fail to locate the actual cause of a syntax error. An errant semicolon or brace can result in\nmany errors reported throughout the file. We seek to find the actual source of these syntax errors by relying on the consistency of software: valid source code is usually repetitive and unsurprising. We exploit this consistency by constructing a simple N-gram language model of lexed source code tokens. We implemented an automatic Java syntax-error locator using the corpus of the project itself and evaluated its performance on mutated source code from several projects. Our tool, trained on the past versions of a project, can effectively augment the syntax error locations produced by the native compiler. Thus we provide a methodology and tool that exploits the naturalness of software source code to detect syntax errors alongside the parser.</p>\n", "tags": ["repair", "language model"], "tsne_embedding": [-4.138998985290527, -14.860897064208984]}, {"key": "cerulo2013hidden", "year": "2013", "title": "A Hidden Markov Model to Detect Coded Information Islands in Free Text", "abstract": "<p>Emails and issue reports capture useful knowledge about development practices, bug fixing, and change activities. Extracting such a content is challenging, due to the mix-up of\nsource code and natural language, unstructured text.</p>\n\n<p>In this paper we introduce an approach, based on Hidden Markov Models (HMMs), to extract coded information islands, such as source code, stack traces, and patches, from free text at a token level of granularity. We train a HMM for each category of information contained in the text, and adopt the Viterbi algorithm to recognize whether the sequence of tokens \u2014 e.g., words, language keywords, numbers, parentheses, punctuation marks, etc. \u2014 observed in a text switches among those HMMs. Although our implementation focuses on extracting source code from emails, the approach could be easily extended to include in principle any text-interleaved language.</p>\n\n<p>We evaluated our approach with respect to the state of art on a set of development emails and bug reports drawn from the software repositories of well known open source systems. Results indicate an accuracy between 82% and 99%, which is in line with existing approaches which, differently from ours, require the manual definition of regular expressions or parsers.</p>\n\n", "tags": ["information extraction"], "tsne_embedding": [-24.085420608520508, 2.5755534172058105]}, {"key": "cerulo2015irish", "year": "2015", "title": "Irish: A Hidden Markov Model to detect coded information islands in free text", "abstract": "<p>Developers\u2019 communication, as contained in emails, issue trackers, and forums, is a precious source of information to support the development process. For example, it can\nbe used to capture knowledge about development practice or about a software project itself. Thus, extracting the content of developers\u2019 communication can be useful to support\nseveral software engineering tasks, such as program comprehension, source code analysis, and software analytics. However, automating the extraction process is challenging, due to the unstructured nature of free text, which mixes different coding languages (e.g., source code, stack dumps, and log traces) with natural language parts.</p>\n\n<p>We conduct an extensive evaluation of Irish (InfoRmation ISlands Hmm), an approach we proposed to extract islands of coded information from free text at token granularity, with respect to the state of art approaches based on island parsing or island parsing combined with machine learners. The evaluation considers a wide set of natural language documents (e.g., textbooks, forum discussions, and development emails) taken from different contexts and encompassing different coding languages. Results indicate an F-measure of Irish between 74% and 99%; this is in line with existing approaches which, differently from Irish, require specific expertise for the definition of regular expressions or grammars.</p>\n\n", "tags": ["information extraction"], "tsne_embedding": [-24.08621597290039, 2.5876152515411377]}, {"key": "chae2016automatically", "year": "2016", "title": "Automatically generating features for learning program analysis heuristics", "abstract": "<p>We present a technique for automatically generating features for data-driven program analyses. Recently data-driven approaches for building a program analysis have been proposed, which mine existing codebases and automatically learn heuristics for finding a cost-effective abstraction for a given analysis task. Such approaches reduce the burden of the analysis designers, but they do not remove it completely; they still leave the highly nontrivial task of designing so called features to the hands of the designers. Our technique automates this feature design process. The idea is to use programs as features after reducing and abstracting them. Our technique goes through selected program-query pairs in codebases, and it reduces and abstracts the program in each pair to a few lines of code, while ensuring that the analysis behaves similarly for the original and the new programs with respect to the query. Each reduced program serves as a boolean feature for program-query pairs. This feature evaluates to true for a given program-query pair when (as a program) it is included in the program part of the pair. We have implemented our approach for three real-world program analyses. Our experimental evaluation shows that these analyses with automatically-generated features perform comparably to those with manually crafted features.</p>\n", "tags": ["representation"], "tsne_embedding": [-7.400017738342285, 17.37325668334961]}, {"key": "chakraborty2018tree2tree", "year": "2018", "title": "CODIT: Code Editing with Tree-Based Neural Machine Translation", "abstract": "<p>The way developers edit day-to-day code tends to be repetitive, often using existing code elements. Many researchers have tried to automate repetitive code changes by learning from specific change templates which are applied to limited scope. The advancement of Neural Machine Translation (NMT) and the availability of vast open-source evolutionary data opens up the possibility of automatically learning those templates from the wild. However, unlike natural languages, for which NMT techniques were originally devised, source code and its changes have certain properties. For instance, compared to natural language, source code vocabulary can be significantly larger. Further, good changes in code do not break its syntactic structure. Thus, deploying state-of-the-art NMT models without adapting the methods to the source code domain yields sub-optimal results. To this end, we propose a novel Tree based NMT system to model source code changes and learn code change patterns from the wild. We realize our model with a change suggestion engine: CODIT and train the model with more than 30k real-world changes and evaluate it on 6k patches. Our evaluation shows the effectiveness of CODIT in learning and suggesting patches.CODIT also shows promise generating bug fix patches.</p>\n", "tags": ["grammar", "grammar", "repair", "code generation"], "tsne_embedding": [0.3965854048728943, -17.837875366210938]}, {"key": "chakraborty2020deep", "year": "2021", "title": "Deep Learning based Vulnerability Detection: Are We There Yet?", "abstract": "<p>Automated detection of software vulnerabilities is a fundamental problem in software security. Existing program analysis techniques either suffer from high false positives or false negatives. Recent progress in Deep Learning (DL) has resulted in a surge of interest in applying DL for automated vulnerability detection. Several recent studies have demonstrated promising results achieving an accuracy of up to 95% at detecting vulnerabilities. In this paper, we ask, \u201chow well do the state-of-the-art DL-based techniques perform in a real-world vulnerability prediction scenario?\u201d. To our surprise, we find that their performance drops by more than 50%. A systematic investigation of what causes such precipitous performance drop reveals that existing DL-based vulnerability prediction approaches suffer from challenges with the training data (e.g., data duplication, unrealistic distribution of vulnerable classes, etc.) and with the model choices (e.g., simple token-based models). As a result, these approaches often do not learn features related to the actual cause of the vulnerabilities. Instead, they learn unrelated artifacts from the dataset (e.g., specific variable/function names, etc.). Leveraging these empirical findings, we demonstrate how a more principled approach to data collection and model design, based on realistic settings of vulnerability prediction, can lead to better solutions. The resulting tools perform significantly better than the studied baseline: up to 33.57% boost in precision and 128.38% boost in recall compared to the best performing model in the literature. Overall, this paper elucidates existing DL-based vulnerability prediction systems\u2019 potential issues and draws a roadmap for future DL-based vulnerability prediction research. In that spirit, we make available all the artifacts supporting our results: https://git.io/Jf6IA</p>\n", "tags": ["defect", "survey"], "tsne_embedding": [-14.949426651000977, -11.069944381713867]}, {"key": "chakraborty2021multimodal", "year": "2021", "title": "On Multi-Modal Learning of Editing Source Code", "abstract": "<p>In recent years, Neural Machine Translator (NMT) has shown promise in automatically editing source code. Typical NMT based code editor only considers the code that needs to be changed as input and suggests developers with a ranked list of patched code to choose from - where the correct one may not always be at the top of the list. While NMT based code editing systems generate a broad spectrum of plausible patches, the correct one depends on the developers\u2019 requirement and often on the context where the patch is applied. Thus, if developers provide some hints, using natural language, or providing patch context, NMT models can benefit from them. As a proof of concept, in this research, we leverage three modalities of information: edit location, edit code context, commit messages (as a proxy of developers\u2019 hint in natural language) to automatically generate edits with NMT models. To that end, we build MODIT, a multi-modal NMT based code editing engine. With in-depth investigation and analysis, we show that developers\u2019 hint as an input modality can narrow the search space for patches and outperform state-of-the-art models to generate correctly patched code in top-1 position.</p>\n", "tags": ["Transformer", "edit"], "tsne_embedding": [0.10225608944892883, -18.47548484802246]}, {"key": "chen2019capturing", "year": "2019", "title": "Capturing source code semantics via tree-based convolution over API-enhanced AST", "abstract": "<p>When deep learning meets big code, a key question is how to efficiently learn a distributed representation for source code that can capture its semantics effectively. We propose to use tree-based convolution over API-enhanced AST. To demonstrate the effectiveness of our approach, we apply it to detect semantic clones\u2014code fragments with similar semantics but dissimilar syntax. Experiment results show that our approach outperforms an existing state-of-the-art approach that uses tree-based LSTM, with an increase of 0.39 and 0.12 in F1-score on OJClone and BigCloneBench respectively. We further propose architectures that incorporate our approach for code search and code summarization.</p>\n", "tags": ["grammar", "representation"], "tsne_embedding": [-10.9555082321167, -2.3257877826690674]}, {"key": "chen2019literature", "year": "2019", "title": "A Literature Study of Embeddings on Source Code", "abstract": "<p>Natural language processing has improved tremendously after the success of word embedding techniques such as word2vec. Recently, the same idea has been applied on source code with encouraging results. In this survey, we aim to collect and discuss the usage of word embedding techniques on programs and source code. The articles in this survey have been collected by asking authors of related work and with an extensive search on Google Scholar. Each article is categorized into five categories: 1. embedding of tokens 2. embedding of functions or methods 3. embedding of sequences or sets of method calls 4. embedding of binary code 5. other embeddings. We also provide links to experimental data and show some remarkable visualization of code embeddings. In summary, word embedding has been successfully applied on different granularities of source code. With access to countless open-source repositories, we see a great potential of applying other data-driven natural language processing techniques on source code in the future.</p>\n", "tags": ["representation"], "tsne_embedding": [-8.428256034851074, 2.8105554580688477]}, {"key": "chen2019mining", "year": "2019", "title": "Mining Likely Analogical APIs across Third-Party Libraries via Large-Scale Unsupervised API Semantics Embedding", "abstract": "<p>Establishing API mappings between third-party libraries is a prerequisite step for library migration tasks. Manually establishing API mappings is tedious due to the large number of APIs to be examined. Having an automatic technique to create a database of likely API mappings can significantly ease the task. Unfortunately, existing techniques either adopt supervised learning mechanism that requires already-ported or functionality similar applications across major programming languages or platforms, which are difficult to come by for an arbitrary pair of third-party libraries, or cannot deal with lexical gap in the API descriptions of different libraries. To overcome these limitations, we present an unsupervised deep learning based approach to embed both API usage semantics and API description (name and document) semantics into vector space for inferring likely analogical API mappings between libraries. Based on deep learning models trained using tens of millions of API call sequences, method names and comments of 2.8 millions of methods from 135,127 GitHub projects, our approach significantly outperforms other deep learning or traditional information retrieval (IR) methods for inferring likely analogical APIs. We implement a proof-of-concept website which can recommend analogical APIs for 583,501 APIs of 111 pairs of analogical Java libraries with diverse functionalities. This scale of third-party analogical-API database has never been achieved before.</p>\n", "tags": ["API", "representation"], "tsne_embedding": [-9.074019432067871, 5.315155029296875]}, {"key": "chen2019sequencer", "year": "2019", "title": "SequenceR: Sequence-to-Sequence Learning for End-to-End Program Repair", "abstract": "<p>This paper presents a novel end-to-end approach to program repair based on sequence-to-sequence learning. We devise, implement, and evaluate a system, called SequenceR, for fixing bugs based on sequence-to-sequence learning on source code. This approach uses the copy mechanism to overcome the unlimited vocabulary problem that occurs with big code. Our system is data-driven; we train it on 35,578 commits, carefully curated from open-source repositories. We evaluate it on 4,711 independent real bug fixes, as well on the Defects4J benchmark used in program repair research. SequenceR is able to perfectly predict the fixed line for 950/4711 testing samples. It captures a wide range of repair operators without any domain-specific top-down design.</p>\n", "tags": ["repair", "code generation"], "tsne_embedding": [-7.17805290222168, -20.68086814880371]}, {"key": "chen2021evaluating", "year": "2021", "title": "Evaluating Large Language Models Trained on Code", "abstract": "<p>We introduce Codex, a GPT language model fine-tuned on publicly available code from GitHub, and study its Python code-writing capabilities. A distinct production version of Codex powers GitHub Copilot. On HumanEval, a new evaluation set we release to measure functional correctness for synthesizing programs from docstrings, our model solves 28.8% of the problems, while GPT-3 solves 0% and GPT-J solves 11.4%. Furthermore, we find that repeated sampling from the model is a surprisingly effective strategy for producing working solutions to difficult prompts. Using this method, we solve 70.2% of our problems with 100 samples per problem. Careful investigation of our model reveals its limitations, including difficulty with docstrings describing long chains of operations and with binding operations to variables. Finally, we discuss the potential broader impacts of deploying powerful code generation technologies, covering safety, security, and economics.</p>\n", "tags": ["language model", "synthesis"], "tsne_embedding": [11.827057838439941, 10.481400489807129]}, {"key": "chen2021plur", "year": "2021", "title": "PLUR: A Unifying, Graph-Based View of Program Learning, Understanding, and Repair", "abstract": "<p>Machine learning for understanding and editing source code has recently attracted significant interest, with many developments in new models, new code representations, and new tasks.This proliferation can appear disparate and disconnected, making each approach seemingly unique and incompatible, thus obscuring the core machine learning challenges and contributions.In this work, we demonstrate that the landscape can be significantly simplified by taking a general approach of mapping a graph to a sequence of tokens and pointers.Our main result is to show that 16 recently published tasks of different shapes can be cast in this form, based on which a single model architecture achieves near or above state-of-the-art results on nearly all tasks, outperforming custom models like code2seq and alternative generic models like Transformers.This unification further enables multi-task learning and a series of cross-cutting experiments about the importance of different modeling choices for code understanding and repair tasks.The full framework, called PLUR, is easily extensible to more tasks, and will be open-sourced (https://github.com/google-research/plur).</p>\n", "tags": ["repair"], "tsne_embedding": [-5.337552547454834, -9.287328720092773]}, {"key": "chen2022codet", "year": "2022", "title": "CodeT: Code Generation with Generated Tests", "abstract": "<p>Given a programming problem, pre-trained language models such as Codex have demonstrated the ability to generate multiple different code solutions via sampling. However, selecting a correct or best solution from those samples still remains a challenge. While an easy way to verify the correctness of a code solution is through executing test cases, producing high-quality test cases is prohibitively expensive. In this paper, we explore the use of pre-trained language models to automatically generate test cases, calling our method CodeT: Code generation with generated Tests. CodeT executes the code solutions using the generated test cases, and then chooses the best solution based on a dual execution agreement with both the generated test cases and other generated solutions. We evaluate CodeT on five different pre-trained models with both HumanEval and MBPP benchmarks. Extensive experimental results demonstrate CodeT can achieve significant, consistent, and surprising improvements over previous methods. For example, CodeT improves the pass@1 on HumanEval to 65.8%, an increase of absolute 18.8% on the code-davinci-002 model, and an absolute 20+% improvement over previous state-of-the-art results.</p>\n", "tags": ["synthesis", "Transformer", "execution"], "tsne_embedding": [18.734359741210938, 7.038089275360107]}, {"key": "chen2023diversevul", "year": "2023", "title": "DiverseVul: A New Vulnerable Source Code Dataset for Deep Learning Based Vulnerability Detection", "abstract": "<p>We propose and release a new vulnerable source code dataset. We curate the dataset by crawling security issue websites, extracting vulnerability-fixing commits and source codes from the corresponding projects. Our new dataset contains 150 CWEs, 26,635 vulnerable functions, and 352,606 non-vulnerable functions extracted from 7,861 commits. Our dataset covers 305 more projects than all previous datasets combined. We show that increasing the diversity and volume of training data improves the performance of deep learning models for vulnerability detection.\nCombining our new dataset with previous datasets, we present an analysis of the challenges and promising research directions of using deep learning for detecting software vulnerabilities. We study 11 model architectures belonging to 4 families. Our results show that deep learning is still not ready for vulnerability detection, due to high false positive rate, low F1 score, and difficulty of detecting hard CWEs. In particular, we demonstrate an important generalization challenge for the deployment of deep learning-based models.\nHowever, we also identify hopeful future research directions. We demonstrate that large language models (LLMs) are the future for vulnerability detection, outperforming Graph Neural Networks (GNNs) with manual feature engineering. Moreover, developing source code specific pre-training objectives is a promising research direction to improve the vulnerability detection performance.</p>\n", "tags": ["dataset", "Transformer", "vulnerability"], "tsne_embedding": [-14.965526580810547, -10.250619888305664]}, {"key": "chibotaru2019scalable", "year": "2019", "title": "Scalable Taint Specification Inference with Big Code", "abstract": "<p>We present a new scalable, semi-supervised method for inferring\ntaint analysis specifications by learning from a large dataset of programs.\nTaint specifications capture the role of library APIs (source, sink, sanitizer)\nand are a critical ingredient of any taint analyzer that aims to detect\nsecurity violations based on information flow.</p>\n\n<p>The core idea of our method\nis to formulate the taint specification learning problem as a linear\noptimization task over a large set of information flow constraints.\nThe resulting constraint system can then be efficiently solved with\nstate-of-the-art solvers. Thanks to its scalability, our method can infer\nmany new and interesting taint specifications by simultaneously learning from\na large dataset of programs (e.g., as found on GitHub), while requiring \nfew manual annotations.</p>\n\n<p>We implemented our method in an end-to-end system,\ncalled Seldon, targeting Python, a language where static specification\ninference is particularly hard due to lack of typing information.\nWe show that Seldon is practically effective: it learned almost 7,000 API\nroles from over 210,000 candidate APIs with very little supervision\n(less than 300 annotations) and with high estimated precision (67%).\nFurther,using the learned specifications, our taint analyzer flagged more than\n20,000 violations in open source projects, 97% of which were\nundetectable without the inferred specifications.</p>\n", "tags": ["defect", "program analysis"], "tsne_embedding": [-7.418021202087402, 15.200289726257324]}, {"key": "chirkova2020empirical", "year": "2020", "title": "Empirical Study of Transformers for Source Code", "abstract": "<p>Initially developed for natural language processing (NLP), Transformers are now widely used for source code processing, due to the format similarity between source code and text. In contrast to natural language, source code is strictly structured, i. e. follows the syntax of the programming language. Several recent works develop Transformer modifications for capturing syntactic information in source code. The drawback of these works is that they do not compare to each other and all consider different tasks. In this work, we conduct a thorough empirical study of the capabilities of Transformers to utilize syntactic information in different tasks. We consider three tasks (code completion, function naming and bug fixing) and re-implement different syntax-capturing modifications in a unified framework. We show that Transformers are able to make meaningful predictions based purely on syntactic information and underline the best practices of taking the syntactic information into account for improving the performance of the model.</p>\n", "tags": ["Transformer"], "tsne_embedding": [-0.7875751256942749, 6.769552230834961]}, {"key": "chirkova2021embeddings", "year": "2021", "title": "On the Embeddings of Variables in Recurrent Neural Networks for Source Code", "abstract": "<p>Source code processing heavily relies on the methods widely used in natural language processing (NLP), but involves specifics that need to be taken into account to achieve higher quality. An example of this specificity is that the semantics of a variable is defined not only by its name but also by the contexts in which the variable occurs. In this work, we develop dynamic embeddings, a recurrent mechanism that adjusts the learned semantics of the variable when it obtains more information about the variable\u2019s role in the program. We show that using the proposed dynamic embeddings significantly improves the performance of the recurrent neural network, in code completion and bug fixing tasks.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [0.9829411506652832, -7.58345365524292]}, {"key": "chow2023beware", "year": "2023", "title": "Beware of the Unexpected: Bimodal Taint Analysis", "abstract": "<p>Static analysis is a powerful tool for detecting security vulnerabilities and other programming problems. Global taint tracking, in particular, can spot vulnerabilities arising from complicated data flow across multiple functions. However, precisely identifying which flows are problematic is challenging, and sometimes depends on factors beyond the reach of pure program analysis, such as conventions and informal knowledge. For example, learning that a parameter <code class=\"language-plaintext highlighter-rouge\">name</code> of an API function <code class=\"language-plaintext highlighter-rouge\">locale</code> ends up in a file path is surprising and potentially problematic. In contrast, it would be completely unsurprising to find that a parameter <code class=\"language-plaintext highlighter-rouge\">command</code> passed to an API function <code class=\"language-plaintext highlighter-rouge\">execaCommand</code> is eventually interpreted as part of an operating-system command. This paper presents Fluffy, a bimodal taint analysis that combines static analysis, which reasons about data flow, with machine learning, which probabilistically determines which flows are potentially problematic. The key idea is to let machine learning models predict from natural language information involved in a taint flow, such as API names, whether the flow is expected or unexpected, and to inform developers only about the latter. We present a general framework and instantiate it with four learned models, which offer different trade-offs between the need to annotate training data and the accuracy of predictions. We implement Fluffy on top of the CodeQL analysis framework and apply it to 250K JavaScript projects. Evaluating on five common vulnerability types, we find that Fluffy achieves an F1 score of 0.85 or more on four of them across a variety of datasets.</p>\n", "tags": ["static analysis"], "tsne_embedding": [-7.21423864364624, 15.19821548461914]}, {"key": "ciurumelea2020suggesting", "year": "2020", "title": "Suggesting Comment Completions for Python using Neural Language Models", "abstract": "<p>Source-code comments are an important communication medium between developers to better understand and maintain software. Current research focuses on auto-generating comments by summarizing the code. However, good comments contain additional details, like important design decisions or required trade-offs, and only developers can decide on the proper comment content. Automated summarization techniques cannot include information that does not exist in the code, therefore fully-automated approaches while helpful, will be of limited use. In our work, we propose to empower developers through a semi-automated system instead. We investigate the feasibility of using neural language models trained on a large corpus of Python documentation strings to generate completion suggestions and obtain promising results. By focusing on confident predictions, we can obtain a top-3 accuracy of over 70%, although this comes at the cost of lower suggestion frequency. Our models can be improved by leveraging context information like the signature and the full body of the method. Additionally, we are able to return good accuracy completions even for new projects, suggesting the generalizability of our approach.</p>\n", "tags": ["bimodal", "autocomplete", "documentation"], "tsne_embedding": [4.033416748046875, -11.221794128417969]}, {"key": "clement2020pymt5", "year": "2020", "title": "PyMT5: multi-mode translation of natural language and Python code with transformers", "abstract": "<p>Simultaneously modeling source code and natural language has many exciting applications in automated software development and understanding. Pursuant to achieving such technology, we introduce PyMT5, the Python method text-to-text transfer transformer, which is trained to translate between all pairs of Python method feature combinations: a single model that can both predict whole methods from natural language documentation strings (docstrings) and summarize code into docstrings of any common style. We present an analysis and modeling effort of a large-scale parallel corpus of 26 million Python methods and 7.7 million method-docstring pairs, demonstrating that for docstring and method generation, PyMT5 outperforms similarly-sized auto-regressive language models (GPT2) which were English pre-trained or randomly initialized. On the CodeSearchNet test set, our best model predicts 92.1% syntactically correct method bodies, achieved a BLEU score of 8.59 for method generation and 16.3 for docstring generation (summarization), and achieved a ROUGE-L F-score of 24.8 for method generation and 36.7 for docstring generation.</p>\n", "tags": ["bimodal", "code generation", "summarization", "documentation", "language model", "pretraining"], "tsne_embedding": [11.977579116821289, 2.8171751499176025]}, {"key": "clement2021distilling", "year": "2021", "title": "Distilling Transformers for Neural Cross-Domain Search", "abstract": "<p>Pre-trained transformers have recently clinched top spots in the gamut of natural language tasks and pioneered solutions to software engineering tasks. Even information retrieval has not been immune to the charm of the transformer, though their large size and cost is generally a barrier to deployment. While there has been much work in streamlining, caching, and modifying transformer architectures for production, here we explore a new direction: distilling a large pre-trained translation model into a lightweight bi-encoder which can be efficiently cached and queried. We argue from a probabilistic perspective that sequence-to-sequence models are a conceptually ideal\u2014albeit highly impractical\u2014retriever. We derive a new distillation objective, implementing it as a data augmentation scheme. Using natural language source code search as a case study for cross-domain search, we demonstrate the validity of this idea by significantly improving upon the current leader of the CodeSearchNet challenge, a recent natural language code search benchmark.</p>\n", "tags": ["search", "Transformer"], "tsne_embedding": [8.443479537963867, -1.1834397315979004]}, {"key": "clement2021long", "year": "2021", "title": "Long-Range Modeling of Source Code Files with eWASH: Extended Window Access by Syntax Hierarchy", "abstract": "<p>Statistical language modeling and translation with transformers have found many successful applications in program understanding and generation tasks, setting high benchmarks for tools in modern software development environments. The finite context window of these neural models means, however, that they will be unable to leverage the entire relevant context of large files and packages for any given task. While there are many efforts to extend the context window, we introduce an architecture-independent approach for leveraging the syntactic hierarchies of source code for incorporating entire file-level context into a fixed-length window. Using concrete syntax trees of each source file we extract syntactic hierarchies and integrate them into context window by selectively removing from view more specific, less relevant scopes for a given task. We evaluate this approach on code generation tasks and joint translation of natural language and source code in Python programming language, achieving a new state-of-the-art in code completion and summarization for Python in the CodeXGLUE benchmark. We also introduce new CodeXGLUE benchmarks for user-experience-motivated tasks: code completion with normalized literals, method body completion/code summarization conditioned on file-level context.</p>\n", "tags": ["Transformer", "language model", "code generation"], "tsne_embedding": [11.203651428222656, 7.777548789978027]}, {"key": "commit2vec2019lozoya", "year": "2019", "title": "Commit2Vec: Learning Distributed Representations of Code Changes", "abstract": "<p>Deep learning methods, which have found successful applications in fields like image classification and natural language processing, have recently been applied to source code analysis too, due to the enormous amount of freely available source code (e.g., from open-source software repositories).</p>\n\n<p>In this work, we elaborate upon a state-of-the-art approach to the representation of source code that uses information about its syntactic structure, and we adapt it to represent source changes (i.e., commits). We use this representation to classify security-relevant commits.</p>\n\n<p>Because our method uses transfer learning (that is, we train a network on a \u201cpretext task\u201d for which abundant labeled data is available, and then we use such network for the target task of commit classification, for which fewer labeled instances are available), we studied the impact of pre-training the network using two different pretext tasks versus a randomly initialized model.</p>\n\n<p>Our results indicate that representations that leverage the structural information obtained through code syntax outperform token-based representations. Furthermore, the performance metrics obtained when pre-training on a loosely related pretext task with a very large dataset (&gt;10e6 samples) were surpassed when pretraining on a smaller dataset (&gt;10e4 samples) but for a pretext task that is more closely related to the target task.</p>\n", "tags": ["edit"], "tsne_embedding": [-5.915755748748779, -0.5671128630638123]}, {"key": "compton2020embedding", "year": "2020", "title": "Embedding Java Classes with code2vec: Improvements from Variable Obfuscation", "abstract": "<p>Automatic source code analysis in key areas of software engineering, such as code security, can benefit from Machine Learning (ML). However, many standard ML approaches require a numeric representation of data and cannot be applied directly to source code. Thus, to enable ML, we need to embed source code into numeric feature vectors while maintaining the semantics of the code as much as possible. code2vec is a recently released embedding approach that uses the proxy task of method name prediction to map Java methods to feature vectors. However, experimentation with code2vec shows that it learns to rely on variable names for prediction, causing it to be easily fooled by typos or adversarial attacks. Moreover, it is only able to embed individual Java methods and cannot embed an entire collection of methods such as those present in a typical Java class, making it difficult to perform predictions at the class level (e.g., for the identification of malicious Java classes). Both shortcomings are addressed in the research presented in this paper. We investigate the effect of obfuscating variable names during the training of a code2vec model to force it to rely on the structure of the code rather than specific names and consider a simple approach to creating class-level embeddings by aggregating sets of method embeddings. Our results, obtained on a challenging new collection of source-code classification problems, indicate that obfuscating variable names produces an embedding model that is both impervious to variable naming and more accurately reflects code semantics. The datasets, models, and code are shared for further ML research on source code.</p>\n", "tags": ["naming", "adversarial"], "tsne_embedding": [-8.117870330810547, 0.5984892845153809]}, {"key": "corley2015exploring", "year": "2015", "title": "Exploring the Use of Deep Learning for Feature Location", "abstract": "<p>Deep learning models are a class of neural networks. Relative to n-gram models, deep learning models can capture more complex statistical patterns based on smaller training corpora. In this paper we explore the use of a particular deep learning model, document vectors (DVs), for feature location. DVs seem well suited to use with source code, because they both capture the influence of context on each term in a corpus and map terms into a continuous semantic space that encodes semantic relationships such as synonymy. We present preliminary results that show that a feature location technique (FLT) based on DVs can outperform an analogous FLT based on latent Dirichlet allocation (LDA) and then suggest several directions for future work on the use of deep learning models to improve developer effectiveness in feature location.</p>\n", "tags": ["feature location", "representation"], "tsne_embedding": [-1.951317310333252, 2.569117546081543]}, {"key": "cummins2017end", "year": "2017", "title": "End-to-end Deep Learning of Optimization Heuristics", "abstract": "<p>Accurate automatic optimization heuristics are necessary for dealing with the complexity and diversity of modern hardware and software. Machine learning is a proven technique for learning such heuristics, but its success is bound by the quality of the features used. These features must be hand crafted by developers through a combination of expert domain knowledge and trial and error. This makes the quality of the final model directly dependent on the skill and available time of the system architect.</p>\n\n<p>Our work introduces a better way for building heuristics. We develop a deep neural network that learns heuristics over raw code, entirely without using code features. The neural network simultaneously constructs appropriate representations of the code and learns how best to optimize, removing the need for manual feature creation. Further, we show that our neural nets can transfer learning from one optimization problem to another, improving the accuracy of new models, without the help of human experts.</p>\n\n<p>We compare the effectiveness of our automatically generated heuristics against ones with features hand-picked by experts. We examine two challenging tasks: predicting optimal mapping for heterogeneous parallelism and GPU thread coarsening factors. In 89% of the cases, the quality of our fully automatic heuristics matches or surpasses that of state-of-the-art predictive models using hand-crafted features, providing on average 14% and 12% more performance with no human effort expended on designing features.</p>\n", "tags": ["optimization"], "tsne_embedding": [13.340367317199707, 17.187808990478516]}, {"key": "cummins2017synthesizing", "year": "2017", "title": "Synthesizing benchmarks for predictive modeling", "abstract": "<p>Predictive modeling using machine learning is an effective method for building compiler heuristics, but there is a shortage of benchmarks. Typical machine learning experiments outside of the compilation field train over thousands or millions of examples. In machine learning for compilers, however, there are typically only a few dozen common benchmarks available. This limits the quality of learned models, as they have very sparse training data for what are often high-dimensional feature spaces. What is needed is a way to generate an unbounded number of training programs that finely cover the feature space. At the same time the generated programs must be similar to the types of programs that human developers actually write, otherwise the learning will target the wrong parts of the feature space. We mine open source repositories for program fragments and apply deep learning techniques to automatically construct models for how humans write programs. We sample these models to generate an unbounded number of runnable training programs. The quality of the programs is such that even human developers struggle to distinguish our generated programs from hand-written code. We use our generator for OpenCL programs, CLgen, to automatically synthesize thousands of programs and show that learning over these improves the performance of a state of the art predictive model by 1.27x. In addition, the fine covering of the feature space automatically exposes weaknesses in the feature design which are invisible with the sparse training examples from existing benchmark suites. Correcting these weaknesses further increases performance by 4.30x.</p>\n", "tags": ["optimization", "code generation"], "tsne_embedding": [12.28368854522705, 16.104990005493164]}, {"key": "cummins2018compiler", "year": "2018", "title": "Compiler Fuzzing through Deep Learning", "abstract": "<p>Random program generation \u2014 fuzzing \u2014 is an effective technique\nfor discovering bugs in compilers but successful fuzzers require\nextensive development effort for every language supported by the\ncompiler, and often leave parts of the language space untested.</p>\n\n<p>We introduce DeepSmith, a novel machine learning approach\nto accelerating compiler validation through the inference of generative models for compiler inputs. Our approach\ninfers a learned\nmodel of the structure of real world code based on a large corpus of open source code. Then, it uses the model to automatically\ngenerate tens of thousands of realistic programs. Finally, we apply\nestablished differential testing methodologies on them to expose\nbugs in compilers. We apply our approach to the OpenCL programming language, automatically exposing bugs with little effort on our\nside. In 1,000 hours of automated testing of commercial and open\nsource compilers, we discover bugs in all of them, submitting 67\nbug reports. Our test cases are on average two orders of magnitude\nsmaller than the state-of-the-art, require 3.03\u00d7 less time to generate\nand evaluate, and expose bugs which the state-of-the-art cannot.\nOur random program generator, comprising only 500 lines of code,\ntook 12 hours to train for OpenCL versus the state-of-the-art taking\n9 man months to port from a generator for C and 50,000 lines of\ncode. With 18 lines of code we extended our program generator to\na second language, uncovering crashes in Solidity compilers in 12\nhours of automated testing.</p>\n", "tags": ["fuzzing", "code generation"], "tsne_embedding": [10.58889102935791, 18.544681549072266]}, {"key": "cummins2020programl", "year": "2020", "title": "ProGraML: Graph-based Deep Learning for Program Optimization and Analysis", "abstract": "<p>The increasing complexity of computing systems places a tremendous burden on optimizing compilers, requiring ever more accurate and aggressive optimizations. Machine learning offers significant benefits for constructing optimization heuristics but there remains a gap between what state-of-the-art methods achieve and the performance of an optimal heuristic. Closing this gap requires improvements in two key areas: a representation that accurately captures the semantics of programs, and a model architecture with sufficient expressiveness to reason about this representation.</p>\n\n<p>We introduce ProGraML - Program Graphs for Machine Learning - a novel graph-based program representation using a low level, language agnostic, and portable format; and machine learning models capable of performing complex downstream tasks over these graphs. The ProGraML representation is a directed attributed multigraph that captures control, data, and call relations, and summarizes instruction and operand types and ordering. Message Passing Neural Networks propagate information through this structured representation, enabling whole-program or per-vertex classification tasks.</p>\n\n<p>ProGraML provides a general-purpose program representation that equips learnable models to perform the types of program analysis that are fundamental to optimization. To this end, we evaluate the performance of our approach first on a suite of traditional compiler analysis tasks: control flow reachability, dominator trees, data dependencies, variable liveness, and common subexpression detection. On a benchmark dataset of 250k LLVM-IR files covering six source programming languages, ProGraML achieves an average 94.0 F1 score, significantly outperforming the state-of-the-art approaches. We then apply our approach to two high-level tasks - heterogeneous device mapping and program classification - setting new state-of-the-art performance in both.</p>\n", "tags": ["dataset", "GNN"], "tsne_embedding": [-3.1090188026428223, -7.426473617553711]}, {"key": "cvitkovic2018open", "year": "2018", "title": "Open Vocabulary Learning on Source Code with a Graph-Structured Cache", "abstract": "<p>Machine learning models that take computer program source code as input typically use Natural Language Processing (NLP) techniques. However, a major challenge is that code is written using an open, rapidly changing vocabulary due to, e.g., the coinage of new variable and method names. Reasoning over such a vocabulary is not something for which most NLP methods are designed. We introduce a Graph-Structured Cache to address this problem; this cache contains a node for each new word the model encounters with edges connecting each word to its occurrences in the code. We find that combining this graph-structured cache strategy with recent Graph-Neural-Network-based models for supervised learning on code improves the models\u2019 performance on a code completion task and a variable naming task \u2014 with over 100% relative improvement on the latter \u2014 at the cost of a moderate increase in computation time.</p>\n", "tags": ["GNN", "variable misuse", "defect", "representation"], "tsne_embedding": [-6.243736267089844, -4.5323357582092285]}, {"key": "dam2016deep", "year": "2016", "title": "A deep language model for software code", "abstract": "<p>Existing language models such as n-grams for software code often fail to capture a long context where dependent code elements scatter far apart. In this paper, we propose a novel approach to build a language model for software code to address this particular issue. Our language model, partly inspired by human memory, is built upon the powerful deep learning-based Long Short Term Memory architecture that is capable of learning long-term dependencies which occur frequently in software code. Results from our intrinsic evaluation on a corpus of Java projects have demonstrated the effectiveness of our language model. This work contributes to realizing our vision for DeepSoft, an end-to-end, generic deep learning-based framework for modeling software and its development process.</p>\n", "tags": ["language model", "code generation"], "tsne_embedding": [-0.6048599481582642, 0.934149980545044]}, {"key": "dash2018refinym", "year": "2018", "title": "RefiNym: Using Names to Refine Types", "abstract": "<p>Source code is bimodal: it combines a formal algorithmic channel and a natural language channel of identifiers and comments. In this work, we model the bimodality of code with name lows, an assignment low graph augmented to track identiier names. Conceptual types are logically distinct types that do not always coincide with program types. Passwords and URLs are example conceptual types that can share the program type string. Our tool, RefiNym, is an unsupervised method that mines a lattice of conceptual types from name lows and reiies them into distinct nominal types. For string, RefiNym inds and splits conceptual types originally merged into a single type, reducing the number of same-type variables per scope from 8.7 to 2.2 while eliminating 21.9% of scopes that have more than one same-type variable in scope. This makes the code more self-documenting and frees the type system to prevent a developer from inadvertently assigning data across conceptual types.</p>\n", "tags": ["program analysis", "types"], "tsne_embedding": [-9.157577514648438, 11.307740211486816]}, {"key": "david2019neural", "year": "2019", "title": "Neural Reverse Engineering of Stripped Binaries", "abstract": "<p>We address the problem of predicting procedure names in stripped executables which contain no debug information.\nPredicting procedure names can dramatically ease the task of reverse engineering, saving precious time and human effort. \nWe present a novel approach that leverages static analysis of binaries with encoder-decoder-based neural networks.\nThe main idea is to use static analysis to obtain enriched representations of API call sites; encode a set of sequences\nof these call sites; and finally, attend to the encoded sequences while decoding the target name token-by-token. \nWe evaluate our model by predicting procedure names over 60,000 procedures in 10,000 stripped executables.\nOur model achieves 81.70 precision and 80.12 recall in predicting procedure names within GNU packages, and 55.48\nprecision and 51.31 recall in a diverse, cross-package, dataset. Comparing to previous approaches,\nthe predictions made by our model are much more accurate and informative.</p>\n", "tags": ["naming", "deobfuscation", "GNN"], "tsne_embedding": [-16.389060974121094, 14.893036842346191]}, {"key": "defreez2018path", "year": "2018", "title": "Path-Based Function Embedding and its Application to Specification Mining", "abstract": "<p>Identifying the relationships among program elements is useful\nfor program understanding, debugging, and analysis. One such\nrelationship is synonymy. Function synonyms are functions that\nplay a similar role in code, e.g. functions that perform initialization\nfor different device drivers, or functions that implement different\nsymmetric-key encryption schemes. Function synonyms are not\nnecessarily semantically equivalent and can be syntactically dissimilar; consequently, approaches for identifying code clones or\nfunctional equivalence cannot be used to identify them. This paper presents <code class=\"language-plaintext highlighter-rouge\">func2vec</code>, an algorithm that maps each function to a vector in a vector space such that function synonyms are grouped\ntogether. We compute the function embedding by training a neu-\nral network on sentences generated from random walks over an\nencoding of the program as a labeled pushdown system (\u2113-PDS).\nWe demonstrate that <code class=\"language-plaintext highlighter-rouge\">func2vec</code>\nis effective at identifying function\nsynonyms in the Linux kernel. Furthermore, we show how function\nsynonyms enable mining error-handling specifications with high\nsupport in Linux file systems and drivers.</p>\n", "tags": ["program analysis", "representation"], "tsne_embedding": [-6.234133243560791, 8.455171585083008]}, {"key": "derezendemartins2020concra.md", "year": "2020", "title": "CoNCRA: A Convolutional Neural Network Code Retrieval Approach", "abstract": "<p>Software developers routinely search for code using general-purpose search engines. However, these search engines cannot find code semantically unless it has an accompanying description. We propose a technique for semantic code search: A Convolutional Neural Network approach to code retrieval (CoNCRA). Our technique aims to find the code snippet that most closely matches the developer\u2019s intent, expressed in natural language. We evaluated our approach\u2019s efficacy on a dataset composed of questions and code snippets collected from Stack Overflow. Our preliminary results showed that our technique, which prioritizes local interactions (words nearby), improved the state-of-the-art (SOTA) by 5% on average, retrieving the most relevant code snippets in the top 3 (three) positions by almost 80% of the time. Therefore, our technique is promising and can improve the efficacy of semantic code retrieval.</p>\n\n", "tags": ["search"], "tsne_embedding": [-14.618121147155762, 4.736110210418701]}, {"key": "devanbu2020deep", "year": "2020", "title": "Deep Learning & Software Engineering: State of Research and Future Directions", "abstract": "<p>Given the current transformative potential of research that sits at the intersection of Deep Learning (DL) and Software Engineering (SE), an NSF-sponsored community workshop was conducted in co-location with the 34th IEEE/ACM International Conference on Automated Software Engineering (ASE\u201919) in San Diego, California. The goal of this workshop was to outline high priority areas for cross-cutting research. While a multitude of exciting directions for future work were identified, this report provides a general summary of the research areas representing the areas of highest priority which were discussed at the workshop. The intent of this report is to serve as a potential roadmap to guide future work that sits at the intersection of SE &amp; DL.</p>\n", "tags": ["survey"], "tsne_embedding": [8.291260719299316, -24.42363166809082]}, {"key": "devlin2017semantic", "year": "2017", "title": "Semantic Code Repair using Neuro-Symbolic Transformation Networks", "abstract": "<p>We study the problem of semantic code repair, which can be broadly defined as automatically fixing\nnon-syntactic bugs in source code. The majority of past work in semantic code repair assumed access\nto unit tests against which candidate repairs could be validated. In contrast, the goal here is to\ndevelop a strong statistical model to accurately predict both bug locations and exact fixes without\naccess to information about the intended correct behavior of the program. Achieving such a goal\nrequires a robust contextual repair model, which we train on a large corpus of real-world source\ncode that has been augmented with synthetically injected bugs. Our framework adopts a two-stage\napproach where first a large set of repair candidates are generated by rule-based processors, and\nthen these candidates are scored by a statistical model using a novel neural network architecture\nwhich we refer to as Share, Specialize, and Compete. Specifically, the architecture (1) generates\na shared encoding of the source code using an RNN over the abstract syntax tree, \n(2) scores each candidate repair using specialized network modules, and (3) then normalizes these\nscores together so they can compete against one another in comparable probability space. We evaluate\nour model on a real-world test set gathered from GitHub containing four common categories of bugs.\nOur model is able to predict the exact correct repair 41% of the time with a single guess, compared\nto 13% accuracy for an attentional sequence-to-sequence model.</p>\n", "tags": ["repair"], "tsne_embedding": [-5.725096702575684, -21.392337799072266]}, {"key": "deze2021mulcode", "year": "2021", "title": "MulCode: A Multi-task Learning Approach for Source Code Understanding", "abstract": "<p>Recent years have witnessed the significant rise of Deep Learning (DL) techniques applied to source code. Researchers exploit DL for a multitude of tasks and achieve impressive results. However, most tasks are explored separately, resulting in a lack of generalization of the solutions. In this work, we propose MulCode, a multi-task learning approach for source code understanding that learns unified representation space for tasks, with the pre-trained BERT model for the token sequence and the Tree-LSTM model for abstract syntax trees. Furthermore, we integrate two source code views into a hybrid representation via the attention mechanism and set learnable uncertainty parameters to adjust the tasks\u2019 relationship. We train and evaluate MulCode in three downstream tasks: comment classification, author attribution, and duplicate function detection. In all tasks, MulCode outperforms the state-of-theart techniques. Moreover, experiments on three unseen tasks demonstrate the generalization ability of MulCode compared with state-of-the-art embedding methods.</p>\n", "tags": ["representation"], "tsne_embedding": [6.554128646850586, -3.2189650535583496]}, {"key": "deze2022bridging", "year": "2022", "title": "Bridging Pre-trained Models and Downstream Tasks for Source Code Understanding", "abstract": "<p>With the great success of pre-trained models, the pretrain-then-finetune paradigm has been widely adopted on downstream tasks for source code understanding. However, compared to costly training a large-scale model from scratch, how to effectively adapt pre-trained models to a new task has not been fully explored. In this paper, we propose an approach to bridge pre-trained models and code-related tasks. We exploit semantic-preserving transformation to enrich downstream data diversity, and help pre-trained models learn semantic features that are invariant to these semantically equivalent transformations. Further, we introduce curriculum learning to organize the transformed data in an easy-to-hard manner to fine-tune existing pre-trained models.</p>\n\n<p>We apply our approach to a range of pre-trained models, and they significantly outperform the state-of-the-art models on tasks for source code understanding, such as algorithm classification, code clone detection, and code search. Our experiments even show that without heavy pre-training on code data, natural language pre-trained model RoBERTa fine-tuned with our lightweight approach could outperform or rival existing code pre-trained models fine-tuned on the above tasks, such as CodeBERT and GraphCodeBERT. This finding suggests that there is still much room for improvement in code pre-trained models.</p>\n", "tags": ["representation", "language model"], "tsne_embedding": [2.904816150665283, -1.1543899774551392]}, {"key": "dinella2020hoppity", "year": "2020", "title": "Hoppity: Learning Bug Detection and Repair", "abstract": "<p>We present a learning-based approach to detect and fix a broad range of bugs in Javascript programs. We frame the problem in terms of learning a sequence of graph transformations: given a buggy program modeled by a graph structure, our model makes a sequence of predictions including the position of bug nodes and corresponding graph edits to produce a fix. Unlike previous works that use deep neural networks, our approach targets bugs that are more complex and semantic in nature (i.e.~bugs that require adding or deleting statements to fix). We have realized our approach in a tool called HOPPITY. By training on 338,877 Javascript code change commits on Github, HOPPITY correctly detects and fixes bugs in 9,612 out of 42,365 programs in an end-to-end fashion. Given the bug location and type of the fix, HOPPITY also outperforms the baseline approach by a wide margin.</p>\n", "tags": ["edit", "repair"], "tsne_embedding": [-8.454808235168457, -17.74882698059082]}, {"key": "dinella2021deepmerge", "year": "2021", "title": "DeepMerge: Learning to Merge Programs", "abstract": "<p>Program merging is ubiquitous in modern software development. Although commonly used in most version control systems, text-based merge algorithms are prone to producing spurious merge conflicts: they report a conflict even when program changes do not interfere with each other semantically. Spurious merge conflicts are costly to development as the need for manual intervention stalls modern continuous integration pipelines. We propose a novel data-driven approach to identify and resolve spurious merge conflicts with a sequence-to-sequence machine learning model. We realize our approach in a tool DeepMerge that uses a novel combination of (i) an edit-aware embedding of merge inputs and (ii) a variation of pointer networks to construct resolutions from input segments. We also propose an algorithm to extract ground truth manual resolutions from a code corpus and employ it to curate a dataset comprising 10,729 non-trivial resolutions in Javascript programs. Our evaluation shows that DeepMerge can predict correct resolutions with high precision (72%) and modest recall (34%) on the dataset overall, and high recall (78%) on merges comprising of upto 3 lines that comprise 24% of the dataset.</p>\n", "tags": ["edit", "repair"], "tsne_embedding": [-3.4805145263671875, -11.741138458251953]}, {"key": "dinella2022toga", "year": "2022", "title": "TOGA: A Neural Method for Test Oracle Generation", "abstract": "<p>Testing is widely recognized as an important stage of the software\ndevelopment lifecycle. Effective software testing can provide benefits such as bug finding, preventing regressions, and documentation.\nIn terms of documentation, unit tests express a unit\u2019s intended\nfunctionality, as conceived by the developer. A test oracle, typically expressed as an condition, documents the intended behavior\nof a unit under a given test prefix. Synthesizing a functional test\noracle is a challenging problem, as it must capture the intended\nfunctionality rather than the implemented functionality.\nIn this paper, we propose TOGA (a neural method for Test Oracle\nGenerAtion), a unified transformer-based neural approach to infer\nboth exceptional and assertion test oracles based on the context of\nthe focal method. Our approach can handle units with ambiguous\nor missing documentation, and even units with a missing implementation. We evaluate our approach on both oracle inference accuracy\nand functional bug-finding. Our technique improves accuracy by\n33% over existing oracle inference approaches, achieving 96% overall accuracy on a held out test dataset. Furthermore, we show that\nwhen integrated with a automated test generation tool (EvoSuite),\nour approach finds 57 real world bugs in large-scale Java programs,\nincluding 30 bugs that are not found by any other automated testing\nmethod in our evaluation</p>\n", "tags": ["code generation", "Transformer", "test generation"], "tsne_embedding": [20.760507583618164, 4.6326680183410645]}, {"key": "ding2019asm2vec", "year": "2019", "title": "Asm2Vec: Boosting Static Representation Robustness for Binary Clone Search against Code Obfuscation and Compiler Optimization", "abstract": "<p>Reverse engineering is a manually intensive but necessary technique for understanding the inner workings of new malware, finding vulnerabilities in existing systems, and detecting patent infringements in released software. An assembly clone search engine facilitates the work of reverse engineers by identifying those duplicated or known parts. However, it is challenging to design a robust clone search engine, since there exist various compiler optimization options and code obfuscation techniques that make logically similar assembly functions appear to be very different. A practical clone search engine relies on a robust vector representation of assembly code. However, the existing clone search approaches, which rely on a manual feature engineering process to form a feature vector for an assembly function, fail to consider the relationships between features and identify those unique patterns that can statistically distinguish assembly functions. To address this problem, we propose to jointly learn the lexical semantic relationships and the vector representation of assembly functions based on assembly code. We have developed an assembly code representation learning model \\emph{Asm2Vec}. It only needs assembly code as input and does not require any prior knowledge such as the correct mapping between assembly functions. It can find and incorporate rich semantic relationships among tokens appearing in assembly code. We conduct extensive experiments and benchmark the learning model with state-of-the-art static and dynamic clone search approaches. We show that the learned representation is more robust and significantly outperforms existing methods against changes introduced by obfuscation and optimizations.</p>\n", "tags": ["representation", "clone"], "tsne_embedding": [-15.337540626525879, -4.8686017990112305]}, {"key": "ding2021contrastive", "year": "2021", "title": "Contrastive Learning for Source Code with Structural and Functional Properties", "abstract": "<p>Pre-trained transformer models have recently shown promises for understanding the source code. Most existing works expect to understand code from the textual features and limited structural knowledge of code. However, the program functionalities sometimes cannot be fully revealed by the code sequence, even with structure information. Programs can contain very different tokens and structures while sharing the same functionality, but changing only one or a few code tokens can introduce unexpected or malicious program behaviors while preserving the syntax and most tokens. In this work, we present BOOST, a novel self-supervised model to focus pre-training based on the characteristics of source code. We first employ automated, structure-guided code transformation algorithms that generate (i.) functionally equivalent code that looks drastically different from the original one, and (ii.) textually and syntactically very similar code that is functionally distinct from the original. We train our model in a way that brings the functionally equivalent code closer and distinct code further through a contrastive learning objective. To encode the structure information, we introduce a new node-type masked language model objective that helps the model learn about structural context. We pre-train BOOST with a much smaller dataset than the state-of-the-art models, but our small models can still match or outperform these large models in code understanding and generation tasks.</p>\n", "tags": ["representation", "pretraining", "Transformer"], "tsne_embedding": [3.4068729877471924, -3.902871608734131]}, {"key": "doderlein2022piloting", "year": "2022", "title": "Piloting Copilot and Codex: Hot Temperature, Cold Prompts, or Black Magic?", "abstract": "<p>Language models are promising solutions for tackling increasing complex problems. In software engineering, they recently attracted attention in code assistants, with programs automatically written in a given programming language from a programming task description in natural language. They have the potential to save time and effort when writing code. However, these systems are currently poorly understood, preventing them from being used optimally. In this paper, we investigate the various input parameters of two language models, and conduct a study to understand if variations of these input parameters (e.g. programming task description and the surrounding context, creativity of the language model, number of generated solutions) can have a significant impact on the quality of the generated programs. We design specific operators for varying input parameters and apply them over two code assistants (Copilot and Codex) and two benchmarks representing algorithmic problems (HumanEval and LeetCode). Our results showed that varying the input parameters can significantly improve the performance of language models. However, there is a tight dependency when varying the temperature, the prompt and the number of generated solutions, making potentially hard for developers to properly control the parameters to obtain an optimal result. This work opens opportunities to propose (automated) strategies for improving performance.</p>\n", "tags": ["Transformer"], "tsne_embedding": [14.379667282104492, 11.2256498336792]}, {"key": "dong2023codescore", "year": "2023", "title": "CodeScore: Evaluating Code Generation by Learning Code Execution", "abstract": "<p>A proper code evaluation metric (CEM) profoundly impacts the evolution of code generation, which is an important research field in NLP and software engineering. Prevailing CEMs can be categorized into match-based CEMs (e.g., BLEU, Accuracy, and CodeBLEU) and execution-based CEMs (e.g., AvgPassRatio and Pass@k), but both of them suffer from some issues. The former only measures differences in surface form regardless of the functional equivalence of codes, while the latter has huge execution overheads, including collecting expensive test cases, resolving tedious execution dependencies, and enormous execution time. To address these issues, in this paper, we propose CodeScore, an efficient and effective CEM for code generation, which estimates test case PassRatio of generated code without executing code. We also present a framework named UniCE for training unified code evaluation models by learning code execution, i.e., learning PassRatio and Executability of generated code. In order to learn code execution comprehensively, we construct more than 100 test cases for each task in several popular benchmark datasets, covering MBPP, APPS, and HumanEval. Experimental results show that CodeScore has obtained a state-of-the-art correlation with execution-based CEMs. CodeScore is strongly correlated with AvgPassPatio, and binary CodeScore is moderately correlated with Pass@1. In particular, CodeScore eliminates the need for test cases and execution dependencies in inference, and CodeScore reduces execution time by three orders of magnitude compared to AvgPassPatio and Pass@1.</p>\n", "tags": ["Transformer", "evaluation"], "tsne_embedding": [19.101850509643555, 7.365787982940674]}, {"key": "drain2021deepdebug", "year": "2021", "title": "DeepDebug: Fixing Python Bugs Using Stack Traces, Backtranslation, and Code Skeletons", "abstract": "<p>The joint task of bug localization and program repair is an integral part of the software development process. In this work we present DeepDebug, an approach to automated debugging using large, pretrained transformers. We begin by training a bug-creation model on reversed commit data for the purpose of generating synthetic bugs. We apply these synthetic bugs toward two ends. First, we directly train a backtranslation model on all functions from 200K repositories. Next, we focus on 10K repositories for which we can execute tests, and create buggy versions of all functions in those repositories that are covered by passing tests. This provides us with rich debugging information such as stack traces and print statements, which we use to finetune our model which was pretrained on raw source code. Finally, we strengthen all our models by expanding the context window beyond the buggy function itself, and adding a skeleton consisting of that function\u2019s parent class, imports, signatures, docstrings, and method bodies, in order of priority. On the QuixBugs benchmark, we increase the total number of fixes found by over 50%, while also decreasing the false positive rate from 35% to 5% and decreasing the timeout from six hours to one minute. On our own benchmark of executable tests, our model fixes 68% of all bugs on its first attempt without using traces, and after adding traces it fixes 75% on first attempt. We will open-source our framework and validation set for evaluating on executable tests.</p>\n", "tags": ["repair", "Transformer"], "tsne_embedding": [-10.635602951049805, -20.33320426940918]}, {"key": "drain2021generating", "year": "2021", "title": "Generating Bug-Fixes Using Pretrained Transformers", "abstract": "<p>Detecting and fixing bugs are two of the most important yet frustrating parts of the software development cycle. Existing bug detection tools are based mainly on static analyzers, which rely on mathematical logic and symbolic reasoning about the program execution to detect common types of bugs. Fixing bugs is typically left out to the developer. In this work we introduce DeepDebug: a data-driven program repair approach which learns to detect and fix bugs in Java methods mined from real-world GitHub repositories. We frame bug-patching as a sequence-to-sequence learning task consisting of two steps: (i) denoising pretraining, and (ii) supervised finetuning on the target translation task. We show that pretraining on source code programs improves the number of patches found by 33% as compared to supervised training from scratch, while domain-adaptive pretraining from natural language to code further improves the accuracy by another 32%. We refine the standard accuracy evaluation metric into non-deletion and deletion-only fixes, and show that our best model generates 75% more non-deletion fixes than the previous state of the art. In contrast to prior work, we attain our best results when generating raw code, as opposed to working with abstracted code that tends to only benefit smaller capacity models. Finally, we observe a subtle improvement from adding syntax embeddings along with the standard positional embeddings, as well as with adding an auxiliary task to predict each token\u2019s syntactic class. Despite focusing on Java, our approach is language agnostic, requiring only a general-purpose parser such as tree-sitter.</p>\n", "tags": ["Transformer", "repair"], "tsne_embedding": [-6.926741600036621, -17.8829345703125]}, {"key": "edelmann2019neural", "year": "2019", "title": "Neural-Network Guided Expression Transformation", "abstract": "<p>Optimizing compilers, as well as other translator systems, often work by rewriting expressions according to equivalence preserving rules. Given an input expression and its optimized form, finding the sequence of rules that were applied is a non-trivial task. Most of the time, the tools provide no proof, of any kind, of the equivalence between the original expression and its optimized form. In this work, we propose to reconstruct proofs of equivalence of simple mathematical expressions, after the fact, by finding paths of equivalence preserving transformations between expressions. We propose to find those sequences of transformations using a search algorithm, guided by a neural network heuristic. Using a Tree-LSTM recursive neural network, we learn a distributed representation of expressions where the Manhattan distance between vectors approximately corresponds to the rewrite distance between expressions. We then show how the neural network can be efficiently used to search for transformation paths, leading to substantial gain in speed compared to an uninformed exhaustive search. In one of our experiments, our neural-network guided search algorithm is able to solve more instances with a 2 seconds timeout per instance than breadth-first search does with a 5 minutes timeout per instance.</p>\n", "tags": ["optimization", "grammar"], "tsne_embedding": [14.313555717468262, -14.675862312316895]}, {"key": "ederhardt2019unsupervised", "year": "2019", "title": "Unsupervised Learning of API Aliasing Specifications", "abstract": "<p>Real world applications make heavy use of powerful libraries\nand frameworks, posing a significant challenge for static analysis\nas the library implementation may be very complex or unavailable.\nThus, obtaining specifications that summarize the behaviors of\nthe library is important as it enables static analyzers to precisely\ntrack the effects of APIs on the client program, without requiring\nthe actual API implementation.</p>\n\n<p>In this work, we propose a novel method\nfor discovering aliasing specifications of APIs by learning from a large\ndataset of programs. Unlike prior work, our method does not require\nmanual annotation, access to the library\u2019s source code or ability to\nrun its APIs. Instead, it learns specifications in a fully unsupervised manner,\nby statically observing usages of APIs in the dataset. The core idea is to\nlearn a probabilistic model of interactions between API methods and aliasing\nobjects, enabling identification of additional likely aliasing relations,\nand to then infer aliasing specifications ofAPIs that explain these relations.\nThe learned specifications are then used to augment an API-aware points-to analysis.</p>\n\n<p>We implemented our approach in a tool called USpec and used it to automatically\nlearn aliasing specifications from millions of source code files.\nUSpec learned over 2000 specifications of various Java and Python APIs, in the process\nimproving the results of the points-to analysis and its clients.</p>\n", "tags": ["API", "program analysis"], "tsne_embedding": [-8.426765441894531, 14.318095207214355]}, {"key": "efstathiou2019semantic", "year": "2019", "title": "Semantic Source Code Models Using Identifier Embeddings", "abstract": "<p>The emergence of online open source repositories in the recent years has led to an explosion in the volume of openly available source code, coupled with metadata that relate to a variety of software development activities. As an effect, in line with recent advances in machine learning research, software maintenance activities are switching from symbolic formal methods to data-driven methods. In this context, the rich semantics hidden in source code identifiers provide opportunities for building semantic representations of code which can assist tasks of code search and reuse. To this end, we deliver in the form of pretrained vector space models, distributed code representations for six popular programming languages, namely, Java, Python, PHP, C, C++, and C#. The models are produced using fastText, a state-of-the-art library for learning word representations. Each model is trained on data from a single programming language; the code mined for producing all models amounts to over 13.000 repositories. We indicate dissimilarities between natural language and source code, as well as variations in coding conventions in between the different programming languages we processed. We describe how these heterogeneities guided the data preprocessing decisions we took and the selection of the training parameters in the released models. Finally, we propose potential applications of the models and discuss limitations of the models.</p>\n", "tags": ["representation"], "tsne_embedding": [-7.110222816467285, 3.113985300064087]}, {"key": "eghbali2022crystalbleu", "year": "2022", "title": "CrystalBLEU: Precisely and Efficiently Measuring the Similarity of Code", "abstract": "<p>Recent years have brought a surge of work on predicting pieces\nof source code, e.g., for code completion, code migration, program\nrepair, or translating natural language into code. All this work faces\nthe challenge of evaluating the quality of a prediction w.r.t. some\noracle, typically in the form of a reference solution. A common\nevaluation metric is the BLEU score, an n-gram-based metric originally proposed for evaluating natural language translation, but\nadopted in software engineering because it can be easily computed\non any programming language and enables automated evaluation at\nscale. However, a key difference between natural and programming\nlanguages is that in the latter, completely unrelated pieces of code\nmay have many common n-grams simply because of the syntactic\nverbosity and coding conventions of programming languages. We\nobserve that these trivially shared n-grams hamper the ability of\nthe metric to distinguish between truly similar code examples and\ncode examples that are merely written in the same language. This\npaper presents CrystalBLEU, an evaluation metric based on BLEU,\nthat allows for precisely and efficiently measuring the similarity of\ncode. Our metric preserves the desirable properties of BLEU, such\nas being language-agnostic, able to handle incomplete or partially\nincorrect code, and efficient, while reducing the noise caused by\ntrivially shared n-grams. We evaluate CrystalBLEU on two datasets\nfrom prior work and on a new, labeled dataset of semantically equivalent programs. Our results show that CrystalBLEU can distinguish\nsimilar from dissimilar code examples 1.9\u20134.5 times more effectively, when compared to the original BLEU score and a previously\nproposed variant of BLEU for code.</p>\n", "tags": ["evaluation"], "tsne_embedding": [-4.136614799499512, 7.767448902130127]}, {"key": "ellis2021dreamcoder", "year": "2021", "title": "DreamCoder: bootstrapping inductive program synthesis with wake-sleep library learning", "abstract": "<p>We present a system for inductive program synthesis called DreamCoder, which inputs a corpus of synthesis problems each specified by one or a few examples, and automatically derives a library of program components and a neural search policy that can be used to efficiently solve other similar synthesis problems. The library and search policy bootstrap each other iteratively through a variant of \u201cwake-sleep\u201d approximate Bayesian learning. A new refactoring algorithm based on E-graph matching identifies common sub-components across synthesized programs, building a progressively deepening library of abstractions capturing the structure of the input domain. We evaluate on eight domains including classic program synthesis areas and AI tasks such as planning, inverse graphics, and equation discovery. We show that jointly learning the library and neural search policy leads to solving more problems, and solving them more quickly.</p>\n", "tags": ["synthesis", "search"], "tsne_embedding": [16.42171859741211, 15.650626182556152]}, {"key": "elnaggar2021codetrans", "year": "2021", "title": "CodeTrans: Towards Cracking the Language of Silicon's Code Through Self-Supervised Deep Learning and High Performance Computing", "abstract": "<p>Currently, a growing number of mature natural language processing applications make people\u2019s life more convenient. Such applications are built by source code - the language in software engineering. However, the applications for understanding source code language to ease the software engineering process are under-researched. Simultaneously, the transformer model, especially its combination with transfer learning, has been proven to be a powerful technique for natural language processing tasks. These breakthroughs point out a promising direction for process source code and crack software engineering tasks. This paper describes CodeTrans - an encoder-decoder transformer model for tasks in the software engineering domain, that explores the effectiveness of encoder-decoder transformer models for six software engineering tasks, including thirteen sub-tasks. Moreover, we have investigated the effect of different training strategies, including single-task learning, transfer learning, multi-task learning, and multi-task learning with fine-tuning. CodeTrans outperforms the state-of-the-art models on all the tasks. To expedite future works in the software engineering domain, we have published our pre-trained models of CodeTrans.</p>\n", "tags": ["Transformer"], "tsne_embedding": [6.964255332946777, -1.4125064611434937]}, {"key": "feng2020codebert", "year": "2020", "title": "CodeBERT: A Pre-Trained Model for Programming and Natural Languages", "abstract": "<p>We present CodeBERT, a bimodal pre-trained model for programming language (PL) and nat-ural language (NL). CodeBERT learns general-purpose representations that support downstream NL-PL applications such as natural language codesearch, code documentation generation, etc. We develop CodeBERT with Transformer-based neural architecture, and train it with a hybrid objective function that incorporates the pre-training task of replaced token detection, which is to detect plausible alternatives sampled from generators. This enables us to utilize both bimodal data of NL-PL pairs and unimodal data, where the former provides input tokens for model training while the latter helps to learn better generators. We evaluate CodeBERT on two NL-PL applications by fine-tuning model parameters. Results show that CodeBERT achieves state-of-the-art performance on both natural language code search and code documentation generation tasks. Furthermore, to investigate what type of knowledge is learned in CodeBERT, we construct a dataset for NL-PL probing, and evaluate in a zero-shot setting where parameters of pre-trained models are fixed. Results show that CodeBERT performs better than previous pre-trained models on NL-PL probing.</p>\n", "tags": ["pretraining"], "tsne_embedding": [7.011294841766357, 0.26673299074172974]}, {"key": "fernandes2019structured", "year": "2019", "title": "Structured Neural Summarization", "abstract": "<p>Summarization of long sequences into a concise statement is a core problem in natural language processing, requiring non-trivial understanding of the input. Based on the promising results of graph neural networks on highly structured data, we develop a framework to extend existing sequence encoders with a graph component that can reason about long-distance relationships in weakly structured data such as text. In an extensive evaluation, we show that the resulting hybrid sequence-graph models outperform both pure sequence models as well as pure graph models on a range of summarization tasks.</p>\n", "tags": ["summarization", "GNN", "documentation"], "tsne_embedding": [11.047006607055664, -12.293143272399902]}, {"key": "fowkes2016parameter", "year": "2016", "title": "Parameter-Free Probabilistic API Mining across GitHub", "abstract": "<p>Existing API mining algorithms can be difficult to use as they require expensive parameter tuning and the returned set of API calls can be large, highly redundant and difficult to understand. To address this, we present PAM (Probabilistic API Miner), a near parameter-free probabilistic algorithm for mining the most interesting API call patterns. We show that PAM significantly outperforms both MAPO and UPMiner, achieving 69% test-set precision, at retrieving relevant API call sequences from GitHub. Moreover, we focus on libraries for which the developers have explicitly provided code examples, yielding over 300,000 LOC of hand-written API example code from the 967 client projects in the data set. This evaluation suggests that the hand-written examples actually have limited coverage of real API usages.</p>\n\n", "tags": ["API", "pattern mining"], "tsne_embedding": [-10.26633071899414, 13.638066291809082]}, {"key": "fowkes2017autofolding", "year": "2017", "title": "Autofolding for Source Code Summarization", "abstract": "<p>Developers spend much of their time reading and browsing source code, raising new opportunities for summarization methods. Indeed, modern code editors provide code folding, which allows one to selectively hide blocks of code. However this is impractical to use as folding decisions must be made manually or based on simple rules. We introduce the\nautofolding problem, which is to automatically create a code summary by folding less informative code regions. We present a novel solution by formulating the problem as a sequence of AST folding decisions, leveraging a scoped topic model for code tokens. On an annotated set of popular open source projects, we show that our summarizer outperforms simpler baselines, yielding a 28% error reduction. Furthermore, we find through a case study that our summarizer is strongly preferred by experienced developers. More broadly, we hope this work will aid program comprehension by turning code folding into a usable and valuable tool.</p>\n", "tags": ["summarization"], "tsne_embedding": [6.391695976257324, -8.716781616210938]}, {"key": "franks2015cacheca", "year": "2015", "title": "CACHECA: A Cache Language Model Based Code Suggestion Tool", "abstract": "<p>Nearly every Integrated Development Environment includes a form of code completion. The suggested completions (\u201csuggestions\u201d) are typically based on information available at compile time, such as type signatures and variables in scope. A statistical approach, based on estimated models of code patterns in large code corpora, has been demonstrated to be effective at predicting tokens given a context. In this demo, we present CACHECA, an Eclipse plugin that combines the native suggestions with a statistical suggestion regime. We demonstrate that a combination of the two approaches more than doubles Eclipse\u2019s suggestion accuracy. A video demonstration is available at <a href=\"https://www.youtube.com/watch?v=3INk0N3JNtc\">https://www.youtube.com/watch?v=3INk0N3JNtc</a>.</p>\n", "tags": ["language model"], "tsne_embedding": [0.7374308109283447, 10.75999927520752]}, {"key": "fried2022incoder", "year": "2022", "title": "InCoder: A Generative Model for Code Infilling and Synthesis", "abstract": "<p>Code is seldom written in a single left-to-right pass and is instead repeatedly edited and refined. We introduce InCoder, a unified generative model that can perform program synthesis (via left-to-right generation) as well as editing (via infilling). InCoder is trained to generate code files from a large corpus of permissively licensed code, where regions of code have been randomly masked and moved to the end of each file, allowing code infilling with bidirectional context. Our model is the first generative model that is able to directly perform zero-shot code infilling, which we evaluate on challenging tasks such as type inference, comment generation, and variable re-naming. We find that the ability to condition on bidirectional context substantially improves performance on these tasks, while still performing comparably on standard program synthesis benchmarks in comparison to left-to-right only models pretrained at similar scale. The InCoder models and code are publicly released at https://sites.google.com/view/incoder-code-models</p>\n", "tags": ["Transformer", "code generation", "naming", "summarization"], "tsne_embedding": [15.899864196777344, 11.009075164794922]}, {"key": "fu2019coda", "year": "2019", "title": "Coda: An End-to-End Neural Program Decompiler", "abstract": "<p>Reverse engineering of binary executables is a critical problem in the computer security domain. On the one hand, malicious parties may recover interpretable source codes from the software products to gain commercial advantages. On the other hand, binary decompilation can be leveraged for code vulnerability analysis and malware detection. However, efficient binary decompilation is challenging. Conventional decompilers have the following major limitations: (i) they are only applicable to specific source-target language pair, hence incurs undesired development cost for new language tasks; (ii) their output high-level code cannot effectively preserve the correct functionality of the input binary; (iii) their output program does not capture the semantics of the input and the reversed program is hard to interpret. To address the above problems, we propose Coda1, the first end-to-end neural-based framework for code decompilation. Coda decomposes the decompilation task into of two key phases: First, Coda employs an instruction type-aware encoder and a tree decoder for generating an abstract syntax tree (AST) with attention feeding during the code sketch generation stage. Second, Coda then updates the code sketch using an iterative error correction machine guided by an ensembled neural error predictor. By finding a good approximate candidate and then fixing it towards perfect, Coda achieves superior with performance compared to baseline approaches. We assess Coda\u2019s performance with extensive experiments on various benchmarks. Evaluation results show that Coda achieves an average of 82% program recovery accuracy on unseen binary samples, where the state-of-the-art decompilers yield 0% accuracy. Furthermore, Coda outperforms the sequence-to-sequence model with attention by a margin of 70% program accuracy. Our work reveals the vulnerability of binary executables and imposes a new threat to the protection of Intellectual Property (IP) for software development.</p>\n", "tags": ["decompilation"], "tsne_embedding": [4.408936977386475, 17.76947784423828]}, {"key": "gao2019neural", "year": "2019", "title": "A Neural Model for Method Name Generation from Functional Description", "abstract": "<p>The names of software artifacts, e.g., method names, are important for software understanding and maintenance, as good names can help developers easily understand others\u2019 code. However, the existing naming guidelines are difficult for developers, especially novices, to come up with meaningful, concise and compact names for the variables, methods, classes and files. With the popularity of open source, an enormous amount of project source code can be accessed, and the exhaustiveness and instability of manually naming methods could now be relieved by automatically learning a naming model from a large code repository. Nevertheless, building a comprehensive naming system is still challenging, due to the gap between natural language functional descriptions and method names. Specifically, there are three challenges: how to model the relationship between the functional descriptions and formal method names, how to handle the explosion of vocabulary when dealing with large repositories, and how to leverage the knowledge learned from large repositories to a specific project. To answer these questions, we propose a neural network to directly generate readable method names from natural language description. The proposed method is built upon the encoder-decoder framework with the attention and copying mechanisms. Our experiments show that our method can generate meaningful and accurate method names and achieve significant improvement over the state-of-the-art baseline models. We also address the cold-start problem using a training trick to utilize big data in GitHub for specific projects.</p>\n", "tags": ["naming", "summarization"], "tsne_embedding": [-4.1538777351379395, 1.1957954168319702]}, {"key": "garg2022deepperf", "year": "2022", "title": "DeepPERF: A Deep Learning-Based Approach For Improving Software Performance", "abstract": "<p>Improving software performance is an important yet challenging part of the software development cycle. Today, the majority of performance inefficiencies are identified and patched by performance experts. Recent advancements in deep learning approaches and the wide-spread availability of open source data creates a great opportunity to automate the identification and patching of performance problems. In this paper, we present DeepPERF, a transformer-based approach to suggest performance improvements for C# applications. We pretrain DeepPERF on English and Source code corpora and followed by finetuning for the task of generating performance improvement patches for C# applications. Our evaluation shows that our model can generate the same performance improvement suggestion as the developer fix in ~53% of the cases, getting ~34% of them verbatim in our expert-verified dataset of performance changes made by C# developers. Additionally, we evaluate DeepPERF on 50 open source C# repositories on GitHub using both benchmark and unit tests and find that our model is able to suggest valid performance improvements that can improve both CPU usage and Memory allocations. So far we\u2019ve submitted 19 pull-requests with 28 different performance optimizations and 11 of these PRs have been approved by the project owners.</p>\n", "tags": ["Transformer", "optimization"], "tsne_embedding": [5.962279796600342, -24.293231964111328]}, {"key": "gholamian2021naturalness", "year": "2021", "title": "On the Naturalness and Localness of Software Logs", "abstract": "<p>Logs are an essential part  of  the  development  and\nmaintenance  of  large  and  complex  software  systems  as  they\ncontain rich information pertaining to the dynamic content and\nstate  of  the  system.  As  such,  developers  and  practitioners  rely\nheavily  on  the  logs  to  monitor  their  systems.  In  parallel,  the\nincreasing  volume  and  scale  of  the  logs,  due  to  the  growing\ncomplexity  of  modern  software  systems,  renders  the  traditional\nway  of  manual  log  inspection  insurmountable.  Consequently,  to\nhandle  large  volumes  of  logs  efficiently  and  effectively,  various\nprior research aims to automate the analysis of log files. Thus, in\nthis paper, we begin with the hypothesis that log files are natural\nand local and these attributes can be applied for automating log\nanalysis tasks. We guide our research with six research questions\nwith regards to the naturalness and localness of the log files, and\npresent  a  case  study  on  anomaly  detection  and  introduce  a  tool\nfor anomaly detection, called ANALOG, to demonstrate how our\nnew  findings  facilitate  the  automated  analysis  of  logs.</p>\n", "tags": ["logging", "language model"], "tsne_embedding": [-16.494535446166992, -15.459939956665039]}, {"key": "glassman2015overcode", "year": "2015", "title": "OverCode: visualizing variation in student solutions to programming problems at scale", "abstract": "<p>In MOOCs, a single programming exercise may produce thousands of solutions from learners. Understanding solution variation is important for providing appropriate feedback to students at scale. The wide variation among these solutions can be a source of pedagogically valuable examples and can be used to refine the autograder for the exercise by exposing corner cases. We present OverCode, a system for visualizing and exploring thousands of programming solutions. OverCode uses both static and dynamic analysis to cluster similar solutions, and lets teachers further filter and cluster solutions based on different criteria. We evaluated OverCode against a nonclustering baseline in a within-subjects study with 24 teaching assistants and found that the OverCode interface allows teachers to more quickly develop a high-level view of students\u2019 understanding and misconceptions, and to provide feedback that is relevant to more students\u2019 solutions.</p>\n", "tags": ["repair"], "tsne_embedding": [19.546640396118164, 22.808650970458984]}, {"key": "goens2019case", "year": "2019", "title": "A case study on machine learning for synthesizing benchmarks", "abstract": "<p>Good benchmarks are hard to find because they require a substantial effort to keep them representative for the constantly changing challenges of a particular field. Synthetic benchmarks are a common approach to deal with this, and methods from machine learning are natural candidates for synthetic benchmark generation. In this paper we investigate the usefulness of machine learning in the prominent CLgen benchmark generator. We re-evaluate CLgen by comparing the benchmarks generated by the model with the raw data used to train it. This re-evaluation indicates that, for the use case considered, machine learning did not yield additional benefit over a simpler method using the raw data. We investigate the reasons for this and provide further insights into the challenges the problem could pose for potential future generators.</p>\n", "tags": ["code generation"], "tsne_embedding": [13.447332382202148, 15.673482894897461]}, {"key": "gros2020code", "year": "2020", "title": "Code to Comment \"Translation\": Data, Metrics, Baselining & Evaluation", "abstract": "<p>The relationship of comments to code, and in particular, the task of generating useful comments given the code, has long been of interest. The earliest approaches have been based on strong syntactic theories of comment-structures, and relied on textual templates. More recently, researchers have applied deep learning methods to this task, and specifically, trainable generative translation models which are known to work very well for Natural Language translation (e.g., from German to English). We carefully examine the underlying assumption here: that the task of generating comments sufficiently resembles the task of translating between natural languages, and so similar models and evaluation metrics could be used. We analyze several recent code-comment datasets for this task: CodeNN, DeepCom, FunCom, and DocString. We compare them with WMT19, a standard dataset frequently used to train state of the art natural language translators. We found some interesting differences between the code-comment data and the WMT19 natural language data. Next, we describe and conduct some studies to calibrate BLEU (which is commonly used as a measure of comment quality). using \u201caffinity pairs\u201d of methods, from different projects, in the same project, in the same class, etc; Our study suggests that the current performance on some datasets might need to be improved substantially. We also argue that fairly naive information retrieval (IR) methods do well enough at this task to be considered a reasonable baseline. Finally, we make some suggestions on how our findings might be used in future research in this area.</p>\n", "tags": ["bimodal", "documentation"], "tsne_embedding": [5.3319501876831055, 2.5774104595184326]}, {"key": "gu2016deep", "year": "2016", "title": "Deep API Learning", "abstract": "<p>Developers often wonder how to implement a certain functionality (e.g., how to parse XML files) using APIs. Obtaining an API usage sequence based on an API-related natural language query is very helpful in this regard. Given a query, existing approaches utilize information retrieval models to search for matching API sequences. These approaches treat queries and APIs as bag-of-words (i.e., keyword matching or word-to-word alignment) and lack a deep understanding of the semantics of the query.</p>\n\n<p>We propose DeepAPI, a deep learning based approach to generate API usage sequences for a given natural language query. Instead of a bags-of-words assumption, it learns the\nsequence of words in a query and the sequence of associated APIs. DeepAPI adapts a neural language model named RNN Encoder-Decoder. It encodes a word sequence (user query) into a fixed-length context vector, and generates an API sequence based on the context vector. We also augment the RNN Encoder-Decoder by considering the importance of individual APIs. We empirically evaluate our approach with more than 7 million annotated code snippets collected from GitHub. The results show that our approach generates largely accurate API sequences and outperforms the related approaches.</p>\n\n", "tags": ["API", "search"], "tsne_embedding": [-18.7464656829834, 6.329680442810059]}, {"key": "gu2017deepam", "year": "2017", "title": "DeepAM: Migrate APIs with Multi-modal Sequence to Sequence Learning", "abstract": "<p>Computer programs written in one language are often required to be ported to other languages to support multiple devices and environments. When programs use language specific APIs (Application Programming Interfaces), it is very challenging to migrate these APIs to the corresponding APIs written in other languages. Existing approaches mine API mappings from projects that have corresponding versions in two languages. They rely on the sparse availability of bilingual projects, thus producing a limited number of API mappings. In this paper, we propose an intelligent system called DeepAM for automatically mining API mappings from a large-scale code corpus without bilingual projects. The key component of DeepAM is based on the multimodal sequence to sequence learning architecture that aims to learn joint semantic representations of bilingual API sequences from big source code data. Experimental results indicate that DeepAM significantly increases the accuracy of API mappings as well as the number of API mappings, when compared with the state-of-the-art approaches.</p>\n", "tags": ["API"], "tsne_embedding": [-9.406251907348633, 6.744251251220703]}, {"key": "gu2018deep", "year": "2018", "title": "Deep Code Search", "abstract": "<p>To implement a program functionality, developers can reuse previously written code snippets by searching through a large-scale codebase. Over the years, many code search tools have been proposed to help developers. The existing approaches often treat source code as textual documents and utilize information retrieval models to retrieve relevant code snippets that match a given query. These approaches mainly rely on the textual similarity between source code and natural language query. They lack a deep understanding of the semantics of queries and source code.</p>\n\n<p>In this paper, we propose a novel deep neural network named CODEnn (Code-Description Embedding Neural Network). Instead of matching text similarity, CODEnn jointly embeds code snippets and natural language descriptions into a high-dimensional vector space, in such a way that code snippet and its corresponding description have similar vectors. Using the unified vector representation, code snippets related to a natural language query can be retrieved according to their vectors. Semantically related words can also be recognized and irrelevant/noisy keywords in queries can be handled.</p>\n\n<p>As a proof-of-concept application, we implement a code search tool named DeepCS using the proposed CODEnn model. We empirically evaluate DeepCS on a large scale codebase collected from GitHub. The experimental results show that our approach can effectively retrieve relevant code snippets and outperforms previous techniques.</p>\n\n", "tags": ["search"], "tsne_embedding": [-15.75903034210205, 5.083855152130127]}, {"key": "gui2022cross", "year": "2022", "title": "Cross-Language Binary-Source Code Matching with Intermediate Representations", "abstract": "<p>Binary-source code matching plays an important role in many security and software engineering related tasks such as malware detection, reverse engineering and vulnerability assessment. Currently, several approaches have been proposed for binary-source code matching by jointly learning the embeddings of binary code and source code in a common vector space. Despite much effort, existing approaches target on matching the binary code and source code written in a single programming language. However, in practice, software applications are often written in different programming languages to cater for different requirements and computing platforms. Matching binary and source code across programming languages introduces additional challenges when maintaining multi-language and multi-platform applications. To this end, this paper formulates the problem of cross-language binary-source code matching, and develops a new dataset for this new problem. We present a novel approach XLIR, which is a Transformer-based neural network by learning the intermediate representations for both binary and source code. To validate the effectiveness of XLIR, comprehensive experiments are conducted on two tasks of cross-language binary-source code matching, and cross-language source-source code matching, on top of our curated dataset. Experimental results and analysis show that our proposed XLIR with intermediate representations significantly outperforms other state-of-the-art models in both of the two tasks.</p>\n", "tags": ["code similarity", "clone"], "tsne_embedding": [-14.734819412231445, -7.467597961425781]}, {"key": "gulwani2014nlyze", "year": "2014", "title": "NLyze: Interactive Programming by Natural Language for SpreadSheet Data Analysis and Manipulation", "abstract": "<p>Millions of computer end users need to perform tasks over tabular spreadsheet data, yet lack the programming knowledge to do such tasks automatically. This paper describes\nthe design and implementation of a robust natural language\nbased interface to spreadsheet programming. Our methodology involves designing a typed domain-specific language\n(DSL) that supports an expressive algebra of map, filter, reduce, join, and formatting capabilities at a level of abstraction appropriate for non-expert users. The key algorithmic\ncomponent of our methodology is a translation algorithm\nfor converting a natural language specification in the context of a given spreadsheet to a ranked set of likely programs\nin the DSL. The translation algorithm leverages the spreadsheet spatial and temporal context to assign interpretations\nto specifications with implicit references, and is thus robust\nto a variety of ways in which end users can express the same\ntask. The translation algorithm builds over ideas from keyword programming and semantic parsing to achieve both\nhigh precision and high recall. We implemented the system\nas an Excel add-in called NLyze that supports a rich user\ninteraction model including annotating the user\u2019s natural\nlanguage specification and explaining the synthesized DSL\nprograms by paraphrasing them into structured English. We\ncollected a total of 3570 English descriptions for 40 spreadsheet tasks and our system was able to generate the intended\ninterpretation as the top candidate for 94% (97% for the top\n3) of those instances.</p>\n\n", "tags": ["code generation", "bimodal", "synthesis"], "tsne_embedding": [21.48685646057129, 12.113261222839355]}, {"key": "guo2017semantically", "year": "2017", "title": "Semantically enhanced software traceability using deep learning techniques", "abstract": "<p>In most safety-critical domains the need for traceability is prescribed by certifying bodies. Trace links are generally created among requirements, design, source code, test cases and other artifacts; however, creating such links manually is time consuming and error prone. Automated solutions use information retrieval and machine learning techniques to generate trace links; however, current techniques fail to understand semantics of the software artifacts or to integrate domain knowledge into the tracing process and therefore tend to deliver imprecise and inaccurate results. In this paper, we present a solution that uses deep learning to incorporate requirements artifact semantics and domain knowledge into the tracing solution. We propose a tracing network architecture that utilizes Word Embedding and Recurrent Neural Network (RNN) models to generate trace links. Word embedding learns word vectors that represent knowledge of the domain corpus and RNN uses these word vectors to learn the sentence semantics of requirements artifacts. We trained 360 different configurations of the tracing network using existing trace links in the Positive Train Control domain and identified the Bidirectional Gated Recurrent Unit (BI-GRU) as the best model for the tracing task. BI-GRU significantly out-performed state-of-the-art tracing methods including the Vector Space Model and Latent Semantic Indexing.</p>\n", "tags": ["traceability", "representation"], "tsne_embedding": [-0.9554259181022644, -2.7077741622924805]}, {"key": "guo2020graphcodebert", "year": "2020", "title": "GraphCodeBERT: Pre-training Code Representations with Data Flow", "abstract": "<p>Pre-trained models for programming language have achieved dramatic empirical improvements on a variety of code-related tasks such as code search, code completion, code summarization, etc. However, existing pre-trained models regard a code snippet as a sequence of tokens, while ignoring the inherent structure of code, which provides crucial code semantics and would enhance the code understanding process. We present GraphCodeBERT, a pre-trained model for programming language that considers the inherent structure of code. Instead of taking syntactic-level structure of code like abstract syntax tree (AST), we use data flow in the pre-training stage, which is a semantic-level structure of code that encodes the relation of \u201cwhere-the-value-comes-from\u201d between variables. Such a semantic-level structure is neat and does not bring an unnecessarily deep hierarchy of AST, the property of which makes the model more efficient. We develop GraphCodeBERT based on Transformer. In addition to using the task of masked language modeling, we introduce two structure-aware pre-training tasks. One is to predict code structure edges, and the other is to align representations between source code and code structure. We implement the model in an efficient way with a graph-guided masked attention function to incorporate the code structure. We evaluate our model on four tasks, including code search, clone detection, code translation, and code refinement. Results show that code structure and newly introduced pre-training tasks can improve GraphCodeBERT and achieves state-of-the-art performance on the four downstream tasks. We further show that the model prefers structure-level attentions over token-level attentions in the task of code search.</p>\n", "tags": ["pretraining"], "tsne_embedding": [3.7513747215270996, -1.463058352470398]}, {"key": "guo2022learning", "year": "2022", "title": "Learning to Complete Code with Sketches", "abstract": "<p>Code completion is usually cast as a language modelling problem, i.e., continuing an input in a left-to-right fashion. However, in practice, some parts of the completion (e.g., string literals) may be very hard to predict, whereas subsequent parts directly follow from the context. To handle this, we instead consider the scenario of generating code completions with \u201choles\u201d inserted in places where a model is uncertain. We develop Grammformer, a Transformer-based model that guides code generation by the programming language grammar, and compare it to a variety of more standard sequence models.</p>\n\n<p>We train the models on code completion for C# and Python given partial code context. To evaluate models, we consider both ROUGE as well as a new metric RegexAcc that measures success of generating completions matching long outputs with as few holes as possible. In our experiments, Grammformer generates 10-50% more accurate completions compared to traditional generative models and 37-50% longer sketches compared to sketch-generating baselines trained with similar techniques.</p>\n", "tags": ["Transformer", "language model", "grammar"], "tsne_embedding": [2.6664249897003174, 10.419408798217773]}, {"key": "guo2022unixcoder", "year": "2022", "title": "UniXcoder: Unified Cross-Modal Pre-training for Code Representation", "abstract": "<p>Pre-trained models for programming languages have recently demonstrated great success on code intelligence. To support both code-related understanding and generation tasks, recent works attempt to pre-train unified encoder-decoder models. However, such encoder-decoder framework is sub-optimal for auto-regressive tasks, especially code completion that requires a decoder-only manner for efficient inference. In this paper, we present UniXcoder, a unified cross-modal pre-trained model for programming language. The model utilizes mask attention matrices with prefix adapters to control the behavior of the model and leverages cross-modal contents like AST and code comment to enhance code representation. To encode AST that is represented as a tree in parallel, we propose a one-to-one mapping method to transform AST in a sequence structure that retains all structural information from the tree. Furthermore, we propose to utilize multi-modal contents to learn representation of code fragment with contrastive learning, and then align representations among programming languages using a cross-modal generation task. We evaluate UniXcoder on five code-related tasks over nine datasets. To further evaluate the performance of code fragment representation, we also construct a dataset for a new task, called zero-shot code-to-code search. Results show that our model achieves state-of-the-art performance on most tasks and analysis reveals that comment and AST can both enhance UniXcoder.</p>\n", "tags": ["Transformer"], "tsne_embedding": [4.3347063064575195, -2.6972122192382812]}, {"key": "gupta2017deepfix", "year": "2017", "title": "DeepFix: Fixing Common C Language Errors by Deep Learning", "abstract": "<p>The problem of automatically fixing programming errors is a\nvery active research topic in software engineering. This is a\nchallenging problem as fixing even a single error may require\nanalysis of the entire program. In practice, a number of errors\narise due to programmer\u2019s inexperience with the programming language or lack of attention to detail. We call these\ncommon programming errors. These are analogous to grammatical errors in natural languages. Compilers detect such errors, but their error messages are usually inaccurate. In this\nwork, we present an end-to-end solution, called DeepFix, that\ncan fix multiple such errors in a program without relying on\nany external tool to locate or fix them. At the heart of DeepFix\nis a multi-layered sequence-to-sequence neural network with\nattention which is trained to predict erroneous program locations along with the required correct statements. On a set of\n6971 erroneous C programs written by students for 93 programming tasks, DeepFix could fix 1881 (27%) programs\ncompletely and 1338 (19%) programs partially.</p>\n", "tags": ["repair", "code generation"], "tsne_embedding": [-5.712907791137695, -24.92090606689453]}, {"key": "gupta2018deep", "year": "2018", "title": "Deep Reinforcement Learning for Programming Language Correction", "abstract": "<p>Novice programmers often struggle with the formal\nsyntax of programming languages.  To assist them,\nwe design a novel programming language correction  framework  amenable  to  reinforcement  learning.  The framework allows an agent to mimic human  actions  for  text  navigation  and  editing.   We\ndemonstrate that the agent can be trained through\nself-exploration directly from the raw input, that is,\nprogram text itself, without any knowledge of the\nformal syntax of the programming language.   We\nleverage expert demonstrations for one tenth of the\ntraining data to accelerate training.  The proposed\ntechnique  is  evaluated  on 6975\nerroneous  C  programs with typographic errors, written by students\nduring an introductory programming course.  Our\ntechnique fixes 14%\nmore programs and 29% more\ncompiler error messages relative to those fixed by\na state-of-the-art tool, DeepFix, which uses a fully\nsupervised neural machine translation approach.</p>\n", "tags": ["repair", "code generation"], "tsne_embedding": [-5.454510688781738, -25.766143798828125]}, {"key": "gupta2018intelligent", "year": "2018", "title": "Intelligent code reviews using deep learning", "abstract": "<p>Peer code review is a best practice in Software Engineering where source code is reviewed manually by one or more peers(reviewers) of the code author. It is widely acceptable both in industry and open-source software (OSS) systems as a process for early detection and reduction of software defects. A larger chunk of reviews given during peer reviews are related to common issues such as coding style, documentations, and best practices. This makes the code review process less effective as reviewers focus less on finding important defects. Hence, there is a need to automatically find such common issues and help reviewers perform focused code reviews. Some of this is solved by rule based systems called linters but they are rigid and needs a lot of manual effort to adapt them for a new issue.</p>\n\n<p>In this work, we present an automatic, flexible, and adaptive code analysis system called DeepCodeReviewer (DCR). DCR learns how to recommend code reviews related to common issues using historical peer reviews and deep learning. DCR uses deep learning to learn review relevance to a code snippet and recommend the right review from a repository of common reviews. DCR is trained on histroical peer reviews available from internal code repositories at Microsoft. Experiments demonstrate strong performance of developed deep learning model in classifying relevant and non-relevant reviews w.r.t to a code snippet, and ranking reviews given a code snippet. We have also evaluated DCR recommentations using a user study and survey. The results of our user study show good acceptance rate and answers of our survey questions are strongly correlated with our system\u2019s goal of making code reviews focused on finding defects.</p>\n", "tags": ["representation", "review"], "tsne_embedding": [-1.2115365266799927, -13.067279815673828]}, {"key": "gupta2019neural", "year": "2019", "title": "Neural Attribution for Semantic Bug-Localization in Student Programs", "abstract": "<p>Providing feedback is an integral part of teaching. Most open online courses on programming make use of automated grading systems to support programming assignments and give real-time feedback. These systems usually rely on test results to quantify the programs\u2019 functional correctness. They return failing tests to the students as feedback. However, students may find it difficult to debug their programs if they receive no hints about where the bug is and how to fix it. In this work, we present NeuralBugLocator, a deep learning based technique, that can localize the bugs in a faulty program with respect to a failing test, without even running the program. At the heart of our technique is a novel tree convolutional neural network which is trained to predict whether a program passes or fails a given test. To localize the bugs, we analyze the trained network using a state-of-the-art neural prediction attribution technique and see which lines of the programs make it predict the test outcomes. Our experiments show that NeuralBugLocator is generally more accurate than two state-of-the-art program-spectrum based and one syntactic difference based bug-localization baselines.</p>\n", "tags": ["defect", "representation"], "tsne_embedding": [-10.54615592956543, -16.446767807006836]}, {"key": "gvero2015synthesizing", "year": "2015", "title": "Synthesizing Java expressions from free-form queries", "abstract": "<p>We present a new code assistance tool for integrated development environments. Our system accepts as input free-form queries containing a mixture of English and Java, and produces Java code expressions that take the query into account and respect syntax, types, and scoping rules of Java, as well as statistical usage patterns. In contrast to solutions based on code search, the results returned by our tool need not directly correspond to any previously seen code fragment. As part of our system we have constructed a probabilistic context free grammar for Java constructs and library invocations, as well as an algorithm that uses a customized natural language processing tool chain to extract information from free-form text queries. We present the results on a number of examples showing that our technique (1) often produces the expected code fragments, (2) tolerates much of the flexibility of natural language, and (3) can repair incorrect Java expressions that use, for example, the wrong syntax or missing arguments.</p>\n", "tags": ["synthesis", "code generation", "bimodal"], "tsne_embedding": [-2.3427090644836426, 11.163572311401367]}, {"key": "habib2019neural", "year": "2019", "title": "Neural Bug Finding: A Study of Opportunities and Challenges", "abstract": "<p>Static analysis is one of the most widely adopted techniques to find software bugs before code is put in production. Designing and implementing effective and efficient static analyses is difficult and requires high expertise, which results in only a few experts able to write such analyses. This paper explores the opportunities and challenges of an alternative way of creating static bug detectors: neural bug finding. The basic idea is to formulate bug detection as a classification problem, and to address this problem with neural networks trained on examples of buggy and non-buggy code. We systematically study the effectiveness of this approach based on code examples labeled by a state-of-the-art, static bug detector. Our results show that neural bug finding is surprisingly effective for some bug patterns, sometimes reaching a precision and recall of over 80%, but also that it struggles to understand some program properties obvious to a traditional analysis. A qualitative analysis of the results provides insights into why neural bug finders sometimes work and sometimes do not work. We also identify pitfalls in selecting the code examples used to train and validate neural bug finders, and propose an algorithm for selecting effective training data.</p>\n", "tags": ["program analysis"], "tsne_embedding": [-10.331966400146484, -15.400602340698242]}, {"key": "hajipour2019samplefix", "year": "2019", "title": "SampleFix: Learning to Correct Programs by Sampling Diverse Fixes", "abstract": "<p>Automatic program correction is an active topic of research, which holds the potential of dramatically improving productivity of programmers during the software development process and correctness of software in general. Recent advances in machine learning, deep learning and NLP have rekindled the hope to eventually fully automate the process of repairing programs. A key challenges is ambiguity, as multiple codes \u2013 or fixes \u2013 can implement the same functionality. In addition, dataset by nature fail to capture the variance introduced by such ambiguities. Therefore, we propose a deep generative model to automatically correct programming errors by learning a distribution of potential fixes. Our model is formulated as a deep conditional variational autoencoder that samples diverse fixes for the given erroneous programs. In order to account for ambiguity and inherent lack of representative datasets, we propose a novel regularizer to encourage the model to generate diverse fixes. Our evaluations on common programming errors show for the first time the generation of diverse fixes and strong improvements over the state-of-the-art approaches by fixing up to 61% of the mistakes.</p>\n", "tags": ["repair", "code generation"], "tsne_embedding": [-5.948396682739258, -24.29443359375]}, {"key": "haldar2020multiperspective", "year": "2020", "title": "A Multi-Perspective Architecture for Semantic Code Search", "abstract": "<p>The ability to match pieces of code to their corresponding natural language descriptions and vice versa is fundamental for natural language search interfaces to software repositories. In this paper, we propose a novel multi-perspective cross-lingual neural framework for code\u2013text matching, inspired in part by a previous model for monolingual text-to-text matching, to capture both global and local similarities. Our experiments on the CoNaLa dataset show that our proposed model yields better performance on this cross-lingual text-to-code matching task than previous approaches that map code and text to a single joint embedding space.</p>\n", "tags": ["search"], "tsne_embedding": [-15.179193496704102, 3.543656349182129]}, {"key": "haque2020improved", "year": "2020", "title": "Improved Automatic Summarization of Subroutines via Attention to File Context", "abstract": "<p>Software documentation largely consists of short, natural language summaries of the subroutines in the software. These summaries help programmers quickly understand what a subroutine does without having to read the source code him or herself. The task of writing these descriptions is called \u201csource code summarization\u201d and has been a target of research for several years. Recently, AI-based approaches have superseded older, heuristic-based approaches. Yet, to date these AI-based approaches assume that all the content needed to predict summaries is inside subroutine itself. This assumption limits performance because many subroutines cannot be understood without surrounding context. In this paper, we present an approach that models the file context of subroutines (i.e. other subroutines in the same file) and uses an attention mechanism to find words and concepts to use in summaries. We show in an experiment that our approach extends and improves several recent baselines.</p>\n", "tags": ["summarization"], "tsne_embedding": [7.230151653289795, -9.258594512939453]}, {"key": "haque2022semantic", "year": "2022", "title": "Semantic Similarity Metrics for Evaluating Source Code Summarization", "abstract": "<p>Source code summarization involves creating brief descriptions of source code in natural language. These descriptions are a key component of software documentation such as JavaDocs. Automatic code summarization is a prized target of software engineering research, due to the high value summaries have to programmers and the simultaneously high cost of writing and maintaining documentation by hand. Current work is almost all based on machine models trained via big data input. Large datasets of examples of code and summaries of that code are used to train an e.g. encoder-decoder neural model. Then the output predictions of the model are evaluated against a set of reference summaries. The input is code not seen by the model, and the prediction is compared to a reference. The means by which a prediction is compared to a reference is essentially word overlap, calculated via a metric such as BLEU or ROUGE. The problem with using word overlap is that not all words in a sentence have the same importance, and many words have synonyms. The result is that calculated similarity may not match the perceived similarity by human readers. In this paper, we conduct an experiment to measure the degree to which various word overlap metrics correlate to human-rated similarity of predicted and reference summaries. We evaluate alternatives based on current work in semantic similarity metrics and propose recommendations for evaluation of source code summarization.</p>\n", "tags": ["human evaluation", "evaluation"], "tsne_embedding": [-3.609511137008667, 5.970107555389404]}, {"key": "harer2018learning", "year": "2018", "title": "Learning to Repair Software Vulnerabilities with Generative Adversarial Networks", "abstract": "<p>Motivated by the problem of automated repair of software vulnerabilities, we propose an adversarial learning approach that maps from one discrete source domain to another target domain without requiring paired labeled examples or source and target domains to be bijections. We demonstrate that the proposed adversarial learning approach is an effective technique for repairing software vulnerabilities, performing close to seq2seq approaches that require labeled pairs. The proposed Generative Adversarial Network approach is application-agnostic in that it can be applied to other problems similar to code repair, such as grammar correction or sentiment translation.</p>\n", "tags": ["repair", "code generation"], "tsne_embedding": [-4.564173221588135, -22.366193771362305]}, {"key": "hashimoto2018retrieve", "year": "2018", "title": "A Retrieve-and-Edit Framework for Predicting Structured Outputs", "abstract": "<p>For the task of generating complex outputs such as source code, editing existing\noutputs can be easier than generating complex outputs from scratch.  With this\nmotivation, we propose an approach that first retrieves a training example based on\nthe input (e.g., natural language description) and then edits it to the desired output\n(e.g., code). Our contribution is a computationally efficient method for learning\na retrieval model that embeds the input in a task-dependent way without relying\non a hand-crafted metric or incurring the expense of jointly training the retriever\nwith the editor.  Our retrieve-and-edit framework can be applied on top of any\nbase model. We show that on a new autocomplete task for GitHub Python code\nand the Hearthstone cards benchmark, retrieve-and-edit significantly boosts the\nperformance of a vanilla sequence-to-sequence model on both tasks.</p>\n", "tags": ["bimodal", "search", "code generation"], "tsne_embedding": [6.247818946838379, -14.829292297363281]}, {"key": "hata2018learning", "year": "2018", "title": "Learning to Generate Corrective Patches using Neural Machine Translation", "abstract": "<p>Bug fixing is generally a manually-intensive task. However, recent work has proposed the idea of automated program repair, which aims to repair (at least a subset of) bugs in different ways such as code mutation, etc. Following in the same line of work as automated bug repair, in this paper we aim to leverage past fixes to propose fixes of current/future bugs. Specifically, we propose Ratchet, a corrective patch generation system using neural machine translation. By learning corresponding pre-correction and post-correction code in past fixes with a neural sequence-to-sequence model, Ratchet is able to generate a fix code for a given bug-prone code query. We perform an empirical study with five open source projects, namely Ambari, Camel, Hadoop, Jetty and Wicket, to evaluate the effectiveness of Ratchet. Our findings show that Ratchet can generate syntactically valid statements 98.7% of the time, and achieve an F1-measure between 0.41-0.83 with respect to the actual fixes adopted in the code base. In addition, we perform a qualitative validation using 20 participants to see whether the generated statements can be helpful in correcting bugs. Our survey showed that Ratchet\u2019s output was considered to be helpful in fixing the bugs on many occasions, even if fix was not 100% correct.</p>\n", "tags": ["repair", "code generation"], "tsne_embedding": [-5.607941627502441, -20.59916877746582]}, {"key": "hazoom2021text", "year": "2021", "title": "Text-to-SQL in the Wild: A Naturally-Occurring Dataset Based on Stack Exchange Data", "abstract": "<p>Most available semantic parsing datasets, comprising of pairs of natural utterances and logical forms, were collected solely for the purpose of training and evaluation of natural language understanding systems. As a result, they do not contain any of the richness and variety of natural-occurring utterances, where humans ask about data they need or are curious about. In this work, we release SEDE, a dataset with 12,023 pairs of utterances and SQL queries collected from real usage on the Stack Exchange website. We show that these pairs contain a variety of real-world challenges which were rarely reflected so far in any other semantic parsing dataset, propose an evaluation metric based on comparison of partial query clauses that is more suitable for real-world queries, and conduct experiments with strong baselines, showing a large gap between the performance on SEDE compared to other common datasets.</p>\n", "tags": ["dataset"], "tsne_embedding": [21.37929916381836, -2.241657257080078]}, {"key": "he2019learning", "year": "2019", "title": "Learning to Fuzz from Symbolic Execution with Application to Smart Contracts", "abstract": "<p>Fuzzing and symbolic execution are two complementary techniques for discovering software vulnerabilities. Fuzzing is fast and scalable, but can be ineffective when it fails to randomly select the right inputs. Symbolic execution is thorough but slow and often does not scale to deep program paths with complex path conditions. In this work, we propose to learn an effective and fast fuzzer from symbolic execution, by phrasing the learning task in the framework of imitation learning. During learning, a symbolic execution expert generates a large number of quality inputs improving coverage on thousands of programs. Then, a fuzzing policy, represented with a suitable architecture of neural networks, is trained on the generated dataset. The learned policy can then be used to fuzz new programs. We instantiate our approach to the problem of fuzzing smart contracts, a domain where contracts often implement similar functionality (facilitating learning) and security is of utmost importance. We present an end-to-end system, ILF (for Imitation Learning based Fuzzer), and an extensive evaluation over &gt;18K contracts. Our results show that ILF is effective: (i) it is fast, generating 148 transactions per second, (ii) it outperforms existing fuzzers (e.g., achieving 33% more coverage), and (iii) it detects more vulnerabilities than existing fuzzing and symbolic execution tools for Ethereum.</p>\n", "tags": ["fuzzing", "GNN"], "tsne_embedding": [10.216413497924805, 20.104782104492188]}, {"key": "he2021learning", "year": "2021", "title": "Learning to Find Naming Issues with Big Code and Small Supervision", "abstract": "<p>We introduce a new approach for finding and fixing naming\nissues in source code. The method is based on a careful\ncombination of unsupervised and supervised procedures: (i)\nunsupervised mining of patterns from Big Code that express\ncommon naming idioms. Program fragments violating such\nidioms indicates likely naming issues, and (ii) supervised\nlearning of a classifier on a small labeled dataset which filters\npotential false positives from the violations.</p>\n\n<p>We implemented our method in a system called\nNamer and evaluated it on a large number of Python and Java programs.\nWe demonstrate that Namer is effective in finding naming mistakes\nin real world repositories with high precision (\u223c70%).\nPerhaps surprisingly, we also show that existing deep learning methods\nare not practically effective and achieve low precision in finding naming issues (up to \u223c16%).</p>\n", "tags": ["repair"], "tsne_embedding": [-19.167339324951172, -3.456692695617676]}, {"key": "he2022distribution", "year": "2022", "title": "On Distribution Shift in Learning-based Bug Detectors", "abstract": "<p>Deep learning has recently achieved initial success in program analysis tasks such as bug detection. Lacking real bugs, most existing works construct training and test data by injecting synthetic bugs into correct programs. Despite achieving high test accuracy (e.g. &gt;90%), the resulting bug detectors are found to be surprisingly unusable in practice, i.e., &lt;10% precision when used to scan real software repositories. In this work, we argue that this massive performance difference is caused by distribution shift, i.e., a fundamental mismatch between the real bug distribution and the synthetic bug distribution used to train and evaluate the detectors. To address this key challenge, we propose to train a bug detector in two phases, first on a synthetic bug distribution to adapt the model to the bug detection domain, and then on a real bug distribution to drive the model towards the real distribution. During these two phases, we leverage a multi-task hierarchy, focal loss, and contrastive learning to further boost performance. We evaluate our approach extensively on three widely studied bug types, for which we construct new datasets carefully designed to capture the real bug distribution. The results demonstrate that our approach is practically effective and successfully mitigates the distribution shift: our learned detectors are highly performant on both our constructed test set and the latest version of open source repositories.</p>\n", "tags": ["defect"], "tsne_embedding": [-10.017012596130371, -17.91069221496582]}, {"key": "hellendoorn2015will", "year": "2015", "title": "Will they like this? Evaluating Code Contributions With Language Models", "abstract": "<p>Popular open-source software projects receive and\nreview contributions from a diverse array of developers, many\nof whom have little to no prior involvement with the project. A\nrecent survey reported that reviewers consider conformance to\nthe project\u2019s code style to be one of the top priorities when evaluating code contributions on Github. We propose to quantitatively\nevaluate the existence and effects of this phenomenon. To this aim\nwe use language models, which were shown to accurately capture\nstylistic aspects of code. We find that rejected changesets do\ncontain code significantly less similar to the project than accepted\nones; furthermore, the less similar changesets are more likely\nto be subject to thorough review. Armed with these results we\nfurther investigate whether new contributors learn to conform to\nthe project style and find that experience is positively correlated\nwith conformance to the project\u2019s code style.</p>\n", "tags": ["review", "language model"], "tsne_embedding": [-19.883010864257812, -19.674579620361328]}, {"key": "hellendoorn2017deep", "year": "2017", "title": "Are Deep Neural Networks the Best Choice for Modeling Source Code?", "abstract": "<p>Current statistical language modeling techniques, including deep-learning based models, have proven to be quite effective for source\ncode. We argue here that the special properties of source code can\nbe exploited for further improvements. In this work, we enhance\nestablished language modeling approaches to handle the special\nchallenges of modeling source code, such as: frequent changes,\nlarger, changing vocabularies, deeply nested scopes, etc. We present\na fast, nested language modeling toolkit specifically designed for\nsoftware, with the ability to add &amp; remove text, and mix &amp; swap out\nmany models. Specifically, we improve upon prior cache-modeling\nwork and present a model with a much more expansive, multi-level\nnotion of locality that we show to be well-suited for modeling\nsoftware. We present results on varying corpora in comparison\nwith traditional N -gram, as well as RNN, and LSTM deep-learning\nlanguage models, and release all our source code for public use.\nOur evaluations suggest that carefully adapting N-gram models for\nsource code can yield performance that surpasses even RNN and\nLSTM based deep-learning models.</p>\n", "tags": ["language model"], "tsne_embedding": [-0.5032984614372253, 2.39994740486145]}, {"key": "hellendoorn2018deep", "year": "2018", "title": "Deep Learning Type Inference", "abstract": "<p>Dynamically typed languages such as JavaScript and Python are\nincreasingly popular, yet static typing has not been totally eclipsed:\nPython now supports type annotations and languages like TypeScript offer a middle-ground for JavaScript: a strict superset of\nJavaScript, to which it transpiles, coupled with a type system that\npermits partially typed programs. However, static typing has a cost:\nadding annotations, reading the added syntax, and wrestling with\nthe type system to fix type errors. Type inference can ease the\ntransition to more statically typed code and unlock the benefits of\nricher compile-time information, but is limited in languages like\nJavaScript as it cannot soundly handle duck-typing or runtime evaluation\nvia eval. We propose DeepTyper, a deep learning model\nthat understands which types naturally occur in certain contexts\nand relations and can provide type suggestions, which can often\nbe verified by the type checker, even if it could not infer the type\ninitially. DeepTyper, leverages an automatically aligned corpus\nof tokens and types to accurately predict thousands of variable\nand function type annotations. Furthermore, we demonstrate that\ncontext is key in accurately assigning these types and introduce a\ntechnique to reduce overfitting on local cues while highlighting the\nneed for further improvements. Finally, we show that our model\ncan interact with a compiler to provide more than 4,000 additional\ntype annotations with over 95% precision that could not be inferred\nwithout the aid of DeepTyper.</p>\n", "tags": ["representation", "types"], "tsne_embedding": [-3.998743772506714, 23.186429977416992]}, {"key": "hellendoorn2020global", "year": "2020", "title": "Global Relational Models of Source Code", "abstract": "<p>Models of code can learn distributed representations of a program\u2019s syntax and semantics to predict many non-trivial properties of a program. Recent state-of-the-art models leverage highly structured representations of programs, such as trees, graphs and paths therein (e.g. data-flow relations), which are precise and abundantly available for code. This provides a strong inductive bias towards semantically meaningful relations, yielding more generalizable representations than classical sequence-based models. Unfortunately, these models primarily rely on graph-based message passing to represent relations in code, which makes them de facto local due to the high cost of message-passing steps, quite in contrast to modern, global sequence-based models, such as the Transformer. In this work, we bridge this divide between global and structured models by introducing two new hybrid model families that are both global and incorporate structural bias: Graph Sandwiches, which wrap traditional (gated) graph message-passing layers in sequential message-passing layers; and Graph Relational Embedding Attention Transformers (GREAT for short), which bias traditional Transformers with relational information from graph edge types. By studying a popular, non-trivial program repair task, variable-misuse identification, we explore the relative merits of traditional and hybrid model families for code representation. Starting with a  graph-based model that already improves upon the prior state-of-the-art for this task by 20%, we show that our proposed hybrid models improve an additional 10-15%, while training both faster and using fewer parameters.</p>\n", "tags": ["variable misuse", "defect", "GNN", "Transformer"], "tsne_embedding": [-5.651524543762207, -7.94791316986084]}, {"key": "henkel2020semantic", "year": "2022", "title": "Semantic Robustness of Models of Source Code", "abstract": "<p>Deep neural networks are vulnerable to adversarial examples - small input perturbations that result in incorrect predictions. We study this problem for models of source code, where we want the neural network to be robust to source-code modifications that preserve code functionality. To facilitate training robust models, we define a powerful and generic adversary that can employ sequences of parametric, semantics-preserving program transformations. We then explore how, with such an adversary, one can train models that are robust to adversarial program transformations. We conduct a thorough evaluation of our approach and find several surprising facts: we find robust training to beat dataset augmentation in every evaluation we performed; we find that a state-of-the-art architecture (code2seq) for models of code is harder to make robust than a simpler baseline; additionally, we find code2seq to have surprising weaknesses not present in our simpler baseline model; finally, we find that robust models perform better against unseen data from different sources (as one might hope) - however, we also find that robust models are not clearly better in the cross-language transfer task. To the best of our knowledge, we are the first to study the interplay between robustness of models of code and the domain-adaptation and cross-language transfer tasks.</p>\n", "tags": ["adversarial", "naming"], "tsne_embedding": [2.863356113433838, 22.04091453552246]}, {"key": "heyman2020neural", "year": "2020", "title": "Neural Code Search Revisited: Enhancing Code Snippet Retrieval through Natural Language Intent", "abstract": "<p>In this work, we propose and study annotated code search: the retrieval of code snippets paired with brief descriptions of their intent using natural language queries. On three benchmark datasets, we investigate how code retrieval systems can be improved by leveraging descriptions to better capture the intents of code snippets. Building on recent progress in transfer learning and natural language processing, we create a domain-specific retrieval model for code annotated with a natural language description. We find that our model yields significantly more relevant search results (with absolute gains up to 20.6% in mean reciprocal rank) compared to state-of-the-art code retrieval methods that do not use descriptions but attempt to compute the intent of snippets solely from unannotated code.</p>\n", "tags": ["search"], "tsne_embedding": [-13.945302963256836, 5.3240838050842285]}, {"key": "hindle2012naturalness", "year": "2012", "title": "On the Naturalness of Software", "abstract": "<p>Natural languages like English are rich, complex,\nand powerful. The highly creative and graceful use of languages\nlike English and Tamil, by masters like Shakespeare and\nAvvaiyar, can certainly delight and inspire. But in practice,\ngiven cognitive constraints and the exigencies of daily life, most\nhuman utterances are far simpler and much more repetitive\nand predictable. In fact, these utterances can be very usefully\nmodeled using modern statistical methods. This fact has led\nto the phenomenal success of statistical approaches to speech\nrecognition, natural language translation, question-answering,\nand text mining and comprehension.</p>\n\n<p>We begin with the conjecture that most software is also\nnatural, in the sense that it is created by humans at work,\nwith all the attendant constraints and limitations\u2014and thus,\nlike natural language, it is also likely to be repetitive and\npredictable. We then proceed to ask whether a) code can\nbe usefully modeled by statistical language models and b)\nsuch models can be leveraged to support software engineers.\nUsing the widely adopted n-gram model, we provide empirical\nevidence supportive of a positive answer to both these questions.\nWe show that code is also very repetitive, and in fact even more\nso than natural languages. As an example use of the model,\nwe have developed a simple code completion engine for Java\nthat, despite its simplicity, already improves Eclipse\u2019s built-in\ncompletion capability. We conclude the paper by laying out a\nvision for future research in this area.</p>\n\n", "tags": ["language model", "autocomplete"], "tsne_embedding": [0.7103778719902039, 7.578859806060791]}, {"key": "hoang2020cc2vec", "year": "2020", "title": "CC2Vec: Distributed Representations of Code Changes", "abstract": "<p>Existing work on software patches often use features specific to a single task. These works often rely on manually identified features, and human effort is required to identify these features for each task. In this work, we propose CC2Vec, a neural network model that learns a representation of code changes guided by their accompanying log messages, which represent the semantic intent of the code changes. CC2Vec models the hierarchical structure of a code change with the help of the attention mechanism and uses multiple comparison functions to identify the differences between the removed and added code.</p>\n\n<p>To evaluate if CC2Vec can produce a distributed representation of code changes that is general and useful for multiple tasks on software patches, we use the vectors produced by CC2Vec for three tasks: log message generation, bug fixing patch identification, and just-in-time defect prediction. In all tasks, the models using CC2Vec outperform the state-of-the-art techniques.</p>\n", "tags": ["edit"], "tsne_embedding": [-0.8079769611358643, -16.457805633544922]}, {"key": "hong2021fix", "year": "2021", "title": "Fix-Filter-Fix: Intuitively Connect Any Models for Effective Bug Fixing", "abstract": "<p>Locating and fixing bugs is a time-consuming task. Most neural machine translation (NMT) based approaches for automatically bug fixing lack generality and do not make full use of the rich information in the source code. In NMT-based bug fixing, we find some predicted code identical to the input buggy code (called unchanged fix) in NMT-based approaches due to high similarity between buggy and fixed code (e.g., the difference may only appear in one particular line). Obviously, unchanged fix is not the correct fix because it is the same as the buggy code that needs to be fixed. Based on these, we propose an intuitive yet effective general framework (called Fix-Filter-Fix or F\u02c63) for bug fixing. F\u02c63 connects models with our filter mechanism to filter out the last model\u2019s unchanged fix to the next. We propose an F\u02c63 theory that can quantitatively and accurately calculate the F\u02c63 lifting effect. To evaluate, we implement the Seq2Seq Transformer (ST) and the AST2Seq Transformer (AT) to form some basic F\u02c63 instances, called F\u02c63_ST+AT and F\u02c63_AT+ST. Comparing them with single model approaches and many model connection baselines across four datasets validates the effectiveness and generality of F\u02c63 and corroborates our findings and methodology.</p>\n", "tags": ["repair"], "tsne_embedding": [-4.748866558074951, -20.444578170776367]}, {"key": "hsiao2014using", "year": "2014", "title": "Using Web Corpus Statistics for Program Analysis", "abstract": "<p>Several program analysis tools\u2014such as plagiarism detection and bug finding\u2014rely on knowing a piece of code\u2019s\nrelative semantic importance. For example, a plagiarism detector should not bother reporting two programs that have\nan identical simple loop counter test, but should report programs that share more distinctive code. Traditional program\nanalysis techniques (e.g., finding data and control dependencies) are useful, but do not say how surprising or common\na line of code is. Natural language processing researchers\nhave encountered a similar problem and addressed it using\nan n-gram model of text frequency, derived from statistics\ncomputed over text corpora.</p>\n\n<p>We propose and compute an n-gram model for programming languages, computed over a corpus of 2.8 million\nJavaScript programs we downloaded from the Web. In contrast to previous techniques, we describe a code n-gram as\na subgraph of the program dependence graph that contains\nall nodes and edges reachable in n steps from the statement.\nWe can count n-grams in a program and count the frequency\nof n-grams in the corpus, enabling us to compute tf-idf-style\nmeasures that capture the differing importance of different\nlines of code. We demonstrate the power of this approach by\nimplementing a plagiarism detector with accuracy that beats\nprevious techniques, and a bug-finding tool that discovered\nover a dozen previously unknown bugs in a collection of real\ndeployed programs.</p>\n", "tags": ["defect"], "tsne_embedding": [-4.832841873168945, 9.58032512664795]}, {"key": "hu2017codesum", "year": "2017", "title": "CodeSum: Translate Program Language to Natural Language", "abstract": "<p>During software maintenance, programmers spend a lot of time on code comprehension. Reading comments is an effective way for programmers to reduce the reading and navigating time when comprehending source code. Therefore, as a critical task in software engineering, code summarization aims to generate brief natural language descriptions for source code. In this paper, we propose a new code summarization model named CodeSum. CodeSum exploits the attention-based sequence-to-sequence (Seq2Seq) neural network with Structure-based Traversal (SBT) of Abstract Syntax Trees (AST). The AST sequences generated by SBT can better present the structure of ASTs and keep unambiguous. We conduct experiments on three large-scale corpora in different program languages, i.e., Java, C#, and SQL, in which Java corpus is our new proposed industry code extracted from Github. Experimental results show that our method CodeSum outperforms the state-of-the-art significantly.</p>\n", "tags": ["bimodal", "summarization"], "tsne_embedding": [8.210565567016602, -7.995974540710449]}, {"key": "huang2021cosqa", "year": "2021", "title": "CoSQA: 20,000+ Web Queries for Code Search and Question Answering", "abstract": "<p>Finding codes given natural language query is beneficial to the productivity of software developers.\nFuture progress towards better semantic matching between query and code requires richer supervised training resources.\nTo remedy this, we introduce the CoSQA dataset. It includes 20,604 labels for pairs of natural language queries and codes,\neach annotated by at least 3 human annotators. We further introduce a contrastive learning method dubbed CoCLR to enhance query-code matching, which works as a data augmenter to bring more artificially generated training instances. We show that evaluated on CodeXGLUE with the same CodeBERT model, training on CoSQA improves the accuracy of code question answering by 5.1%, and incorporating CoCLR brings a further improvement of 10.5%.</p>\n", "tags": ["dataset", "search"], "tsne_embedding": [-15.563424110412598, 9.350217819213867]}, {"key": "husain2019codesearchnet", "year": "2019", "title": "CodeSearchNet Challenge: Evaluating the State of Semantic Code Search", "abstract": "<p>Semantic code search is the task of retrieving relevant code given a natural language query. While related to other information retrieval tasks, it requires bridging the gap between the language used in code (often abbreviated and highly technical) and natural language more suitable to describe vague concepts and ideas.</p>\n\n<p>To enable evaluation of progress on code search, we are releasing the CodeSearchNet Corpus and are presenting the CodeSearchNet Challenge, which consists of 99 natural language queries with about 4k expert relevance annotations of likely results from CodeSearchNet Corpus. The corpus contains about 6 million functions from open-source code spanning six programming languages (Go, Java, JavaScript, PHP, Python, and Ruby). The CodeSearchNet Corpus also contains automatically generated query-like natural language for 2 million functions, obtained from mechanically scraping and preprocessing associated function documentation. In this article, we describe the methodology used to obtain the corpus and expert labels, as well as a number of simple baseline solutions for the task.</p>\n\n<p>We hope that CodeSearchNet Challenge encourages researchers and practitioners to study this interesting task further and will host a competition and leaderboard to track the progress on the challenge. We are also keen on extending CodeSearchNet Challenge to more queries and programming languages in the future.</p>\n", "tags": ["dataset", "search"], "tsne_embedding": [-12.802377700805664, 6.973323345184326]}, {"key": "hussain2019deep", "year": "2019", "title": "Deep Transfer Learning for Source Code Modeling", "abstract": "<p>In recent years, deep learning models have shown great potential in source code modeling and analysis. Generally, deep learning-based approaches are problem-specific and data-hungry. A challenging issue of these approaches is that they require training from starch for a different related problem. In this work, we propose a transfer learning-based approach that significantly improves the performance of deep learning-based source code models. In contrast to traditional learning paradigms, transfer learning can transfer the knowledge learned in solving one problem into another related problem. First, we present two recurrent neural network-based models RNN and GRU for the purpose of transfer learning in the domain of source code modeling. Next, via transfer learning, these pre-trained (RNN and GRU) models are used as feature extractors. Then, these extracted features are combined into attention learner for different downstream tasks. The attention learner leverages from the learned knowledge of pre-trained models and fine-tunes them for a specific downstream task. We evaluate the performance of the proposed approach with extensive experiments with the source code suggestion task. The results indicate that the proposed approach outperforms the state-of-the-art models in terms of accuracy, precision, recall, and F-measure without training the models from scratch.</p>\n", "tags": ["pretraining"], "tsne_embedding": [1.3461413383483887, -1.4381253719329834]}, {"key": "iyer2016summarizing", "year": "2016", "title": "Summarizing Source Code using a Neural Attention Model", "abstract": "<p>High quality source code is often paired\nwith high level summaries of the computation it performs, for example in code\ndocumentation or in descriptions posted\nin online forums. Such summaries are\nextremely useful for applications such as\ncode search but are expensive to manually\nauthor, hence only done for a small fraction of all code that is produced. In this\npaper, we present the first completely data-driven approach for generating high level\nsummaries of source code. Our model,\nCODE-NN , uses Long Short Term Memory (LSTM) networks with attention to\nproduce sentences that describe C# code\nsnippets and SQL queries. CODE-NN\nis trained on a new corpus that is automatically collected from StackOverflow,\nwhich we release. Experiments demonstrate strong performance on two tasks:\n(1) code summarization, where we establish the first end-to-end learning results\nand outperform strong baselines, and (2)\ncode retrieval, where our learned model\nimproves the state of the art on a recently\nintroduced C# benchmark by a large margin.</p>\n", "tags": ["summarization", "bimodal"], "tsne_embedding": [9.096697807312012, -8.658316612243652]}, {"key": "iyer2018mapping", "year": "2018", "title": "Mapping Language to Code in Programmatic Context", "abstract": "<p>Source code is rarely written in isolation. It depends significantly on the programmatic context, such as the class that the code would reside in. To study this phenomenon, we introduce the task of generating class member functions given English documentation and the programmatic context provided by the rest of the class. This task is challenging because the desired code can vary greatly depending on the functionality the class provides (e.g., a sort function may or may not be available when we are asked to \u201creturn the smallest element\u201d in a particular member variable list). We introduce CONCODE, a new large dataset with over 100,000 examples consisting of Java classes from online code repositories, and develop a new encoder-decoder architecture that models the interaction between the method documentation and the class environment. We also present a detailed error analysis suggesting that there is significant room for future work on this task.</p>\n", "tags": ["bimodal", "code generation"], "tsne_embedding": [-2.7855262756347656, 12.36742115020752]}, {"key": "iyer2019learning", "year": "2019", "title": "Learning Programmatic Idioms for Scalable Semantic Parsing", "abstract": "<p>Programmers typically organize executable source code using high-level coding patterns or idiomatic structures such as nested loops, exception handlers and recursive blocks, rather than as individual code tokens. In contrast, state of the art semantic parsers still map natural language instructions to source code by building the code syntax tree one node at a time. In this paper, we introduce an iterative method to extract code idioms from large source code corpora by repeatedly collapsing most-frequent depth-2 subtrees of their syntax trees, and we train semantic parsers to apply these idioms during decoding. We apply this idiom-based code generation to a recent context-dependent semantic parsing task, and improve the state of the art by 2.2% BLEU score while reducing training time by more than 50%. This improved speed enables us to scale up the model by training on an extended training set that is 5x times larger, to further move up the state of the art by an additional 2.3% BLEU and 0.9% exact match.</p>\n", "tags": ["pattern mining", "code generation", "grammar"], "tsne_embedding": [16.3587703704834, -1.646540880203247]}, {"key": "jain2020contrastive", "year": "2020", "title": "Contrastive Code Representation Learning", "abstract": "<p>Machine-aided programming tools such as type predictors and code summarizers\nare increasingly learning-based. However, most code representation learning approaches rely on supervised learning with task-specific annotated datasets. We propose Contrastive Code Representation Learning (ContraCode), a self-supervised\nalgorithm for learning task-agnostic semantic representations of programs via contrastive learning. Our approach uses no human-provided labels, relying only on\nthe raw text of programs. In particular, we design an unsupervised pretext task by\ngenerating textually divergent copies of source functions via automated source-tosource compiler transforms that preserve semantics. We train a neural model to\nidentify variants of an anchor program within a large batch of negatives. To solve\nthis task, the network must extract program features representing the functionality,\nnot form, of the program. This is the first application of instance discrimination\nto code representation learning to our knowledge. We pre-train models over 1.8m\nunannotated JavaScript methods mined from GitHub. ContraCode pre-training\nimproves code summarization accuracy by 7.9% over supervised approaches and\n4.8% over RoBERTa pre-training. Moreover, our approach is agnostic to model architecture; for a type inference task, contrastive pre-training consistently improves\nthe accuracy of existing baselines.</p>\n", "tags": ["representation", "pretraining"], "tsne_embedding": [3.5779547691345215, -4.50611686706543]}, {"key": "jayasundara2019treecaps", "year": "2019", "title": "TreeCaps: Tree-Structured Capsule Networks for Program Source Code Processing", "abstract": "<p>Program comprehension is a fundamental task in software development and maintenance processes. Software developers often need to understand a large amount of existing code before they can develop new features or fix bugs in existing programs. Being able to process programming language code automatically and provide summaries of code functionality accurately can significantly help developers to reduce time spent in code navigation and understanding, and thus increase productivity. Different from natural language articles, source code in programming languages often follows rigid syntactical structures and there can exist dependencies among code elements that are located far away from each other through complex control flows and data flows. Existing studies on tree-based convolutional neural networks (TBCNN) and gated graph neural networks (GGNN) are not able to capture essential semantic dependencies among code elements accurately. In this paper, we propose novel tree-based capsule networks (TreeCaps) and relevant techniques for processing program code in an automated way that encodes code syntactical structures and captures code dependencies more accurately. Based on evaluation on programs written in different programming languages, we show that our TreeCaps-based approach can outperform other approaches in classifying the functionalities of many programs.</p>\n", "tags": ["representation"], "tsne_embedding": [-8.953062057495117, -5.395569801330566]}, {"key": "jesse2021learning", "year": "2021", "title": "Learning Type Annotation: Is Big Data Enough?", "abstract": "<p>TypeScript is a widely used optionally-typed language where developers can adopt \u201cpay as you go\u201d typing: they can add types as\ndesired, and benefit from static typing. The \u201ctype annotation tax\u201d\nor manual effort required to annotate new or existing TypeScript\ncan be reduced by a variety of automatic methods. Probabilistic\nmachine-learning (ML) approaches work quite well. ML approaches\nuse different inductive biases, ranging from simple token sequences\nto complex graphical neural network (GNN) models capturing syntax and semantic relations. More sophisticated inductive biases are\nhand-engineered to exploit the formal nature of software. Rather\nthan deploying fancy inductive biases for code, can we just use \u201cbig\ndata\u201d to learn natural patterns relevant to typing? We find evidence\nsuggesting that this is the case. We present TypeBert, demonstrating that even with simple token-sequence inductive bias used in\nBERT-style models and enough data, type-annotation performance\nof the most sophisticated models can be surpassed.</p>\n", "tags": ["Transformer", "types"], "tsne_embedding": [-4.636005878448486, 23.845388412475586]}, {"key": "jesse2022learning", "year": "2022", "title": "Learning To Predict User-Defined Types", "abstract": "<p>TypeScript is a widely adopted gradual typed language where developers can optionally type variables, functions, parameters and more. Probabilistic type inference approaches with ML (machine learning) work well especially for commonly occurring types such as boolean, number, and string. TypeScript permits a wide range of types including developer defined class names and type interfaces. These developer defined types, termed user-defined types, can be written within the realm of language naming conventions. The set of user-defined types is boundless and existing bounded type guessing approaches are an imperfect solution. Existing works either under perform in user-defined types or ignore user-defined types altogether. This work leverages a BERT-style pre-trained model, with multi-task learning objectives, to learn how to type user-defined classes and interfaces. Thus we present DIVERSETYPER, a solution that explores the diverse set of user-defined types by uniquely aligning classes and interfaces declarations to the places in which they are used. DIVERSETYPER surpasses all existing works including those that model user-defined types.</p>\n", "tags": ["Transformer", "types"], "tsne_embedding": [-5.265903949737549, 23.43271255493164]}, {"key": "jesse2023large", "year": "2023", "title": "Large Language Models and Simple, Stupid Bugs", "abstract": "<p>With the advent of powerful neural language models, AI-based systems to assist developers in coding tasks are becoming widely available; Copilot is one such system. Copilot uses Codex, a large language model (LLM), to complete code conditioned on a preceding \u201cprompt\u201d. Codex, however, is trained on public GitHub repositories, viz., on code that may include bugs and vulnerabilities. Previous studies [1], [2] show Codex reproduces vulnerabilities seen in training. In this study, we examine how prone Codex is to generate an interesting bug category, single statement bugs, commonly referred to as simple, stupid bugs or SStuBs in the MSR community. We find that Codex and similar LLMs do help avoid some SStuBs, but do produce known, verbatim SStuBs as much as 2x as likely than known, verbatim correct code. We explore the consequences of the Codex generated SStuBs and propose avoidance strategies that suggest the possibility of reducing the production of known, verbatim SStubs, and increase the possibility of producing known, verbatim fixes.</p>\n", "tags": ["Transformer", "defect"], "tsne_embedding": [-11.91993236541748, -18.50330924987793]}, {"key": "jian2021multimodal", "year": "2021", "title": "Multimodal Representation for Neural Code Search", "abstract": "<p>Semantic code search is about finding semantically relevant code snippets for a given natural language query. In the state-of-the-art approaches, the semantic similarity between code and query is quantified as the distance of their representation in the shared vector space. In this paper, to improve the vector space, we introduce tree-serialization methods on a simplified form of AST and build the multimodal representation for the code data. We conduct extensive experiments using a single corpus that is large-scale and multi-language: CodeSearchNet. Our results show that both our tree-serialized representations and multimodal learning model improve the performance of code search. Last, we define intuitive quantification metrics oriented to the completeness of semantic and syntactic information of the code data, to help understand the experimental findings.</p>\n", "tags": ["search", "representation"], "tsne_embedding": [-16.615163803100586, 3.6841907501220703]}, {"key": "jian2022assemble", "year": "2022", "title": "Assemble Foundation Models for Automatic Code Summarization", "abstract": "<p>Automatic code summarization is beneficial to software development and maintenance since it reduces the burden of manual tasks. Currently, artificial intelligence is undergoing a paradigm shift. The foundation models pretrained on massive data and finetuned to downstream tasks surpass specially customized models. This trend inspired us to consider reusing foundation models instead of learning from scratch. Based on this, we propose a flexible and robust approach for automatic code summarization based on neural networks. We assemble available foundation models, such as CodeBERT and GPT-2, into a single model named AdaMo. Moreover, we utilize Gaussian noise as the simulation of contextual information to optimize the latent representation. Furthermore, we introduce two adaptive schemes from the perspective of knowledge transfer, namely continuous pretraining and intermediate finetuning, and design intermediate stage tasks for general sequence-to-sequence learning. Finally, we evaluate AdaMo against a benchmark dataset for code summarization, by comparing it with state-of-the-art models.</p>\n", "tags": ["summarization", "documentation", "language model"], "tsne_embedding": [11.09488582611084, -9.255125045776367]}, {"key": "jiang2017automatically", "year": "2017", "title": "Automatically Generating Commit Messages from Diffs using Neural Machine Translation", "abstract": "<p>Commit messages are a valuable resource in comprehension of software evolution, since they provide a record of changes such as feature additions and bug repairs. Unfortunately, programmers often neglect to write good commit messages. Different techniques have been proposed to help programmers by automatically writing these messages. These techniques are effective at describing what changed, but are often verbose and lack context for understanding the rationale behind a change. In contrast, humans write messages that are short and summarize the high level rationale. In this paper, we adapt Neural Machine Translation (NMT) to automatically \u201ctranslate\u201d diffs into commit messages. We trained an NMT algorithm using a corpus of diffs and human-written commit messages from the top 1k Github projects. We designed a filter to help ensure that we only trained the algorithm on higher-quality commit messages. Our evaluation uncovered a pattern in which the messages we generate tend to be either very high or very low quality. Therefore, we created a quality-assurance filter to detect cases in which we are unable to produce good messages, and return a warning instead.</p>\n", "tags": ["edit", "bimodal"], "tsne_embedding": [2.1346776485443115, -20.16584014892578]}, {"key": "jiang2021treebert", "year": "2021", "title": "TreeBERT: A Tree-Based Pre-Trained Model for Programming Language", "abstract": "<p>Source code can be parsed into the abstract syntax tree (AST) based on defined syntax rules. However, in pre-training, little work has considered the incorporation of tree structure into the learning process. In this paper, we present TreeBERT, a tree-based pre-trained model for improving programming language-oriented generation tasks. To utilize tree structure, TreeBERT represents the AST corresponding to the code as a set of composition paths and introduces node position embedding. The model is trained by tree masked language modeling (TMLM) and node order prediction (NOP) with a hybrid objective. TMLM uses a novel masking strategy designed according to the tree\u2019s characteristics to help the model understand the AST and infer the missing semantics of the AST. With NOP, TreeBERT extracts the syntactical structure by learning the order constraints of nodes in AST. We pre-trained TreeBERT on datasets covering multiple programming languages. On code summarization and code documentation tasks, TreeBERT outperforms other pre-trained models and state-of-the-art models designed for these tasks. Furthermore, TreeBERT performs well when transferred to the pre-trained unseen programming language.</p>\n", "tags": ["grammar", "Transformer"], "tsne_embedding": [8.781534194946289, -4.507744789123535]}, {"key": "johnson2020learning", "year": "2020", "title": "Learning Graph Structure With A Finite-State Automaton Layer", "abstract": "<p>Graph-based neural network models are producing strong results in a number of domains, in part because graphs provide flexibility to encode domain knowledge in the form of relational structure (edges) between nodes in the graph. In practice, edges are used both to represent intrinsic structure (e.g., abstract syntax trees of programs) and more abstract relations that aid reasoning for a downstream task (e.g., results of relevant program analyses). In this work, we study the problem of learning to derive abstract relations from the intrinsic graph structure. Motivated by their power in program analyses, we consider relations defined by paths on the base graph accepted by a finite-state automaton. We show how to learn these relations end-to-end by relaxing the problem into learning finite-state automata policies on a graph-based POMDP and then training these policies using implicit differentiation. The result is a differentiable Graph Finite-State Automaton (GFSA) layer that adds a new edge type (expressed as a weighted adjacency matrix) to a base graph. We demonstrate that this layer can find shortcuts in grid-world graphs and reproduce simple static analyses on Python programs. Additionally, we combine the GFSA layer with a larger graph-based model trained end-to-end on the variable misuse program understanding task, and find that using the GFSA layer leads to better performance than using hand-engineered semantic edges or other baseline methods for adding learned edge types.</p>\n", "tags": ["GNN", "program analysis"], "tsne_embedding": [-5.598071575164795, -6.72192907333374]}, {"key": "jung2021commitbert", "year": "2021", "title": "CommitBERT: Commit Message Generation Using Pre-Trained Programming Language Model", "abstract": "<p>Commit message is a document that summarizes source code changes in natural language. A good commit message clearly shows the source code changes, so this enhances collaboration between developers. Therefore, our work is to develop a model that automatically writes the commit message. To this end, we release 345K datasets consisting of code modification and commit messages in six programming languages (Python, PHP, Go, Java, JavaScript, and Ruby). Similar to the neural machine translation (NMT) model, using our dataset, we feed the code modification to the encoder input and the commit message to the decoder input and measure the result of the generated commit message with BLEU-4. Also, we propose the following two training methods to improve the result of generating the commit message: (1) A method of preprocessing the input to feed the code modification to the encoder input. (2) A method that uses an initial weight suitable for the code domain to reduce the gap in contextual representation between programming language (PL) and natural language (NL).</p>\n", "tags": ["dataset", "language model", "Transformer"], "tsne_embedding": [2.717041492462158, -18.979515075683594]}, {"key": "kacmajor2019automatic", "year": "2019", "title": "Automatic Acquisition of Annotated Training Corpora for Test-Code Generation", "abstract": "<p>Open software repositories make large amounts of source code publicly available. Potentially, this source code could be used as training data to develop new, machine learning-based programming tools. For many applications, however, raw code scraped from online repositories does not constitute an adequate training dataset. Building on the recent and rapid improvements in machine translation (MT), one possibly very interesting application is code generation from natural language descriptions. One of the bottlenecks in developing these MT-inspired systems is the acquisition of parallel text-code corpora required for training code-generative models. This paper addresses the problem of automatically synthetizing parallel text-code corpora in the software testing domain. Our approach is based on the observation that self-documentation through descriptive method names is widely adopted in test automation, in particular for unit testing. Therefore, we propose synthesizing parallel corpora comprised of parsed test function names serving as code descriptions, aligned with the corresponding function bodies. We present the results of applying one of the state-of-the-art MT methods on such a generated dataset. Our experiments show that a neural MT model trained on our dataset can generate syntactically correct and semantically relevant short Java functions from quasi-natural language descriptions of functionality.</p>\n", "tags": [], "tsne_embedding": [15.505870819091797, 4.758970260620117]}, {"key": "kanade2020pretrained", "year": "2020", "title": "Pre-trained Contextual Embedding of Source Code", "abstract": "<p>The source code of a program not only serves as a formal description of an executable task, but it also serves to communicate developer intent in a human-readable form. To facilitate this, developers use meaningful identifier names and natural-language documentation. This makes it possible to successfully apply sequence-modeling approaches, shown to be effective in natural-language processing, to source code. A major advancement in natural-language understanding has been the use of pre-trained token embeddings; BERT and other works have further shown that pre-trained contextual embeddings can be extremely powerful and can be fine-tuned effectively for a variety of downstream supervised tasks. Inspired by these developments, we present the first attempt to replicate this success on source code. We curate a massive corpus of Python programs from GitHub to pre-train a BERT model, which we call Code Understanding BERT (CuBERT). We also pre-train Word2Vec embeddings on the same dataset. We create a benchmark of five classification tasks and compare fine-tuned CuBERT against sequence models trained with and without the Word2Vec embeddings. Our results show that CuBERT outperforms the baseline methods by a margin of 2.9-22%. We also show its superiority when fine-tuned with smaller datasets, and over fewer epochs. We further evaluate CuBERT\u2019s effectiveness on a joint classification, localization and repair task involving prediction of two pointers.</p>\n", "tags": ["pretraining"], "tsne_embedding": [4.615090370178223, 1.0321924686431885]}, {"key": "karaivanov2014phrase", "year": "2014", "title": "Phrase-Based Statistical Translation of Programming Languages", "abstract": "<p>Phrase-based statistical machine translation approaches have been\nhighly successful in translating between natural languages and are\nheavily used by commercial systems (e.g. Google Translate).</p>\n\n<p>The main objective of this work is to investigate the applicability of\nthese approaches for translating between programming languages.\nTowards that, we investigated several variants of the phrase-based\ntranslation approach: i) a direct application of the approach to\nprogramming languages, ii) a novel modification of the approach\nto incorporate the grammatical structure of the target programming\nlanguage (so to avoid generating target programs which do not\nparse), and iii) a combination of ii) with custom rules added to\nimprove the quality of the translation.</p>\n\n<p>To experiment with the above systems, we investigated machine\ntranslation from C# to Java. For the training, which takes about\n60 hours, we used a parallel corpus of 20, 499 C#-to-Java method\ntranslations. We then evaluated each of the three systems above by\ntranslating 1,000 C# methods. Our experimental results indicate\nthat with the most advanced system, about 60% of the translated\nmethods compile (the top ranked) and out of a random sample of 50\ncorrectly compiled methods, 68% (34 methods) were semantically\nequivalent to the reference solution.</p>\n", "tags": ["migration", "code generation"], "tsne_embedding": [9.25278091430664, 5.548157215118408]}, {"key": "karampatsis2019deep", "year": "2019", "title": "Maybe Deep Neural Networks are the Best Choice for Modeling Source Code", "abstract": "<p>Statistical language modeling techniques have successfully been applied to source code, yielding a variety of new software development tools, such as tools for code suggestion and improving readability. A major issue with these techniques is that code introduces new vocabulary at a far higher rate than natural language, as new identifier names proliferate. But traditional language models limit the vocabulary to a fixed set of common words. For code, this strong assumption has been shown to have a significant negative effect on predictive performance. But the open vocabulary version of the neural network language models for code have not been introduced in the literature. We present a new open-vocabulary neural language model for code that is not limited to a fixed vocabulary of identifier names. We employ a segmentation into subword units, subsequences of tokens chosen based on a compression criterion, following previous work in machine translation. Our network achieves best in class performance, outperforming even the state-of-the-art methods of Hellendoorn and Devanbu that are designed specifically to model code. Furthermore, we present a simple method for dynamically adapting the model to a new test project, resulting in increased performance. We showcase our methodology on code corpora in three different languages of over a billion tokens each, hundreds of times larger than in previous work. To our knowledge, this is the largest neural language model for code that has been reported.</p>\n", "tags": ["language model"], "tsne_embedding": [0.10459935665130615, 2.833695888519287]}, {"key": "karampatsis2020big", "year": "2020", "title": "Big Code != Big Vocabulary: Open-Vocabulary Models for Source Code", "abstract": "<p>Statistical language modeling techniques have successfully been applied to large source code corpora, yielding a variety of new software development tools, such as tools for code suggestion, improving readability, and API migration. A major issue with these techniques is that code introduces new vocabulary at a far higher rate than natural language, as new identifier names proliferate. Both large vocabularies and out-of-vocabulary issues severely affect Neural Language Models (NLMs) of source code, degrading their performance and rendering them unable to scale. In this paper, we address this issue by: 1) studying how various modelling choices impact the resulting vocabulary on a large-scale corpus of 13,362 projects; 2) presenting an open vocabulary source code NLM that can scale to such a corpus, 100 times larger than in previous work; and 3) showing that such models outperform the state of the art on three distinct code corpora (Java, C, Python). To our knowledge, these are the largest NLMs for code that have been reported.</p>\n", "tags": ["language model"], "tsne_embedding": [0.485882431268692, 3.584587335586548]}, {"key": "karampatsis2020scelmo", "year": "2020", "title": "SCELMo: Source Code Embeddings from Language Models", "abstract": "<p>Continuous embeddings of tokens in computer programs have been used to support a variety of software development tools, including readability, code search, and program repair. Contextual embeddings are common in natural language processing but have not been previously applied in software engineering. We introduce a new set of deep contextualized word representations for computer programs based on language models. We train a set of embeddings using the ELMo (embeddings from language models) framework of Peters et al (2018). We investigate whether these embeddings are effective when fine-tuned for the downstream task of bug detection. We show that even a low-dimensional embedding trained on a relatively small corpus of programs can improve a state-of-the-art machine learning system for bug detection.</p>\n", "tags": ["pretraining", "defect"], "tsne_embedding": [-7.328933238983154, -13.974515914916992]}, {"key": "karmakar2021what", "year": "2021", "title": "What do pre-trained code models know about code?", "abstract": "<p>Pre-trained models of code built on the transformer architecture have performed well on software engineering (SE) tasks such as predictive code generation, code summarization, among others. However, whether the vector representations from these pre-trained models comprehensively encode characteristics of source code well enough to be applicable to a broad spectrum of downstream tasks remains an open question.</p>\n\n<p>One way to investigate this is with diagnostic tasks called probes. In this paper, we construct four probing tasks (probing for surface-level, syntactic, structural, and semantic information) for pre-trained code models. We show how probes can be used to identify whether models are deficient in (understanding) certain code properties, characterize different model layers, and get insight into the model sample-efficiency.</p>\n\n<p>We probe four models that vary in their expected knowledge of code properties: BERT (pre-trained on English), CodeBERT and CodeBERTa (pre-trained on source code, and natural language documentation), and GraphCodeBERT (pre-trained on source code with dataflow). While GraphCodeBERT performs more consistently overall, we find that BERT performs surprisingly well on some code tasks, which calls for further investigation.</p>\n", "tags": ["Transformer"], "tsne_embedding": [4.020792484283447, -0.4340304434299469]}, {"key": "karmakar2022jemma", "year": "2022", "title": "JEMMA: An Extensible Java Dataset for ML4Code Applications", "abstract": "<p>Machine Learning for Source Code (ML4Code) is an active research field in which extensive experimentation is needed to discover how to best use source code\u2019s richly structured information. With this in mind, we introduce JEMMA, an Extensible Java Dataset for ML4Code Applications, which is a large-scale, diverse, and high-quality dataset targeted at ML4Code. Our goal with JEMMA is to lower the barrier to entry in ML4Code by providing the building blocks to experiment with source code models and tasks. JEMMA comes with a considerable amount of pre-processed information such as metadata, representations (e.g., code tokens, ASTs, graphs), and several properties (e.g., metrics, static analysis results) for 50,000 Java projects from the 50KC dataset, with over 1.2 million classes and over 8 million methods. JEMMA is also extensible allowing users to add new properties and representations to the dataset, and evaluate tasks on them. Thus, JEMMA becomes a workbench that researchers can use to experiment with novel representations and tasks operating on source code. To demonstrate the utility of the dataset, we also report results from two empirical studies on our data, ultimately showing that significant work lies ahead in the design of context-aware source code models that can reason over a broader network of source code entities in a software project, the very task that JEMMA is designed to help with.</p>\n", "tags": ["dataset"], "tsne_embedding": [-7.343691349029541, -1.0344130992889404]}, {"key": "karpathy2015visualizing", "year": "2015", "title": "Visualizing and Understanding Recurrent Networks", "abstract": "<p>Recurrent Neural Networks (RNNs), and specifically a variant with Long Short-Term Memory (LSTM), are enjoying renewed interest as a result of successful\napplications in a wide range of machine learning problems that involve sequential\ndata. However, while LSTMs provide exceptional results in practice, the source\nof their performance and their limitations remain rather poorly understood. Using character-level language models as an interpretable testbed, we aim to bridge\nthis gap by providing an analysis of their representations, predictions and error\ntypes. In particular, our experiments reveal the existence of interpretable cells that\nkeep track of long-range dependencies such as line lengths, quotes and brackets.\nMoreover, our comparative analysis with finite horizon n-gram models traces the\nsource of the LSTM improvements to long-range structural dependencies. Finally,\nwe provide analysis of the remaining errors and suggests areas for further study.</p>\n\n", "tags": ["language model", "code generation"], "tsne_embedding": [17.249658584594727, -11.798368453979492]}, {"key": "katz2019towards", "year": "2019", "title": "Towards Neural Decompilation", "abstract": "<p>We address the problem of automatic decompilation, converting a program in low-level representation back to a higher-level human-readable programming language. The problem of decompilation is extremely important for security researchers. Finding vulnerabilities and understanding how malware operates is much easier when done over source code.</p>\n\n<p>The importance of decompilation has motivated the construction of hand-crafted rule-based decompilers. Such decompilers have been designed by experts to detect specific control-flow structures and idioms in low-level code and lift them to source level. The cost of supporting additional languages or new language features in these models is very high.</p>\n\n<p>We present a novel approach to decompilation based on neural machine translation. The main idea is to automatically learn a decompiler from a given compiler. Given a compiler from a source language S to a target language T , our approach automatically trains a decompiler that can translate (decompile) T back to S . We used our framework to decompile both LLVM IR and x86 assembly to C code with high success rates. Using our LLVM and x86 instantiations, we were able to successfully decompile over 97% and 88% of our benchmarks respectively.</p>\n", "tags": ["decompilation"], "tsne_embedding": [4.668735504150391, 17.709131240844727]}, {"key": "key2022speak", "year": "2022", "title": "I Speak, You Verify: Toward Trustworthy Neural Program Synthesis", "abstract": "<p>We develop an approach for improving the trustworthiness and overall accuracy of program synthesizers based on large language models for source code. Given a natural language description of a programming problem, our method samples both candidate programs as well as candidate predicates specifying how the program should behave. We learn to analyze the agreement between programs and predicates to judge both which program is most likely to be correct, and also judge whether the language model is able to solve the programming problem in the first place. This latter capacity allows favoring high precision over broad recall: fostering trust by only proposing a program when the system is certain that it is correct.</p>\n", "tags": ["synthesis"], "tsne_embedding": [6.696533679962158, 19.635438919067383]}, {"key": "kharkar2022learning", "year": "2022", "title": "Learning to Reduce False Positives in Analytic Bug Detectors", "abstract": "<p>Due to increasingly complex software design and rapid iterative development, code defects and security vulnerabilities are prevalent in modern software. In response, programmers rely on static analysis tools to regularly scan their codebases and find potential bugs. In order to maximize coverage, however, these tools generally tend to report a significant number of false positives, requiring developers to manually verify each warning. To address this problem, we propose a Transformer-based learning approach to identify false positive bug warnings. We demonstrate that our models can improve the precision of static analysis by 17.5%. In addition, we validated the generalizability of this approach across two major bug types: null dereference and resource leak.</p>\n", "tags": ["Transformer", "static analysis"], "tsne_embedding": [-13.633225440979004, -15.965250968933105]}, {"key": "kim2020code", "year": "2020", "title": "Code Prediction by Feeding Trees to Transformers", "abstract": "<p>In this paper, we describe how to leverage Transformer, a recent neural architecture for learning from sequential data (such as text), for code completion. As in the realm of natural language processing, Transformers surpass the prediction accuracy achievable by RNNs; we provide an experimental confirmation of this over a Python dataset.</p>\n\n<p>Furthermore, we show that the way to obtain even better accuracy from Transformers is to expose the syntactic structure of code, which is easily recovered by parsing, to the neural network. This works significantly better than presenting the code as a linear token sequence, which is how Transformers were originally intended to be used.</p>\n\n<p>To accomplish this, we propose a novel enhancement to the self-attention mechanism of the Transformer. We enable the mechanism to learn weights\u2014that is, how much to focus on each preceding token in the input\u2014not only on the basis of a token\u2019s value, but also on the basis of the spatial relationships, as in their positions in the abstract syntax tree, between each pair of tokens.</p>\n\n<p>We provide comprehensive experimental evaluation of our proposal, along with alternative design choices, on a standard Python dataset, as well as on a Python corpus internal to Facebook.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [11.561749458312988, -5.256263732910156]}, {"key": "koc2017learning", "year": "2017", "title": "Learning a Classifier for False Positive Error Reports Emitted by Static Code Analysis Tools", "abstract": "<p>The large scale and high complexity of modern software systems\nmake perfectly precise static code analysis (SCA) infeasible. Therefore SCA tools often over-approximate, so not to miss any real\nproblems. This, however, comes at the expense of raising false\nalarms, which, in practice, reduces the usability of these tools.</p>\n\n<p>To partially address this problem, we propose a novel learning\nprocess whose goal is to discover program structures that cause\na given SCA tool to emit false error reports, and then to use this\ninformation to predict whether a new error report is likely to be a\nfalse positive as well. To do this, we first preprocess code to isolate\nthe locations that are related to the error report. Then, we apply\nmachine learning techniques to the preprocessed code to discover\ncorrelations and to learn a classifier.</p>\n\n<p>We evaluated this approach in an initial case study of a widely-used SCA tool for Java. Our results showed that for our dataset\nwe could accurately classify a large majority of false positive error\nreports. Moreover, we identified some common coding patterns that\nled to false positive errors. We believe that SCA developers may be\nable to redesign their methods to address these patterns and reduce\nfalse positive error reports.</p>\n", "tags": ["static analysis"], "tsne_embedding": [-14.096083641052246, -15.277273178100586]}, {"key": "kocetkov2022stack", "year": "2022", "title": "The Stack: 3TB of permissively licensed source code", "abstract": "<p>Large Language Models (LLMs) play an ever-increasing role in the field of\nArtificial Intelligence (AI)\u2013not only for natural language processing but also\nfor code understanding and generation. To stimulate open and responsible\nresearch on LLMs for code, we introduce The Stack, a 3.1 TB dataset\nconsisting of permissively licensed source code in 30 programming languages.\nWe describe how we collect the full dataset, construct a permissively licensed\nsubset, and present promising results on text2code benchmarks by training 350M-parameter decoders on different Python subsets. We find that\n(1) near-deduplicating the data significantly boosts performance across all\nexperiments, and (2) it is possible to match previously reported HumanEval\nand MBPP performance using only permissively licensed data. We make the\ndataset available at https://hf.co/BigCode and give developers the possi-\nbility to have their code removed from the dataset by following the instruc-\ntions at https://www.bigcode-project.org/docs/about/the-stack/.</p>\n", "tags": ["dataset"], "tsne_embedding": [9.480957984924316, 11.442817687988281]}, {"key": "korbak2021energy", "year": "2021", "title": "Energy-Based Models for Code Generation under Compilability Constraints", "abstract": "<p>Neural language models can be successfully trained on source code, leading to applications such as code completion. However, their versatile autoregressive self-supervision objective overlooks important global sequence-level features that are present in the data such as syntactic correctness or compilability. In this work, we pose the problem of learning to generate compilable code as constraint satisfaction. We define an Energy-Based Model (EBM) representing a pre-trained generative model with an imposed constraint of generating only compilable sequences. We then use the KL-Adaptive Distributional Policy Gradient algorithm (Khalifa et al., 2021) to train a generative model approximating the EBM. We conduct experiments showing that our proposed approach is able to improve compilability rates without sacrificing diversity and complexity of the generated samples.</p>\n", "tags": ["code generation"], "tsne_embedding": [15.152406692504883, -7.73841667175293]}, {"key": "kovalchuk2022human", "year": "2022", "title": "Human perceiving behavior modeling in evaluation of code generation models", "abstract": "<p>Within this study, we evaluated a series of code generation models based on CodeGen and GPTNeo to compare the metric-based performance and human evaluation. For a deeper analysis of human perceiving within the evaluation procedure we\u2019ve implemented a 5-level Likert scale assessment of the model output using a perceiving model based on the Theory of Planned Behavior (TPB). Through such analysis, we showed an extension of model assessment as well as a deeper understanding of the quality and applicability of generated code for practical question answering. The approach was evaluated with several model settings in order to assess diversity in quality and style of answer. With the TPB-based model, we showed a different level of perceiving the model result, namely personal understanding, agreement level, and readiness to use the particular code. With such analysis, we investigate a series of issues in code generation as natural language generation (NLG) problems observed in a practical context of programming question-answering with code.</p>\n", "tags": ["code generation", "evaluation", "human evaluation"], "tsne_embedding": [18.47039222717285, 9.191991806030273]}, {"key": "kovalchuk2023test", "year": "2023", "title": "Test-based and metric-based evaluation of code generation models for practical question answering", "abstract": "<p>We performed a comparative analysis of code generation model performance with evaluation using common NLP metrics in comparison to a test-based evaluation. The investigation was performed in the context of question answering with code (test-to-code problem) and was aimed at applicability checking both ways for generated code evaluation in a fully automatic manner. We used CodeGen and GPTNeo pretrained models applied to a problem of question answering using Stack Overflow-based corpus (APIzation). For test-based evaluation, industrial test-generation solutions (Machinet, UTBot) were used for providing automatically generated tests. The analysis showed that the performance evaluation based solely on NLP metrics or on tests provides a rather limited assessment of generated code quality. We see the evidence that predictions with both high and low NLP metrics exist that pass and don\u2019t pass tests. With the early results of our empirical study being discussed in this paper, we believe that the combination of both approaches may increase possible ways for building, evaluating, and training code generation models.</p>\n", "tags": ["code generation", "test generation", "natural language generation", "evaluation", "metrics", "natural language processing"], "tsne_embedding": [18.190502166748047, 8.558449745178223]}, {"key": "kovalenko2019pathminer", "year": "2019", "title": "PathMiner : A Library for Mining of Path-Based Representations of Code", "abstract": "<p>One recent, significant advance in modeling source code for machine learning algorithms has been the introduction of path-based representation \u2013 an approach consisting in representing a snippet of code as a collection of paths from its syntax tree. Such representation efficiently captures the structure of code, which, in turn, carries its semantics and other information.\nBuilding the path-based representation involves parsing the code and extracting the paths from its syntax tree; these steps build up to a substantial technical job. With no common reusable toolkit existing for this task, the burden of mining diverts the focus of researchers from the essential work and hinders newcomers in the field of machine learning on code.</p>\n\n<p>In this paper, we present PathMiner \u2013 an open-source library for mining path-based representations of code. PathMiner is fast, flexible, well-tested, and easily extensible to support input code in any common programming language. Preprint [https://doi.org/10.5281/zenodo.2595271]; released tool [https://doi.org/10.5281/zenodo.2595257].</p>\n", "tags": ["representation", "grammar"], "tsne_embedding": [-3.7305283546447754, 15.033232688903809]}, {"key": "kremenek2007factor", "year": "2007", "title": "A Factor Graph Model for Software Bug Finding", "abstract": "<p>Automatic tools for finding software errors require\nknowledge of the rules a program must obey, or\n\u201cspecifications,\u201d before they can identify bugs. We\npresent a method that combines factor graphs and\nstatic program analysis to automatically infer specifications directly from programs. We illustrate the\napproach on inferring functions in C programs that\nallocate and release resources, and evaluate the approach on three codebases: SDL, OpenSSH, and\nthe OS kernel for Mac OS X (XNU). The inferred\nspecifications are highly accurate and with them we\nhave discovered numerous bugs.</p>\n\n", "tags": ["program analysis"], "tsne_embedding": [-14.522480964660645, -16.897321701049805]}, {"key": "kulal2019spoc", "year": "2019", "title": "SPoC: Search-based Pseudocode to Code", "abstract": "<p>We consider the task of mapping pseudocode to long programs that are functionally correct. Given test cases as a mechanism to validate programs, we search over the space of possible translations of the pseudocode to find a program that passes the validation. However, without proper credit assignment to localize the sources of program failures, it is difficult to guide search toward more promising programs. We propose to perform credit assignment based on signals from compilation errors, which constitute 88.7% of program failures. Concretely, we treat the translation of each pseudocode line as a discrete portion of the program, and whenever a synthesized program fails to compile, an error localization method tries to identify the portion of the program responsible for the failure. We then focus search over alternative translations of the pseudocode for those portions. For evaluation, we collected the SPoC dataset (Search-based Pseudocode to Code) containing 18,356 programs with human-authored pseudocode and test cases. Under a budget of 100 program compilations, performing search improves the synthesis success rate over using the top-one translation of the pseudocode from 25.6% to 44.7%.</p>\n", "tags": ["bimodal", "synthesis"], "tsne_embedding": [17.98284912109375, 2.824460029602051]}, {"key": "kurbatova2020recommendation", "year": "2020", "title": "Recommendation of Move Method Refactoring Using Path-Based Representation of Code", "abstract": "<p>Software refactoring plays an important role in increasing code quality. One of the most popular refactoring types is the Move Method refactoring. It is usually applied when a method depends more on members of other classes than on its own original class. Several approaches have been proposed to recommend Move Method refactoring automatically. Most of them are based on heuristics and have certain limitations (e.g., they depend on the selection of metrics and manually-defined thresholds). In this paper, we propose an approach to recommend Move Method refactoring based on a path-based representation of code called code2vec that is able to capture the syntactic structure and semantic information of a code fragment. We use this code representation to train a machine learning classifier suggesting to move methods to more appropriate classes. We evaluate the approach on two publicly available datasets: a manually compiled dataset of well-known open-source projects and a synthetic dataset with automatically injected code smell instances. The results show that our approach is capable of recommending accurate refactoring opportunities and outperforms JDeodorant and JMove, which are state of the art tools in this field.</p>\n", "tags": ["refactoring"], "tsne_embedding": [-16.486066818237305, -20.66015625]}, {"key": "kushman2013using", "year": "2013", "title": "Using Semantic Unification to Generate Regular Expressions from Natural Language", "abstract": "<p>We consider the problem of translating natural language text queries into regular expressions which represent their meaning. The mismatch in the level of abstraction between the natural language representation and the regular expression representation make this a novel and challenging problem. However, a given regular expression can be written in many semantically equivalent forms, and we exploit this flexibility to facilitate translation by finding a form which more directly corresponds to the natural language. We evaluate our technique on a set of natural language queries and their associated regular expressions which we gathered from Amazon Mechanical Turk. Our model substantially outperforms a state-of-the-art semantic parsing baseline, yielding a 29% absolute improvement in accuracy.</p>\n", "tags": ["bimodal", "code generation"], "tsne_embedding": [21.2347469329834, -1.4443269968032837]}, {"key": "lachaux2020unsupervised", "year": "2020", "title": "Unsupervised Translation of Programming Languages", "abstract": "<p>A transcompiler, also known as source-to-source translator, is a system that converts source code from a high-level programming language (such as C++ or Python) to another. Transcompilers are primarily used for interoperability, and to port codebases written in an obsolete or deprecated language (e.g. COBOL, Python 2) to a modern one. They typically rely on handcrafted rewrite rules, applied to the source code abstract syntax tree. Unfortunately, the resulting translations often lack readability, fail to respect the target language conventions, and require manual modifications in order to work properly. The overall translation process is timeconsuming and requires expertise in both the source and target languages, making code-translation projects expensive. Although neural models significantly outperform their rule-based counterparts in the context of natural language translation, their applications to transcompilation have been limited due to the scarcity of parallel data in this domain. In this paper, we propose to leverage recent approaches in unsupervised machine translation to train a fully unsupervised neural transcompiler. We train our model on source code from open source GitHub projects, and show that it can translate functions between C++, Java, and Python with high accuracy. Our method relies exclusively on monolingual source code, requires no expertise in the source or target languages, and can easily be generalized to other programming languages. We also build and release a test set composed of 852 parallel functions, along with unit tests to check the correctness of translations. We show that our model outperforms rule-based commercial baselines by a significant margin.</p>\n", "tags": ["migration"], "tsne_embedding": [12.159062385559082, 6.496209144592285]}, {"key": "lacomis2019neural", "year": "2019", "title": "A Neural Approach to Decompiled Identifier Renaming", "abstract": "<p>The decompiler is one of the most common tools for examining binaries without corresponding source code. It transforms binaries into high-level code, reversing the compilation process. However, compilation loses information contained within the original source code (e.g. structure, type information, and variable names). Semantically meaningful variable names are known to increase code understandability, but they generally cannot be recovered by decompilers. We propose the Decompiled Identifier Renaming Engine (DIRE), a novel probabilistic technique for variable name recovery that uses both lexical and structural information. We also present a technique for generating corpora suitable for training and evaluating models of decompiled code renaming, which we use to create a corpus of 164,632 unique x86-64 binaries generated from C projects mined from GitHub. Our results show that on this corpus DIRE can predict variable names identical to the names in the original source code up to 74.3% of the time.</p>\n", "tags": ["deobfuscation", "naming", "compilation"], "tsne_embedding": [-17.12190055847168, 15.577438354492188]}, {"key": "lanchantin2018exploring", "year": "2018", "title": "Exploring the Naturalness of Buggy Code with Recurrent Neural Network", "abstract": "<p>Statistical   language   models   are   powerful   tools\nwhich  have  been  used  for  many  tasks  within  natural language processing. Recently, they have been\nused for other sequential data such as source code.\n(Ray et al., 2015) showed that it is possible train an\nn-gram\nsource code language mode,  and use it to\npredict buggy lines in code by determining \u201cunnatural\u201d lines via entropy with respect to the language\nmodel.  In this work, we propose using a more advanced language modeling technique, Long Short-term Memory recurrent neural networks, to model\nsource code and classify buggy lines based on entropy.   We  show  that  our  method  slightly  outperforms an\nn-gram model in the buggy line classification task using AUC</p>\n", "tags": ["language model", "defect"], "tsne_embedding": [0.8903043270111084, -8.596742630004883]}, {"key": "leclair2019neural", "year": "2019", "title": "A Neural Model for Generating Natural Language Summaries of Program Subroutines", "abstract": "<p>Source code summarization \u2013 creating natural language descriptions of source code behavior \u2013 is a rapidly-growing research topic with applications to automatic documentation generation, program comprehension, and software maintenance. Traditional techniques relied on heuristics and templates built manually by human experts. Recently, data-driven approaches based on neural machine translation have largely overtaken template-based systems. But nearly all of these techniques rely almost entirely on programs having good internal documentation; without clear identifier names, the models fail to create good summaries. In this paper, we present a neural model that combines words from code with code structure from an AST. Unlike previous approaches, our model processes each data source as a separate input, which allows the model to learn code structure independent of the text in code. This process helps our approach provide coherent summaries in many cases even when zero internal documentation is provided. We evaluate our technique with a dataset we created from 2.1m Java methods. We find improvement over two baseline techniques from SE literature and one from NLP literature.</p>\n", "tags": ["summarization", "documentation"], "tsne_embedding": [8.370781898498535, -9.081829071044922]}, {"key": "leclair2019recommendations", "year": "2019", "title": "Recommendations for Datasets for Source Code Summarization", "abstract": "<p>Source Code Summarization is the task of writing short, natural language descriptions of source code. The main use for these descriptions is in software documentation e.g. the one-sentence Java method descriptions in JavaDocs. Code summarization is rapidly becoming a popular research problem, but progress is restrained due to a lack of suitable datasets. In addition, a lack of community standards for creating datasets leads to confusing and unreproducible research results \u2013 we observe swings in performance of more than 33% due only to changes in dataset design. In this paper, we make recommendations for these standards from experimental results. We release a dataset based on prior work of over 2.1m pairs of Java methods and one sentence method descriptions from over 28k Java projects. We describe the dataset and point out key differences from natural language data, to guide and support future researchers.</p>\n", "tags": ["summarization", "dataset"], "tsne_embedding": [7.4661736488342285, -10.611132621765137]}, {"key": "leclair2020improved", "year": "2020", "title": "Improved Code Summarization via a Graph Neural Network", "abstract": "<p>Automatic source code summarization is the task of generating natural language descriptions for source code. Automatic code summarization is a rapidly expanding research area, especially as the community has taken greater advantage of advances in neural network and AI technologies. In general, source code summarization techniques use the source code as input and outputs a natural language description. Yet a strong consensus is developing that using structural information as input leads to improved performance. The first approaches to use structural information flattened the AST into a sequence. Recently, more complex approaches based on random AST paths or graph neural networks have improved on the models using flattened ASTs. However, the literature still does not describe the using a graph neural network together with source code sequence as separate inputs to a model. Therefore, in this paper, we present an approach that uses a graph-based neural architecture that better matches the default structure of the AST to generate these summaries. We evaluate our technique using a data set of 2.1 million Java method-comment pairs and show improvement over four baseline techniques, two from the software engineering literature, and two from machine learning literature.</p>\n", "tags": ["summarization"], "tsne_embedding": [9.130900382995605, -9.929259300231934]}, {"key": "lee2020montage", "year": "2020", "title": "Montage: A Neural Network Language Model-Guided JavaScript Engine Fuzzer", "abstract": "<p>JavaScript (JS) engine vulnerabilities pose significant security threats affecting billions of web browsers. While fuzzing is a prevalent technique for finding such vulnerabilities, there have been few studies that leverage the recent advances in neural network language models (NNLMs). In this paper, we present Montage, the first NNLM-guided fuzzer for finding JS engine vulnerabilities. The key aspect of our technique is to transform a JS abstract syntax tree (AST) into a sequence of AST subtrees that can directly train prevailing NNLMs. We demonstrate that Montage is capable of generating valid JS tests, and show that it outperforms previous studies in terms of finding vulnerabilities. Montage found 37 real-world bugs, including three CVEs, in the latest JS engines, demonstrating its efficacy in finding JS engine bugs.</p>\n", "tags": ["fuzzing", "language model"], "tsne_embedding": [6.275827407836914, 7.029848575592041]}, {"key": "lee2021cotraining", "year": "2021", "title": "Co-Training for Commit Classification", "abstract": "<p>Commits in version control systems (e.g. Git) track changes in a software project. Commits comprise noisy user-generated natural language and code patches. Automatic commit classification (CC) has been used to determine the type of code maintenance activities performed, as well as to detect bug fixes in code repositories. Much prior work occurs in the fully-supervised setting \u2013 a setting that can be a stretch in resource-scarce situations presenting difficulties in labeling commits. In this paper, we apply co-training, a semi-supervised learning method, to take advantage of the two views available \u2013 the commit message (natural language) and the code changes (programming language) \u2013 to improve commit classification.</p>\n", "tags": ["Transformer", "bimodal", "defect"], "tsne_embedding": [0.6820520162582397, -20.196775436401367]}, {"key": "levy2017learning", "year": "2017", "title": "Learning to Align the Source Code to the Compiled Object Code", "abstract": "<p>We propose a new neural network architecture\nand use it for the task of statement-by-statement\nalignment of source code and its compiled object code. Our architecture learns the alignment\nbetween the two sequences \u2013 one being the translation of the other \u2013 by mapping each statement\nto a context-dependent representation vector and\naligning such vectors using a grid of the two sequence domains. Our experiments include short\nC functions, both artificial and human-written,\nand show that our neural network architecture\nis able to predict the alignment with high accuracy, outperforming known baselines. We also\ndemonstrate that our model is general and can\nlearn to solve graph problems such as the Traveling Salesman Problem.</p>\n", "tags": ["decompilation"], "tsne_embedding": [13.602724075317383, -14.422142028808594]}, {"key": "lherondelle2022topical", "year": "2022", "title": "Topical: Learning Repository Embeddings from Source Code using Attention", "abstract": "<p>Machine learning on source code (MLOnCode) promises to transform how software is delivered. By mining the context and relationship between software artefacts, MLOnCode\naugments the software developer\u2019s capabilities with code autogeneration, code recommendation, code auto-tagging and other data-driven enhancements. For many of these tasks a script level\nrepresentation of code is sufficient, however, in many cases a repository level representation that takes into account various dependencies and repository structure is imperative, for example,\nauto-tagging repositories with topics or auto-documentation of repository code etc. Existing methods for computing repository level representations suffer from (a) reliance on natural language\ndocumentation of code (for example, README files) (b) naive aggregation of method/script-level representation, for example, by concatenation or averaging. This paper introduces Topical a\ndeep neural network to generate repository level embeddings of publicly available GitHub code repositories directly from source code. Topical incorporates an attention mechanism that projects the source code, the full dependency graph and the\nscript level textual information into a dense repository-level representation. To compute the repository-level representations, Topical is trained to predict the topics associated with a repository, on a dataset of publicly available GitHub repositories that\nwere crawled along with their ground truth topic tags. Our experiments show that the embeddings computed by Topical are able to outperform multiple baselines, including baselines\nthat naively combine the method-level representations through averaging or concatenation at the task of repository auto-tagging. Furthermore, we show that Topical\u2019s attention mechanism outperforms naive aggregation methods when computing repositorylevel representations from script-level representation generated\nby existing methods. Topical is a lightweight framework for computing repository-level representation of code repositories that scales efficiently with the number of topics and dataset size.</p>\n", "tags": ["representation", "topic modelling"], "tsne_embedding": [-5.804888725280762, 2.5683035850524902]}, {"key": "li2016gated", "year": "2016", "title": "Gated Graph Sequence Neural Networks", "abstract": "<p>Graph-structured data appears frequently in domains including chemistry, natural\nlanguage semantics, social networks, and knowledge bases. In this work, we study\nfeature learning techniques for graph-structured inputs. Our starting point is previous work on Graph Neural Networks (Scarselli et al., 2009), which we modify\nto use gated recurrent units and modern optimization techniques and then extend\nto output sequences. The result is a flexible and broadly useful class of neural network models that has favorable inductive biases relative to purely sequence-based\nmodels (e.g., LSTMs) when the problem is graph-structured. We demonstrate the\ncapabilities on some simple AI (bAbI) and graph algorithm learning tasks. We\nthen show it achieves state-of-the-art performance on a problem from program\nverification, in which subgraphs need to be described as abstract data structures.</p>\n\n", "tags": ["GNN", "program analysis"], "tsne_embedding": [11.35571002960205, -13.878962516784668]}, {"key": "li2017code", "year": "2017", "title": "Code Completion with Neural Attention and Pointer Networks", "abstract": "<p>Intelligent code completion has become an essential tool to accelerate modern software development. To facilitate effective code completion for dynamically-typed programming languages, we apply neural language models by learning from large codebases, and investigate the effectiveness of attention mechanism on the code completion task. However, standard neural language models even with attention mechanism cannot correctly predict out-of-vocabulary (OoV) words thus restrict the code completion performance. In this paper, inspired by the prevalence of locally repeated terms in program source code, and the recently proposed pointer networks which can reproduce words from local context, we propose a pointer mixture network for better predicting OoV words in code completion. Based on the context, the pointer mixture network learns to either generate a within-vocabulary word through an RNN component, or copy an OoV word from local context through a pointer component. Experiments on two benchmarked datasets demonstrate the effectiveness of our attention mechanism and pointer mixture network on the code completion task.</p>\n\n", "tags": ["language model", "autocomplete"], "tsne_embedding": [4.051047325134277, 11.163348197937012]}, {"key": "li2017software", "year": "2017", "title": "Software Defect Prediction via Convolutional Neural Network", "abstract": "<p>To improve software reliability, software defect prediction is utilized to assist developers in finding potential bugs\nand allocating their testing efforts. Traditional defect prediction\nstudies mainly focus on designing hand-crafted features, which\nare input into machine learning classifiers to identify defective\ncode. However, these hand-crafted features often fail to capture\nthe semantic and structural information of programs. Such\ninformation is important in modeling program functionality and\ncan lead to more accurate defect prediction.\nIn this paper, we propose a framework called Defect Prediction\nvia Convolutional Neural Network (DP-CNN), which leverages\ndeep learning for effective feature generation. Specifically, based\non the programs\u2019 Abstract Syntax Trees (ASTs), we first extract\ntoken vectors, which are then encoded as numerical vectors\nvia mapping and word embedding. We feed the numerical\nvectors into Convolutional Neural Network to automatically\nlearn semantic and structural features of programs. After that,\nwe combine the learned features with traditional hand-crafted\nfeatures, for accurate software defect prediction. We evaluate our\nmethod on seven open source projects in terms of F-measure in\ndefect prediction. The experimental results show that in average,\nDP-CNN improves the state-of-the-art method by 12%.</p>\n\n", "tags": ["defect"], "tsne_embedding": [-9.418313980102539, -12.576244354248047]}, {"key": "li2019improving", "year": "2019", "title": "Improving Bug Detection via Context-Based Code Representation Learning and Attention-Based Neural Networks", "abstract": "<p>Bug detection has been shown to be an effective way to help developers in detecting bugs early, thus, saving much effort and time in software development process. Recently, deep learning-based bug detection approaches have gained successes over the traditional machine learning-based approaches, the rule-based program analysis approaches, and mining-based approaches. However, they are still limited in detecting bugs that involve multiple methods and suffer high rate of false positives. In this paper, we propose a combination approach with the use of contexts and attention neural network to overcome those limitations. We propose to use as the global context the Program Dependence Graph (PDG) and Data Flow Graph (DFG) to connect the method under investigation with the other relevant methods that might contribute to the buggy code. The global context is complemented by the local context extracted from the path on the AST built from the method\u2019s body. The use of PDG and DFG enables our model to reduce the false positive rate, while to complement for the potential reduction in recall, we make use of the attention neural network mechanism to put more weights on the buggy paths in the source code. That is, the paths that are similar to the buggy paths will be ranked higher, thus, improving the recall of our model. We have conducted several experiments to evaluate our approach on a very large dataset with +4.973M methods in 92 different project versions. The results show that our tool can have a relative improvement up to 160% on F-score when comparing with the state-of-the-art bug detection approaches. Our tool can detect 48 true bugs in the list of top 100 reported bugs, which is 24 more true bugs when comparing with the baseline approaches. We also reported that our representation is better suitable for bug detection and relatively improves over the other representations up to 206% in accuracy.</p>\n", "tags": ["representation", "defect"], "tsne_embedding": [-9.480769157409668, -15.120335578918457]}, {"key": "li2019neural", "year": "2019", "title": "Neural Code Search Evaluation Dataset", "abstract": "<p>There has been an increase of interest in code search using natural language. Assessing the performance of such code search models can be difficult without a readily available evaluation suite. In this paper, we present an evaluation dataset consisting of natural language query and code snippet pairs, with the hope that future work in this area can use this dataset as a common benchmark. We also provide the results of two code search models ([1] and [6]) from recent work.</p>\n", "tags": ["dataset", "search"], "tsne_embedding": [-14.383831024169922, 5.880625247955322]}, {"key": "li2019using", "year": "2019", "title": "Using GGNN to recommend log statement level", "abstract": "<p>In software engineering, log statement is an important part because programmers can\u2019t access to users\u2019 program and they can only rely on log message to find the root of bugs. The mechanism of \u201clog level\u201d allows developers and users to specify the appropriate amount of logs to print during the execution of the software. And 26\\% of the log statement modification is to modify the level. We tried to use ML method to predict the suitable level of log statement. The specific model is GGNN(gated graph neural network) and we have drawn lessons from Microsoft\u2019s research. In this work, we apply Graph Neural Networks to predict the usage of log statement level of some open source java projects from github. Given the good performance of GGNN in this task, we are confident that GGNN is an excellent choice for processing source code. We envision this model can play an important role in applying AI/ML technique for Software Development Life Cycle more broadly.</p>\n", "tags": ["GNN", "logging"], "tsne_embedding": [-7.227499961853027, -10.423206329345703]}, {"key": "li2020dlfix", "year": "2020", "title": "DLFix: Context-based Code Transformation Learning for Automated Program Repair", "abstract": "<p>Automated Program Repair (APR) is very useful in helping developers in the process of software development and maintenance. Despite recent advances in deep learning (DL), the DL-based APR approaches still have limitations in learning bug-fixing code changes and the context of the surrounding source code of the bug-fixing code changes. These limitations lead to incorrect fixing locations or fixes. In this paper, we introduce DLFix, a two-tier DL model that treats APR as code transformation learning from the prior bug fixes and the surrounding code contexts of the fixes. The first layer is a tree-based RNN model that learns the contexts of bug fixes and its result is used as an additional weighting input for the second layer designed to learn the bug-fixing code transformations.</p>\n\n<p>We conducted several experiments to evaluate DLFix in two benchmarks: Defect4J and Bugs.jar, and a newly built bug datasets with a total of +20K real-world bugs in eight projects. We compared DLFix against a total of 13 state-of-the-art pattern-based APR tools. Our results show that DLFix can auto-fix more bugs than 11 of them, and is comparable and complementary to the top two pattern-based APR tools in which there are 7 and 11 unique bugs that they cannot detect, respectively, but we can. Importantly, DLFix is fully automated and data-driven, and does not require hard-coding of bug-fixing patterns as in those tools. We compared DLFix against 4 state-of-the-art deep learning based APR models. DLFix is able to fix 2.5 times more bugs than the best performing~baseline.</p>\n", "tags": ["edit", "repair", "grammar"], "tsne_embedding": [-7.204683303833008, -19.25014877319336]}, {"key": "li2020learning", "year": "2020", "title": "Learning Code-Query Interaction for Enhancing Code Searches", "abstract": "<p>Code search plays an important role in software development and maintenance. In recent years, deep learning (DL) has achieved a great success in this domain-several DL-based code search methods, such as DeepCS and UNIF, have been proposed for exploring deep, semantic correlations between code and queries; each method usually embeds source code and natural language queries into real vectors followed by computing their vector distances representing their semantic correlations. Meanwhile, deep learning-based code search still suffers from three main problems, i.e., the OOV (Out of Vocabulary) problem, the independent similarity matching problem, and the small training dataset problem. To tackle the above problems, we propose CQIL, a novel, deep learning-based code search method. CQIL learns code-query interactions and uses a CNN (Convolutional Neural Network) to compute semantic correlations between queries and code snippets. In particular, CQIL employs a hybrid representation to model code-query correlations, which solves the OOV problem. CQIL also deeply learns the code-query interaction for enhancing code searches, which solves the independent similarity matching and the small training dataset problems. We evaluate CQIL on two datasets (CODEnn and CosBench). The evaluation results show the strengths of CQIL-it achieves the MAP@1 values, 0.694 and 0.574, on CODEnn and CosBench, respectively. In particular, it outperforms DeepCS and UNIF, two state-of-the-art code search methods, by 13.6% and 18.1% in MRR, respectively, when the training dataset is insufficient.</p>\n", "tags": ["search"], "tsne_embedding": [-16.6279239654541, 5.547369956970215]}, {"key": "li2021learning", "year": "2021", "title": "Learning to Extend Program Graphs to Work-in-Progress Code", "abstract": "<p>Source code spends most of its time in a broken or incomplete state during software development. This presents a challenge to machine learning for code, since high-performing models typically rely on graph structured representations of programs derived from traditional program analyses. Such analyses may be undefined for broken or incomplete code. We extend the notion of program graphs to work-in-progress code by learning to predict edge relations between tokens, training on well-formed code before transferring to work-in-progress code. We consider the tasks of code completion and localizing and repairing variable misuse in a work-in-process scenario. We demonstrate that training relation-aware models with fine-tuned edges consistently leads to improved performance on both tasks.</p>\n", "tags": ["Transformer", "autocomplete", "repair"], "tsne_embedding": [-5.628622055053711, -8.659207344055176]}, {"key": "li2021toward", "year": "2021", "title": "Toward Less Hidden Cost of Code Completion with Acceptance and Ranking Models", "abstract": "<p>Code completion is widely used by software developers to provide coding suggestions given a partially written code snippet. Apart from the traditional code completion methods, which only support single token completion at minimal positions, recent studies show the ability to provide longer code completion at more flexible positions. However, such frequently triggered and longer completion results reduce the overall precision as they generate more invalid results. Moreover, different studies are mostly incompatible with each other. Thus, it is vital to develop an ensemble framework that can combine results from multiple models to draw merits and offset defects of each model.\nThis paper conducts a coding simulation to collect data from code context and different code completion models and then apply the data in two tasks. First, we introduce an acceptance model which can dynamically control whether to display completion results to the developer. It uses simulation features to predict whether correct results exist in the output of these models. Our best model reduces the percentage of false-positive completion from 55.09% to 17.44%. Second, we design a fusion ranking scheme that can automatically identify the priority of the completion results and reorder the candidates from multiple code completion models. This scheme is flexible in dealing with various models, regardless of the type or the length of their completion results. We integrate this ranking scheme with two frequency models and a GPT-2 styled language model, along with the acceptance model to yield 27.80% and 37.64% increase in TOP1 and TOP5 accuracy, respectively. In addition, we propose a new code completion evaluation metric, Benefit-Cost Ratio(BCR), taking into account the benefit of keystrokes saving and hidden cost of completion list browsing, which is closer to real coder experience scenario.</p>\n", "tags": ["autocomplete", "language model", "optimization", "Transformer"], "tsne_embedding": [2.374124050140381, 13.406289100646973]}, {"key": "li2022codereviewer", "year": "2022", "title": "CodeReviewer: Pre-Training for Automating Code Review Activities", "abstract": "<p>Code review is an essential part to software development lifecycle since it aims at guaranteeing the quality of codes. Modern code review activities necessitate developers viewing, understanding and even running the programs to assess logic, functionality, latency, style and other factors. It turns out that developers have to spend far too much time reviewing the code of their peers. Accordingly, it is in significant demand to automate the code review process. In this research, we focus on utilizing pre-training techniques for the tasks in the code review scenario. We collect a large-scale dataset of real world code changes and code reviews from open-source projects in nine of the most popular programming languages. To better understand code diffs and reviews, we propose CodeReviewer, a pre-trained model that utilizes four pre-training tasks tailored specifically for the code review senario. To evaluate our model, we focus on three key tasks related to code review activities, including code change quality estimation, review comment generation and code refinement. Furthermore, we establish a high-quality benchmark dataset based on our collected data for these three tasks and conduct comprehensive experiments on it. The experimental results demonstrate that our model outperforms the previous state-of-the-art pre-training approaches in all tasks. Further analysis show that our proposed pre-training tasks and the multilingual pre-training dataset benefit the model on the understanding of code changes and reviews.</p>\n", "tags": ["review"], "tsne_embedding": [-0.5097344517707825, -13.503625869750977]}, {"key": "li2022exploring", "year": "2022", "title": "Exploring Representation-Level Augmentation for Code Search", "abstract": "<p>Code search, which aims at retrieving the most relevant code fragment for a given natural language query, is a common activity in software development practice. Recently, contrastive learning is widely used in code search research, where many data augmentation approaches for source code (e.g., semantic-preserving program transformation) are proposed to learn better representations.  However, these augmentations are at the raw-data level, which requires additional code analysis in the preprocessing stage and additional training costs in the training stage. In this paper, we explore augmentation methods that augment data (both code and query) at representation level which does not require additional data processing and training, and based on this we propose a general format of representation-level augmentation that unifies existing methods. Then, we propose three new augmentation methods (linear extrapolation, binary interpolation, and Gaussian scaling) based on the general format. Furthermore, we theoretically analyze the advantages of the proposed augmentation methods over traditional contrastive learning methods on code search. We experimentally evaluate the proposed representation-level augmentation methods with state-of-the-art code search models on a large-scale public dataset consisting of six programming languages. The experimental results show that our approach can consistently boost the performance of the studied code search models.</p>\n", "tags": ["search", "Transformer"], "tsne_embedding": [-14.258282661437988, 8.898874282836914]}, {"key": "liguori2021shellcode_ia32", "year": "2021", "title": "Shellcode_IA32: A Dataset for Automatic Shellcode Generation", "abstract": "<p>We take the first step to address the task of automatically generating shellcodes, i.e., small pieces of code used as a payload in the exploitation of a software vulnerability, starting from natural language comments. We assemble and release a novel dataset (Shellcode_IA32), consisting of challenging but common assembly instructions with their natural language descriptions. We experiment with standard methods in neural machine translation (NMT) to establish baseline performance levels on this task.</p>\n", "tags": ["code generation", "dataset"], "tsne_embedding": [12.085869789123535, -2.902562141418457]}, {"key": "lin2017program", "year": "2017", "title": "Program Synthesis from Natural Language Using Recurrent Neural Networks", "abstract": "<p>Oftentimes, a programmer may have difficulty implementing a\ndesired operation. Even when the programmer can describe her\ngoal in English, it can be difficult to translate into code. Existing\nresources, such as question-and-answer websites, tabulate specific\noperations that someone has wanted to perform in the past, but\nthey are not effective in generalizing to new tasks, to compound\ntasks that require combining previous questions, or sometimes even\nto variations of listed tasks.</p>\n\n<p>Our goal is to make programming easier and more productive by\nletting programmers use their own words and concepts to express\nthe intended operation, rather than forcing them to accommodate\nthe machine by memorizing its grammar. We have built a system\nthat lets a programmer describe a desired operation in natural language, then automatically translates it to a programming language\nfor review and approval by the programmer. Our system, Tellina,\ndoes the translation using recurrent neural networks (RNNs), a\nstate-of-the-art natural language processing technique that we augmented with slot (argument) filling and other enhancements.</p>\n\n<p>We evaluated Tellina in the context of shell scripting. We trained\nTellina\u2019s RNNs on textual descriptions of file system operations\nand bash one-liners, scraped from the web. Although recovering\ncompletely correct commands is challenging, Tellina achieves top-3\naccuracy of 80% for producing the correct command structure. In a\ncontrolled study, programmers who had access to Tellina outperformed those who did not, even when Tellina\u2019s predictions were\nnot completely correct, to a statistically significant degree.</p>\n", "tags": ["bimodal", "code generation"], "tsne_embedding": [14.872549057006836, -10.864738464355469]}, {"key": "lin2018nl2bash", "year": "2018", "title": "NL2Bash: A Corpus and Semantic Parser for Natural Language Interface to the Linux Operating System", "abstract": "<p>We present new data and semantic parsing methods for the problem of mapping english sentences to Bash commands (NL2Bash). Our long-term goal is to enable any user to easily solve otherwise repetitive tasks (such as file manipulation, search, and application-specific scripting) by simply stating their intents in English. We take a first step in this domain, by providing a large new dataset of challenging but commonly used commands paired with their English descriptions, along with the baseline methods to establish performance levels on this task.</p>\n", "tags": ["bimodal", "code generation"], "tsne_embedding": [15.251694679260254, -0.18560241162776947]}, {"key": "lin2019impact", "year": "2019", "title": "On the Impact of Refactoring Operations on Code Naturalness", "abstract": "<p>Recent studies have demonstrated that software is natural, that is, its source code is highly repetitive and predictable like human languages. Also, previous studies suggested the existence of a relationship between code quality and its naturalness, presenting empirical evidence showing that buggy code is \u201cless natural\u201d than non-buggy code. We conjecture that this qualitynaturalness relationship could be exploited to support refactoring activities (e.g., to locate source code areas in need of refactoring). We perform a first step in this direction by analyzing whether refactoring can improve the naturalness of code. We use state-of-the-art tools to mine a large dataset of refactoring operations performed in open source systems. Then, we investigate the impact of different types of refactoring operations on the naturalness of the impacted code. We found that (i) code refactoring does not necessarily increase the naturalness of the refactored code; and (ii) the impact on the code naturalness strongly depends on the type of refactoring operations.</p>\n", "tags": ["language model", "refactoring"], "tsne_embedding": [-15.795100212097168, -20.318618774414062]}, {"key": "ling2016latent", "year": "2016", "title": "Latent Predictor Networks for Code Generation", "abstract": "<p>Many  language  generation  tasks  require\nthe production of text conditioned on both\nstructured  and  unstructured  inputs.\nWe present  a  novel  neural  network  architecture  which  generates  an  output  sequence\nconditioned on an arbitrary number of input  functions.\nCrucially,  our  approach\nallows  both  the  choice  of  conditioning\ncontext and the granularity of generation,\nfor  example  characters  or  tokens,  to  be\nmarginalised, thus permitting scalable and\neffective training.  Using this framework,\nwe address the problem of generating programming code from a mixed natural language  and  structured  specification.\nWe create two new data sets for this paradigm\nderived  from  the  collectible  trading  card\ngames  Magic  the  Gathering  and  Hearthstone.   On  these,  and  a  third  preexisting\ncorpus,  we  demonstrate  that  marginalising multiple predictors allows our model\nto outperform strong benchmarks.</p>\n\n", "tags": ["bimodal", "code generation"], "tsne_embedding": [14.686856269836426, -7.331377029418945]}, {"key": "ling2020adaptive", "year": "2020", "title": "Adaptive Deep Code Search", "abstract": "<p>Searching code in a large-scale codebase using natural language queries is a common practice during software development. Deep learning-based code search methods demonstrate superior performance if models are trained with large amount of text-code pairs. However, few deep code search models can be easily transferred from one codebase to another. It can be very costly to prepare training data for a new codebase and re-train an appropriate deep learning model. In this paper, we propose AdaCS, an adaptive deep code search method that can be trained once and transferred to new codebases. AdaCS decomposes the learning process into embedding domain-specific words and matching general syntactic patterns. Firstly, an unsupervised word embedding technique is used to construct a matching matrix to represent the lexical similarities. Then, a recurrent neural network is used to capture latent syntactic patterns from these matching matrices in a supervised way. As the supervised task learns general syntactic patterns that exist across domains, AdaCS is transferable to new codebases. Experimental results show that: when extended to new software projects never seen in the training data, AdaCS is more robust and significantly outperforms state-of-the-art deep code search methods.</p>\n", "tags": ["search"], "tsne_embedding": [-17.609285354614258, 4.886910438537598]}, {"key": "ling2020deep", "year": "2020", "title": "Deep Graph Matching and Searching for Semantic Code Retrieval", "abstract": "<p>Code retrieval is to find the code snippet from a large corpus of source code repositories that highly matches the query of natural language description. Recent work mainly uses natural language processing techniques to process both query texts (i.e., human natural language) and code snippets (i.e., machine programming language), however neglecting the deep structured features of query texts and source codes, both of which contain rich semantic information. In this paper, we propose an end-to-end deep graph matching and searching (DGMS) model based on graph neural networks for the task of semantic code retrieval. To this end, we first represent both natural language query texts and programming language code snippets with the unified graph-structured data, and then use the proposed graph matching and searching model to retrieve the best matching code snippet. In particular, DGMS not only captures more structural information for individual query texts or code snippets but also learns the fine-grained similarity between them by cross-attention based semantic matching operations. We evaluate the proposed DGMS model on two public code retrieval datasets with two representative programming languages (i.e., Java and Python). Experiment results demonstrate that DGMS significantly outperforms state-of-the-art baseline models by a large margin on both datasets. Moreover, our extensive ablation studies systematically investigate and illustrate the impact of each part of DGMS.</p>\n", "tags": ["search", "GNN"], "tsne_embedding": [-15.606006622314453, 4.379115581512451]}, {"key": "liu2016towards", "year": "2016", "title": "Towards Better Program Obfuscation: Optimization via Language Models", "abstract": "<p>As a common practice in software development, program\nobfuscation aims at deterring reverse engineering and malicious attacks on released source or binary code. Owning ample obfuscation techniques, we have relatively little\nknowledge on how to most effectively use them. The biggest\nchallenge lies in identifying the most useful combination of\nthese techniques. We propose a unified framework to automatically generate and optimize obfuscation based on an\nobscurity language model and a Monte Carlo Markov Chain\n(MCMC) based search algorithm. We further instantiate it\nfor JavaScript programs and developed the Closure tool.\nCompared to the well-known Google Closure Compiler, Closure outperforms its default setting by 26%. For programs\nwhich have already been well obfuscated, Closure can still\noutperform by 22%.</p>\n", "tags": ["deobfuscation"], "tsne_embedding": [-14.835834503173828, 18.680082321166992]}, {"key": "liu2018neural", "year": "2018", "title": "Neural-Machine-Translation-Based Commit Message Generation: How Far Are We?", "abstract": "<p>Commit messages can be regarded as the documentation of software changes. These messages describe the content and purposes of changes, hence are useful for program comprehension and software maintenance. However, due to the lack of time and direct motivation, commit messages sometimes are neglected by developers. To address this problem, Jiang et al. proposed an approach (we refer to it as NMT), which leverages a neural machine translation algorithm to automatically generate short commit messages from code. The reported performance of their approach is promising, however, they did not explore why their approach performs well. Thus, in this paper, we first perform an in-depth analysis of their experimental results. We find that (1) Most of the test &lt;pre&gt;diffs&lt;/pre&gt; from which NMT can generate high-quality messages are similar to one or more training &lt;pre&gt;diffs&lt;/pre&gt; at the token level. (2) About 16% of the commit messages in Jiang et al.\u2019s dataset are noisy due to being automatically generated or due to them describing repetitive trivial changes. (3) The performance of NMT declines by a large amount after removing such noisy commit messages. In addition, NMT is complicated and time-consuming. Inspired by our first finding, we proposed a simpler and faster approach, named NNGen (Nearest Neighbor Generator), to generate concise commit messages using the nearest neighbor algorithm. Our experimental results show that NNGen is over 2,600 times faster than NMT, and outperforms NMT in terms of BLEU (an accuracy measure that is widely used to evaluate machine translation systems) by 21%. Finally, we also discuss some observations for the road ahead for automated commit message generation to inspire other researchers.</p>\n", "tags": ["edit", "summarization"], "tsne_embedding": [2.4106204509735107, -19.762630462646484]}, {"key": "liu2019deepfuzz", "year": "2019", "title": "DeepFuzz: Automatic Generation of Syntax Valid C Programs for Fuzz Testing", "abstract": "<p>Compilers  are among  the  most  fundamental  programming\ntools for building software. However, production compilers\nremain  buggy.  Fuzz  testing  is  often  leveraged  with  newly-generated,\nor  mutated  inputs  in  order  to  find  new  bugs  or security vulnerabilities.\nIn this paper, we propose a grammar-based fuzzing tool called DeepFuzz. Based on a generative\nSequence-to-Sequence model, DeepFuzz automatically and continuously generates well-formed\nC programs. We use this set of new C programs to fuzz off-the-shelf C compilers, e.g. GCC and Clang/LLVM.\nWe present a detailed case study to analyze  the  success  rate  and  coverage  improvement  of  the\ngenerated C programs for fuzz testing. We analyze the performance of DeepFuzz with three types of sampling\nmethods  as  well  as  three  types  of  generation  strategies.  Consequently, DeepFuzz \nimproved the testing efficacy in regards to the line, function, and branch coverage. In our preliminary\nstudy, we found and reported 8 bugs of GCC, all of which are actively being addressed by developers.</p>\n", "tags": ["fuzzing", "code generation"], "tsne_embedding": [10.438848495483398, 18.812776565551758]}, {"key": "liu2019generating", "year": "2019", "title": "Generating commit messages from diffs using pointer-generator network", "abstract": "<p>The commit messages in source code repositories are valuable but not easy to be generated manually in time for tracking issues, reporting bugs, and understanding codes. Recently published works indicated that the deep neural machine translation approaches have drawn considerable attentions on automatic generation of commit messages. However, they could not deal with out-of-vocabulary (OOV) words, which are essential context-specific identifiers such as class names and method names in code diffs. In this paper, we propose PtrGNCMsg, a novel approach which is based on an improved sequence-to-sequence model with the pointer-generator network to translate code diffs into commit messages. By searching the smallest identifier set with the highest probability, PtrGNCMsg outperforms recent approaches based on neural machine translation, and first enables the prediction of OOV words. The experimental results based on the corpus of diffs and manual commit messages from the top 2,000 Java projects in GitHub show that PtrGNCMsg outperforms the state-of-the-art approach with improved BLEU by 1.02, ROUGE-1 by 4.00 and ROUGE-L by 3.78, respectively.</p>\n", "tags": ["edit"], "tsne_embedding": [3.0368802547454834, -20.11392593383789]}, {"key": "liu2019learning", "year": "2019", "title": "Learning to Sport and Refactor Inconsistent Method Names", "abstract": "<p>To ensure code readability and facilitate software maintenance, program methods must be named properly. In particular, method names must be consistent with the corresponding method implementations. Debugging method names remains an important topic in the literature, where various approaches analyze commonalities among method names in a large dataset to detect inconsistent method names and suggest better ones. We note that the state-of-the-art does not analyze the implemented code itself to assess consistency. We thus propose a novel automated approach to debugging method names based on the analysis of consistency between method names and method code. The approach leverages deep feature representation techniques adapted to the nature of each artifact. Experimental results on over 2.1 million Java methods show that we can achieve up to 15 percentage points improvement over the state-of-the-art, establishing a record performance of 67.9% F1-measure in identifying inconsistent method names. We further demonstrate that our approach yields up to 25% accuracy in suggesting full names, while the state-of-the-art lags far behind at 1.1% accuracy. Finally, we report on our success in fixing 66 inconsistent method names in a live study on projects in the wild.</p>\n", "tags": ["naming"], "tsne_embedding": [-20.287479400634766, -4.083089828491211]}, {"key": "liu2019neural", "year": "2019", "title": "Neural query expansion for code search", "abstract": "<p>Searching repositories of existing source code for code snippets is a key task in software engineering. Over the years, many approaches to this problem have been proposed. One recent tool called NCS, takes in a natural language query and outputs relevant code snippets, often being able to correctly answer Stack Overflow questions. But what happens when the developer doesn\u2019t provide a query with a clear intent? What if shorter queries are used to demonstrate a more vague intent?</p>\n\n<p>We find that the performance of NCS regresses with shorter queries. Furthermore, data from developers\u2019 code search history logs shows that shorter queries have a less successful code search session: there are more query reformulations and more time is spent browsing the results. These observations lead us to believe that using NCS alone with short queries may not be productive enough.</p>\n\n<p>In this paper, we explore an additional way of using neural networks in code search: the automatic expansion of queries. We present NQE, a neural model that takes in a set of keywords and predicts a set of keywords to expand the query to NCS. NQE learns to predict keywords that co-occur with the query keywords in the underlying corpus, which helps expand the query in a productive way. Our results show that with query expansion, NQE + NCS is able to perform better than using NCS alone.</p>\n", "tags": ["search"], "tsne_embedding": [-15.637319564819336, 7.543615341186523]}, {"key": "liu2020automating", "year": "2020", "title": "Automating Just-In-Time Comment Updating", "abstract": "<p>Code comments are valuable for program comprehension and software maintenance, and also require maintenance with code evolution. However, when changing code, developers sometimes neglect updating the related comments, bringing in inconsistent or obsolete comments (aka., bad comments). Such comments are detrimental since they may mislead developers and lead to future bugs. Therefore, it is necessary to fix and avoid bad comments. In this work, we argue that bad comments can be reduced and even avoided by automatically performing comment updates with code changes. We refer to this task as \u201cJust-In-Time (JIT) Comment Updating\u201d and propose an approach named CUP (Comment UPdater) to automate this task. CUP can be used to assist developers in updating comments during code changes and can consequently help avoid the introduction of bad comments. Specifically, CUP leverages a novel neural sequence-to-sequence model to learn comment update patterns from extant code-comment co-changes and can automatically generate a new comment based on its corresponding old comment and code change. Several customized enhancements, such as a special tokenizer and a novel co-attention mechanism, are introduced in CUP by us to handle the characteristics of this task. We build a dataset with over 108K comment-code co-change samples and evaluate CUP on it. The evaluation results show that CUP outperforms an information-retrieval-based and a rule-based baselines by substantial margins, and can reduce developers\u2019 edits required for JIT comment updating. In addition, the comments generated by our approach are identical to those updated by developers in 1612 (16.7%) test samples, 7 times more than the best-performing baseline.</p>\n", "tags": ["documentation"], "tsne_embedding": [1.5174614191055298, -14.735509872436523]}, {"key": "liu2022open", "year": "2022", "title": "Open-ended Knowledge Tracing", "abstract": "<p>In education applications, knowledge tracing refers to the problem of estimating students\u2019 time-varying concept/skill mastery level from their past responses to questions and predicting their future performance. One key limitation of most existing knowledge tracing methods is that they treat student responses to questions as binary-valued, i.e., whether they are correct or incorrect. Response correctness analysis/prediction ignores important information on student knowledge contained in the exact content of the responses, especially for open-ended questions. In this paper, we conduct the first exploration into open-ended knowledge tracing (OKT) by studying the new task of predicting students\u2019 exact open-ended responses to questions. Our work is grounded in the domain of computer science education with programming questions. We develop an initial solution to the OKT problem, a student knowledge-guided code generation approach, that combines program synthesis methods using language models with student knowledge tracing methods. We also conduct a series of quantitative and qualitative experiments on a real-world student code dataset to validate OKT and demonstrate its promise in educational applications.</p>\n", "tags": ["education", "code generation"], "tsne_embedding": [20.06367301940918, 22.064878463745117]}, {"key": "lomshakov2023fine", "year": "2023", "title": "Fine-Tuning Large Language Models for Answering Programming Questions with Code Snippets", "abstract": "<p>We study the ability of pretrained large language models (LLM) to answer questions from online question answering fora such as Stack Overflow. We consider question-answer pairs where the main part of the answer consists of source code. On two benchmark datasets \u2014 CoNaLa and a newly collected dataset based on Stack Overflow \u2014 we investigate how a closed-book question answering system can be improved by fine-tuning the LLM for the downstream task, prompt engineering, and data preprocessing. We use publicly available autoregressive language models such as GPT-Neo, CodeGen, and PanGu-Coder, and after the proposed fine-tuning achieve a BLEU score of 0.4432 on the CoNaLa test set, significantly exceeding previous state of the art for this task.</p>\n", "tags": ["program synthesis", "question answering", "large language models"], "tsne_embedding": [16.672819137573242, 8.46234130859375]}, {"key": "louis2018deep", "year": "2018", "title": "Deep Learning to Detect Redundant Method Comments", "abstract": "<p>Comments in software are critical for maintenance and reuse. But apart from prescriptive advice, there is little practical support or quantitative understanding of what makes a comment useful. In this paper, we introduce the task of identifying comments which are uninformative about the code they are meant to document. To address this problem, we introduce the notion of comment entailment from code, high entailment indicating that a comment\u2019s natural language semantics can be inferred directly from the code. Although not all entailed comments are low quality, comments that are too easily inferred, for example, comments that restate the code, are widely discouraged by authorities on software style. Based on this, we develop a tool called CRAIC which scores method-level comments for redundancy. Highly redundant comments can then be expanded or alternately removed by the developer. CRAIC uses deep language models to exploit large software corpora without requiring expensive manual annotations of entailment. We show that CRAIC can perform the comment entailment task with good agreement with human judgements. Our findings also have implications for documentation tools. For example, we find that common tags in Javadoc are at least two times more predictable from code than non-Javadoc sentences, suggesting that Javadoc tags are less informative than more free-form comments</p>\n", "tags": ["bimodal", "documentation"], "tsne_embedding": [2.320995807647705, -12.39518928527832]}, {"key": "louis2020where", "year": "2020", "title": "Where should I comment my code? A dataset and model for predicting locations that need comments", "abstract": "<p>Programmers should write code comments, but not on every line\nof code. We have created a machine learning model that suggests\nlocations where a programmer should write a code comment. We\ntrained it on existing commented code to learn locations that are\nchosen by developers. Once trained, the model can predict locations\nin new code. Our models achieved precision of 74% and recall of\n13% in identifying comment-worthy locations. This first success\nopens the door to future work, both in the new where-to-comment\nproblem and in guiding comment generation.</p>\n", "tags": ["bimodal", "documentation"], "tsne_embedding": [1.4606876373291016, -11.106645584106445]}, {"key": "loyola2017neural", "year": "2017", "title": "A Neural Architecture for Generating Natural Language Descriptions from Source Code Changes", "abstract": "<p>We propose a model to automatically describe changes introduced in the source code of a program using natural language. Our method receives as input a set of code commits, which contains both the modifications and message introduced by an user. These two modalities are used to train an encoder-decoder architecture. We evaluated our approach on twelve real world open source projects from four different programming languages. Quantitative and qualitative results showed that the proposed approach can generate feasible and semantically sound descriptions not only in standard in-project settings, but also in a cross-project setting.</p>\n", "tags": ["edit", "summarization"], "tsne_embedding": [2.7104454040527344, -17.5483455657959]}, {"key": "loyola2018content", "year": "2018", "title": "Content Aware Source Code Change Description Generation", "abstract": "<p>We propose to study the generation of descriptions from source code changes by integrating  the  messages  included  on  code\ncommits and the intra-code documentation\ninside the source in the form of docstrings.\nOur hypothesis is that although both types\nof descriptions are not directly aligned in\nsemantic terms \u2014one explaining a change\nand  the  other  the  actual  functionality  of\nthe code being modified\u2014 there could be\ncertain common ground that is useful for\nthe  generation.   To  this  end,  we  propose\nan architecture that uses the source code-docstring relationship to guide the description generation.  We discuss the results of\nthe approach comparing against a baseline\nbased  on  a  sequence-to-sequence  model,\nusing standard automatic natural language\ngeneration metrics as well as with a human\nstudy, thus offering a comprehensive view\nof the feasibility of the approach.</p>\n", "tags": ["edit", "summarization"], "tsne_embedding": [2.464888095855713, -17.1273193359375]}, {"key": "lu2019program", "year": "2019", "title": "Program Classification Using Gated Graph Attention Neural Network for Online Programming Service", "abstract": "<p>The online programing services, such as Github, TopCoder, and EduCoder, have promoted a lot of social interactions among the service users. However, the existing social interactions is rather limited and inefficient due to the rapid increasing of source-code repositories, which is difficult to explore manually. The emergence of source-code mining provides a promising way to analyze those source codes, so that those source codes can be relatively easy to understand and share among those service users. Among all the source-code mining attempts,program classification lays a foundation for various tasks related to source-code understanding, because it is impossible for a machine to understand a computer program if it cannot classify the program correctly. Although numerous machine learning models, such as the Natural Language Processing (NLP) based models and the Abstract Syntax Tree (AST) based models, have been proposed to classify computer programs based on their corresponding source codes, the existing works cannot fully characterize the source codes from the perspective of both the syntax and semantic information. To address this problem, we proposed a Graph Neural Network (GNN) based model, which integrates data flow and function call information to the AST,and applies an improved GNN model to the integrated graph, so as to achieve the state-of-art program classification accuracy. The experiment results have shown that the proposed work can classify programs with accuracy over 97%.</p>\n", "tags": ["GNN", "representation"], "tsne_embedding": [-8.563132286071777, -6.974808216094971]}, {"key": "lu2021codexglue", "year": "2021", "title": "CodeXGLUE: A Machine Learning Benchmark Dataset for Code Understanding and Generation", "abstract": "<p>Benchmark datasets have a significant impact on accelerating research in programming language tasks. In this paper, we introduce CodeXGLUE, a benchmark dataset to foster machine learning research for program understanding and generation. CodeXGLUE includes a collection of 10 tasks across 14 datasets and a platform for model evaluation and comparison. CodeXGLUE also features three baseline systems, including the BERT-style, GPT-style, and Encoder-Decoder models, to make it easy for researchers to use the platform. The availability of such data and baselines can help the development and validation of new methods that can be applied to various program understanding and generation problems.</p>\n", "tags": ["benchmark", "Transformer"], "tsne_embedding": [11.693930625915527, 8.82160472869873]}, {"key": "lu2022reacc", "year": "2022", "title": "ReACC: A Retrieval-Augmented Code Completion Framework", "abstract": "<p>Code completion, which aims to predict the following code token(s) according to the code context, can improve the productivity of software development. Recent work has proved that statistical language modeling with transformers can greatly improve the performance in the code completion task via learning from large-scale source code datasets. However, current approaches focus only on code context within the file or project, i.e. internal context. Our distinction is utilizing \u201cexternal\u201d context, inspired by human behaviors of copying from the related code snippets when writing code. Specifically, we propose a retrieval-augmented code completion framework, leveraging both lexical copying and referring to code with similar semantics by retrieval. We adopt a stage-wise training approach that combines a source code retriever and an auto-regressive language model for programming language. We evaluate our approach in the code completion task in Python and Java programming languages, achieving a state-of-the-art performance on CodeXGLUE benchmark.</p>\n", "tags": ["Transformer", "autocomplete"], "tsne_embedding": [1.2256109714508057, 12.033944129943848]}, {"key": "luan2019aroma", "year": "2015", "title": "Aroma: code recommendation via structural code search", "abstract": "<p>Programmers often write code that has similarity to existing code written somewhere. A tool that could help programmers to search such similar code would be immensely useful. Such a tool could help programmers to extend partially written code snippets to completely implement necessary functionality, help to discover extensions to the partial code which are commonly included by other programmers, help to cross-check against similar code written by other programmers, or help to add extra code which would fix common mistakes and errors. We propose Aroma, a tool and technique for code recommendation via structural code search. Aroma indexes a huge code corpus including thousands of open-source projects, takes a partial code snippet as input, searches the corpus for method bodies containing the partial code snippet, and clusters and intersects the results of the search to recommend a small set of succinct code snippets which both contain the query snippet and appear as part of several methods in the corpus. We evaluated Aroma on 2000 randomly selected queries created from the corpus, as well as 64 queries derived from code snippets obtained from Stack Overflow, a popular website for discussing code. We implemented Aroma for 4 different languages, and developed an IDE plugin for Aroma. Furthermore, we conducted a study where we asked 12 programmers to complete programming tasks using Aroma, and collected their feedback. Our results indicate that Aroma is capable of retrieving and recommending relevant code snippets efficiently.</p>\n", "tags": ["search"], "tsne_embedding": [-12.111055374145508, 8.559446334838867]}, {"key": "maddison2014structured", "year": "2014", "title": "Structured Generative Models of Natural Source Code", "abstract": "<p>We study the problem of building generative\nmodels of natural source code (NSC); that is,\nsource code written by humans and meant to\nbe understood by humans. Our primary con-\ntribution is to describe new generative models\nthat are tailored to NSC. The models are based\non probabilistic context free grammars (PCFGs)\nand neuro-probabilistic language models (Mnih\n&amp; Teh, 2012), which are extended to incorporate\nadditional source code-specific structure. These\nmodels can be efficiently trained on a corpus\nof source code and outperform a variety of less\nstructured baselines in terms of predictive log\nlikelihoods on held-out data.</p>\n\n", "tags": ["language model", "code generation", "grammar", "grammar"], "tsne_embedding": [16.746307373046875, -6.645323753356934]}, {"key": "mahmud2021code", "year": "2021", "title": "Code to Comment Translation: A Comparative Study on Model Effectiveness & Errors", "abstract": "<p>Automated source code summarization is a popular software engineering research topic wherein machine translation models are employed to \u201ctranslate\u201d code snippets into relevant natural language descriptions. Most evaluations of such models are conducted using automatic reference-based metrics. However, given the relatively large semantic gap between programming languages and natural language, we argue that this line of research would benefit from a qualitative investigation into the various error modes of current state-of-the-art models. Therefore, in this work, we perform both a quantitative and qualitative comparison of three recently proposed source code summarization models. In our quantitative evaluation, we compare the models based on the smoothed BLEU-4, METEOR, and ROUGE-L machine translation metrics, and in our qualitative evaluation, we perform a manual open-coding of the most common errors committed by the models when compared to ground truth captions. Our investigation reveals new insights into the relationship between metric-based performance and model prediction errors grounded in an error taxonomy that can be used to drive future research efforts.</p>\n", "tags": ["survey", "summarization", "Transformer"], "tsne_embedding": [6.359640121459961, -11.381911277770996]}, {"key": "malik2019nl2type", "year": "2019", "title": "NL2Type: Inferring JavaScript Function Types from Natural Language Information", "abstract": "<p>JavaScript is dynamically typed and hence lacks thetype safety  of  statically  typed  languages,\nleading  to  suboptimal IDE support, difficult to understand APIs, and unexpected run-time behavior.\nSeveral gradual type systems have been proposed, e.g., Flow and TypeScript, but they rely on developers\nto annotatecode with types. This paper presents NL2Type, a learning-based approach for predicting likely\ntype signatures of JavaScript functions. The key idea is to exploit natural language information in\nsource code, such as comments, function names, and parameternames,  a  rich  source  of  knowledge\nthat  is  typically  ignored by  type  inference  algorithms.  We  formulate  the  problem  of predicting\ntypes as a classification problem and train a recurrent, LSTM-based neural model that, after learning\nfrom an annotatedcode  base,  predicts  function  types  for  unannotated  code.  We evaluate   the \napproach   with   a   corpus   of   162,673   JavaScript files  from  real-world  projects. \nNL2Type  predicts  types  with  aprecision of 84.1% and a recall of 78.9% when considering only\nthe  top-most  suggestion,  and  with  a  precision  of  95.5%  and  arecall  of  89.6%  when\nconsidering  the  top-5  suggestions.  The\napproach  outperforms  both  JSNice,  a  state-of-the-art  approach that  analyzes  implementations \nof  functions  instead  of  natural language  information,  and  DeepTyper,  a  recent  type  prediction\napproach that is also based on deep learning. Beyond predicting types,  NL2Type  serves  as  a\nconsistency  checker  for  existing type  annotations.  We  show  that  it  discovers  39  inconsistencies\nthat  deserve  developer  attention  (from  a  manual  analysis  of  50 warnings), most of which \nare due to incorrect type annotations.</p>\n", "tags": ["bimodal", "types"], "tsne_embedding": [-3.9406609535217285, 22.46445655822754]}, {"key": "mammadli2020static", "year": "2020", "title": "Static Neural Compiler Optimization via Deep Reinforcement Learning", "abstract": "<p>The phase-ordering problem of modern compilers has received a lot of attention from the research community over the years, yet remains largely unsolved. Various optimization sequences exposed to the user are manually designed by compiler developers. In designing such a sequence developers have to choose the set of optimization passes, their parameters and ordering within a sequence. Resulting sequences usually fall short of achieving optimal runtime for a given source code and may sometimes even degrade the performance when compared to unoptimized version. In this paper, we employ a deep reinforcement learning approach to the phase-ordering problem. Provided with sub-sequences constituting LLVM\u2019s O3 sequence, our agent learns to outperform the O3 sequence on the set of source codes used for training and achieves competitive performance on the validation set, gaining up to 1.32x speedup on previously-unseen programs. Notably, our approach differs from autotuning methods by not depending on one or more test runs of the program for making successful optimization decisions. It has no dependence on any dynamic feature, but only on the statically-attainable intermediate representation of the source code. We believe that the models trained using our approach can be integrated into modern compilers as neural optimization agents, at first to complement, and eventually replace the hand-crafted optimization sequences.</p>\n", "tags": ["compilation"], "tsne_embedding": [11.909907341003418, 16.942039489746094]}, {"key": "mangal2015user", "year": "2015", "title": "A User-Guided Approach to Program Analysis", "abstract": "<p>Program analysis tools often produce undesirable output\ndue to various approximations. We present an approach\nand a system Eugene that allows user feedback to guide\nsuch approximations towards producing the desired output.\nWe formulate the problem of user-guided program analysis in terms of solving a combination of hard rules and soft\nrules: hard rules capture soundness while soft rules capture\ndegrees of approximations and preferences of users. Our\ntechnique solves the rules using an off-the-shelf solver in a\nmanner that is sound (satisfies all hard rules), optimal (maximally satisfies soft rules), and scales to real-world analy-\nses and programs. We evaluate Eugene on two different\nanalyses with labeled output on a suite of seven Java pro-\ngrams of size 131\u2013198 KLOC. We also report upon a user\nstudy involving nine users who employ Eugene to guide an\ninformation-flow analysis on three Java micro-benchmarks.\nIn our experiments, Eugene significantly reduces misclassified reports upon providing limited amounts of feedback.</p>\n", "tags": ["program analysis"], "tsne_embedding": [-8.976258277893066, 18.431438446044922]}, {"key": "markovtsev2017topic", "year": "2017", "title": "Topic modeling of public repositories at scale using names in source code", "abstract": "<p>Programming languages themselves have a limited number of reserved keywords and character based tokens that\ndefine the language specification. However, programmers have a rich use of natural language within their code\nthrough comments, text literals and naming entities. The programmer defined names that can be found in source\ncode are a rich source of information to build a high level understanding of the project. The goal of this paper\nis to apply topic modeling to names used in over 13.6 million repositories and perceive the inferred topics.\nOne of the problems in such a study is the occurrence of duplicate repositories not officially marked as forks (obscure forks).\nWe show how to address it using the same identifiers which are extracted for topic modeling.</p>\n\n<p>We open with a discussion on naming in source code, we then elaborate on our approach to remove exact duplicate\nand fuzzy duplicate repositories using Locality Sensitive Hashing on the bag-of-words model and then discuss our work\non topic modeling; and finally present the results from our data analysis together with open-access to the source code,\ntools and datasets.</p>\n", "tags": ["topic modeling", "pattern mining"], "tsne_embedding": [-18.398258209228516, -1.7559326887130737]}, {"key": "markovtsev2018public", "year": "2018", "title": "Public Git Archive: a Big Code dataset for all", "abstract": "<p>The number of open source software projects has been growing exponentially. The major online software repository host, GitHub, has accumulated tens of millions of publicly available Git version-controlled repositories. Although the research potential enabled by the available open source code is clearly substantial, no significant large-scale open source code datasets exist. In this paper, we present the Public Git Archive \u2013 dataset of 182,014 top-bookmarked Git repositories from GitHub. We describe the novel data retrieval pipeline to reproduce it. We also elaborate on the strategy for performing dataset updates and legal issues. The Public Git Archive occupies 3.0 TB on disk and is an order of magnitude larger than the current source code datasets. The dataset is made available through HTTP and provides the source code of the projects, the related metadata, and development history. The data retrieval pipeline employs an optimized worker queue model and an optimized archive format to efficiently store forked Git repositories, reducing the amount of data to download and persist. Public Git Archive aims to open a myriad of new opportunities for Big Code research.</p>\n", "tags": ["dataset"], "tsne_embedding": [0.014391683973371983, 15.660175323486328]}, {"key": "markovtsev2019style", "year": "2019", "title": "STYLE-ANALYZER: fixing code style inconsistencies with interpretable unsupervised algorithms", "abstract": "<p>Source code reviews are manual, time-consuming, and expensive. Human involvement should be focused on analyzing the most relevant aspects of the program, such as logic and maintainability, rather than amending style, syntax, or formatting defects. Some tools with linting capabilities can format code automatically and report various stylistic violations for supported programming languages. They are based on rules written by domain experts, hence, their configuration is often tedious, and it is impractical for the given set of rules to cover all possible corner cases. Some machine learning-based solutions exist, but they remain uninterpretable black boxes. This paper introduces STYLE-ANALYZER, a new open source tool to automatically fix code formatting violations using the decision tree forest model which adapts to each codebase and is fully unsupervised. STYLE-ANALYZER is built on top of our novel assisted code review framework, Lookout. It accurately mines the formatting style of each analyzed Git repository and expresses the found format patterns with compact human-readable rules. STYLE-ANALYZER can then suggest style inconsistency fixes in the form of code review comments. We evaluate the output quality and practical relevance of STYLE-ANALYZER by demonstrating that it can reproduce the original style with high precision, measured on 19 popular JavaScript projects, and by showing that it yields promising results in fixing real style mistakes. STYLE-ANALYZER includes a web application to visualize how the rules are triggered. We release STYLE-ANALYZER as a reusable and extendable open source software package on GitHub for the benefit of the community.</p>\n", "tags": ["style"], "tsne_embedding": [-19.2509822845459, -18.631593704223633]}, {"key": "mastropaolo2022using", "year": "2022", "title": "Using Deep Learning to Generate Complete Log Statements", "abstract": "<p>Logging is a practice widely adopted in several phases of the software lifecycle. For example, during software development log statements allow engineers to verify and debug the system by exposing fine-grained information of the running software. While the benefits of logging are undisputed, taking proper decisions about where to inject log statements, what information to log, and at which log level (e.g., error, warning) is crucial for the logging effectiveness. In this paper, we present LANCE (Log stAtemeNt reCommEnder), the first approach supporting developers in all these decisions. LANCE features a Text-To-Text-Transfer-Transformer (T5) model that has been trained on 6,894,456 Java methods. LANCE takes as input a Java method and injects in it a full log statement, including a human-comprehensible logging message and properly choosing the needed log level and the statement location. Our results show that LANCE is able to (i) properly identify the location in the code where to inject the statement in 65.9% of Java methods requiring it; (ii) selecting the proper log level in 66.2% of cases; and (iii) generate a completely correct log statement including a meaningful logging message in 15.2% of cases.</p>\n", "tags": ["Transformer", "logging"], "tsne_embedding": [-6.881874084472656, -11.49078369140625]}, {"key": "mehrotra2020modeling", "year": "2020", "title": "Modeling Functional Similarity in Source Code with Graph-Based Siamese Networks", "abstract": "<p>Code clones are duplicate code fragments that share (nearly) similar syntax or semantics. Code clone detection plays an important role in software maintenance, code refactoring, and reuse. A substantial amount of research has been conducted in the past to detect clones. A majority of these approaches use lexical and syntactic information to detect clones. However, only a few of them target semantic clones. Recently, motivated by the success of deep learning models in other fields, including natural language processing and computer vision, researchers have attempted to adopt deep learning techniques to detect code clones. These approaches use lexical information (tokens) and(or) syntactic structures like abstract syntax trees (ASTs) to detect code clones. However, they do not make sufficient use of the available structural and semantic information hence, limiting their capabilities.</p>\n\n<p>This paper addresses the problem of semantic code clone detection using program dependency graphs and geometric neural networks, leveraging the structured syntactic and semantic information. We have developed a prototype tool HOLMES, based on our novel approach, and empirically evaluated it on popular code clone benchmarks. Our results show that HOLMES performs considerably better than the other state-of-the-art tool, TBCCD. We also evaluated HOLMES on unseen projects and performed cross dataset experiments to assess the generalizability of HOLMES. Our results affirm that HOLMES outperforms TBCCD since most of the pairs that HOLMES detected were either undetected or suboptimally reported by TBCCD.</p>\n", "tags": ["clone", "GNN"], "tsne_embedding": [-13.4051513671875, -3.53072452545166]}, {"key": "menon2013machine", "year": "2013", "title": "A Machine Learning Framework for Programming by Example", "abstract": "<p>Learning programs is a timely and interesting challenge. In Programming by Example\n(PBE), a system attempts to infer a program\nfrom input and output examples alone, by\nsearching for a composition of some set of\nbase functions. We show how machine learning can be used to speed up this seemingly\nhopeless search problem, by learning weights\nthat relate textual features describing the\nprovided input-output examples to plausible\nsub-components of a program. This generic\nlearning framework lets us address problems\nbeyond the scope of earlier PBE systems.\nExperiments on a prototype implementation\nshow that learning improves search and ranking on a variety of text processing tasks found\non help forums.</p>\n", "tags": ["code generation"], "tsne_embedding": [20.000852584838867, 18.902429580688477]}, {"key": "mesbah2019deepdelta", "year": "2019", "title": "DeepDelta: Learning to Repair Compilation Errors", "abstract": "<p>Programmers spend a substantial amount of time manually repairing\ncode that does not compile. We observe that the repairs for\nany particular error class typically follow a pattern and are highly\nmechanical. We propose a novel approach that automatically learns\nthese patterns with a deep neural network and suggests program\nrepairs for the most costly classes of build-time compilation failures.\nWe describe how we collect all build errors and the human-authored,\nin-progress code changes that cause those failing builds to transition\nto successful builds at Google. We generate an AST diff from the\ntextual code changes and transform it into a domain-specific\nlanguage called Delta that encodes the change that must be made\nto make the code compile. We then feed the compiler diagnostic\ninformation (as source) and the Delta changes that resolved the\ndiagnostic (as target) into a Neural Machine Translation network for\ntraining. For the two most prevalent and costly classes of Java compilation errors,\nnamely missing symbols and mismatched methodsignatures, our system called DeepDelta,\ngenerates the correct repair changes for 19,314 out of 38,788 (50%) of unseen compilation\nerrors. The correct changes are in the top three suggested axes 86% of the time on average.</p>\n", "tags": ["repair", "edit", "compilation"], "tsne_embedding": [-3.534766912460327, -18.367307662963867]}, {"key": "mir2021manytypes4py", "year": "2021", "title": "ManyTypes4Py: A Benchmark Python Dataset for Machine Learning-based Type Inference", "abstract": "<p>In this paper, we present ManyTypes4Py, a large Python dataset for machine learning (ML)-based type inference. The dataset contains a total of 5,382 Python projects with more than 869K type annotations. Duplicate source code files were removed to eliminate the negative effect of the duplication bias. To facilitate training and evaluation of ML models, the dataset was split into training, validation and test sets by files. To extract type information from abstract syntax trees (ASTs), a lightweight static analyzer pipeline is developed and accompanied with the dataset. Using this pipeline, the collected Python projects were analyzed and the results of the AST analysis were stored in JSON-formatted files. The ManyTypes4Py dataset is shared on zenodo and its tools are publicly available on GitHub.</p>\n", "tags": ["dataset", "types"], "tsne_embedding": [-2.5673024654388428, 25.203899383544922]}, {"key": "mir2021type4py", "year": "2021", "title": "Type4Py: Deep Similarity Learning-Based Type Inference for Python", "abstract": "<p>Dynamic languages, such as Python and Javascript, trade static typing for developer flexibility. While this allegedly enables greater productivity, lack of static typing can cause runtime exceptions, type inconsistencies, and is a major factor for weak IDE support. To alleviate these issues, PEP 484 introduced optional type annotations for Python. As retrofitting types to existing codebases is error-prone and laborious, learning-based approaches have been proposed to enable automatic type annotations based on existing, partially annotated codebases. However, the prediction of rare and user-defined types is still challenging. In this paper, we present Type4Py, a deep similarity learning-based type inference model for Python. We design a hierarchical neural network model that learns to discriminate between types of the same kind and dissimilar types in a high-dimensional space, which results in clusters of types. Nearest neighbor search suggests likely type signatures of given Python functions. The types visible to analyzed modules are surfaced using lightweight dependency analysis. The results of quantitative and qualitative evaluation indicate that Type4Py significantly outperforms state-of-the-art approaches at the type prediction task. Considering the Top-1 prediction, Type4Py obtains 19.33% and 13.49% higher precision than Typilus and TypeWriter, respectively, while utilizing a much bigger vocabulary.</p>\n", "tags": ["types"], "tsne_embedding": [-3.296851396560669, 24.452165603637695]}, {"key": "monperrus2021megadiff", "year": "2021", "title": "Megadiff: A Dataset of 600k Java Source Code Changes Categorized by Diff Size", "abstract": "<p>This paper presents Megadiff, a dataset of source code diffs. It focuses on Java, with strict inclusion criteria based on commit message and diff size. Megadiff contains 663 029 Java diffs that can be used for research on commit comprehension, fault localization, automated program repair, and machine learning on code changes.</p>\n", "tags": ["dataset", "edit"], "tsne_embedding": [-13.202577590942383, -24.90667152404785]}, {"key": "mou2014building", "year": "2014", "title": "Building Program Vector Representations for Deep Learning", "abstract": "<p>Deep learning has made significant breakthroughs\nin various fields of artificial intelligence. Advantages of deep\nlearning include the ability to capture highly complicated features, weak involvement of human engineering, etc. However,\nit is still virtually impossible to use deep learning to analyze\nprograms since deep architectures cannot be trained effectively\nwith pure back propagation. In this pioneering paper, we propose\nthe \u201ccoding criterion\u201d to build program vector representations,\nwhich are the premise of deep learning for program analysis. Our\nrepresentation learning approach directly makes deep learning a\nreality in this new field. We evaluate the learned vector representations both qualitatively and quantitatively. We conclude, based\non the experiments, the coding criterion is successful in building\nprogram representations. To evaluate whether deep learning\nis beneficial for program analysis, we feed the representations\nto deep neural networks, and achieve higher accuracy in the\nprogram classification task than \u201cshallow\u201d methods, such as\nlogistic regression and the support vector machine. This result\nconfirms the feasibility of deep learning to analyze programs. It\nalso gives primary evidence of its success in this new field. We\nbelieve deep learning will become an outstanding technique for\nprogram analysis in the near future.</p>\n\n", "tags": ["representation", "grammar"], "tsne_embedding": [-1.813832402229309, -5.1591339111328125]}, {"key": "mou2016convolutional", "year": "2016", "title": "Convolutional Neural Networks over Tree Structures for Programming Language Processing", "abstract": "<p>Programming language processing (similar to natural language processing) is a hot research topic in the field of software engineering; it has also aroused growing interest in the\nartificial intelligence community. However, different from a\nnatural language sentence, a program contains rich, explicit,\nand complicated structural information. Hence, traditional\nNLP models may be inappropriate for programs. In this paper, we propose a novel tree-based convolutional neural network (TBCNN) for programming language processing, in\nwhich a convolution kernel is designed over programs\u2019 abstract syntax trees to capture structural information. TBCNN\nis a generic architecture for programming language processing; our experiments show its effectiveness in two different program analysis tasks: classifying programs according\nto functionality, and detecting code snippets of certain patterns. TBCNN outperforms baseline methods, including several neural models for NLP.</p>\n", "tags": ["representation", "grammar"], "tsne_embedding": [-9.137490272521973, -5.402666091918945]}, {"key": "movshovitz2013natural", "year": "2013", "title": "Natural Language Models for Predicting Programming Comments", "abstract": "<p>Statistical language models have successfully been used to describe and analyze\nnatural language documents. Recent work\napplying language models to programming languages is focused on the task\nof predicting code, while mainly ignoring\nthe prediction of programmer comments.\nIn this work, we predict comments from\nJAVA source files of open source projects,\nusing topic models and n-grams, and we\nanalyze the performance of the models\ngiven varying amounts of background data\non the project being predicted. We evaluate models on their comment-completion\ncapability in a setting similar to code completion tools built into standard code\neditors, and show that using a comment\ncompletion tool can save up to 47% of the\ncomment typing.</p>\n\n", "tags": ["bimodal", "documentation", "summarization"], "tsne_embedding": [0.3536474406719208, 9.714911460876465]}, {"key": "movshovitz2015kb", "year": "2015", "title": "KB-LDA: Jointly Learning a Knowledge Base of Hierarchy, Relations, and Facts", "abstract": "<p>Many existing knowledge bases (KBs), including Freebase, Yago, and NELL, rely\non a fixed ontology, given as an input\nto the system, which defines the data to\nbe cataloged in the KB, i.e., a hierarchy of categories and relations between\nthem. The system then extracts facts that\nmatch the predefined ontology. We propose an unsupervised model that jointly\nlearns a latent ontological structure of an\ninput corpus, and identifies facts from the\ncorpus that match the learned structure.\nOur approach combines mixed membership stochastic block models and topic\nmodels to infer a structure by jointly modeling text, a latent concept hierarchy, and\nlatent semantic relationships among the\nentities mentioned in the text. As a case\nstudy, we apply the model to a corpus\nof Web documents from the software domain, and evaluate the accuracy of the various components of the learned ontology.</p>\n", "tags": ["pattern mining"], "tsne_embedding": [-3.110393762588501, 3.1684675216674805]}, {"key": "mukherjee2020searching", "year": "2020", "title": "Searching a Database of Source Codes Using Contextualized Code Search", "abstract": "<p>We assume a database containing a large set of program source codes and consider the problem of contextualized code search over that database. A programmer has written some part of a program, but has left part of the program (such as a method or a function body) incomplete. The goal is to use the context surrounding the missing code to automatically \u2018figure out\u2019 which of the codes in the database would be useful to the programmer in order to help complete the missing code, in the sense that the programmer could either re-purpose the retrieved code and use the re-purposed code to fill the missing spot in the program. Or, the user could use the retrieved code as a model for implementing the missing code. The search is \u2018contextualized\u2019 in the sense that the search engine should use clues in the partially-completed code to figure out which database code is most useful. The user should not be required to formulate an explicit query.</p>\n\n<p>We cast contextualized code search as a learning problem, where the goal is to learn a distribution function computing the likelihood that each database code completes the program, and propose a neural model for predicting which database code is likely to be most useful. Because it will be prohibitively expensive to apply a neural model to each code in a database of millions or billions of codes at search time, one of our key technical concerns is ensuring a speedy search. We address this by learning a \u2018reverse encoder\u2019 that can be used to reduce the problem of evaluating each database code to computing a convolution of two normal distributions, making it possible to search a large database of codes in a reasonable time.</p>\n", "tags": ["search", "representation"], "tsne_embedding": [-17.766183853149414, 8.437091827392578]}, {"key": "mukherjee2021neural", "year": "2021", "title": "Neural Program Generation Modulo Static Analysis", "abstract": "<p>State-of-the-art neural models of source code tend to be evaluated on the generation\nof individual expressions and lines of code, and commonly fail on long-horizon\ntasks such as the generation of entire method bodies. We propose to address this\ndeficiency using weak supervision from a static program analyzer. Our neurosymbolic method allows a deep generative model to symbolically compute, using calls\nto a static-analysis tool, long-distance semantic relationships in the code that it\nhas already generated. During training, the model observes these relationships\nand learns to generate programs conditioned on them. We apply our approach to\nthe problem of generating entire Java methods given the remainder of the class\nthat contains the method. Our experiments show that the approach substantially\noutperforms state-of-the-art transformers and a model that explicitly tries to learn\nprogram semantics on this task, both in terms of producing programs free of basic\nsemantic errors and in terms of syntactically matching the ground truth.</p>\n", "tags": ["synthesis", "language model"], "tsne_embedding": [18.34864044189453, 0.21695023775100708]}, {"key": "murali2017bayesian", "year": "2018", "title": "Bayesian Sketch Learning for Program Synthesis", "abstract": "<p>We present a Bayesian statistical approach to the problem of automatic program synthesis. Our synthesizer starts\nby learning, offline and from an existing corpus, a probabilistic model of real-world programs. During synthesis,\nit is provided some ambiguous and incomplete evidence about the nature of the programming task that the user\nwants automated, for example sets of API calls or data types that are relevant for the task. Given this input, the\nsynthesizer infers a posterior distribution over type-safe programs that assigns higher likelihood to programs\nthat, according to the learned model, are more likely to match the evidence.</p>\n\n<p>We realize this approach using two key ideas. First, our learning techniques operate not over code but\nsyntactic abstractions, or sketches, of programs. During synthesis, we infer a posterior distribution over sketches,\nthen concretize samples from this distribution into type-safe programs using combinatorial techniques. Second,\nour statistical model explicitly models the full intent behind a synthesis task as a latent variable. To infer\nsketches, we first estimate a posterior distribution on the intent, then use samples from this posterior to generate\na distribution over possible sketches. We show that our model can be implemented effectively using the new\nneural architecture of Bayesian encoder-decoders, which can be trained with stochastic gradient descent and\nyields a simple inference procedure.</p>\n\n<p>We implement our ideas in a system, called BAYOU , for the synthesis of API-heavy Java methods. We train\nBAYOU on a large corpus of Android apps, and find that the trained system can often synthesize complex\nmethods given just a few API method names or data types as evidence. The experiments also justify the design\nchoice of using a latent intent variable and the levels of abstraction at which sketches and evidence are defined.</p>\n", "tags": ["code generation", "API"], "tsne_embedding": [11.961529731750488, 13.80479907989502]}, {"key": "murali2017finding", "year": "2017", "title": "Finding Likely Errors with Bayesian Specifications", "abstract": "<p>We present a Bayesian framework for learning probabilistic specifications from large, unstructured code corpora, and\na method to use this framework to statically detect anomalous, hence likely buggy, program behavior. The distinctive\ninsight here is to build a statistical model that correlates all\nspecifications hidden inside a corpus with the syntax and\nobserved behavior of programs that implement these specifications. During the analysis of a particular program, this\nmodel is conditioned into a posterior distribution that prioritizes specifications that are relevant to this program. This\nallows accurate program analysis even if the corpus is highly\nheterogeneous. The problem of finding anomalies is now\nframed quantitatively, as a problem of computing a distance\nbetween a \u201creference distribution\u201d over program behaviors\nthat our model expects from the program, and the distribution over behaviors that the program actually produces.</p>\n\n<p>We present a concrete embodiment of our framework that\ncombines a topic model and a neural network model to learn\nspecifications, and queries the learned models to compute\nanomaly scores. We evaluate this implementation on the\ntask of detecting anomalous usage of Android APIs. Our\nencouraging experimental results show that the method can\nautomatically discover subtle errors in Android applications\nin the wild, and has high precision and recall compared to\ncompeting probabilistic approaches.</p>\n", "tags": ["program analysis", "API"], "tsne_embedding": [-10.909294128417969, 18.008468627929688]}, {"key": "nadeem2022codedsi", "year": "2022", "title": "CodeDSI: Differentiable Code Search", "abstract": "<p>Reimplementing solutions to previously solved software engineering problems is not only inefficient but also introduces inadequate and error-prone code. Many existing methods achieve impressive performance on this issue by using autoregressive text-generation models trained on code. However, these methods are not without their flaws. The generated code from these models can be buggy, lack documentation, and introduce vulnerabilities that may go unnoticed by developers. An alternative to code generation \u2013 neural code search \u2013 is a field of machine learning where a model takes natural language queries as input and, in turn, relevant code samples from a database are returned. Due to the nature of this pre-existing database, code samples can be documented, tested, licensed, and checked for vulnerabilities before being used by developers in production. In this work, we present CodeDSI, an end-to-end unified approach to code search. CodeDSI is trained to directly map natural language queries to their respective code samples, which can be retrieved later. In an effort to improve the performance of code search, we have investigated docid representation strategies, impact of tokenization on docid structure, and dataset sizes on overall code search performance. Our results demonstrate CodeDSI strong performance, exceeding conventional robust baselines by 2-6% across varying dataset sizes.</p>\n", "tags": ["search"], "tsne_embedding": [-14.168858528137207, 7.881669998168945]}, {"key": "naik2022probing", "year": "2022", "title": "Probing Semantic Grounding in Language Models of Code with Representational Similarity Analysis", "abstract": "<p>Representational Similarity Analysis is a method from cognitive neuroscience, which helps in comparing representations from two different sources of data. In this paper, we propose using Representational Similarity Analysis to probe the semantic grounding in language models of code. We probe representations from the CodeBERT model for semantic grounding by using the data from the IBM CodeNet dataset. Through our experiments, we show that current pre-training methods do not induce semantic grounding in language models of code, and instead focus on optimizing form-based patterns. We also show that even a little amount of fine-tuning on semantically relevant tasks increases the semantic grounding in CodeBERT significantly. Our ablations with the input modality to the CodeBERT model show that using bimodal inputs (code and natural language) over unimodal inputs (only code) gives better semantic grounding and sample efficiency during semantic fine-tuning. Finally, our experiments with semantic perturbations in code reveal that CodeBERT is able to robustly distinguish between semantically correct and incorrect code.</p>\n", "tags": ["interpretability", "language model", "evaluation", "Transformer"], "tsne_embedding": [7.52793550491333, 1.3207120895385742]}, {"key": "nair2020funcgnn", "year": "2020", "title": "funcGNN: A Graph Neural Network Approach to Program Similarity", "abstract": "<p>Program similarity is a fundamental concept, central to the solution of software engineering tasks such as software plagiarism, clone identification, code refactoring and code search. Accurate similarity estimation between programs requires an in-depth understanding of their structure, semantics and flow. A control flow graph (CFG), is a graphical representation of a program which captures its logical control flow and hence its semantics. A common approach is to estimate program similarity by analysing CFGs using graph similarity measures, e.g. graph edit distance (GED). However, graph edit distance is an NP-hard problem and computationally expensive, making the application of graph similarity techniques to complex software programs impractical. This study intends to examine the effectiveness of graph neural networks to estimate program similarity, by analysing the associated control flow graphs. We introduce funcGNN, which is a graph neural network trained on labeled CFG pairs to predict the GED between unseen program pairs by utilizing an effective embedding vector. To our knowledge, this is the first time graph neural networks have been applied on labeled CFGs for estimating the similarity between high-level language programs. Results: We demonstrate the effectiveness of funcGNN to estimate the GED between programs and our experimental analysis demonstrates how it achieves a lower error rate (0.00194), with faster (23 times faster than the quickest traditional GED approximation method) and better scalability compared with the state of the art methods. funcGNN posses the inductive learning ability to infer program structure and generalise to unseen programs. The graph embedding of a program proposed by our methodology could be applied to several related software engineering problems (such as code plagiarism and clone identification) thus opening multiple research directions.</p>\n", "tags": ["GNN", "clone"], "tsne_embedding": [-12.907855033874512, -4.835139274597168]}, {"key": "nguyen2013lexical", "year": "2013", "title": "Lexical Statistical Machine Translation for Language Migration", "abstract": "<p>Prior research has shown that source code also exhibits naturalness, i.e. it is written by humans and is likely to be\nrepetitive. The researchers also showed that the n-gram language model is useful in predicting the next token in a source\nfile given a large corpus of existing source code. In this paper, we investigate how well statistical machine translation\n(SMT) models for natural languages could help in migrating source code from one programming language to another.\nWe treat source code as a sequence of lexical tokens and\napply a phrase-based SMT model on the lexemes of those\ntokens. Our empirical evaluation on migrating two Java\nprojects into C# showed that lexical, phrase-based SMT\ncould achieve high lexical translation accuracy ( BLEU from\n81.3-82.6%). Users would have to manually edit only 11.9-15.8% of the total number of tokens in the resulting code to\ncorrect it. However, a high percentage of total translation\nmethods (49.5-58.6%) is syntactically incorrect. Therefore,\nour result calls for a more program-oriented SMT model that\nis capable of better integrating the syntactic and semantic\ninformation of a program to support language migration.</p>\n", "tags": ["migration", "API"], "tsne_embedding": [9.026114463806152, 5.139874458312988]}, {"key": "nguyen2013statistical", "year": "2013", "title": "A Statistical Semantic Language Model for Source Code", "abstract": "<p>Recent research has successfully applied the statistical n-gram language model to show that source code exhibits a\ngood level of repetition. The n-gram model is shown to have\ngood predictability in supporting code suggestion and completion. However, the state-of-the-art n-gram approach to\ncapture source code regularities/patterns is based only on\nthe lexical information in a local context of the code units.\nTo improve predictability, we introduce SLAMC, a novel statistical semantic language model for source code. It incorporates semantic information into code tokens and models the\nregularities/patterns of such semantic annotations, called sememes, rather than their lexemes. It combines the local context in semantic n-grams with the global technical concerns/functionality into an n-gram topic model, together with pairwise associations of program elements. Based on SLAMC,\nwe developed a new code suggestion method, which is empirically evaluated on several projects to have relatively 18\u201368%\nhigher accuracy than the state-of-the-art approach.</p>\n\n", "tags": ["language model"], "tsne_embedding": [-1.5909593105316162, 8.696609497070312]}, {"key": "nguyen2013study", "year": "2013", "title": "A Study of Repetitiveness of Code Changes in Software Evolution", "abstract": "<p>In this paper, we present a large-scale study of\nrepetitiveness of code changes in software evolution. We collected\na large data set of 2,841 Java projects, with 1.7 billion source lines\nof code (SLOC) at the latest revisions, 1.8 million code change\nrevisions (0.4 million fixes), 6.2 million changed files, and 2.5\nbillion changed SLOCs. A change is considered repeated within\nor cross-project if it matches another change having occurred\nin the history of the project or another project, respectively. We\nreport the following important findings. First, repetitiveness of\nchanges could be as high as 70\u2013100% at small sizes and decreases\nexponentially as size increases. Second, repetitiveness is higher\nand more stable in the cross-project setting than in the project-within one. Third, fixing changes repeat similarly to general\nchanges. Importantly, learning code changes and recommending\nthem in software evolution is beneficial with accuracy for top-1\nrecommendation of over 30% and top-3 of nearly 35%. Repeated\nfixing changes could also be useful for automatic program repair.</p>\n\n", "tags": ["edit"], "tsne_embedding": [-13.753318786621094, -24.136493682861328]}, {"key": "nguyen2014statistical", "year": "2014", "title": "Statistical Learning Approach for Mining API Usage Mappings for Code Migration", "abstract": "<p>The same software product nowadays could appear in multiple platforms and devices. To address business needs, software companies\ndevelop a software product in a programming language and then\nmigrate it to another one. To support that process, semi-automatic\nmigration tools have been proposed. However, they require users\nto manually define the mappings between the respective APIs of\nthe libraries used in two languages. To reduce such manual effort,\nwe introduce StaMiner, a novel data-driven approach that statistically learns the mappings between APIs from the corpus of the\ncorresponding client code of the APIs in two languages Java and\nC#. Instead of using heuristics on the textual or structural similarity\nbetween APIs in two languages to map API methods and classes\nas in existing mining approaches, StaMiner is based on a statistical\nmodel that learns the mappings in such a corpus and provides mappings for APIs with all possible arities. Our empirical evaluation\non several projects shows that StaMiner can detect API usage mappings with higher accuracy than a state-of-the-art approach. With\nthe resulting API mappings mined by StaMiner, Java2CSharp, an\nexisting migration tool, could achieve a higher level of accuracy.</p>\n", "tags": ["migration", "API"], "tsne_embedding": [-8.640149116516113, 8.067264556884766]}, {"key": "nguyen2015divide", "year": "2014", "title": "Divide-and-Conquer Approach for Multi-phase Statistical Migration for Source Code", "abstract": "<p>Prior research shows that directly applying phrase-based SMT on lexical tokens to migrate Java to C# produces\nmuch semantically incorrect code. A key limitation is the use of\nsequences in phrase-based SMT to model and translate source\ncode with well-formed structures. We propose mppSMT, a divideand-conquer technique to address that with novel training and migration algorithms using phrase-based SMT in three phases. First,\nmppSMT treats a program as a sequence of syntactic units and\nmaps/translates such sequences in two languages to one another.\nSecond, with a syntax-directed fashion, it deals with the tokens\nwithin syntactic units by encoding them with semantic symbols to\nrepresent their data and token types. This encoding via semantic\nsymbols helps better migration of API usages. Third, the lexical\ntokens corresponding to each sememe are mapped or migrated.\nThe resulting sequences of tokens are merged together to form\nthe final migrated code. Such divide-and-conquer and syntax-direction strategies enable phrase-based SMT to adapt well to\nsyntactical structures in source code, thus, improving migration\naccuracy. Our empirical evaluation on several real-world systems\nshows that 84.8\u201397.9% and 70\u201383% of the migrated methods are\nsyntactically and semantically correct, respectively. 26.3\u201351.2%\nof total migrated methods are exactly matched to the human-written C# code in the oracle. Compared to Java2CSharp, a rule-based migration tool, it achieves higher semantic accuracy from\n6.6\u201357.7% relatively. Importantly, it does not require manual\nlabeling for training data or manual definition of rules.</p>\n", "tags": ["migration"], "tsne_embedding": [8.476828575134277, 5.357624530792236]}, {"key": "nguyen2015graph", "year": "2015", "title": "Graph-based Statistical Language Model for Code", "abstract": "<p>n-gram statistical language model has been successfully applied to capture programming patterns to support code\ncompletion and suggestion. However, the approaches using n-gram face challenges in capturing the patterns at higher levels\nof abstraction due to the mismatch between the sequence nature\nin n-grams and the structure nature of syntax and semantics\nin source code. This paper presents GraLan, a graph-based\nstatistical language model and its application in code suggestion. GraLan can learn from a source code corpus and compute\nthe appearance probabilities of any graphs given the observed\n(sub)graphs. We use GraLan to develop an API suggestion\nengine and an AST-based language model, ASTLan. ASTLan\nsupports the suggestion of the next valid syntactic template\nand the detection of common syntactic templates. Our empirical\nevaluation on a large corpus of open-source projects has shown\nthat our engine is more accurate in API code suggestion than\nthe state-of-the-art approaches, and in 75% of the cases, it can\ncorrectly suggest the API with only five candidates. ASTLan also\nhas high accuracy in suggesting the next syntactic template and\nis able to detect many useful and common syntactic templates.</p>\n", "tags": ["representation", "language model", "autocomplete"], "tsne_embedding": [-0.5086987018585205, 8.865811347961426]}, {"key": "nguyen2016learning", "year": "2016", "title": "Learning API Usages from Bytecode: A Statistical Approach", "abstract": "<p>Mobile app developers rely heavily on standard API frameworks and libraries. However, learning API usages is often challenging due to the fast-changing nature of API frameworks for mobile systems and the insufficiency of API documentation and source code examples. In this paper, we propose a novel approach to learn API usages from bytecode of Android mobile apps. Our core contributions include HAPI, a statistical model of API usages and three algorithms to extract method call sequences from apps\u2019 bytecode, to train HAPI based on those sequences, and to recommend method calls in code completion using the trained HAPIs. Our empirical evaluation shows that our prototype tool can effectively learn API usages from 200 thousand apps containing 350 million method sequences. It recommends next method calls with top-3 accuracy of 90% and outperforms baseline approaches on average 10-20%.</p>\n", "tags": ["representation", "API"], "tsne_embedding": [-11.251977920532227, 14.637451171875]}, {"key": "nguyen2016mapping", "year": "2016", "title": "Mapping API Elements for Code Migration with Vector Representations", "abstract": "<p>Mapping API elements has a significant role in software development, especially in code migration. A manual process of defining the migration is tedious and error-prone while recent approaches to automatically mine API mappings are limited to discover the mappings with textually similar APIs\u2019 names. This leads to the low accuracy in existing migration tools.We propose an approach to automatically mine API mappings which overcomes the lexical mismatch problem. We represent an API by its usages instead of its name.To characterize an API with its context consisting of surrounding APIs in its usages, we take advantage of Word2Vec model to project the APIs of Java JDK and C# .NET into corresponding continuous vector spaces. The semantic relations among APIs will be observed in those continuous space as the geometric arrangements between their representation vectors in two vector spaces.We use a learning approach to derive the linear (e.g., rotating and scaling) transformation function between two vector spaces. Transformation function is trained from human-defined pairs of API mappings from Java to C#. To find the C# API mapping with a given Java API, we use the learned function to compute its transformed vector in the C# vector space. Then, the C# API which has the most similar vector with the transformed vector is considered as the result. Our experiment shows that for just one suggestion, we are able to correctly derive the API in C# in almost 43% of the cases. With 5 suggestions, we can correctly suggest the correct C# API in almost 3 out of 4 cases (73.2%).</p>\n", "tags": ["migration", "API"], "tsne_embedding": [-8.071035385131836, 7.338508129119873]}, {"key": "nguyen2017exploring", "year": "2017", "title": "Exploring API Embedding for API Usages and Applications", "abstract": "<p>Word2Vec is a class of neural network models that\nas being trained from a large corpus of texts, they can produce for\neach unique word a corresponding vector in a continuous space in\nwhich linguistic contexts of words can be observed. In this work,\nwe study the characteristics of Word2Vec vectors, called API 2 VEC\nor API embeddings, for the API elements within the API sequences in source code. Our empirical study shows that the close\nproximity of the API 2 VEC vectors for API elements reflects the\nsimilar usage contexts containing the surrounding APIs of those\nAPI elements. Moreover, API 2 VEC can capture several similar\nsemantic relations between API elements in API usages via vector\noffsets. We demonstrate the usefulness of API 2 VEC vectors for\nAPI elements in three applications. First, we build a tool that mines the pairs of API elements that share the same usage relations\namong them. The other applications are in the code migration\ndomain. We develop API 2 API , a tool to automatically learn the\nAPI mappings between Java and C# using a characteristic of the\nAPI 2 VEC vectors for API elements in the two languages: semantic\nrelations among API elements in their usages are observed in the\ntwo vector spaces for the two languages as similar geometric\narrangements among their API 2 VEC vectors. Our empirical\nevaluation shows that API 2 API relatively improves 22.6% and\n40.1% top-1 and top-5 accuracy over a state-of-the-art mining\napproach for API mappings. Finally, as another application in\ncode migration, we are able to migrate equivalent API usages\nfrom Java to C# with up to 90.6% recall and 87.2% precision.</p>\n", "tags": ["API", "representation"], "tsne_embedding": [-8.401476860046387, 6.7361979484558105]}, {"key": "nguyen2019graph", "year": "2019", "title": "Graph-based Mining of In-the-Wild, Fine-grained, Semantic Code Change Patterns", "abstract": "<p>Existing approaches for detecting repetitive code changes relying on syntactic similarity cannot effectively detect semantic change patterns. In this work, we introduce a novel graph-based mining approach, CPatMiner, which is capable of detecting semantic code change patterns from a large number of open-source repositories by capturing dependencies between fine-grained change elements. We evaluated CPatMiner by mining change patterns in a diverse corpus of 5,000+ open-source projects from GitHub with 170,000+ developers. We use three complementary methods. First, we sent the mined patterns to the authors and received 108 responses. 70% of respondents recognized those patterns as their meaningful frequent changes. 79% of respondents even named the patterns, and 44% wanted IDEs to automate such repetitive changes. The mined patterns belong to various activities: adaptive (9%), perfective (20%), corrective (35%) and preventive (36%). Second, we compared CPatMiner with the state-of-the-art, AST-based technique, and reported that CPatMiner detects 2.1x more meaningful patterns. Third, we used CPatMiner to search for patterns in a corpus of 88 GitHub projects with longer histories consisting of 164M SLOCs. It constructed 322K fine-grained change graphs containing 3M nodes, and detected 17K change patterns which provide unique insights on the practice of change patterns among individuals and teams. We found that a large percentage (75%) of the patterns from individual developers are commonly shared with others, and this holds true for teams. Moreover, we found that the patterns spread widely over time. Thus, we call for a community-based change pattern database to provide important resources in novel applications.</p>\n", "tags": ["edit", "pattern mining"], "tsne_embedding": [-14.197354316711426, -23.856935501098633]}, {"key": "nguyen2020suggesting", "year": "2020", "title": "Suggesting Natural Method Names to Check Name Consistencies", "abstract": "<p>Misleading names of the methods in a project or the APIs in a software library confuse developers about program functionality\nand API usages, leading to API misuses and defects. In this paper,we introduce MNire, a machine learning approach to check the\nconsistency between the name of a given method and its implementation. MNire first generates a candidate name and compares the\ncurrent name against it. If the two names are sufficiently similar, we consider the method as consistent. To generate the method name,\nwe draw our ideas and intuition from an empirical study on the nature of method names in a large dataset. Our key finding is that\nhigh proportions of the tokens of method names can be found in the three contexts of a given method including its body,\nthe interface (the method\u2019s parameter types and return type), and the enclosing class\u2019 name. Even when such tokens are not there,\nMNire uses the contexts to predict the tokens due to the high likelihoods of their co-occurrences. Our unique idea is to treat\nthe name generation as an abstract summarization on the tokens collected from the names of the program entities in the three\nabove contexts.</p>\n\n<p>We conducted several experiments to evaluate MNire in method name consistency checking and in method name\nrecommending on large datasets with +14M methods. In detecting inconsistency method names, MNire improves the state-of-the-art\napproach by 10.4% and 11% relatively in recall and precision, respectively. In method name recommendation, MNire improves relatively\nover the state-of-the-art technique, code2vec, in both recall (18.2% higher) and precision (11.1% higher). To assess MNire\u2019s usefulness,\nwe used it to detect inconsistent methods and suggest new names in several active, GitHub projects. We made 50 pull requests (PRs) and received\n42 responses. Among them, five PRs were merged into the main branch, and 13 were approved for later merging. In total, in 31/42 cases,\nthe developer teams agree that our suggested names are more meaningful than the current names, showing MNire\u2019s usefulness.</p>\n", "tags": ["naming"], "tsne_embedding": [-20.25969696044922, -3.7266039848327637]}, {"key": "nie2021evaluation", "year": "2021", "title": "Impact of Evaluation Methodologies on Code Summarization", "abstract": "<p>There has been a growing interest in developing machine learning (ML) models for code summarization tasks, e.g., comment generation and method naming. Despite substantial increase in the effectiveness of ML models, the evaluation methodologies, i.e., the way people split datasets into training, validation, and test sets, were not well studied. Specifically, no prior work on code summarization considered the timestamps of code and comments during evaluation. This may lead to evaluations that are inconsistent with the intended use cases. In this paper, we introduce the time-segmented evaluation methodology, which is novel to the code summarization research community, and compare it with the mixed-project and cross-project methodologies that have been commonly used. Each methodology can be mapped to some use cases, and the time-segmented methodology should be adopted in the evaluation of ML models for code summarization. To assess the impact of methodologies, we collect a dataset of (code, comment) pairs with timestamps to train and evaluate several recent ML models for code summarization. Our experiments show that different methodologies lead to conflicting evaluation results. We invite the community to expand the set of methodologies used in evaluations.</p>\n", "tags": ["evaluation", "dataset"], "tsne_embedding": [7.69342565536499, -11.422307968139648]}, {"key": "nijkamp2022conversational", "year": "2022", "title": "A Conversational Paradigm for Program Synthesis", "abstract": "<p>Program synthesis strives to generate a computer program as a solution to a given problem specification. We propose a conversational program synthesis approach via large language models, which addresses the challenges of searching over a vast program space and user intent specification faced in prior approaches. Our new approach casts the process of writing a specification and program as a multi-turn conversation between a user and a system. It treats program synthesis as a sequence prediction problem, in which the specification is expressed in natural language and the desired program is conditionally sampled. We train a family of large language models, called CodeGen, on natural language and programming language data. With weak supervision in the data and the scaling up of data size and model size, conversational capacities emerge from the simple autoregressive language modeling. To study the model behavior on conversational program synthesis, we develop a multi-turn programming benchmark (MTPB), where solving each problem requires multi-step synthesis via multi-turn conversation between the user and the model. Our findings show the emergence of conversational capabilities and the effectiveness of the proposed conversational program synthesis paradigm. In addition, our model CodeGen (with up to 16B parameters trained on TPU-v4) outperforms OpenAI\u2019s Codex on the HumanEval benchmark. We make the training library JaxFormer including checkpoints available as open source contribution: https://github.com/salesforce/CodeGen.</p>\n", "tags": ["Transformer", "synthesis"], "tsne_embedding": [13.290722846984863, 12.082601547241211]}, {"key": "nijkamp2023codegen2", "year": "2023", "title": "CodeGen2: Lessons for Training LLMs on Programming and Natural Languages", "abstract": "<p>Large language models (LLMs) have demonstrated remarkable abilities in representation learning for program synthesis and understanding tasks. The quality of the learned representations appears to be dictated by the neural scaling laws as a function of the number of model parameters and observations, while imposing upper bounds on the model performance by the amount of available data and compute, which is costly.</p>\n\n<p>In this study, we attempt to render the training of LLMs for program synthesis more efficient by unifying four key components: (1) model architectures, (2) learning methods, (3) infill sampling, and, (4) data distributions. Specifically, for the model architecture, we attempt to unify encoder and decoder-based models into a single prefix-LM. For learning methods, (i) causal language modeling, (ii) span corruption, (iii) infilling are unified into a simple learning algorithm. For infill sampling, we explore the claim of a \u201cfree lunch\u201d hypothesis. For data distributions, the effect of a mixture distribution of programming and natural languages on model performance is explored.</p>\n\n<p>We conduct a comprehensive series of empirical experiments on 1B LLMs, for which failures and successes of this exploration are distilled into four lessons. We will provide a final recipe for training and release CodeGen2 models in size 1B, 3.7B, 7B, and, 16B parameters, along with the training framework as open-source: https://github.com/salesforce/CodeGen2</p>\n", "tags": ["Transformer"], "tsne_embedding": [11.244291305541992, 11.896505355834961]}, {"key": "nitin2021direct", "year": "2021", "title": "DIRECT : A Transformer-based Model for Decompiled Identifier Renaming", "abstract": "<p>Decompiling binary executables to high-level code is an important step in reverse engineering scenarios, such as malware analysis and legacy code maintenance. However, the generated high-level code is difficult to understand since the original variable names are lost. In this paper, we leverage transformer models to reconstruct the original variable names from decompiled code. Inherent differences between code and natural language present certain challenges in applying conventional transformer-based architectures to variable name recovery. We propose DIRECT, a novel transformer-based architecture customized specifically for the task at hand. We evaluate our model on a dataset of decompiled functions and find that DIRECT outperforms the previous state-of-the-art model by up to 20%. We also present ablation studies evaluating the impact of each of our modifications. We make the source code of DIRECT available to encourage reproducible research.</p>\n", "tags": ["Transformer", "decompilation"], "tsne_embedding": [-17.094409942626953, 15.596951484680176]}, {"key": "niu2022spt-code", "year": "2022", "title": "SPT-Code: Sequence-to-Sequence Pre-Training for Learning Source Code Representations", "abstract": "<p>Recent years have seen the successful application of large pre-trained modelsto code representation learning, resulting in substantial improvements on many code-related downstream tasks. But there are issues surrounding theirapplication to SE tasks. First, the majority of the pre-trained models focus on pre-training only the encoder of the Transformer. For generation tasks that are addressed using models with the encoder-decoder architecture, however, there is no reason why the decoder should be left out during pre-training. Second, many existing pre-trained models, including state-of-the-art models such as T5-learning, simply reuse the pre-training tasks designed for natural languages. Moreover, to learn the natural language description of source code needed eventually for code-related tasks such as code summarization, existingpre-training tasks require a bilingual corpus composed of source code and the associated natural language description, which severely limits the amount of data for pre-training. To this end, we propose SPT-Code, a sequence-to-sequence pre-trained model for source code. In order to pre-train SPT-Code in a sequence-to-sequence manner and address the aforementioned weaknesses associated with existing pre-training tasks, we introduce three pre-training tasks that are specifically designed to enable SPT-Code to learn knowledge of source code, the corresponding code structure, as well as a natural language description of the code without relying on any bilingual corpus, and eventually exploit these three sources of information when it is applied to downstreamt asks. Experimental results demonstrate that SPT-Code achieves state-of-the-artperformance on five code-related downstream tasks after fine-tuning.</p>\n", "tags": ["Transformer", "representation"], "tsne_embedding": [5.355798244476318, -1.1194102764129639]}, {"key": "nye2021program", "year": "2021", "title": "Program Synthesis with Large Language Models", "abstract": "<p>This paper explores the limits of the current generation of large language models for program synthesis in general purpose programming languages. We evaluate a collection of such models (with between 244M and 137B parameters) on two new benchmarks, MBPP and MathQA-Python, in both the few-shot and fine-tuning regimes. Our benchmarks are designed to measure the ability of these models to synthesize short Python programs from natural language descriptions. The Mostly Basic Programming Problems (MBPP) dataset contains 974 programming tasks, designed to be solvable by entry-level programmers. The MathQA-Python dataset, a Python version of the MathQA benchmark, contains 23914 problems that evaluate the ability of the models to synthesize code from more complex text. On both datasets, we find that synthesis performance scales log-linearly with model size. Our largest models, even without finetuning on a code dataset, can synthesize solutions to 59.6 percent of the problems from MBPP using few-shot learning with a well-designed prompt. Fine-tuning on a held-out portion of the dataset improves performance by about 10 percentage points across most model sizes. On the MathQA-Python dataset, the largest fine-tuned model achieves 83.8 percent accuracy. Going further, we study the model\u2019s ability to engage in dialog about code, incorporating human feedback to improve its solutions. We find that natural language feedback from a human halves the error rate compared to the model\u2019s initial prediction. Additionally, we conduct an error analysis to shed light on where these models fall short and what types of programs are most difficult to generate. Finally, we explore the semantic grounding of these models by fine-tuning them to predict the results of program execution. We find that even our best models are generally unable to predict the output of a program given a specific input.</p>\n", "tags": ["Transformer", "synthesis"], "tsne_embedding": [13.311851501464844, 11.487395286560059]}, {"key": "nye2021show", "year": "2021", "title": "Show Your Work: Scratchpads for Intermediate Computation with Language Models", "abstract": "<p>Large pre-trained language models perform remarkably well on tasks that can be done \u201cin one pass\u201d, such as generating realistic text or synthesizing computer programs. However, they struggle with tasks that require unbounded multi-step computation, such as adding integers or executing programs. Surprisingly, we find that these same models are able to perform complex multi-step computations \u2013 even in the few-shot regime \u2013 when asked to perform the operation \u201cstep by step\u201d, showing the results of intermediate computations. In particular, we train transformers to perform multi-step computations by asking them to emit intermediate computation steps into a \u201cscratchpad\u201d. On a series of increasingly complex tasks ranging from long addition to the execution of arbitrary programs, we show that scratchpads dramatically improve the ability of language models to perform multi-step computations.</p>\n", "tags": ["Transformer", "execution"], "tsne_embedding": [15.255411148071289, 12.748706817626953]}, {"key": "oda2015learning", "year": "2015", "title": "Learning to Generate Pseudo-code from Source Code using Statistical Machine Translation", "abstract": "<p>Pseudo-code written in natural language can aid\nthe comprehension of source code in unfamiliar programming\nlanguages. However, the great majority of source code has no\ncorresponding pseudo-code, because pseudo-code is redundant\nand laborious to create. If pseudo-code could be generated\nautomatically and instantly from given source code, we could\nallow for on-demand production of pseudo-code without human\neffort. In this paper, we propose a method to automatically\ngenerate pseudo-code from source code, specifically adopting the\nstatistical machine translation (SMT) framework. SMT, which\nwas originally designed to translate between two natural languages, allows us to automatically learn the relationship between\nsource code/pseudo-code pairs, making it possible to create a\npseudo-code generator with less human effort. In experiments,\nwe generated English or Japanese pseudo-code from Python\nstatements using SMT, and find that the generated pseudo-code\nis largely accurate, and aids code understanding.</p>\n", "tags": ["representation", "bimodal", "grammar"], "tsne_embedding": [10.27160358428955, 4.2456889152526855]}, {"key": "oh2015learning", "year": "2015", "title": "Learning a Strategy for Adapting a Program Analysis via Bayesian Optimisation", "abstract": "<p>Building a cost-effective static analyser for real-world programs is still regarded an art. One key contributor to this\ngrim reputation is the difficulty in balancing the cost and the\nprecision of an analyser. An ideal analyser should be adap-\ntive to a given analysis task, and avoid using techniques that\nunnecessarily improve precision and increase analysis cost.\nHowever, achieving this ideal is highly nontrivial, and it requires a large amount of engineering efforts.</p>\n\n<p>In this paper we present a new approach for building\nan adaptive static analyser. In our approach, the analyser\nincludes a sophisticated parameterised strategy that decides, for each part of a given program, whether to apply\na precision-improving technique to that part or not. We\npresent a method for learning a good parameter for such\na strategy from an existing codebase via Bayesian optimisation. The learnt strategy is then used for new, unseen programs. Using our approach, we developed partially flow-\nand context-sensitive variants of a realistic C static analyser.\nThe experimental results demonstrate that using Bayesian\noptimisation is crucial for learning from an existing codebase. Also, they show that among all program queries that\nrequire flow- or context-sensitivity, our partially flow- and\ncontext-sensitive analysis answers the 75% of them, while\nincreasing the analysis cost only by 3.3x of the baseline\nflow- and context-insensitive analysis, rather than 40x or\nmore of the fully sensitive version.</p>\n", "tags": ["program analysis"], "tsne_embedding": [-7.722342491149902, 17.582828521728516]}, {"key": "omar2013structured", "year": "2013", "title": "Structured Statistical Syntax Tree Prediction", "abstract": "<p>Statistical models of source code can be used to improve\ncode completion systems, assistive interfaces, and code\ncompression engines. We are developing a statistical model\nwhere programs are represented as syntax trees, rather than\nsimply a stream of tokens. Our model, initially for the Java\nlanguage, combines corpus data with information about syntax, types and the program context. We tested this model\nusing open source code corpuses and find that our model\nis significantly more accurate than the current state of the\nart, providing initial evidence for our claim that combining\nstructural and statistical information is a fruitful strategy.</p>\n", "tags": ["language model", "grammar"], "tsne_embedding": [-0.7288470268249512, 9.948951721191406]}, {"key": "orlanski2021reading", "year": "2021", "title": "Reading StackOverflow Encourages Cheating: Adding Question Text Improves Extractive Code Generation", "abstract": "<p>Answering a programming question with only its title is difficult as salient contextual information is left out. To address this, we present a corpus of over 40,000 StackOverflow question texts to be used in conjunction with the corresponding intents from the CoNaLa dataset (Yin et al., 2018). Using both the intent and the question body, we use BART to establish a baseline BLEU score of 34.35 for this new task. We then find further improvements of 2.8% by combining the mined CoNaLa data with the labeled data to achieve a 35.32 BLEU score. We then evaluate the prior state-of-the-art CoNaLa models with this additional data. We find that our proposed method of using the body and mined data beats that of the previous state-of-the-art by a 71.96% BLEU score. Finally, we perform ablations that prove that BART is an unsupervised multimodal learner and examine its extractive behavior.</p>\n", "tags": ["dataset", "Transformer"], "tsne_embedding": [10.258553504943848, 0.9166370034217834]}, {"key": "ott2018deep", "year": "2018", "title": "A Deep Learning Approach to Identifying Source Code in Images and Video", "abstract": "<p>While substantial progress has been made in mining code on an\nInternet scale, efforts to date have been overwhelmingly focused on\ndata sets where source code is represented natively as text. Large\nvolumes of source code available online and embedded in technical\nvideos have remained largely unexplored, due in part to the complexity of extraction when code is represented with images. Existing\napproaches to code extraction and indexing in this environment rely\nheavily on computationally intense optical character recognition.\nTo improve the ease and efficiency of identifying this embedded\ncode, as well as identifying similar code examples, we develop a\ndeep learning solution based on convolutional neural networks and\nautoencoders. Focusing on Java for proof of concept, our technique\nis able to identify the presence of typeset and handwritten source\ncode in thousands of video images with 85.6%-98.6% accuracy based\non syntactic and contextual features learned through deep architectures. When combined with traditional approaches, this provides\na more scalable basis for video indexing that can be incorporated\ninto existing software search and mining tools.</p>\n", "tags": ["information extraction"], "tsne_embedding": [-11.487238883972168, 0.6877660155296326]}, {"key": "pandi2020opttyper", "year": "2020", "title": "OptTyper: Probabilistic Type Inference by Optimising Logical and Natural Constraints", "abstract": "<p>We present a new approach to the type inference problem for dynamic languages. Our goal is to combine logical constraints, that is, deterministic information from a type system, with natural constraints, uncertain information about types from sources like identifier names. To this end, we introduce a framework for probabilistic type inference that combines logic and learning: logical constraints on the types are extracted from the program, and deep learning is applied to predict types from surface-level code properties that are statistically associated, such as variable names. The main insight of our method is to constrain the predictions from the learning procedure to respect the logical constraints, which we achieve by relaxing the logical inference problem of type prediction into a continuous optimisation problem. To evaluate the idea, we built a tool called OptTyper to predict a TypeScript declaration file for a JavaScript library. OptTyper combines a continuous interpretation of logical constraints derived by a simple program transformation and static analysis of the JavaScript code, with natural constraints obtained from a deep learning model, which learns naming conventions for types from a large codebase. We evaluate OptTyper on a data set of 5,800 open-source JavaScript projects that have type annotations in the well-known DefinitelyTyped repository. We find that combining logical and natural constraints yields a large improvement in performance over either kind of information individually, and produces 50% fewer incorrect type predictions than previous approaches.</p>\n", "tags": ["types", "bimodal"], "tsne_embedding": [-4.504485130310059, 22.567792892456055]}, {"key": "panthaplackel2020associating", "year": "2020", "title": "Associating Natural Language Comment and Source Code Entities", "abstract": "<p>Comments are an integral part of software development; they are natural language descriptions associated with source code elements. Understanding explicit associations can be useful in improving code comprehensibility and maintaining the consistency between code and comments. As an initial step towards this larger goal, we address the task of associating entities in Javadoc comments with elements in Java source code. We propose an approach for automatically extracting supervised data using revision histories of open source projects and present a manually annotated evaluation dataset for this task. We develop a binary classifier and a sequence labeling model by crafting a rich feature set which encompasses various aspects of code, comments, and the relationships between them. Experiments show that our systems outperform several baselines learning from the proposed supervision.</p>\n", "tags": ["dataset", "bimodal"], "tsne_embedding": [2.580599308013916, -12.753034591674805]}, {"key": "panthaplackel2020copy", "year": "2020", "title": "Copy that! Editing Sequences by Copying Spans", "abstract": "<p>Neural sequence-to-sequence models are finding increasing use in editing of documents, for example in correcting a text document or repairing source code. In this paper, we argue that common seq2seq models (with a facility to copy single tokens) are not a natural fit for such tasks, as they have to explicitly copy each unchanged token. We present an extension of seq2seq models capable of copying entire spans of the input to the output in one step, greatly reducing the number of decisions required during inference. This extension means that there are now many ways of generating the same output, which we handle by deriving a new objective for training and a variation of beam search for inference that explicitly handle this problem.</p>\n\n<p>In our experiments on a range of editing tasks of natural language and source code, we show that our new model consistently outperforms simpler baselines.</p>\n", "tags": ["edit"], "tsne_embedding": [7.3699116706848145, -15.985909461975098]}, {"key": "panthaplackel2020deep", "year": "2020", "title": "Deep Just-In-Time Inconsistency Detection Between Comments and Source Code", "abstract": "<p>Natural language comments convey key aspects of source code such as implementation, usage, and pre- and post-conditions. Failure to update comments accordingly when the corresponding code is modified introduces inconsistencies, which is known to lead to confusion and software bugs. In this paper, we aim to detect whether a comment becomes inconsistent as a result of changes to the corresponding body of code, in order to catch potential inconsistencies just-in-time, i.e., before they are committed to a version control system. To achieve this, we develop a deep-learning approach that learns to correlate a comment with code changes. By evaluating on a large corpus of comment/code pairs spanning various comment types, we show that our model outperforms multiple baselines by significant margins. For extrinsic evaluation, we show the usefulness of our approach by combining it with a comment update model to build a more comprehensive automatic comment maintenance system which can both detect and resolve inconsistent comments based on code changes.</p>\n", "tags": ["edit", "bimodal", "documentation"], "tsne_embedding": [1.7449493408203125, -14.086603164672852]}, {"key": "panthaplackel2020learning", "year": "2020", "title": "Learning to Update Natural Language Comments Based on Code Changes", "abstract": "<p>We formulate the novel task of automatically updating an existing natural language comment based on changes in the body of code it accompanies. We propose an approach that learns to correlate changes across two distinct language representations, to generate a sequence of edits that are applied to the existing comment to reflect the source code modifications. We train and evaluate our model using a dataset that we collected from commit histories of open-source software projects, with each example consisting of a concurrent update to a method and its corresponding comment. We compare our approach against multiple baselines using both automatic metrics and human evaluation. Results reflect the challenge of this task and that our model outperforms baselines with respect to making edits.</p>\n", "tags": ["bimodal", "edit", "documentation"], "tsne_embedding": [2.3670547008514404, -14.497026443481445]}, {"key": "panthaplackel2021learning", "year": "2021", "title": "Learning to Describe Solutions for Bug Reports Based on Developer Discussions", "abstract": "<p>When a software bug is reported, developers engage in a discussion to collaboratively resolve it. While the solution is likely formulated within the discussion, it is often buried in a large amount of text, making it difficult to comprehend, which delays its implementation. To expedite bug resolution, we propose generating a concise natural language description of the solution by synthesizing relevant content within the discussion, which encompasses both natural language and source code. Furthermore, to support generating an informative description during an ongoing discussion, we propose a secondary task of determining when sufficient context about the solution emerges in real-time. We construct a dataset for these tasks with a novel technique for obtaining noisy supervision from repository changes linked to bug reports. We establish baselines for generating solution descriptions, and develop a classifier which makes a prediction following each new utterance on whether or not the necessary context for performing generation is available. Through automated and human evaluation, we find these tasks to form an ideal testbed for complex reasoning in long, bimodal dialogue context.</p>\n", "tags": ["summarization", "documentation"], "tsne_embedding": [0.04273001104593277, -22.692506790161133]}, {"key": "panthaplackel2022using", "year": "2022", "title": "Using Developer Discussions to Guide Fixing Bugs in Software", "abstract": "<p>Automatically fixing software bugs is a challenging task. While recent work showed that natural language context is useful in guiding bug-fixing models, the approach required prompting developers to provide this context, which was simulated through commit messages written after the bug-fixing code changes were made. We instead propose using bug report discussions, which are available before the task is performed and are also naturally occurring, avoiding the need for any additional information from developers. For this, we augment standard bug-fixing datasets with bug report discussions. Using these newly compiled datasets, we demonstrate that various forms of natural language context derived from such discussions can aid bug-fixing, even leading to improved performance over using commit messages corresponding to the oracle bug-fixing commits.</p>\n", "tags": ["Transformer", "repair"], "tsne_embedding": [-0.159293994307518, -22.76321792602539]}, {"key": "parvez2018building", "year": "2018", "title": "Building Language Models for Text with Named Entities", "abstract": "<p>Text  in  many  domains  involves  a  significant amount of named entities.   Predicting the entity names is often challenging\nfor a language model as they appear less\nfrequent  on  the  training  corpus.   In  this\npaper,  we  propose  a  novel  and  effective\napproach to building a discriminative language  model  which  can  learn  the  entity\nnames by leveraging their entity type information.  We also introduce two benchmark  datasets  based  on  recipes  and  Java\nprogramming codes,  on which we evaluate the proposed model.  Experimental results show that our model achieves 52.2%\nbetter perplexity in recipe generation and\n22.06% on code generation than the state-of-the-art language models.</p>\n", "tags": ["language model"], "tsne_embedding": [2.7321133613586426, 4.028005599975586]}, {"key": "parvez2021retrieval", "year": "2021", "title": "Retrieval Augmented Code Generation and Summarization", "abstract": "<p>Software developers write a lot of source code and documentation during software development. Intrinsically, developers often recall parts of source code or code summaries that they had written in the past while implementing software or documenting them. To mimic developers\u2019 code or summary generation behavior, we propose a retrieval augmented framework, REDCODER, that retrieves relevant code or summaries from a retrieval database and provides them as a supplement to code generation or summarization models. REDCODER has a couple of uniqueness. First, it extends the state-of-the-art dense retrieval technique to search for relevant code or summaries. Second, it can work with retrieval databases that include unimodal (only code or natural language description) or bimodal instances (code-description pairs). We conduct experiments and extensive analysis on two benchmark datasets of code generation and summarization in Java and Python, and the promising results endorse the effectiveness of our proposed retrieval augmented framework.</p>\n", "tags": ["Transformer", "summarization", "code generation"], "tsne_embedding": [5.770211696624756, -5.920531272888184]}, {"key": "pashakhanloo2022codetrek", "year": "2022", "title": "CodeTrek: Flexible Modeling of Code using an Extensible Relational Representation", "abstract": "<p>Designing a suitable representation for code-reasoning tasks is challenging in aspects such as the kinds of program information to model, how to combine them, and how much context to consider. We propose CodeTrek, a deep learning approach that addresses these challenges by representing codebases as databases that conform to rich relational schemas. The relational representation not only allows CodeTrek to uniformly represent diverse kinds of program information, but also to leverage program-analysis queries to derive new semantic relations, which can be readily incorporated without further architectural engineering. CodeTrek embeds this relational representation using a set of walks that can traverse different relations in an unconstrained fashion, and incorporates all relevant attributes along the way. We evaluate CodeTrek on four diverse and challenging Python tasks: variable misuse, exception prediction, unused definition, and variable shadowing.\nCodeTrek achieves an accuracy of 91%, 63%, 98%, and 94% on these tasks respectively, and outperforms state-of-the-art neural models by 2-19% points.</p>\n", "tags": ["representation", "variable misuse"], "tsne_embedding": [-4.490898609161377, -5.015164852142334]}, {"key": "patil2022exploring", "year": "2022", "title": "Exploring Dimensions of Generalizability and Few-shot Transfer for Text-to-SQL Semantic Parsing", "abstract": "<p>Existing work on generalization in Text-to-SQL semantic parsing has been restricted to a zero-shot cross-domain setting. In this paper, we introduce Spider-Gen: a Text-to-SQL benchmark to develop a paradigm of transfer learning across distinct dimensions of generalization in Text-to-SQL semantic parsing. The Spider-Gen benchmark focuses on few-shot adaption for Cross-domain, Lexical, and Structural generalization of Text-to-SQL models. Through our experiments with the Spider-Gen dataset, we show that Seq2Seq language models struggle to generalize against change in data distribution, lexical changes in database schema, and changes in SQL query complexity. Our experiments also reveal that performing few-shot fine-tuning helps Text-to-SQL models to generalize across these changes. However, such few-shot adaptation comes with a negative effect on the knowledge learnt during training. Hence, we also explore Parameter-efficient Fine-tuning methods to overcome the limitations of Seq2Seq Text-to-SQL models. We release the Spider-Gen dataset publicly to facilitate further research in generalization and transfer learning across various dimensions in Text-to-SQL semantic parsing.</p>\n", "tags": ["dataset", "evaluation", "Transformer", "benchmark", "generalizability"], "tsne_embedding": [21.573379516601562, -2.8492074012756348]}, {"key": "patra2016learning", "year": "2016", "title": "Learning to Fuzz: Application-Independent Fuzz Testing with Probabilistic, Generative Models of Input Data", "abstract": "<p>Fuzzing is a popular technique to create test inputs for software that processes structured data. It has been successfully\napplied in various domains, ranging from compilers and interpreters over program analyses to rendering engines, image manipulation tools, and word processors. Existing fuzz\ntesting techniques are tailored for a particular purpose and\nrely on a carefully crafted model of the data to be generated.\nThis paper presents TreeFuzz, a generic approach for generating structured data without an a priori known model. The\nkey idea is to exploit a given corpus of example data to au-\ntomatically infer probabilistic, generative models that create\nnew data with properties similar to the corpus. To support a\nwide range of different properties, TreeFuzz is designed as a\nframework with an extensible set of techniques to infer generative models. We apply the idea to JavaScript programs\nand HTML documents and show that the approach generates mostly valid data for both of them: 96.3% of the generated JavaScript programs are syntactically valid and there are\nonly 2.06 validation errors per kilobyte of generated HTML.\nThe performance of both learning and generation scales linearly w.r.t. the size of the corpus. Using TreeFuzz-generated\nJavaScript programs for differential testing of JavaScript engines exposes various inconsistencies among browsers, including browser bugs and unimplemented language features.</p>\n", "tags": ["fuzzing"], "tsne_embedding": [6.347807884216309, 7.129701614379883]}, {"key": "patra2021semantic", "year": "2021", "title": "A Semantic Bug Seeding: A Learning-Based Approach for Creating Realistic Bugs", "abstract": "<p>When working on techniques to address the wide-spread problem\nof software bugs, one often faces the need for a large number of\nrealistic bugs in real-world programs. Such bugs can either help\nevaluate an approach, e.g., in form of a bug benchmark or a suite\nof program mutations, or even help build the technique, e.g., in\nlearning-based bug detection. Because gathering a large number ofreal bugs is difficult,\na common approach is to rely on automatically\nseeded bugs. Prior work seeds bugs based on syntactic transformation patterns,\nwhich often results in unrealistic bugs and typically \ncannot introduce new, application-specific code tokens. This paper\npresents SemSeed, a technique for automatically seeding bugs in\na semantics-aware way. The key idea is to imitate how a given\nreal-world bug would look like in other programs by semantically\nadapting the bug pattern to the local context. To reason about the\nsemantics of pieces of code, our approach builds on learned token embeddings\nthat encode the semantic similarities of identifiers and literals. Our\nevaluation with real-world JavaScript softwares\nhows that the approach effectively reproduces real bugs and clearly\noutperforms a semantics-unaware approach. The seeded bugs are\nuseful as training data for learning-based bug detection, where\nthey significantly improve the bug detection ability. Moreover, we\nshow that SemSeed-created bugs complement existing mutation\ntesting operators, and that our approach is efficient enough to seed\nhundreds of thousands of bugs within an hour.</p>\n", "tags": ["repair", "edit"], "tsne_embedding": [-8.561169624328613, -16.711505889892578]}, {"key": "pearce2021empirical", "year": "2021", "title": "An Empirical Cybersecurity Evaluation of GitHub Copilot's Code Contributions", "abstract": "<p>There is burgeoning interest in designing AI-based systems to assist humans in designing computing systems, including tools that automatically generate computer code. The most notable of these comes in the form of the first self-described `AI pair programmer\u2019, GitHub Copilot, a language model trained over open-source GitHub code. However, code often contains bugs - and so, given the vast quantity of unvetted code that Copilot has processed, it is certain that the language model will have learned from exploitable, buggy code. This raises concerns on the security of Copilot\u2019s code contributions. In this work, we systematically investigate the prevalence and conditions that can cause GitHub Copilot to recommend insecure code. To perform this analysis we prompt Copilot to generate code in scenarios relevant to high-risk CWEs (e.g. those from MITRE\u2019s \u201cTop 25\u201d list). We explore Copilot\u2019s performance on three distinct code generation axes \u2013 examining how it performs given diversity of weaknesses, diversity of prompts, and diversity of domains. In total, we produce 89 different scenarios for Copilot to complete, producing 1,692 programs. Of these, we found approximately 40% to be vulnerable.</p>\n", "tags": ["Transformer", "language model"], "tsne_embedding": [2.2357699871063232, 18.48350715637207]}, {"key": "peng2021how", "year": "2021", "title": "How could Neural Networks understand Programs?", "abstract": "<p>Semantic understanding of programs is a fundamental problem for programming language processing (PLP). Recent works that learn representations of code based on pre-training techniques in NLP have pushed the frontiers in this direction. However, the semantics of PL and NL have essential differences. These being ignored, we believe it is difficult to build a model to better understand programs, by either directly applying off-the-shelf NLP pre-training techniques to the source code, or adding features to the model by the heuristic. In fact, the semantics of a program can be rigorously defined by formal semantics in PL theory. For example, the operational semantics, describes the meaning of a valid program as updating the environment (i.e., the memory address-value function) through fundamental operations, such as memory I/O and conditional branching. Inspired by this, we propose a novel program semantics learning paradigm, that the model should learn from information composed of (1) the representations which align well with the fundamental operations in operational semantics, and (2) the information of environment transition, which is indispensable for program understanding. To validate our proposal, we present a hierarchical Transformer-based pre-training model called OSCAR to better facilitate the understanding of programs. OSCAR learns from intermediate representation (IR) and an encoded representation derived from static analysis, which are used for representing the fundamental operations and approximating the environment transitions respectively. OSCAR empirically shows the outstanding capability of program semantics understanding on many practical software engineering tasks.</p>\n", "tags": ["Transformer"], "tsne_embedding": [-3.6208412647247314, -3.482907772064209]}, {"key": "phan2021cotext", "year": "2021", "title": "CoTexT: Multi-task Learning with Code-Text Transformer", "abstract": "<p>We present CoTexT, a transformer-based architecture encoder-decoder pre-trained model that learns the representative context between natural language (NL) and programming language (PL) through multi-task learning. CoTexT is pre-trained, in self-supervised fashion, based on large programming language corpus to learn general-purpose understanding and code-text generation supporting downstream NL-PL task such as code summarizing/documentation, code generation, defect detection, code debugging, etc. We train CoTexT on different combination of available PL corpus including both \u201cbimodal\u201d and \u201cunimodal\u201d data where the former is the combinations of both natural texts and their corresponding code snippets in an input sequence and the latter is merely code snippets. We evaluate multi-task learning CoTexT on different generation and classification tasks on CodeXGLUE and it achieves state-of-the-art on all downstream tasks.</p>\n", "tags": ["Transformer"], "tsne_embedding": [6.795690059661865, -0.5586947798728943]}, {"key": "piech2015learning", "year": "2015", "title": "Learning Program Embeddings to Propagate Feedback on Student Code", "abstract": "<p>Providing feedback, both assessing final work\nand giving hints to stuck students, is difficult\nfor open-ended assignments in massive online\nclasses which can range from thousands to millions of students. We introduce a neural network\nmethod to encode programs as a linear mapping\nfrom an embedded precondition space to an embedded postcondition space and propose an algorithm for feedback at scale using these linear maps as features. We apply our algorithm\nto assessments from the Code.org Hour of Code\nand Stanford University\u2019s CS1 course, where we\npropagate human comments on student assignments to orders of magnitude more submissions.</p>\n", "tags": ["representation", "repair", "education"], "tsne_embedding": [19.096446990966797, 21.84296417236328]}, {"key": "poesia2022synchromesh", "year": "2022", "title": "Synchromesh: Reliable code generation from pre-trained language models", "abstract": "<p>Large pre-trained language models have been used to generate code,providing a flexible interface for synthesizing programs from natural language specifications. However, they often violate syntactic and semantic rules of their output language, limiting their practical usability. In this paper, we propose Synchromesh: a framework for substantially improving the reliability of pre-trained models for code generation. Synchromesh comprises two components. First, it retrieves few-shot examples from a training bank using Target Similarity Tuning (TST), a novel method for semantic example selection. TST learns to recognize utterances that describe similar target programs despite differences in surface natural language features. Then, Synchromesh feeds the examples to a pre-trained language model and samples programs using Constrained Semantic Decoding (CSD): a general framework for constraining the output to a set of valid programs in the target language. CSD leverages constraints on partial outputs to sample complete correct programs, and needs neither re-training nor fine-tuning of the language model. We evaluate our methods by synthesizing code from natural language descriptions using GPT-3 and Codex in three real-world languages: SQL queries, Vega-Lite visualizations and SMCalFlow programs. These domains showcase rich constraints that CSD is able to enforce, including syntax, scope, typing rules, and contextual logic. We observe substantial complementary gains from CSD and TST in prediction accuracy and in effectively preventing run-time errors.</p>\n", "tags": ["Transformer", "language model"], "tsne_embedding": [13.642349243164062, 10.374044418334961]}, {"key": "popov2021time", "year": "2021", "title": "Time-Efficient Code Completion Model for the R Programming Language", "abstract": "<p>In this paper we present a deep learning code completion model for the R language. We introduce several techniques to utilize language modeling based architecture in the code completion task. With these techniques, the model requires low resources, but still achieves high quality. We also present an evaluation dataset for the R language completion task. Our dataset contains multiple autocompletion usage contexts that provides robust validation results. The dataset is publicly available.</p>\n", "tags": ["dataset", "language model", "code generation", "Transformer"], "tsne_embedding": [5.291260242462158, 11.102742195129395]}, {"key": "pradel2017deep", "year": "2017", "title": "Deep Learning to Find Bugs", "abstract": "<p>Automated bug detection, e.g., through pattern-based static\nanalysis, is an increasingly popular technique to find programming errors and other code quality issues. Traditionally,\nbug detectors are program analyses that are manually written and carefully tuned by an analysis expert. Unfortunately,\nthe huge amount of possible bug patterns makes it difficult\nto cover more than a small fraction of all bugs. This paper\npresents a new approach toward creating bug detectors. The\nbasic idea is to replace manually writing a program analysis\nwith training a machine learning model that distinguishes\nbuggy from non-buggy code. To address the challenge that\neffective learning requires both positive and negative train-\ning examples, we use simple code transformations that create likely incorrect code from existing code examples. We\npresent a general framework, called DeepBugs, that extracts\npositive training examples from a code corpus, leverages\nsimple program transformations to create negative training\nexamples, trains a model to distinguish these two, and then\nuses the trained model for identifying programming mistakes in previously unseen code. As a proof of concept, we\ncreate four bug detectors for JavaScript that find a diverse set\nof programming mistakes, e.g., accidentally swapped function arguments, incorrect assignments, and incorrect binary\noperations. To find bugs, the trained models use information\nthat is usually discarded by program analyses, such as identifier names of variables and functions. Applying the approach\nto a corpus of 150,000 JavaScript files shows that learned bug\ndetectors have a high accuracy, are very efficient, and reveal\n132 programming mistakes in real-world code.</p>\n\n", "tags": ["defect", "program analysis"], "tsne_embedding": [-8.838676452636719, -16.466398239135742]}, {"key": "pradel2019typewriter", "year": "2019", "title": "TypeWriter: Neural Type Prediction with Search-based Validation", "abstract": "<p>Maintaining large code bases written in dynamically typed languages, such as JavaScript or Python, can be challenging: simple data compatibility errors proliferate, IDE support is lacking and APIs are harder to comprehend. Recent work attempts to address those issues through either static analysis or probabilistic type inference. Unfortunately, static type inference for dynamic languages is inherently limited, while probabilistic approaches suffer from imprecision. This paper presents TypeWriter, the first combination of probabilistic prediction with search-based refinement of predicted types. TypeWriter\u2019s predictor learns to infer the return and argument types for functions from partially annotated code bases by combining the natural language properties of code with programming language-level information. To validate predicted types, TypeWriter invokes a gradual type checker with different combinations of the predicted types, while navigating the space of possible type combinations in a feedback-directed manner. We implement the TypeWriter approach for Python and evaluate it on two code corpora: a multi-million line code base at Facebook and a collection of 500 popular open-source projects. We show that TypeWriter\u2019s type predictor achieves a precision of 64% (91%) and a recall of 52% (68%) in the top-1 (top-5) predictions, and demonstrate that usage contexts are a helpful addition to neural type predictors. By combining predictions with search-based validation, TypeWriter can fully annotate between 42% to 64% of the files in a randomly selected corpus, while ensuring type correctness. A comparison with a static type inference tool shows that TypeWriter adds many more non-trivial types. Overall, TypeWriter provides developers with an effective way to help with the transition to fully type-annotated code.</p>\n", "tags": ["types", "bimodal"], "tsne_embedding": [-3.1728227138519287, 23.4013671875]}, {"key": "pradel2020neural", "year": "2020", "title": "Neural Software Analysis", "abstract": "<p>Many software development problems can be addressed by program analysis tools, which traditionally are based on precise, logical reasoning and heuristics to ensure that the tools are practical. Recent work has shown tremendous success through an alternative way of creating developer tools, which we call neural software analysis. The key idea is to train a neural machine learning model on numerous code examples, which, once trained, makes predictions about previously unseen code. In contrast to traditional program analysis, neural software analysis naturally handles fuzzy information, such as coding conventions and natural language embedded in code, without relying on manually encoded heuristics. This article gives an overview of neural software analysis, discusses when to (not) use it, and presents three example analyses. The analyses address challenging software development problems: bug detection, type prediction, and code completion. The resulting tools complement and outperform traditional program analyses, and are used in industrial practice.</p>\n", "tags": ["program analysis", "survey"], "tsne_embedding": [-11.436620712280273, -13.800308227539062]}, {"key": "pravilov2021unsupervised", "year": "2021", "title": "Unsupervised Learning of General-Purpose Embeddings for Code Changes", "abstract": "<p>Applying machine learning to tasks that operate with code changes requires their numerical representation. In this work, we propose an approach for obtaining such representations during pre-training and evaluate them on two different downstream tasks - applying changes to code and commit message generation. During pre-training, the model learns to apply the given code change in a correct way. This task requires only code changes themselves, which makes it unsupervised. In the task of applying code changes, our model outperforms baseline models by 5.9 percentage points in accuracy. As for the commit message generation, our model demonstrated the same results as supervised models trained for this specific task, which indicates that it can encode code changes well and can be improved in the future by pre-training on a larger dataset of easily gathered code changes.</p>\n", "tags": ["edit", "representation"], "tsne_embedding": [0.11508464813232422, -15.834125518798828]}, {"key": "proksch2015intelligent", "year": "2015", "title": "Intelligent Code Completion with Bayesian Networks", "abstract": "<p>Code completion is an integral part of modern Integrated Development Environments (IDEs). Developers\noften use it to explore Application Programming Interfaces (APIs). It is also useful to reduce the required\namount of typing and to help avoid typos. Traditional code completion systems propose all type-correct\nmethods to the developer. Such a list is often very long with many irrelevant items. More intelligent code\ncompletion systems have been proposed in prior work to reduce the list of proposed methods to relevant\nitems.</p>\n\n<p>This work extends one of these existing approaches, the Best Matching Neighbor (BMN) algorithm. We\nintroduce Bayesian networks as an alternative underlying model, use additional context information for\nmore precise recommendations, and apply clustering techniques to improve model sizes. We compare our\nnew approach, Pattern-based Bayesian Networks (PBN), to the existing BMN algorithm. We extend previously used evaluation methodologies and, in addition to prediction quality, we also evaluate model size and\ninference speed.</p>\n\n<p>Our results show that the additional context information we collect improves prediction quality, especially\nfor queries that do not contain method calls. We also show that PBN can obtain comparable prediction\nquality to BMN, while model size and inference speed scale better with large input sizes.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [-0.46071088314056396, 13.51234245300293]}, {"key": "pu2016skp", "year": "2016", "title": "sk_p: a neural program corrector for MOOCs", "abstract": "<p>We present a novel technique for automatic program correction in MOOCs, capable of fixing both syntactic and semantic errors without manual, problem specific correction strategies. Given an incorrect student program, it generates candidate programs from a distribution of likely corrections, and checks each candidate for correctness against a test suite.</p>\n\n<p>The key observation is that in MOOCs many programs share similar code fragments, and the seq2seq neural network model, used in the natural-language processing task of machine translation, can be modified and trained to recover these fragments.</p>\n\n<p>Experiment shows our scheme can correct 29% of all incorrect submissions and out-performs state of the art approach which requires manual, problem specific correction strategies.</p>\n", "tags": ["repair"], "tsne_embedding": [-3.534902334213257, -25.8164119720459]}, {"key": "puri2021project", "year": "2021", "title": "Project CodeNet: A Large-Scale AI for Code Dataset for Learning a Diversity of Coding Tasks", "abstract": "<p>Advancements in deep learning and machine learning algorithms have enabled\nbreakthrough progress in computer vision, speech recognition, natural language\nprocessing and beyond.  In addition, over the last several decades, software has\nbeen built into the fabric of every aspect of our society.   Together,  these two\ntrends have generated new interest in the fast-emerging research area of \u201cAI for\nCode\u201d. As software development becomes ubiquitous across all industries and code\ninfrastructure of enterprise legacy applications ages, it is more critical than ever\nto increase software development productivity and modernize legacy applications.\nOver the last decade, datasets like ImageNet, with its large scale and diversity,\nhave played a pivotal role in algorithmic advancements from computer vision to\nlanguage and speech understanding. In this paper, we present \u201cProject CodeNet\u201d,\na first-of-its-kind, very large scale, diverse, and high-quality dataset to accelerate\nthe algorithmic advancements in AI for Code.  It consists of 14M code samples\nand about 500M lines of code in 55 different programming languages.  Project\nCodeNet is not only unique in its scale, but also in the diversity of coding tasks\nit can help benchmark:  from code similarity and classification for advances in\ncode recommendation algorithms, and code translation between a large variety\nprogramming languages, to advances in code performance (both runtime, and\nmemory) improvement techniques. CodeNet also provides sample input and output\ntest sets for over 7M code samples, which can be critical for determining code\nequivalence in different languages. As a usability feature, we provide several \npreprocessing tools in Project CodeNet to transform source codes into representations\nthat can be readily used as inputs into machine learning models.</p>\n", "tags": ["dataset"], "tsne_embedding": [-2.772480010986328, -0.3028950095176697]}, {"key": "rabin2019testing", "year": "2019", "title": "Testing Neural Program Analyzers", "abstract": "<p>Deep neural networks have been increasingly used in software engineering and program analysis tasks. They usually take a program and make some predictions about it, e.g., bug prediction. We call these models neural program analyzers. The reliability of neural programs can impact the reliability of the encompassing analyses. In this paper, we describe our ongoing efforts to develop effective techniques for testing neural programs. We discuss the challenges involved in developing such tools and our future plans. In our preliminary experiment on a neural model recently proposed in the literature, we found that the model is very brittle, and simple perturbations in the input can cause the model to make mistakes in its prediction.</p>\n", "tags": ["evaluation", "refactoring"], "tsne_embedding": [-11.274381637573242, -14.532768249511719]}, {"key": "rabin2020demystifying", "year": "2020", "title": "Towards Demystifying Dimensions of Source Code Embeddings", "abstract": "<p>Source code representations are key in applying machine learning techniques for processing and analyzing programs. A popular approach in representing source code is neural source code embeddings that represents programs with high-dimensional vectors computed by training deep neural networks on a large volume of programs. Although successful, there is little known about the contents of these vectors and their characteristics. In this paper, we present our preliminary results towards better understanding the contents of code2vec neural source code embeddings. In particular, in a small case study, we use the code2vec embeddings to create binary SVM classifiers and compare their performance with the handcrafted features. Our results suggest that the handcrafted features can perform very close to the highly-dimensional code2vec embeddings, and the information gains are more evenly distributed in the code2vec embeddings compared to the handcrafted features. We also find that the code2vec embeddings are more resilient to the removal of dimensions with low information gains than the handcrafted features. We hope our results serve a stepping stone toward principled analysis and evaluation of these code representations.</p>\n", "tags": ["evaluation", "representation", "naming", "interpretability"], "tsne_embedding": [-7.977723121643066, 0.8890609741210938]}, {"key": "rabin2021generalizability", "year": "2021", "title": "On the Generalizability of Neural Program Models with respect to Semantic-Preserving Program Transformations", "abstract": "<p>With the prevalence of publicly available source code repositories to train deep neural network models, neural program models can do well in source code analysis tasks such as predicting method names in given programs that cannot be easily done by traditional program analysis techniques. Although such neural program models have been tested on various existing datasets, the extent to which they generalize to unforeseen source code is largely unknown. Since it is very challenging to test neural program models on all unforeseen programs, in this paper, we propose to evaluate the generalizability of neural program models with respect to semantic-preserving transformations: a generalizable neural program model should perform equally well on programs that are of the same semantics but of different lexical appearances and syntactical structures. We compare the results of various neural program models for the method name prediction task on programs before and after automated semantic-preserving transformations. We use three Java datasets of different sizes and three state-of-the-art neural network models for code, namely code2vec, code2seq, and GGNN, to build nine such neural program models for evaluation. Our results show that even with small semantically preserving changes to the programs, these neural program models often fail to generalize their performance. Our results also suggest that neural program models based on data and control dependencies in programs generalize better than neural program models based only on abstract syntax trees. On the positive side, we observe that as the size of the training dataset grows and diversifies the generalizability of correct predictions produced by the neural program models can be improved too. Our results on the generalizability of neural program models provide insights to measure their limitations and provide a stepping stone for their improvement.</p>\n", "tags": ["evaluation", "adversarial", "generalizability", "refactoring", "summarization"], "tsne_embedding": [-3.165071964263916, -2.9307925701141357]}, {"key": "rabin2021understanding", "year": "2021", "title": "Understanding Neural Code Intelligence Through Program Simplification", "abstract": "<p>A wide range of code intelligence (CI) tools, powered by deep neural networks, have been developed recently to improve programming productivity and perform program analysis. To reliably use such tools, developers often need to reason about the behavior of the underlying models and the factors that affect them. This is especially challenging for tools backed by deep neural networks. Various methods have tried to reduce this opacity in the vein of \u201ctransparent/interpretable-AI\u201d. However, these approaches are often specific to a particular set of network architectures, even requiring access to the network\u2019s parameters. This makes them difficult to use for the average programmer, which hinders the reliable adoption of neural CI systems. In this paper, we propose a simple, model-agnostic approach to identify critical input features for models in CI systems, by drawing on software debugging research, specifically delta debugging. Our approach, SIVAND, uses simplification techniques that reduce the size of input programs of a CI model while preserving the predictions of the model. We show that this approach yields remarkably small outputs and is broadly applicable across many model architectures and problem domains. We find that the models in our experiments often rely heavily on just a few syntactic features in input programs. We believe that SIVAND\u2019s extracted features may help understand neural CI systems\u2019 predictions and learned behavior.</p>\n", "tags": ["interpretability", "refactoring", "information extraction"], "tsne_embedding": [7.405038833618164, 17.27204704284668]}, {"key": "rabin2022memorization", "year": "2022", "title": "Memorization and Generalization in Neural Code Intelligence Models", "abstract": "<p>Deep Neural Networks (DNNs) are increasingly being used in software engineering and code intelligence tasks. These are powerful tools that are capable of learning highly generalizable patterns from large datasets through millions of parameters. At the same time, their large capacity can render them prone to memorizing data points. Recent work suggests that the memorization risk manifests especially strongly when the training dataset is noisy, involving many ambiguous or questionable samples, and memorization is the only recourse. The goal of this paper is to evaluate and compare the extent of memorization and generalization in neural code intelligence models. It aims to provide insights on how memorization may impact the learning behavior of neural models in code intelligence systems. To observe the extent of memorization in models, we add random noise to the original training dataset and use various metrics to quantify the impact of noise on various aspects of training and testing. We evaluate several state-of-the-art neural code intelligence models and benchmarks based on Java, Python, and Ruby codebases. Our results highlight important risks: millions of trainable parameters allow the neural networks to memorize anything, including noisy data, and provide a false sense of generalization. We observed all models manifest some forms of memorization. This can be potentially troublesome in most code intelligence tasks where they rely on rather noise-prone and repetitive data sources, such as code from GitHub. To the best of our knowledge, we provide the first study to quantify memorization effects in the domain of software engineering and code intelligence systems. This work raises awareness and provides new insights into important issues of training neural models in code intelligence systems that are usually overlooked by software engineering researchers.</p>\n", "tags": ["evaluation", "memorization", "generalizability", "refactoring", "language model"], "tsne_embedding": [-0.6879260540008545, -0.5809474587440491]}, {"key": "rabin2022understanding", "year": "2022", "title": "Syntax-Guided Program Reduction for Understanding Neural Code Intelligence Models", "abstract": "<p>Neural code intelligence (CI) models are opaque black-boxes and offer little insight on the features they use in making predictions. This opacity may lead to distrust in their prediction and hamper their wider adoption in safety-critical applications. Recently, input program reduction techniques have been proposed to identify key features in the input programs to improve the transparency of CI models. However, this approach is syntax-unaware and does not consider the grammar of the programming language. In this paper, we apply a syntax-guided program reduction technique that considers the grammar of the input programs during reduction. Our experiments on multiple models across different types of input programs show that the syntax-guided program reduction technique is faster and provides smaller sets of key tokens in reduced programs. We also show that the key tokens could be used in generating adversarial examples for up to 65% of the input programs.</p>\n", "tags": ["interpretability", "refactoring", "adversarial"], "tsne_embedding": [7.090533256530762, 17.821218490600586]}, {"key": "rabinovich2017abstract", "year": "2017", "title": "Abstract Syntax Networks for Code Generation and Semantic Parsing", "abstract": "<p>Tasks like code generation and semantic parsing require mapping unstructured (or partially structured) inputs to well-formed, executable outputs. We introduce abstract syntax networks, a modeling framework for these problems. The outputs are represented as abstract syntax trees (ASTs) and constructed by a decoder with a dynamically-determined modular structure paralleling the structure of the output tree. On the benchmark Hearthstone dataset for code generation, our model obtains 79.2 BLEU and 22.7% exact match accuracy, compared to previous state-of-the-art values of 67.1 and 6.1%. Furthermore, we perform competitively on the Atis, Jobs, and Geo semantic parsing datasets with no task-specific engineering.</p>\n", "tags": ["code generation", "grammar"], "tsne_embedding": [15.147153854370117, -3.6910486221313477]}, {"key": "raghothaman2018user", "year": "2018", "title": "User-guided program reasoning using Bayesian inference", "abstract": "<p>Program analyses necessarily make approximations that often lead them to report true alarms interspersed with many false alarms. We propose a new approach to leverage user feedback to guide program analyses towards true alarms and away from false alarms. Our approach associates each alarm with a confidence value by performing Bayesian inference on a probabilistic model derived from the analysis rules. In each iteration, the user inspects the alarm with the highest confidence and labels its ground truth, and the approach recomputes the confidences of the remaining alarms given this feedback. It thereby maximizes the return on the effort by the user in inspecting each alarm. We have implemented our approach in a tool named Bingo for program analyses expressed in Datalog. Experiments with real users and two sophisticated analyses\u2014a static datarace analysis for Java programs and a static taint analysis for Android apps\u2014show significant improvements on a range of metrics, including false alarm rates and number of bugs found.</p>\n", "tags": ["program analysis"], "tsne_embedding": [-9.98571491241455, 18.096731185913086]}, {"key": "rahman2019natural", "year": "2019", "title": "Natural Software Revisited", "abstract": "<p>Recent works have concluded that software is more repetitive and predictable, i.e. more natural, than English texts. These works included \u201csimple/artificial\u201d syntax rules in their language models. When we remove SyntaxTokens we find that code is still repetitive and predictable but only at levels slightly above English. Furthermore, previous works have compared individual Java programs to general English corpora, such as Gutenberg, which contains a historically large range of styles and subjects (e.g. Saint Augustine to Oscar Wilde). We perform an additional comparison of technical StackOverflow English discussions with source code and find that this restricted English is similarly repetitive to code. Although we find that code is less repetitive than previously thought, we suspect that API code element usage will be repetitive across software projects. For example a file is opened and closed in the same manner irrespective of domain. When we restrict our n-grams to those contained in the Java API we find that the entropy is significantly lower than the English corpora. Previous works have focused on sequential sequences of tokens. When we extract program graphs of size 2, 3, and 4 nodes we see that the abstract graph representation is much more concise and repetitive than the sequential representations of the same code. This suggests that future work should focus on statistical graph models that go beyond linear sequences of tokens. Our anonymous replication package makes our scripts and data available to future researchers and reviewers.</p>\n", "tags": [], "tsne_embedding": [-0.014794399030506611, 8.058732032775879]}, {"key": "ramakrishnan2020backdoors", "year": "2022", "title": "Backdoors in Neural Models of Source Code", "abstract": "<p>Deep neural networks are vulnerable to a range of adversaries. A particularly pernicious class of vulnerabilities are backdoors, where model predictions diverge in the presence of subtle triggers in inputs. An attacker can implant a backdoor by poisoning the training data to yield a desired target prediction on triggered inputs. We study backdoors in the context of deep-learning for source code. (1) We define a range of backdoor classes for source-code tasks and show how to poison a dataset to install such backdoors. (2) We adapt and improve recent algorithms from robust statistics for our setting, showing that backdoors leave a spectral signature in the learned representation of source code, thus enabling detection of poisoned data. (3) We conduct a thorough evaluation on different architectures and languages, showing the ease of injecting backdoors and our ability to eliminate them.</p>\n", "tags": ["adversarial"], "tsne_embedding": [3.5817105770111084, 21.136585235595703]}, {"key": "ray2015naturalness", "year": "2015", "title": "On the \u201cNaturalness\u201d of Buggy Code", "abstract": "<p>Real software, the kind working programmers produce by the kLOC\nto solve real-world problems, tends to be \u201cnatural\u201d, like speech or\nnatural language; it tends to be highly repetitive and predictable.\nResearchers have captured this naturalness of software through statistical models and used them to good effect in suggestion engines,\nporting tools, coding standards checkers, and idiom miners. This\nsuggests that code that appears improbable, or surprising, to a good\nstatistical language model is \u201cunnatural\u201d in some sense, and thus\npossibly suspicious. In this paper, we investigate this hypothesis. We consider a large corpus of bug fix commits (ca. 8,296),\nfrom 10 different Java projects, and we focus on its language statistics, evaluating the naturalness of buggy code and the corresponding fixes. We find that code with bugs tends to be more entropic\n(i.e. unnatural), becoming less so as bugs are fixed. Focusing on\nhighly entropic lines is similar in cost-effectiveness to some well-known static bug finders (PMD, FindBugs) and ordering warnings\nfrom these bug finders using an entropy measure improves the cost-effectiveness of inspecting code implicated in warnings. This suggests that entropy may be a valid language-independent and simple\nway to complement the effectiveness of PMD or FindBugs, and\nthat search-based bug-fixing methods may benefit from using entropy both for fault-localization and searching for fixes.</p>\n\n", "tags": ["defect"], "tsne_embedding": [-14.053845405578613, -18.843276977539062]}, {"key": "raychev2014code", "year": "2014", "title": "Code Completion with Statistical Language Models", "abstract": "<p>We address the problem of synthesizing code completions for programs using APIs. Given a program with holes, we synthesize completions for holes with the most likely sequences of method calls.</p>\n\n<p>Our main idea is to reduce the problem of code completion to\na natural-language processing problem of predicting probabilities\nof sentences. We design a simple and scalable static analysis that\nextracts sequences of method calls from a large codebase, and\nindex these into a statistical language model. We then employ\nthe language model to find the highest ranked sentences, and use\nthem to synthesize a code completion. Our approach is able to\nsynthesize sequences of calls across multiple objects together with\ntheir arguments.</p>\n\n<p>Experiments show that our approach is fast and effective. Virtually all computed completions typecheck, and the desired completion appears in the top 3 results in 90% of the cases.</p>\n", "tags": ["language model", "autocomplete", "code generation"], "tsne_embedding": [1.8593682050704956, 10.789772987365723]}, {"key": "raychev2015predicting", "year": "2015", "title": "Predicting Program Properties from \u201cBig Code\u201d", "abstract": "<p>We present a new approach for predicting program properties from\nmassive codebases (aka \u201cBig Code\u201d). Our approach first learns a\nprobabilistic model from existing data and then uses this model to\npredict properties of new, unseen programs.</p>\n\n<p>The key idea of our work is to transform the input program into\na representation which allows us to phrase the problem of inferring program properties as structured prediction in machine learning. This formulation enables us to leverage powerful probabilistic\ngraphical models such as conditional random fields (CRFs) in order\nto perform joint prediction of program properties.</p>\n\n<p>As an example of our approach, we built a scalable prediction\nengine called JSNICE 1 for solving two kinds of problems in the\ncontext of JavaScript: predicting (syntactic) names of identifiers\nand predicting (semantic) type annotations of variables. Experimentally, JSNICE predicts correct names for 63% of name identifiers and its type annotation predictions are correct in 81% of the\ncases. In the first week since its release, JSN ICE was used by more\nthan 30,000 developers and in only few months has become a popular tool in the JavaScript developer community.</p>\n\n<p>By formulating the problem of inferring program properties as\nstructured prediction and showing how to perform both learning\nand inference in this context, our work opens up new possibilities\nfor attacking a wide range of difficult problems in the context of\n\u201cBig Code\u201d including invariant generation, de-compilation, synthesis and others.</p>\n", "tags": ["program analysis", "naming", "types", "deobfuscation"], "tsne_embedding": [-3.5858993530273438, 17.429019927978516]}, {"key": "raychev2016learning", "year": "2016", "title": "Learning Programs from Noisy Data", "abstract": "<p>We present a new approach for learning programs from noisy\ndatasets. Our approach is based on two new concepts: a regularized\nprogram generator which produces a candidate program based on a\nsmall sample of the entire dataset while avoiding overfitting, and a\ndataset sampler which carefully samples the dataset by leveraging\nthe candidate program\u2019s score on that dataset. The two components\nare connected in a continuous feedback-directed loop.</p>\n\n<p>We show how to apply this approach to two settings: one where\nthe dataset has a bound on the noise, and another without a noise\nbound. The second setting leads to a new way of performing\napproximate empirical risk minimization on hypotheses classes\nformed by a discrete search space.</p>\n\n<p>We then present two new kinds of program synthesizers which\ntarget the two noise settings. First, we introduce a novel regularized\nbitstream synthesizer that successfully generates programs even in\nthe presence of incorrect examples. We show that the synthesizer\ncan detect errors in the examples while combating overfitting \u2013\na major problem in existing synthesis techniques. We also show\nhow the approach can be used in a setting where the dataset grows\ndynamically via new examples (e.g., provided by a human).</p>\n\n<p>Second, we present a novel technique for constructing statistical\ncode completion systems. These are systems trained on massive\ndatasets of open source programs, also known as \u201cBig Code\u201d. The\nkey idea is to introduce a domain specific language (DSL) over\ntrees and to learn functions in that DSL directly from the dataset.\nThese learned functions then condition the predictions made by the\nsystem. This is a flexible and powerful technique which generalizes\nseveral existing works as we no longer need to decide a priori on\nwhat the prediction should be conditioned (another benefit is that\nthe learned functions are a natural mechanism for explaining the\nprediction). As a result, our code completion system surpasses the\nprediction capabilities of existing, hard-wired systems.</p>\n", "tags": ["code generation", "grammar"], "tsne_embedding": [11.539164543151855, 15.353825569152832]}, {"key": "reid2022learning", "year": "2022", "title": "Learning to Model Editing Processes", "abstract": "<p>Most existing sequence generation models produce outputs in one pass, usually left-to-right. However, this is in contrast with a more natural approach that humans use in generating content; iterative refinement and editing. Recent work has introduced edit-based models for various tasks (such as neural machine translation and text style transfer), but these generally model a single edit step. In this work, we propose modeling editing processes, modeling the whole process of iteratively generating sequences. We form a conceptual framework to describe the likelihood of multi-step edits, and describe neural models that can learn a generative model of sequences based on these multistep edits. We introduce baseline results and metrics on this task, finding that modeling editing processes improves performance on a variety of axes on both our proposed task and related downstream tasks compared to previous single-step models of edits.</p>\n", "tags": ["Transformer", "edit"], "tsne_embedding": [6.9424729347229, -16.483179092407227]}, {"key": "ren2020codebleu", "year": "2020", "title": "CodeBLEU: a Method for Automatic Evaluation of Code Synthesis", "abstract": "<p>Evaluation metrics play a vital role in the growth of an area as it defines the standard of distinguishing between good and bad models. In the area of code synthesis, the commonly used evaluation metric is BLEU or perfect accuracy, but they are not suitable enough to evaluate codes, because BLEU is originally designed to evaluate the natural language, neglecting important syntactic and semantic features of codes, and perfect accuracy is too strict thus it underestimates different outputs with the same semantic logic. To remedy this, we introduce a new automatic evaluation metric, dubbed CodeBLEU. It absorbs the strength of BLEU in the n-gram match and further injects code syntax via abstract syntax trees (AST) and code semantics via data-flow. We conduct experiments by evaluating the correlation coefficient between CodeBLEU and quality scores assigned by the programmers on three code synthesis tasks, i.e., text-to-code, code translation, and code refinement. Experimental results show that our proposed CodeBLEU can achieve a better correlation with programmer assigned scores compared with BLEU and accuracy.</p>\n", "tags": ["evaluation"], "tsne_embedding": [-3.7191948890686035, 7.8036088943481445]}, {"key": "richardson2017code2text", "year": "2017", "title": "The Code2Text Challenge: Text Generation in Source Code Libraries", "abstract": "<p>We propose a new shared task for tactical data-to-text generation in the domain of source code libraries. Specifically, we focus on text generation of function descriptions from example software projects. Data is drawn from existing resources used for studying the related problem of semantic parser induction (Richardson and Kuhn, 2017b; Richardson and Kuhn, 2017a), and spans a wide variety of both natural languages and programming languages. In this paper, we describe these existing resources, which will serve as training and development data for the task, and discuss plans for building new independent test sets.</p>\n", "tags": ["bimodal"], "tsne_embedding": [15.913534164428711, 3.6252617835998535]}, {"key": "richardson2017function", "year": "2017", "title": "Function Assistant: A Tool for NL Querying of APIs", "abstract": "<p>In this paper, we describe Function Assistant, a lightweight Python-based toolkit for querying and exploring source code repositories using natural language. The toolkit is designed to help end-users of a target API quickly find information about functions through high-level natural language queries and descriptions. For a given text query and background API, the tool finds candidate functions by performing a translation from the text to known representations in the API using the semantic parsing approach of Richardson and Kuhn (2017). Translations are automatically learned from example text-code pairs in example APIs. The toolkit includes features for building translation pipelines and query engines for arbitrary source code projects. To explore this last feature, we perform new experiments on 27 well-known Python projects hosted on Github.</p>\n", "tags": ["bimodal", "API"], "tsne_embedding": [14.11508846282959, 1.1126065254211426]}, {"key": "richardson2017learning", "year": "2017", "title": "Learning Technical Correspondences in Technical Documentation", "abstract": "<p>We consider the problem of translating high-level textual descriptions to formal representations in technical documentation as part of an effort to model the meaning of such documentation. We focus specifically on the problem of learning translational correspondences between text descriptions and grounded representations in the target documentation, such as formal representation of functions or code templates. Our approach exploits the parallel nature of such documentation, or the tight coupling between high-level text and the low-level representations we aim to learn. Data is collected by mining technical documents for such parallel text-representation pairs, which we use to train a simple semantic parsing model. We report new baseline results on sixteen novel datasets, including the standard library documentation for nine popular programming languages across seven natural languages, and a small collection of Unix utility manuals.</p>\n", "tags": ["documentation", "API", "bimodal"], "tsne_embedding": [13.970005989074707, -0.02981375716626644]}, {"key": "richardson2018polyglot", "year": "2018", "title": "Polyglot Semantic Parsing in APIs", "abstract": "<p>Traditional approaches to semantic parsing (SP) work by training individual models for each available parallel dataset of text-meaning pairs. In this paper, we explore the idea of polyglot semantic translation, or learning semantic parsing models that are trained on multiple datasets and natural languages. In particular, we focus on translating text to code signature representations using the software component datasets of Richardson and Kuhn (2017a,b). The advantage of such models is that they can be used for parsing a wide variety of input natural languages and output programming languages, or mixed input languages, using a single unified model. To facilitate modeling of this type, we develop a novel graph-based decoding framework that achieves state-of-the-art performance on the above datasets, and apply this method to two other benchmark SP tasks.</p>\n", "tags": ["bimodal", "API"], "tsne_embedding": [15.171618461608887, -2.7902045249938965]}, {"key": "richter2022can", "year": "2022", "title": "Can we learn from developer mistakes? Learning to localize and repair real bugs from real bug fixes", "abstract": "<p>Real bug fixes found in open source repositories seem to be the perfect source for learning to localize and repair real bugs. However, the absence of large scale bug fix collections has made it difficult to effectively exploit real bug fixes in the training of larger neural models in the past. In contrast, artificial bugs \u2013 produced by mutating existing source code \u2013 can be easily obtained at a sufficient scale and are therefore often preferred in the training of existing approaches. Still, localization and repair models that are trained on artificial bugs usually underperform when faced with real bugs. This raises the question whether bug localization and repair models trained on real bug fixes are more effective in localizing and repairing real bugs.</p>\n\n<p>We address this question by introducing RealiT, a pre-train-and-fine-tune approach for effectively learning to localize and repair real bugs from real bug fixes. RealiT is first pre-trained on a large number of artificial bugs produced by traditional mutation operators and then fine-tuned on a smaller set of real bug fixes. Fine-tuning does not require any modifications of the learning algorithm and hence can be easily adopted in various training scenarios for bug localization or repair (even when real training data is scarce). In addition, we found that training on real bug fixes with RealiT is empirically powerful by nearly doubling the localization performance of an existing model on real bugs while maintaining or even improving the repair performance.</p>\n", "tags": ["Transformer", "repair", "defect"], "tsne_embedding": [-8.62533950805664, -20.401941299438477]}, {"key": "roziere2021dobf", "year": "2021", "title": "DOBF: A Deobfuscation Pre-Training Objective for Programming Languages", "abstract": "<p>Recent advances in self-supervised learning have dramatically improved the state of the art on a wide variety of tasks. However, research in language model pre-training has mostly focused on natural languages, and it is unclear whether models like BERT and its variants provide the best pre-training when applied to other modalities, such as source code. In this paper, we introduce a new pre-training objective, DOBF, that leverages the structural aspect of programming languages and pre-trains a model to recover the original version of obfuscated source code. We show that models pre-trained with DOBF significantly outperform existing approaches on multiple downstream tasks, providing relative improvements of up to 13% in unsupervised code translation, and 24% in natural language code search. Incidentally, we found that our pre-trained model is able to de-obfuscate fully obfuscated source files, and to suggest descriptive variable names.</p>\n", "tags": ["pretraining"], "tsne_embedding": [3.026137113571167, 0.21235190331935883]}, {"key": "roziere2021leveraging", "year": "2021", "title": "Leveraging Automated Unit Tests for Unsupervised Code Translation", "abstract": "<p>With little to no parallel data available for programming languages, unsupervised methods are well-suited to source code translation. However, the majority of unsupervised machine translation approaches rely on back-translation, a method developed in the context of natural language translation and one that inherently involves training on noisy inputs. Unfortunately, source code is highly sensitive to small changes; a single token can result in compilation failures or erroneous programs, unlike natural languages where small inaccuracies may not change the meaning of a sentence. To address this issue, we propose to leverage an automated unit-testing system to filter out invalid translations, thereby creating a fully tested parallel corpus. We found that fine-tuning an unsupervised model with this filtered data set significantly reduces the noise in the translations so-generated, comfortably outperforming the state-of-the-art for all language pairs studied. In particular, for Java \u2192 Python and Python \u2192 C++ we outperform the best previous methods by more than 16% and 24% respectively, reducing the error rate by more than 35%.</p>\n", "tags": ["migration"], "tsne_embedding": [13.435221672058105, 5.363959312438965]}, {"key": "russell2018automated", "year": "2018", "title": "Automated Vulnerability Detection in Source Code Using Deep Representation Learning", "abstract": "<p>Increasing numbers of software vulnerabilities are discovered every year whether they are reported publicly or discovered internally in proprietary code. These vulnerabilities can pose serious risk of exploit and result in system compromise, information leaks, or denial of service. We leveraged the wealth of C and C++ open-source code available to develop a large-scale function-level vulnerability detection system using machine learning. To supplement existing labeled vulnerability datasets, we compiled a vast dataset of millions of open-source functions and labeled it with carefully-selected findings from three different static analyzers that indicate potential exploits. Using these datasets, we developed a fast and scalable vulnerability detection tool based on deep feature representation learning that directly interprets lexed source code. We evaluated our tool on code from both real software packages and the NIST SATE IV benchmark dataset. Our results demonstrate that deep feature representation learning on source code is a promising approach for automated software vulnerability detection.</p>\n", "tags": ["program analysis"], "tsne_embedding": [-14.56045150756836, -9.776228904724121]}, {"key": "saberi2023model", "year": "2023", "title": "Model-Agnostic Syntactical Information for Pre-Trained Programming Language Models", "abstract": "<p>Pre-trained Programming Language Models (PPLMs) achieved many recent states of the art results for many code-related software engineering tasks. Though some studies use data flow or propose tree-based models that utilize Abstract Syntax Tree (AST), most PPLMs do not fully utilize the rich syntactical information in source code. Still, the input is considered a sequence of tokens. There are two issues; the first is computational inefficiency due to the quadratic relationship between input length and attention complexity. Second, any syntactical information, when needed as an extra input to the current PPLMs, requires the model to be pre-trained from scratch, wasting all the computational resources already used for pre-training the current models. In this work, we propose Named Entity Recognition (NER) adapters, lightweight modules that can be inserted into Transformer blocks to learn type information extracted from the AST. These adapters can be used with current PPLMs such as CodeBERT, GraphCodeBERT, and CodeT5. We train the NER adapters using a novel Token Type Classification objective function (TTC). We insert our proposed work in CodeBERT, building CodeBERTER, and evaluate the performance on two tasks of code refinement and code summarization. CodeBERTER improves the accuracy of code refinement from 16.4 to 17.8 while using 20% of training parameter budget compared to the fully fine-tuning approach, and the BLEU score of code summarization from 14.75 to 15.90 while reducing 77% of training parameters compared to the fully fine-tuning approach.</p>\n", "tags": ["Transformer", "repair", "summarization"], "tsne_embedding": [3.2499122619628906, 2.034001588821411]}, {"key": "sahu2022learning", "year": "2022", "title": "Learning to Answer Semantic Queries over Code", "abstract": "<p>During software development, developers need answers to queries about semantic aspects of code. Even though extractive question-answering using neural approaches has been studied widely in natural languages, the problem of answering semantic queries over code using neural networks has not yet been explored. This is mainly because there is no existing dataset with extractive question and answer pairs over code involving complex concepts and long chains of reasoning. We bridge this gap by building a new, curated dataset called CodeQueries, and proposing a neural question-answering methodology over code.\nWe build upon state-of-the-art pre-trained models of code to predict answer and supporting-fact spans. Given a query and code, only some of the code may be relevant to answer the query. We first experiment under an ideal setting where only the relevant code is given to the model and show that our models do well. We then experiment under three pragmatic considerations: (1) scaling to large-size code, (2) learning from a limited number of examples and (3) robustness to minor syntax errors in code. Our results show that while a neural model can be resilient to minor syntax errors in code, increasing size of code, presence of code that is not relevant to the query, and reduced number of training examples limit the model performance. We are releasing our data and models to facilitate future work on the proposed problem of answering semantic queries over code.</p>\n", "tags": ["static analysis", "Transformer"], "tsne_embedding": [-16.158740997314453, 7.916961193084717]}, {"key": "saini2018oreo", "year": "2018", "title": "Oreo: detection of clones in the twilight zone", "abstract": "<p>Source code clones are categorized into four types of increasing difficulty of detection, ranging from purely textual (Type-1) to purely semantic (Type-4). Most clone detectors reported in the literature work well up to Type-3, which accounts for syntactic differences. In between Type-3 and Type-4, however, there lies a spectrum of clones that, although still exhibiting some syntactic similarities, are extremely hard to detect \u2013 the Twilight Zone. Most clone detectors reported in the literature fail to operate in this zone. We present Oreo, a novel approach to source code clone detection that not only detects Type-1 to Type-3 clones accurately, but is also capable of detecting harder-to-detect clones in the Twilight Zone. Oreo is built using a combination of machine learning, information retrieval, and software metrics. We evaluate the recall of Oreo on BigCloneBench, and perform manual evaluation for precision. Oreo has both high recall and precision. More importantly, it pushes the boundary in detection of clones with moderate to weak syntactic similarity in a scalable manner.</p>\n", "tags": ["clone"], "tsne_embedding": [-14.89859390258789, -2.9651334285736084]}, {"key": "santos2018syntax", "year": "2018", "title": "Syntax and Sensibility: Using language models to detect and correct syntax errors", "abstract": "<p>Syntax errors are made by novice and experienced programmers alike; however, novice programmers lack the years of experience that help them quickly resolve these frustrating errors. Standard LR parsers are of little help, typically resolving syntax errors and their precise location poorly. We propose a methodology that locates where syntax errors occur, and suggests possible changes to the token stream that can fix the error identified. This methodology finds syntax errors by using language models trained on correct source code to find tokens that seem out of place. Fixes are synthesized by consulting the language models to determine what tokens are more likely at the estimated error location. We compare <em>n</em>-gram and LSTM (long short-term memory) language models for this task, each trained on a large corpus of Java code collected from GitHub. Unlike prior work, our methodology does not rely that the problem source code comes from the same domain as the training data. We evaluated against a repository of real student mistakes. Our tools are able to find a syntactically-valid fix within its top-2 suggestions, often producing the exact fix that the student used to resolve the error. The results show that this tool and methodology can locate and suggest corrections for syntax errors. Our methodology is of practical use to all programmers, but will be especially useful to novices frustrated with incomprehensible syntax errors.</p>\n", "tags": ["repair", "language model"], "tsne_embedding": [-4.350039482116699, -15.119861602783203]}, {"key": "saraiva2015products", "year": "2015", "title": "Products, Developers, and Milestones: How Should I Build My N-Gram Language Model", "abstract": "<p>Recent work has shown that although programming languages en-\nable source code to be rich and complex, most code tends to be\nrepetitive and predictable. The use of natural language processing\n(NLP) techniques applied to source code such as n-gram language\nmodels show great promise in areas such as code completion, aiding impaired developers, and code search. In this paper, we address\nthree questions related to different methods of constructing lan-\nguage models in an industrial context. Specifically, we ask: (1) Do\napplication specific, but smaller language models perform better\nthan language models across applications? (2) Are developer specific language models effective and do they differ depending on\nwhat parts of the codebase a developer is working in? (3) Finally,\ndo language models change over time, i.e., does a language model\nfrom early development model change later on in development?\nThe answers to these questions enable techniques that make use of\nprogramming language models in development to choose the model\ntraining corpus more effectively.</p>\n\n<p>We evaluate these questions by building 28 language models across\ndevelopers, time periods, and applications within Microsoft Office\nand present the results in this paper. We find that developer and\napplication specific language models perform better than models\nfrom the entire codebase, but that temporality has little to no effect\non language model performance.</p>\n", "tags": ["language model"], "tsne_embedding": [0.8410394787788391, 4.942623615264893]}, {"key": "sarkar2022what", "year": "2022", "title": "What is it like to program with artificial intelligence?", "abstract": "<p>Large language models, such as OpenAI\u2019s codex and Deepmind\u2019s AlphaCode, can generate code to solve a variety of problems expressed in natural language. This technology has already been commercialised in at least one widely-used programming editor extension: GitHub Copilot.</p>\n\n<p>In this paper, we explore how programming with large language models (LLM-assisted programming) is similar to, and differs from, prior conceptualisations of programmer assistance. We draw upon publicly available experience reports of LLM-assisted programming, as well as prior usability and design studies. We find that while LLM-assisted programming shares some properties of compilation, pair programming, and programming via search and reuse, there are fundamental differences both in the technical possibilities as well as the practical experience. Thus, LLM-assisted programming ought to be viewed as a new way of programming with its own distinct properties and challenges.</p>\n\n<p>Finally, we draw upon observations from a user study in which non-expert end user programmers use LLM-assisted tools for solving data tasks in spreadsheets. We discuss the issues that might arise, and open research challenges, in applying large language models to end-user programming, particularly with users who have little or no programming expertise.</p>\n", "tags": ["human evaluation", "review"], "tsne_embedding": [21.341331481933594, 12.067445755004883]}, {"key": "schrouff2019inferring", "year": "2019", "title": "Inferring Javascript types using Graph Neural Networks", "abstract": "<p>The recent use of `Big Code\u2019 with state-of-the-art deep learning methods offers promising avenues to ease program source code writing and correction. As a first step towards automatic code repair, we implemented a graph neural network model that predicts token types for Javascript programs. The predictions achieve an accuracy above 90%, which improves on previous similar work.</p>\n", "tags": ["GNN", "types", "program analysis"], "tsne_embedding": [-8.844036102294922, -9.60936164855957]}, {"key": "schuster2021you", "year": "2021", "title": "You Autocomplete Me: Poisoning Vulnerabilities in Neural Code Completion", "abstract": "<p>Code autocompletion is an integral feature of modern code editors and IDEs. The latest generation of autocompleters uses neural language models, trained on public open-source code repositories, to suggest likely (not just statically feasible) completions given the current context.</p>\n\n<p>We demonstrate that neural code autocompleters are vulnerable to poisoning attacks. By adding a few specially-crafted files to the autocompleter\u2019s training corpus (data poisoning), or else by directly fine-tuning the autocompleter on these files (model poisoning), the attacker can influence its suggestions for attacker-chosen contexts. For example, the attacker can \u201cteach\u201d the autocompleter to suggest the insecure ECB mode for AES encryption, SSLv3 for the SSL/TLS protocol version, or a low iteration count for password-based encryption. Moreover, we show that these attacks can be targeted: an autocompleter poisoned by a targeted attack is much more likely to suggest the insecure completion for files from a specific repo or specific developer.</p>\n\n<p>We quantify the efficacy of targeted and untargeted data- and model-poisoning attacks against state-of-the-art autocompleters based on Pythia and GPT-2. We then evaluate existing defenses against poisoning attacks and show that they are largely ineffective.</p>\n", "tags": ["autocomplete", "adversarial"], "tsne_embedding": [4.066268444061279, 20.378122329711914]}, {"key": "sharma2015nirmal", "year": "2015", "title": "NIRMAL: Automatic Identification of Software Relevant Tweets Leveraging Language Model", "abstract": "<p>Twitter is one of the most widely used social media\nplatforms today. It enables users to share and view short 140-character messages called \u201ctweets\u201d. About 284 million active\nusers generate close to 500 million tweets per day. Such rapid\ngeneration of user generated content in large magnitudes results\nin the problem of information overload. Users who are interested\nin information related to a particular domain have limited means\nto filter out irrelevant tweets and tend to get lost in the huge\namount of data they encounter. A recent study by Singer et\nal. found that software developers use Twitter to stay aware of\nindustry trends, to learn from others, and to network with other\ndevelopers. However, Singer et al. also reported that developers\noften find Twitter streams to contain too much noise which is a\nbarrier to the adoption of Twitter. In this paper, to help developers\ncope with noise, we propose a novel approach named NIRMAL,\nwhich automatically identifies software relevant tweets from a\ncollection or stream of tweets. Our approach is based on language\nmodeling which learns a statistical model based on a training\ncorpus (i.e., set of documents). We make use of a subset of posts\nfrom StackOverflow, a programming question and answer site, as\na training corpus to learn a language model. A corpus of tweets\nwas then used to test the effectiveness of the trained language\nmodel. The tweets were sorted based on the rank the model\nassigned to each of the individual tweets. The top 200 tweets\nwere then manually analyzed to verify whether they are software\nrelated or not, and then an accuracy score was calculated. The\nresults show that decent accuracy scores can be achieved by\nvarious variants of NIRMAL, which indicates that NIRMAL can\neffectively identify software related tweets from a huge corpus of\ntweets.</p>\n", "tags": ["information extraction"], "tsne_embedding": [-10.412135124206543, 3.0921876430511475]}, {"key": "sharma2019feasibility", "year": "2019", "title": "On the Feasibility of Transfer-learning Code Smells using Deep Learning", "abstract": "<p><strong>Context</strong>: A substantial amount of work has been done to detect smells in source code using metrics-based and heuristics-based methods. Machine learning methods have been recently applied to detect source code smells; however, the current practices are considered far from mature.</p>\n\n<p><strong>Objective</strong>: First, explore the feasibility of applying deep learning models to detect smells without extensive feature engineering, just by feeding the source code in tokenized form. Second, investigate the possibility of applying transfer-learning in the context of deep learning models for smell detection.</p>\n\n<p><strong>Method</strong>: We use existing metric-based state-of-the-art methods for detecting three implementation smells and one design smell in C# code. Using these results as the annotated gold standard, we train smell detection models on three different deep learning architectures. These architectures use Convolution Neural Networks (CNNs) of one or two dimensions, or Recurrent Neural Networks (RNNs) as their principal hidden layers. For the first objective of our study, we perform training and evaluation on C# samples, whereas for the second objective, we train the models from C# code and evaluate the models over Java code samples. We perform the experiments with various combinations of hyper-parameters for each model.</p>\n\n<p><strong>Results</strong>: We find it feasible to detect smells using deep learning methods. Our comparative experiments find that there is no clearly superior method between CNN-1D and CNN-2D. We also observe that performance of the deep learning models is smell-specific. Our transfer-learning experiments show that transfer-learning is definitely feasible for implementation smells with performance comparable to that of direct-learning. This work opens up a new paradigm to detect code smells by transfer-learning especially for the programming languages where the comprehensive code smell detection tools are not available.</p>\n", "tags": ["representation", "program analysis"], "tsne_embedding": [-12.747687339782715, -7.489238739013672]}, {"key": "sharma2022exploratory", "year": "2022", "title": "An Exploratory Study on Code Attention in BERT", "abstract": "<p>Many recent models in software engineering introduced deep neural models based on the Transformer architecture or use transformer-based Pre-trained Language Models (PLM) trained on code. Although these models achieve the state of the arts results in many downstream tasks such as code summarization and bug detection, they are based on Transformer and PLM, which are mainly studied in the Natural Language Processing (NLP) field. The current studies rely on the reasoning and practices from NLP for these models in code, despite the differences between natural languages and programming languages. There is also limited literature on explaining how code is modeled. Here, we investigate the attention behavior of PLM on code and compare it with natural language. We pre-trained BERT, a Transformer based PLM, on code and explored what kind of information it learns, both semantic and syntactic. We run several experiments to analyze the attention values of code constructs on each other and what BERT learns in each layer. Our analyses show that BERT pays more attention to syntactic entities, specifically identifiers and separators, in contrast to the most attended token [CLS] in NLP. This observation motivated us to leverage identifiers to represent the code sequence instead of the [CLS] token when used for code clone detection. Our results show that employing embeddings from identifiers increases the performance of BERT by 605% and 4% F1-score in its lower layers and the upper layers, respectively. When identifiers\u2019 embeddings are used in CodeBERT, a code-based PLM, the performance is improved by 21\u201324% in the F1-score of clone detection. The findings can benefit the research community by using code-specific representations instead of applying the common embeddings used in NLP, and open new directions for developing smaller models with similar performance.</p>\n\n", "tags": ["Transformer", "representation", "language model", "interpretability", "pretraining", "clone"], "tsne_embedding": [5.510731220245361, 0.9697679281234741]}, {"key": "sharma2022lamner", "year": "2022", "title": "LAMNER: Code Comment Generation Using Character Language Model and Named Entity Recognition", "abstract": "<p>Code comment generation is the task of generating a high-level natural language description for a given code method/function. Although researchers have been studying multiple ways to generate code comments automatically, previous work mainly considers representing a code token in its entirety semantics form only (e.g., a language model is used to learn the semantics of a code token), and additional code properties such as the tree structure of a code are included as an auxiliary input to the model. There are two limitations: 1) Learning the code token in its entirety form may not be able to capture information succinctly in source code, and 2)The code token does not contain additional syntactic information, inherently important in programming languages. In this paper, we present LAnguage Model and Named Entity Recognition (LAMNER), a code comment generator capable of encoding code constructs effectively and capturing the structural property of a code token. A character-level language model is used to learn the semantic representation to encode a code token. For the structural property of a token, a Named Entity Recognition model is trained to learn the different types of code tokens. These representations are then fed into an encoder-decoder architecture to generate code comments. We evaluate the generated comments from LAMNER and other baselines on a popular Java dataset with four commonly used metrics. Our results show that LAMNER is effective and improves over the best baseline model in BLEU-1, BLEU-2, BLEU-3, BLEU-4, ROUGE-L, METEOR, and CIDEr by 14.34%, 18.98%, 21.55%, 23.00%, 10.52%, 1.44%, and 25.86%, respectively. Additionally, we fused LAMNER\u2019s code representation with the baseline models, and the fused models consistently showed improvement over the nonfused models. The human evaluation further shows that LAMNER produces high-quality code comments.</p>\n\n", "tags": ["summarization", "documentation", "language model", "types", "representation"], "tsne_embedding": [3.051729679107666, 2.7005789279937744]}, {"key": "she2019neuzz", "year": "2019", "title": "NEUZZ: Efficient Fuzzing with Neural Program Smoothing", "abstract": "<p>Fuzzing has become the de facto standard technique for finding software vulnerabilities. However, even state-of-the-art fuzzers are not very efficient at finding hard-to-trigger software bugs. Most popular fuzzers use evolutionary guidance to generate inputs that can trigger different bugs. Such evolutionary algorithms, while fast and simple to implement, often get stuck in fruitless sequences of random mutations. Gradient-guided optimization presents a promising alternative to evolutionary guidance. Gradient-guided techniques have been shown to significantly outperform evolutionary algorithms at solving high-dimensional structured optimization problems in domains like machine learning by efficiently utilizing gradients or higher-order derivatives of the underlying function. However, gradient-guided approaches are not directly applicable to fuzzing as real-world program behaviors contain many discontinuities, plateaus, and ridges where the gradient-based methods often get stuck. We observe that this problem can be addressed by creating a smooth surrogate function approximating the discrete branching behavior of target program. In this paper, we propose a novel program smoothing technique using surrogate neural network models that can incrementally learn smooth approximations of a complex, real-world program\u2019s branching behaviors. We further demonstrate that such neural network models can be used together with gradient-guided input generation schemes to significantly improve the fuzzing efficiency. Our extensive evaluations demonstrate that NEUZZ significantly outperforms 10 state-of-the-art graybox fuzzers on 10 real-world programs both at finding new bugs and achieving higher edge coverage. NEUZZ found 31 unknown bugs that other fuzzers failed to find in 10 real world programs and achieved 3X more edge coverage than all of the tested graybox fuzzers for 24 hours running.</p>\n", "tags": ["fuzzing"], "tsne_embedding": [10.31407642364502, 20.61380386352539]}, {"key": "shi2019learning", "year": "2019", "title": "Learning Execution through Neural Code Fusion", "abstract": "<p>As the performance of computer systems stagnates due to the end of Moore\u2019s Law, there is a need for new models that can understand and optimize the execution of general purpose code. While there is a growing body of work on using Graph Neural Networks (GNNs) to learn representations of source code, these representations do not understand how code dynamically executes. In this work, we propose a new approach to use GNNs to learn fused representations of general source code and its execution. Our approach defines a multi-task GNN over low-level representations of source code and program state (i.e., assembly code and dynamic memory states), converting complex source code constructs and complex data structures into a simpler, more uniform format. We show that this leads to improved performance over similar methods that do not use execution and it opens the door to applying GNN models to new tasks that would not be feasible from static code alone. As an illustration of this, we apply the new model to challenging dynamic tasks (branch prediction and prefetching) from the SPEC CPU benchmark suite, outperforming the state-of-the-art by 26% and 45% respectively. Moreover, we use the learned fused graph embeddings to demonstrate transfer learning with high performance on an indirectly related task (algorithm classification).</p>\n", "tags": ["representation"], "tsne_embedding": [-3.7980120182037354, -7.192282676696777]}, {"key": "shi2022cv4code", "year": "2022", "title": "CV4Code: Sourcecode Understanding via Visual Code Representations", "abstract": "<p>We present CV4Code, a compact and effective computer vision method for sourcecode understanding. Our method leverages the contextual and the structural information available from the code snippet by treating each snippet as a two-dimensional image, which naturally encodes the context and retains the underlying structural information through an explicit spatial representation. To codify snippets as images, we propose an ASCII codepoint-based image representation that facilitates fast generation of sourcecode images and eliminates redundancy in the encoding that would arise from an RGB pixel representation. Furthermore, as sourcecode is treated as images, neither lexical analysis (tokenisation) nor syntax tree parsing is required, which makes the proposed method agnostic to any particular programming language and lightweight from the application pipeline point of view. CV4Code can even featurise syntactically incorrect code which is not possible from methods that depend on the Abstract Syntax Tree (AST). We demonstrate the effectiveness of CV4Code by learning Convolutional and Transformer networks to predict the functional task, i.e. the problem it solves, of the source code directly from its two-dimensional representation, and using an embedding from its latent space to derive a similarity score of two code snippets in a retrieval setup. Experimental results show that our approach achieves state-of-the-art performance in comparison to other methods with the same task and data configurations. For the first time we show the benefits of treating sourcecode understanding as a form of image processing task.</p>\n", "tags": ["code similarity", "Transformer"], "tsne_embedding": [-3.2343239784240723, -0.6718637943267822]}, {"key": "shido2019automatic", "year": "2019", "title": "Automatic Source Code Summarization with Extended Tree-LSTM", "abstract": "<p>Neural machine translation models are used to automatically generate a document from given source code since this can be regarded as a machine translation task. Source code summarization is one of the components for automatic document generation, which generates a summary in natural language from given source code. This suggests that techniques used in neural machine translation, such as Long Short-Term Memory (LSTM), can be used for source code summarization. However, there is a considerable difference between source code and natural language: Source code is essentially structured, having loops and conditional branching, etc. Therefore, there is some obstacle to apply known machine translation models to source code.Abstract syntax trees (ASTs) capture these structural properties and play an important role in recent machine learning studies on source code. Tree-LSTM is proposed as a generalization of LSTMs for tree-structured data. However, there is a critical issue when applying it to ASTs: It cannot handle a tree that contains nodes having an arbitrary number of children and their order simultaneously, which ASTs generally have such nodes. To address this issue, we propose an extension of Tree-LSTM, which we call Multi-way Tree-LSTM and apply it for source code summarization. As a result of computational experiments, our proposal achieved better results when compared with several state-of-the-art techniques.</p>\n", "tags": ["summarization", "grammar"], "tsne_embedding": [9.004355430603027, -7.5394206047058105]}, {"key": "shirani2018evaluation", "year": "2018", "title": "Evaluation of Type Inference with Textual Cues", "abstract": "<p>Type information plays an important role in the success of information retrieval and recommendation systems in software\nengineering. Thus, the absence of types in dynamically-typed\nlanguages poses a challenge to adapt these systems to support\ndynamic languages.</p>\n\n<p>In this paper, we explore the viability of type inference using\ntextual cues.  That is, we formulate the type inference problem as a classification problem which uses the textual features\nin  the  source  code  to  predict  the type  of  variables.   In  this\napproach, a classifier learns a model to distinguish between\ntypes of variables in a program.  The model is subsequently\nused to (approximately) infer the types of other variables.</p>\n\n<p>We  evaluate  the  feasibility  of  this  approach  on  four  Java\nprojects wherein type information is already available in the\nsource code and can be used to train and test a classifier. Our\nexperiments show this approach can predict the type of new\nvariables  with  relatively  high  accuracy  (80% F-measure).\nThese results suggest that textual cues can be\ncomplementary\ntools in inferring types for dynamic languages.</p>\n", "tags": ["information extraction"], "tsne_embedding": [-2.6426942348480225, 22.06764793395996]}, {"key": "shrivastava2020on-the-fly", "year": "2020", "title": "On-the-Fly Adaptation of Source Code Models using Meta-Learning", "abstract": "<p>The ability to adapt to unseen, local contexts is an important challenge that successful models of source code must overcome. One of the most popular approaches for the adaptation of such models is dynamic evaluation. With dynamic evaluation, when running a model on an unseen file, the model is updated immediately after having observed each token in that file. In this work, we propose instead to frame the problem of context adaptation as a meta-learning problem. We aim to train a base source code model that is best able to learn from information in a file to deliver improved predictions of missing tokens. Unlike dynamic evaluation, this formulation allows us to select more targeted information (support tokens) for adaptation, that is both before and after a target hole in a file. We consider an evaluation setting that we call line-level maintenance, designed to reflect the downstream task of code auto-completion in an IDE. Leveraging recent developments in meta-learning such as first-order MAML and Reptile, we demonstrate improved performance in experiments on a large scale Java GitHub corpus, compared to other adaptation baselines including dynamic evaluation. Moreover, our analysis shows that, compared to a non-adaptive baseline, our approach improves performance on identifiers and literals by 44% and 15%, respectively.</p>\n", "tags": ["language model", "autocomplete"], "tsne_embedding": [7.335419654846191, 9.284812927246094]}, {"key": "shrivastava2020repository", "year": "2022", "title": "Repository-Level Prompt Generation for Large Language Models of Code", "abstract": "<p>With the success of large language models (LLMs) of code and their use as code assistants (e.g. Codex used in GitHub Copilot), techniques for introducing domain-specific knowledge in the prompt design process become important. In this work, we propose a framework called Repo-Level Prompt Generator that learns to generate example-specific prompts using a set of rules. These rules take context from the entire repository, thereby incorporating both the structure of the repository and the context from other relevant files (e.g. imports, parent class files). Our technique doesn\u2019t require any access to the weights of the LLM, making it applicable in cases where we only have black-box access to the LLM. We conduct experiments on the task of single-line code-autocompletion using code repositories taken from Google Code archives. We demonstrate that an oracle constructed from our proposed rules gives up to 36% relative improvement over Codex, showing the quality of the rules. Further, we show that when we train a model to select the best rule, we can achieve significant performance gains over Codex. The code for our work can be found at: https://github.com/shrivastavadisha/repo_level_prompt_generation .</p>\n", "tags": ["Transformer", "code completion"], "tsne_embedding": [14.844765663146973, 8.66519546508789]}, {"key": "shuai2020improving", "year": "2020", "title": "Improving Code Search with Co-Attentive Representation Learning", "abstract": "<p>Searching and reusing existing code from a large-scale codebase, e.g, GitHub, can help developers complete a programming task efficiently. Recently, Gu et al. proposed a deep learning-based model (i.e., DeepCS), which significantly outperformed prior models. The DeepCS embedded codebase and natural language queries into vectors by two LSTM (long and short-term memory) models separately, and returned developers the code with higher similarity to a code search query. However, such embedding method learned two isolated representations for code and query but ignored their internal semantic correlations. As a result, the learned isolated representations of code and query may limit the effectiveness of code search.</p>\n\n<p>To address the aforementioned issue, we propose a co-attentive representation learning model, i.e., Co-Attentive Representation Learning Code Search-CNN (CARLCS-CNN). CARLCS-CNN learns interdependent representations for the embedded code and query with a co-attention mechanism. Generally, such mechanism learns a correlation matrix between embedded code and query, and co-attends their semantic relationship via row/column-wise max-pooling. In this way, the semantic correlation between code and query can directly affect their individual representations. We evaluate the effectiveness of CARLCS-CNN on Gu et al.\u2019s dataset with 10k queries. Experimental results show that the proposed CARLCS-CNN model significantly outperforms DeepCS by 26.72% in terms of MRR (mean reciprocal rank). Additionally, CARLCS-CNN is five times faster than DeepCS in model training and four times in testing.</p>\n", "tags": ["search"], "tsne_embedding": [-17.203208923339844, 5.988607406616211]}, {"key": "si2018learning", "year": "2018", "title": "Learning Loop Invariants for Program Verification", "abstract": "<p>A fundamental problem in program verification concerns inferring loop invariants.\nThe problem is undecidable and even practical instances are challenging. Inspired\nby how human experts construct loop invariants, we propose a reasoning framework\nCODE2INV\nthat constructs the solution by multi-step decision making and querying\nan external program graph memory block. By training with reinforcement learning,\nCODE2INV\ncaptures rich program features and avoids the need for ground truth\nsolutions as supervision.  Compared to previous learning tasks in domains with\ngraph-structured data, it addresses unique challenges, such as a binary objective\nfunction and an extremely sparse reward that is given by an automated theorem\nprover only after the complete loop invariant is proposed. We evaluate\nCODE2INV on\na suite of 133 benchmark problems and compare it to three state-of-the-art systems.\nIt solves 106 problems compared to 73 by a stochastic search-based system, 77 by\na heuristic search-based system, and 100 by a decision tree learning-based system.\nMoreover, the strategy learned can be generalized to new programs: compared to\nsolving new instances from scratch, the pre-trained agent is more sample efficient\nin finding solutions.</p>\n", "tags": ["program analysis", "verification"], "tsne_embedding": [13.703612327575684, 19.40104866027832]}, {"key": "silavong2022senatus", "year": "2022", "title": "Senatus - A Fast and Accurate Code-to-Code Recommendation Engine", "abstract": "<p>Machine learning on source code (MLOnCode) is a popular research field that has been driven by the availability of large-scale code repositories and the development of powerful probabilistic and deep learning models for mining source code. Code-to-code recommendation is a task in MLOnCode that aims to recommend relevant, diverse and concise code snippets that usefully extend the code currently being written by a developer in their development environment (IDE). Code-to-code recommendation engines hold the promise of increasing developer productivity by reducing context switching from the IDE and increasing code-reuse. Existing code-to-code recommendation engines do not scale gracefully to large codebases, exhibiting a linear growth in query time as the code repository increases in size. In addition, existing code-to-code recommendation engines fail to account for the global statistics of code repositories in the ranking function, such as the distribution of code snippet lengths, leading to sub-optimal retrieval results. We address both of these weaknesses with Senatus, a new code-to-code recommendation engine. At the core of Senatus is De-Skew LSH a new locality sensitive hashing (LSH) algorithm that indexes the data for fast (sub-linear time) retrieval while also counteracting the skewness in the snippet length distribution using novel abstract syntax tree-based feature scoring and selection algorithms. We evaluate Senatus and find the recommendations to be of higher quality than competing baselines, while achieving faster search. For example on the CodeSearchNet dataset Senatus improves performance by 31.21% F1 and  147.9x faster query time compared to Facebook Aroma. Senatus also outperforms standard MinHash LSH by 29.2% F1 and 51.02x faster query time.</p>\n", "tags": ["code similarity", "search"], "tsne_embedding": [-12.259528160095215, 8.589091300964355]}, {"key": "singh2016question", "year": "2016", "title": "Question Independent Grading using Machine Learning: The Case of Computer Program Grading", "abstract": "<p>Learning supervised models to grade open-ended responses is an expensive process. A model has to be trained for every prompt/question separately, which in turn requires graded samples. In automatic programming evaluation specifically, the focus of this work, this issue is amplified. The models have to be trained not only for every question but also for every language the question is offered in. Moreover, the availability and time taken by experts to create a labeled set of programs for each question is a major bottleneck in scaling such a system. We address this issue by presenting a method to grade computer programs which requires no manually assigned labeled samples for grading responses to a new, unseen question. We extend our previous work (by Srikant, Aggarwal; KDD 2014) wherein we introduced a grammar of features to learn question specific models. In this work, we propose a method to transform those features into a set of features that maintain their structural relation with the labels across questions. Using these features we learn one supervised model, across questions for a given language, which can then be applied to an ungraded response to an unseen question. We show that our method rivals the performance of both, question specific models and the consensus among human experts while substantially outperforming extant ways of evaluating codes. We demonstrate the system single s value by deploying it to grade programs in a high stakes assessment. The learning from this work is transferable to other grading tasks such as math question grading and also provides a new variation to the supervised learning approach.</p>\n", "tags": ["education"], "tsne_embedding": [19.995769500732422, 20.385719299316406]}, {"key": "siow2019core", "year": "2019", "title": "CORE: Automating Review Recommendation for Code Changes", "abstract": "<p>Code review is a common process that is used by developers, in which a reviewer provides useful comments or points out defects in the submitted source code changes via pull request. Code review has been widely used for both industry and open-source projects due to its capacity in early defect identification, project maintenance, and code improvement. With rapid updates on project developments, code review becomes a non-trivial and labor-intensive task for reviewers. Thus, an automated code review engine can be beneficial and useful for project development in practice. Although there exist prior studies on automating the code review process by adopting static analysis tools or deep learning techniques, they often require external sources such as partial or full source code for accurate review suggestion. In this paper, we aim at automating the code review process only based on code changes and the corresponding reviews but with better performance. The hinge of accurate code review suggestion is to learn good representations for both code changes and reviews. To achieve this with limited source, we design a multi-level embedding (i.e., word embedding and character embedding) approach to represent the semantics provided by code changes and reviews. The embeddings are then well trained through a proposed attentional deep learning model, as a whole named CORE. We evaluate the effectiveness of CORE on code changes and reviews collected from 19 popular Java projects hosted on Github. Experimental results show that our model CORE can achieve significantly better performance than the state-of-the-art model (DeepMem), with an increase of 131.03% in terms of Recall@10 and 150.69% in terms of Mean Reciprocal Rank. Qualitative general word analysis among project developers also demonstrates the performance of CORE in automating code review.</p>\n", "tags": ["review"], "tsne_embedding": [-0.9766830205917358, -13.308921813964844]}, {"key": "siow2022learning", "year": "2022", "title": "Learning Program Semantics with Code Representations: An Empirical Study", "abstract": "<p>Program semantics learning is the core and fundamental for various code intelligent tasks e.g., vulnerability detection, clone detection. A considerable amount of existing works propose diverse approaches to learn the program semantics for different tasks and these works have achieved state-of-the-art performance. However, currently, a comprehensive and systematic study on evaluating different program representation techniques across diverse tasks is still missed.</p>\n\n<p>From this starting point, in this paper, we conduct an empirical study to evaluate different program representation techniques. Specifically, we categorize current mainstream code representation techniques into four categories i.e., Feature-based, Sequence-based, Tree-based, and Graph-based program representation technique and evaluate its performance on three diverse and popular code intelligent tasks i.e., {Code Classification}, Vulnerability Detection, and Clone Detection on the public released benchmark. We further design three {research questions (RQs)} and conduct a comprehensive analysis to investigate the performance. By the extensive experimental results, we conclude that (1) The graph-based representation is superior to the other selected techniques across these tasks. (2) Compared with the node type information used in tree-based and graph-based representations, the node textual information is more critical to learning the program semantics. (3) Different tasks require the task-specific semantics to achieve their highest performance, however combining various program semantics from different dimensions such as control dependency, data dependency can still produce promising results.</p>\n", "tags": ["representation"], "tsne_embedding": [-11.241206169128418, -8.980058670043945]}, {"key": "sivaraman2021mining", "year": "2021", "title": "Mining Idioms in the Wild", "abstract": "<p>Existing code repositories contain numerous instances of code patterns that are idiomatic ways of accomplishing a particular programming task. Sometimes, the programming language in use supports specific operators or APIs that can express the same idiomatic imperative code much more succinctly. However, those code patterns linger in repositories because the developers may be unaware of the new APIs or have not gotten around to them. Detection of idiomatic code can also point to the need for new APIs.</p>\n\n<p>We share our experiences in mine idiomatic patterns from the Hack repo at Facebook. We found that existing techniques either cannot identify meaningful patterns from syntax trees or require test-suite-based dynamic analysis to incorporate semantic properties to mine useful patterns. The key insight of the approach proposed in this paper \u2013 Jezero \u2013 is that semantic idioms from a large codebase can be learned from canonicalized dataflow trees. We propose a scalable, lightweight static analysis-based approach to construct such a tree that is well suited to mine semantic idioms using nonparametric Bayesian methods.</p>\n\n<p>Our experiments with Jezero on Hack code shows a clear advantage of adding canonicalized dataflow information to ASTs: Jezero was significantly more effective than a baseline that did not have the dataflow augmentation in being able to effectively find refactoring opportunities from unannotated legacy code.</p>\n", "tags": ["pattern mining", "refactoring"], "tsne_embedding": [-6.288936614990234, 12.289414405822754]}, {"key": "souza2023lexecutor", "year": "2023", "title": "LExecutor: Learning-Guided Execution", "abstract": "<p>Executing code is essential for various program analysis tasks, e.g., to detect bugs that manifest through exceptions or to obtain execution traces for further dynamic analysis. However, executing an arbitrary piece of code is often difficult in practice, e.g., because of missing variable definitions, missing user inputs, and missing third-party dependencies. This paper presents LExecutor, a learning-guided approach for executing arbitrary code snippets in an underconstrained way. The key idea is to let a neural model predict missing values that otherwise would cause the program to get stuck, and to inject these values into the execution. For example, LExecutor injects likely values for otherwise undefined variables and likely return values of calls to otherwise missing functions. We evaluate the approach on Python code from popular open-source projects and on code snippets extracted from Stack Overflow. The neural model predicts realistic values with an accuracy between 80.1% and 94.2%, allowing LExecutor to closely mimic real executions. As a result, the approach successfully executes significantly more code than any available technique, such as simply executing the code as-is. For example, executing the open-source code snippets as-is covers only 4.1% of all lines, because the code crashes early on, whereas LExecutor achieves a coverage of 50.1%.</p>\n\n", "tags": ["execution"], "tsne_embedding": [9.521234512329102, 15.90025806427002]}, {"key": "spirin2021psiminer", "year": "2021", "title": "PSIMiner: A Tool for Mining Rich Abstract Syntax Trees from Code", "abstract": "<p>The application of machine learning algorithms to source code has grown in the past years. Since these algorithms are quite sensitive to input data, it is not surprising that researchers experiment with input representations. Nowadays, a popular starting point to represent code is abstract syntax trees (ASTs). Abstract syntax trees have been used for a long time in various software engineering domains, and in particular in IDEs. The API of modern IDEs allows to manipulate and traverse ASTs, resolve references between code elements, etc. Such algorithms can enrich ASTs with new data and therefore may be useful in ML-based code analysis. In this work, we present PSIMINER\u2014 a tool for processing PSI trees from the IntelliJ Platform. PSI trees contain code syntax trees as well as functions to work with them, and therefore can be used to enrich code representation using static analysis algorithms of modern IDEs. To showcase this idea, we use our tool to infer types of identifiers in Java ASTs and extend the code2seq model for the method name prediction problem.</p>\n", "tags": ["tool"], "tsne_embedding": [-3.773561954498291, 14.42540168762207]}, {"key": "srikant2014system", "year": "2014", "title": "A system to grade computer programming skills using machine learning", "abstract": "<p>The automatic evaluation of computer programs is a nascent area of research with a potential for large-scale impact. Extant program assessment systems score mostly based on the number of test-cases passed, providing no insight into the competency of the programmer. In this paper, we present a system to grade computer programs automatically. In addition to grading a program on its programming practices and complexity, the key kernel of the system is a machine-learning based algorithm which determines closeness of the logic of the given program to a correct program. This algorithm uses a set of highly-informative features, derived from the abstract representations of a given program, that capture the program\u2019s functionality. These features are then used to learn a model to grade the programs, which are built against evaluations done by experts. We show that the regression models provide much better grading than the ubiquitous test-case-pass based grading and rivals the grading accuracy of other open-response problems such as essay grading . We also show that our novel features add significant value over and above basic keyword/expression count features. In addition to this, we propose a novel way of posing computer-program grading as a one-class modeling problem and report encouraging preliminary results. We show the value of the system through a case study in a real-world industrial deployment. To the best of the authors\u2019 knowledge, this is the first time a system using machine learning has been developed and used for grading programs. The work is timely with regard to the recent boom in Massively Online Open Courseware (MOOCs), which promises to produce a significant amount of hand-graded digitized data.</p>\n", "tags": ["education"], "tsne_embedding": [20.367488861083984, 20.42328643798828]}, {"key": "sun2019grammar", "year": "2019", "title": "A Grammar-Based Structural CNN Decoder for Code Generation", "abstract": "<p>Code  generation  maps  a  program  description  to  executable\nsource code in a programming language. Existing approaches\nmainly rely on a recurrent neural network (RNN) as the decoder. However, we find that a program contains significantly\nmore tokens than a natural language sentence, and thus it may\nbe inappropriate for RNN to capture such a long sequence. In\nthis paper, we propose a grammar-based structural convolutional neural network (CNN) for code generation. Our model\ngenerates a program by predicting the grammar rules of the\nprogramming language; we design several CNN modules, including the tree-based convolution and pre-order convolution,\nwhose information is further aggregated by dedicated attentive pooling layers. Experimental results on the HearthStone\nbenchmark dataset show that our CNN code generator significantly outperforms the previous state-of-the-art method by 5\npercentage points; additional experiments on several semantic parsing tasks demonstrate the robustness of our model. We\nalso conduct in-depth ablation test to better understand each\ncomponent of our model.</p>\n", "tags": ["code generation", "grammar"], "tsne_embedding": [13.106813430786133, -5.579643249511719]}, {"key": "sun2020pscs", "year": "2020", "title": "PSCS: A Path-based Neural Model for Semantic Code Search", "abstract": "<p>To obtain code snippets for reuse, programmers prefer to search for related documents, e.g., blogs or Q&amp;A, instead of code itself. The major reason is due to the semantic diversity and mismatch between queries and code snippets. Deep learning models have been proposed to address this challenge. Compared with approaches using information retrieval techniques, deep learning models do not suffer from the information loss caused by refining user intention into keywords. However, the performance of previous works is not satisfactory because they ignore the importance of code structure. When the semantics of code (e.g., identifier names, APIs) are ambiguous, code structure may be the only feature for the model to utilize. In that case, previous works relearn the structural information from lexical tokens of code, which is extremely difficult for a model without any domain knowledge. In this work, we propose PSCS, a path-based neural model for semantic code search. Our model encodes both the semantics and structures of code represented by AST paths. We train and evaluate our model over 330k-19k query-function pairs, respectively. The evaluation results demonstrate that PSCS achieves a SuccessRate of 47.6% and a Mean Reciprocal Rank (MRR) of 30.4% when considering the top-10 results with a match. The proposed approach significantly outperforms both DeepCS, the first approach that applies deep learning to code search task, and CARLCS, a state-of-the-art approach that introduces a co-attentive representation learning model on the basis of DeepCS. The importance of code structure is demonstrated with an ablation study on code features, which enlightens model design for further studies.</p>\n", "tags": ["grammar", "search"], "tsne_embedding": [-17.370162963867188, 6.222411155700684]}, {"key": "svyatkovskiy2019pythia", "year": "2019", "title": "Pythia: AI-assisted Code Completion System", "abstract": "<p>In this paper, we propose a novel end-to-end approach for AI-assisted code completion called Pythia. It generates ranked lists of method and API recommendations which can be used by software developers at edit time. The system is currently deployed as part of Intellicode extension in Visual Studio Code IDE. Pythia exploits state-of-the-art large-scale deep learning models trained on code contexts extracted from abstract syntax trees. It is designed to work at a high throughput predicting the best matching code completions on the order of 100 ms.</p>\n\n<p>We describe the architecture of the system, perform comparisons to frequency-based approach and invocation-based Markov Chain language model, and discuss challenges serving Pythia models on lightweight client devices.</p>\n\n<p>The offline evaluation results obtained on 2700 Python open source software GitHub repositories show a top-5 accuracy of 92%, surpassing the baseline models by 20% averaged over classes, for both intra and cross-project settings.</p>\n\n", "tags": ["autocomplete", "language model"], "tsne_embedding": [4.536182403564453, 9.311846733093262]}, {"key": "svyatkovskiy2020fast", "year": "2020", "title": "Fast and Memory-Efficient Neural Code Completion", "abstract": "<p>Code completion is one of the most widely used features of modern integrated development environments (IDEs). Deep learning has recently made significant progress in the statistical prediction of source code. However, state-of-the-art neural network models consume prohibitively large amounts of memory, causing computational burden to the development environment, especially when deployed in lightweight client devices.</p>\n\n<p>In this work, we reframe neural code completion from a generation task to a task of learning to rank the valid completion suggestions computed from static analyses. By doing so, we are able to design and test a variety of deep neural network model configurations. One of our best models consumes 6 MB of RAM, computes a single suggestion in 8 ms, and achieves 90% recall in its top five suggestions. Our models outperform standard language modeling code completion techniques in terms of predictive performance, computational speed, and memory efficiency. Furthermore, they learn about code semantics from the natural language aspects of the code (e.g. identifier names) and can generalize better to previously unseen code.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [4.398614406585693, 9.923992156982422]}, {"key": "svyatkovskiy2020intellicode", "year": "2020", "title": "IntelliCode Compose: Code Generation Using Transformer", "abstract": "<p>In software development through integrated development environments (IDEs), code completion is one of the most widely used features. Nevertheless, majority of integrated development environments only support completion of methods and APIs, or arguments.\nIn this paper, we introduce IntelliCode Compose \u2212 a general-purpose multilingual code completion tool which is capable of predicting sequences of code tokens of arbitrary types, generating up to entire lines of syntactically correct code. It leverages state-of-the-art generative transformer model trained on 1.2 billion lines of source code in Python, C#, JavaScript and TypeScript programming languages. IntelliCode Compose is deployed as a cloud-based web service. It makes use of client-side tree-based caching, efficient parallel implementation of the beam search decoder, and compute graph optimizations to meet edit-time completion suggestion requirements in the Visual Studio Code IDE and Azure Notebook.\nOur best model yields an average edit similarity of 86.7% and a perplexity of 1.82 for Python programming language.</p>\n", "tags": ["autocomplete", "code generation", "synthesis", "language model", "pretraining"], "tsne_embedding": [2.729336977005005, 9.001118659973145]}, {"key": "szafraniec2022code", "year": "2022", "title": "Code Translation with Compiler Representations", "abstract": "<p>In this paper, we leverage low-level compiler intermediate representations (IR) to improve code translation. Traditional transpilers rely on syntactic information and handcrafted rules, which limits their applicability and produces unnatural-looking code. Applying neural machine translation (NMT) approaches to code has successfully broadened the set of programs on which one can get a natural-looking translation. However, they treat the code as sequences of text tokens, and still do not differentiate well enough between similar pieces of code which have different semantics in different languages. The consequence is low quality translation, reducing the practicality of NMT, and stressing the need for an approach significantly increasing its accuracy. Here we propose to augment code translation with IRs, specifically LLVM IR, with results on the C++, Java, Rust, and Go languages. Our method improves upon the state of the art for unsupervised code translation, increasing the number of correct translations by 11% on average, and up to 79% for the Java - Rust pair. We extend previous test sets for code translation, by adding hundreds of Go and Rust functions. Additionally, we train models with high performance on the problem of IR decompilation, generating programming source code from IR, and study using IRs as intermediary pivot for translation.</p>\n", "tags": ["Transformer", "migration", "decompilation"], "tsne_embedding": [12.039040565490723, 6.26022481918335]}, {"key": "tabassum2020code", "year": "2020", "title": "Code and Named Entity Recognition in StackOverflow", "abstract": "<p>There is an increasing interest in studying natural language and computer code together, as large corpora of programming texts become readily available on the Internet. For example, StackOverflow currently has over 15 million programming related questions written by 8.5 million users. Meanwhile, there is still a lack of fundamental NLP techniques for identifying code tokens or software-related named entities that appear within natural language sentences. In this paper, we introduce a new named entity recognition (NER) corpus for the computer programming domain, consisting of 15,372 sentences annotated with 20 fine-grained entity types. We trained in-domain BERT representations (BERTOverflow) on 152 million sentences from StackOverflow, which lead to an absolute increase of +10 F-1 score over off-the-shelf BERT. We also present the SoftNER model which achieves an overall 79.10 F1 score for code and named entity recognition on StackOverflow data. Our SoftNER model incorporates a context-independent code token classifier with corpus-level features to improve the BERT-based tagging model.</p>\n", "tags": ["dataset", "information extraction"], "tsne_embedding": [3.511122941970825, 3.655651807785034]}, {"key": "tarlow2019learning", "year": "2019", "title": "Learning to Fix Build Errors with Graph2Diff Neural Networks", "abstract": "<p>Professional software developers spend a significant amount oftime fixing builds, but this has received little attention as a prob-lem in automatic program repair. We present a new deep learningarchitecture, called Graph2Diff, for automatically localizing andfixing build errors. We represent source code, build configurationfiles, and compiler diagnostic messages as a graph, and then use aGraph Neural Network model to predict a diff. A diff specifies howto modify the code\u2019s abstract syntax tree, represented in the neuralnetwork as a sequence of tokens and of pointers to code locations.Our network is an instance of a more general abstraction which wecall Graph2Tocopo, which is potentially useful in any developmenttool for predicting source code changes. We evaluate the model ona dataset of over 500k real build errors and their resolutions fromprofessional developers. Compared to the approach of DeepDelta, our approach tackles the harder task of predicting a moreprecise diff but still achieves over double the accuracy.</p>\n", "tags": ["edit", "repair"], "tsne_embedding": [-3.214676856994629, -18.230199813842773]}, {"key": "theeten2019import2vec", "year": "2019", "title": "Import2vec - Learning Embeddings for Software Libraries", "abstract": "<p>We consider the problem of developing suitable learning representations (embeddings) for library packages that capture semantic similarity among libraries. Such representations are known to improve the performance of downstream learning tasks (e.g. classification) or applications such as contextual search and analogical reasoning.</p>\n\n<p>We apply word embedding techniques from natural language processing (NLP) to train embeddings for library packages (\u201clibrary vectors\u201d). Library vectors represent libraries by similar context of use as determined by import statements present in source code. Experimental results obtained from training such embeddings on three large open source software corpora reveals that library vectors capture semantically meaningful relationships among software libraries, such as the relationship between frameworks and their plug-ins and libraries commonly used together within ecosystems such as big data infrastructure projects (in Java), front-end and back-end web development frameworks (in JavaScript) and data science toolkits (in Python).</p>\n", "tags": ["representation"], "tsne_embedding": [-8.565142631530762, 4.093382835388184]}, {"key": "tian2020evaluating", "year": "2020", "title": "Evaluating Representation Learning of Code Changes for Predicting Patch Correctness in Program Repair", "abstract": "<p>A large body of the literature of automated program repair develops approaches where patches are generated to be validated against an oracle (e.g., a test suite). Because such an oracle can be imperfect, the generated patches, although validated by the oracle, may actually be incorrect. While the state of the art explore research directions that require dynamic information or rely on manually-crafted heuristics, we study the benefit of learning code representations to learn deep features that may encode the properties of patch correctness. Our work mainly investigates different representation learning approaches for code changes to derive embeddings that are amenable to similarity computations. We report on findings based on embeddings produced by pre-trained and re-trained neural networks. Experimental results demonstrate the potential of embeddings to empower learning algorithms in reasoning about patch correctness: a machine learning predictor with BERT transformer-based embeddings associated with logistic regression yielded an AUC value of about 0.8 in predicting patch correctness on a deduplicated dataset of 1000 labeled patches. Our study shows that learned representations can lead to reasonable performance when comparing against the state-of-the-art, PATCH-SIM, which relies on dynamic information. These representations may further be complementary to features that were carefully (manually) engineered in the literature.</p>\n", "tags": ["repair", "Transformer"], "tsne_embedding": [-5.5827155113220215, -17.923891067504883]}, {"key": "tomczak2019simulating", "year": "2019", "title": "Simulating Execution Time of Tensor Programs using Graph Neural Networks", "abstract": "<p>Optimizing the execution time of tensor program, e.g., a convolution, involves finding its optimal configuration. Searching the configuration space exhaustively is typically infeasible in practice. In line with recent research using TVM, we propose to learn a surrogate model to overcome this issue. The model is trained on an acyclic graph called an abstract syntax tree, and utilizes a graph convolutional network to exploit structure in the graph. We claim that a learnable graph-based data processing is a strong competitor to heuristic-based feature extraction. We present a new dataset of graphs corresponding to configurations and their execution time for various tensor programs. We provide baselines for a runtime prediction task.</p>\n", "tags": ["GNN"], "tsne_embedding": [11.045905113220215, -14.911345481872559]}, {"key": "tran2019recovering", "year": "2019", "title": "Recovering Variable Names for Minified Code with Usage Contexts", "abstract": "<p>In modern Web technology, JavaScript (JS) code plays an important role. To avoid the exposure of original source code, the variable names in JS code deployed in the wild are often replaced by short, meaningless names, thus making the code extremely difficult to manually understand and analysis. This paper presents JSNeat, an information retrieval (IR)-based approach to recover the variable names in minified JS code. JSNeat follows a data-driven approach to recover names by searching for them in a large corpus of open-source JS code. We use three types of contexts to match a variable in given minified code against the corpus including the context of properties and roles of the variable, the context of that variable and relations with other variables under recovery, and the context of the task of the function to which the variable contributes. We performed several empirical experiments to evaluate JSNeat on the dataset of more than 322K JS files with 1M functions, and 3.5M variables with 176K unique variable names. We found that JSNeat achieves a high accuracy of 69.1%, which is the relative improvements of 66.1% and 43% over two state-of-the-art approaches JSNice and JSNaughty, respectively. The time to recover for a file or for a variable with JSNeat is twice as fast as with JSNice and 4x as fast as with JNaughty, respectively.</p>\n", "tags": ["naming", "deobfuscation"], "tsne_embedding": [-16.579248428344727, 18.77610969543457]}, {"key": "tu2014localness", "year": "2014", "title": "On the Localness of Software", "abstract": "<p>The n-gram language model, which has its roots in statistical natural\nlanguage processing, has been shown to successfully capture the\nrepetitive and predictable regularities (\u201cnaturalness\u201d) of source code,\nand help with tasks such as code suggestion, porting, and designing\nassistive coding devices. However, we show in this paper that this\nnatural-language-based model fails to exploit a special property of\nsource code: localness. We find that human-written programs are\nlocalized: they have useful local regularities that can be captured\nand exploited. We introduce a novel cache language model that\nconsists of both an n-gram and an added \u201ccache\u201d component to\nexploit localness. We show empirically that the additional cache\ncomponent greatly improves the n-gram approach by capturing\nthe localness of software, as measured by both cross-entropy and\nsuggestion accuracy. Our model\u2019s suggestion accuracy is actually\ncomparable to a state-of-the-art, semantically augmented language\nmodel; but it is simpler and easier to implement. Our cache language\nmodel requires nothing beyond lexicalization, and thus is applicable\nto all programming languages.</p>\n", "tags": ["language model"], "tsne_embedding": [-1.7105153799057007, 7.9951629638671875]}, {"key": "tufano2018deep", "year": "2018", "title": "Deep Learning Similarities from Different Representations of Source Code", "abstract": "<p>Assessing the similarity between code components plays a pivotal\nrole in a number of Software Engineering (SE) tasks, such as clone\ndetection, impact analysis, refactoring, <em>etc.</em> \nCode similarity is generally measured by relying on manually defined or hand-crafted\nfeatures,  e.g.,  by analyzing the overlap among identifiers or comparing the Abstract Syntax Trees of two code components. These\nfeatures represent a  best guess at what SE researchers can utilize to\nexploit and reliably assess code similarity for a given task. Recent\nwork has shown, when using a stream of identifiers to represent\nthe code, that Deep Learning (DL) can effectively replace manual\nfeature engineering for the task of clone detection. However, source\ncode can be represented at different levels of abstraction: identifiers, Abstract Syntax Trees, Control Flow Graphs, and Bytecode.\nWe conjecture that each code representation can provide a different,\nyet orthogonal view of the same code fragment, thus, enabling a\nmore reliable detection of similarities in code. In this paper, we\ndemonstrate how SE tasks can benefit from a DL-based approach,\nwhich can automatically learn code similarities from different representations.</p>\n", "tags": ["representation", "clone"], "tsne_embedding": [-13.122420310974121, -2.980240821838379]}, {"key": "tufano2018empirical", "year": "2018", "title": "An Empirical Study on Learning Bug-Fixing Patches in the Wild via Neural Machine Translation", "abstract": "<p>Millions of open-source projects with numerous bug fixes are available in code repositories. This proliferation of software development histories can be leveraged to learn how to fix common programming bugs. To explore such a potential, we perform an empirical study to assess the feasibility of using Neural Machine Translation techniques for learning bug-fixing patches for real defects. First, we mine millions of bug-fixes from the change histories of projects hosted on GitHub, in order to extract meaningful examples of such bug-fixes. Next, we abstract the buggy and corresponding fixed code, and use them to train an Encoder-Decoder model able to translate buggy code into its fixed version. In our empirical investigation we found that such a model is able to fix thousands of unique buggy methods in the wild. Overall, this model is capable of predicting fixed patches generated by developers in 9-50% of the cases, depending on the number of candidate patches we allow it to generate. Also, the model is able to emulate a variety of different Abstract Syntax Tree operations and generate candidate patches in a split second.</p>\n", "tags": ["repair"], "tsne_embedding": [-5.2167649269104, -19.850549697875977]}, {"key": "tufano2018learning", "year": "2018", "title": "Learning How to Mutate Source Code from Bug-Fixes", "abstract": "<p>Mutation testing has been widely accepted as an approach to guide test case generation or to assess the effectiveness of test suites. Empirical studies have shown that mutants are representative of real faults; yet they also indicated a clear need for better, possibly customized, mutation operators and strategies. While some recent papers have tried to devise domain-specific or general purpose mutator operators by manually analyzing real faults, such an activity is effort- (and error-) prone and does not deal with an important practical question as to how to really mutate a given source code element. We propose a novel approach to automatically learn mutants from faults in real programs. First, our approach processes bug fixing changes using fine-grained differencing, code abstraction, and change clustering. Then, it learns mutation models using a deep learning strategy. We have trained and evaluated our technique on a set of ~787k bugs mined from GitHub. Starting from code fixed by developers in the context of a bug-fix, our empirical evaluation showed that our models are able to predict mutants that resemble original fixed bugs in between 9% and 45% of the cases (depending on the model). Moreover, over 98% of the automatically generated mutants are lexically and syntactically correct.</p>\n", "tags": ["repair", "edit"], "tsne_embedding": [-8.789393424987793, -19.088092803955078]}, {"key": "tufano2019learning", "year": "2019", "title": "On Learning Meaningful Code Changes via Neural Machine Translation", "abstract": "<p>Recent years have seen the rise of Deep Learning (DL) techniques applied to source code. Researchers have exploited DL to automate several development and maintenance tasks, such as writing commit messages, generating comments and detecting vulnerabilities among others. One of the long lasting dreams of applying DL to code is the possibility to automate non-trivial coding activities. While some steps in this direction have been taken (e.g., learning how to fix bugs), there is still a lack of empirical evidence on the types of code changes that can be learned and automatically applied by DL. Our goal is to make this first step by quantitatively and qualitatively investigating the ability of a Neural Machine Translation (NMT) model to learn how to automatically apply code changes implemented by developers during pull requests. We train and experiment with the NMT model on a set of 236k pairs of code components before and after the implementation of the changes provided in the pull requests. We show that, when applied in a narrow enough context (i.e., small/medium-sized pairs of methods before/after the pull request changes), NMT can automatically replicate the changes implemented by developers during pull requests in up to 36% of the cases. Moreover, our qualitative analysis shows that the model is capable of learning and replicating a wide variety of meaningful code changes, especially refactorings and bug-fixing activities. Our results pave the way to novel research in the area of DL on code, such as the automatic learning and applications of refactoring.</p>\n", "tags": ["repair", "edit"], "tsne_embedding": [-0.803202211856842, -17.859914779663086]}, {"key": "tufano2020generating", "year": "2020", "title": "Generating Accurate Assert Statements for Unit Test Cases using Pretrained Transformers", "abstract": "<p>Unit testing represents the foundational basis of the software testing pyramid, beneath integration and end-to-end testing. Automated software testing researchers have proposed a variety of techniques to assist developers in this time-consuming task. In this paper we present an approach to support developers in writing unit test cases by generating accurate and useful assert statements. Our approach is based on a state-of-the-art transformer model initially pretrained on an English textual corpus. This semantically rich model is then trained in a semi-supervised fashion on a large corpus of source code. Finally, we finetune this model on the task of generating assert statements for unit tests. The resulting model is able to generate accurate assert statements for a given method under test. In our empirical evaluation, the model was able to predict the exact assert statements written by developers in 62% of the cases in the first attempt. The results show 80% relative improvement for top-1 accuracy over the previous RNN-based approach in the literature. We also show the substantial impact of the pretraining process on the performances of our model, as well as comparing it with assert auto-completion task. Finally, we demonstrate how our approach can be used to augment EvoSuite test cases, with additional asserts leading to improved test coverage.</p>\n", "tags": ["code generation", "synthesis", "test generation"], "tsne_embedding": [20.51327133178711, 5.530069351196289]}, {"key": "tufano2020unit", "year": "2020", "title": "Unit Test Case Generation with Transformers", "abstract": "<p>Automated Unit Test Case generation has been the focus of extensive literature within the research community. Existing approaches are usually guided by the test coverage criteria, generating synthetic test cases that are often difficult to read or understand for developers. In this paper we propose AthenaTest, an approach that aims at generating unit test cases by learning from real-world, developer-written test cases. Our approach relies on a state-of-the-art sequence-to-sequence transformer model which is able to write useful test cases for a given method under test (i.e., focal method). We also introduce methods2test - the largest publicly available supervised parallel corpus of unit test case methods and corresponding focal methods in Java, which comprises 630k test cases mined from 70k open-source repositories hosted on GitHub. We use this dataset to train a transformer model to translate focal methods into the corresponding test cases. We evaluate the ability of our model in generating test cases using natural language processing as well as code-specific criteria. First, we assess the quality of the translation compared to the target test case, then we analyze properties of the test case such as syntactic correctness and number and variety of testing APIs (e.g., asserts). We execute the test cases, collect test coverage information, and compare them with test cases generated by EvoSuite and GPT-3. Finally, we survey professional developers on their preference in terms of readability, understandability, and testing effectiveness of the generated test cases.</p>\n", "tags": ["code generation", "synthesis", "test generation"], "tsne_embedding": [20.02312469482422, 5.071430683135986]}, {"key": "vaithilingam2022expectation", "year": "2022", "title": "Expectation vs. Experience: Evaluating the Usability of Code Generation Tools Powered by Large Language Models", "abstract": "<p>Recent advances in Large Language Models (LLM) have made automatic code generation possible for real-world programming tasks in\ngeneral-purpose programming languages such as Python. However,\nthere are few human studies on the usability of these tools and how\nthey fit the programming workflow. In this work, we conducted\na within-subjects user study with 24 participants to understand\nhow programmers use and perceive Copilot, a LLM-based code\ngeneration tool. We found that, while Copilot did not necessarily\nimprove the task completion time or success rate, most participants preferred to use Copilot in daily programming tasks, since\nCopilot often provided a useful starting point and saved the effort\nof searching online. However, participants did face difficulties in\nunderstanding, editing, and debugging code snippets generated\nby Copilot, which significantly hindered their task-solving effectiveness. Finally, we highlighted several promising directions for\nimproving the design of Copilot based on our observations and\nparticipants\u2019 feedback.</p>\n", "tags": ["human evaluation", "code generation", "language model"], "tsne_embedding": [19.218708038330078, 11.130236625671387]}, {"key": "vasic2019neural", "year": "2019", "title": "Neural Program Repair by Jointly Learning to Localize and Repair", "abstract": "<p>Due to its potential to improve programmer productivity and software quality, automated program repair has been an active topic of research. Newer techniques harness neural networks to learn directly from examples of buggy programs and their fixes. In this work, we consider a recently identified class of bugs called variable-misuse bugs. The state-of-the-art solution for variable misuse enumerates potential fixes for all possible bug locations in a program, before selecting the best prediction. We show that it is beneficial to train a model that jointly and directly localizes and repairs variable-misuse bugs. We present multi-headed pointer networks for this purpose, with one head each for localization and repair. The experimental results show that the joint model significantly outperforms an enumerative solution that uses a pointer based model for repair alone.</p>\n", "tags": ["repair", "program analysis", "variable misuse"], "tsne_embedding": [-7.349186897277832, -22.19622802734375]}, {"key": "vasilescu2017recovering", "year": "2017", "title": "Recovering Clear, Natural Identifiers from Obfuscated JS Names", "abstract": "<p>Well-chosen variable names are critical to source code readability, reusability, and maintainability. Unfortunately, in deployed JavaScript code (which is ubiquitous on the web) the identifier names are frequently minified and overloaded. This is done both for efficiency and also to protect potentially proprietary intellectual property. In this paper, we describe an approach based on statistical machine translation (SMT) that recovers some of the original names from the JavaScript programs minified by the very popular UglifyJS. This simple tool, Autonym, performs comparably to the best currently available deobfuscator for JavaScript, JSNice, which uses sophisticated static analysis. In fact, Autonym is quite complementary to JSNice, performing well when it does not, and vice versa. We also introduce a new tool, JSNaughty, which blends Autonym and JSNice, and significantly outperforms both at identifier name recovery, while remaining just as easy to use as JSNice. JSNaughty is available online at http://jsnaughty.org.</p>\n", "tags": ["deobfuscation", "naming"], "tsne_embedding": [-16.046188354492188, 18.624906539916992]}, {"key": "villmow2021contest", "year": "2021", "title": "ConTest: A Unit Test Completion Benchmark featuring Context", "abstract": "<p>We introduce CONTEST, a benchmark for NLP-based unit test completion, the task of predicting a test\u2019s assert statements given its setup and focal method, i.e. the method to be tested. ConTest is large-scale (with 365k datapoints). Besides the test code and tested code, it also features context code called by either. We found context to be crucial for accurately predicting assertions. We also introduce baselines based on transformer encoder-decoders, and study the effects of including syntactic information and context. Overall, our models achieve a BLEU score of 38.2, while only generating unparsable code in 1.92% of cases.</p>\n", "tags": ["benchmark", "dataset", "verification", "Transformer"], "tsne_embedding": [20.98694610595703, 6.189559459686279]}, {"key": "wan2018improving", "year": "2018", "title": "Improving Automatic Source Code Summarization via Deep Reinforcement Learning", "abstract": "<p>Code summarization provides a high level natural language description of the function performed by code, as it can benefit the software maintenance, code categorization and retrieval. To the best of our knowledge, most state-of-the-art approaches follow an encoder-decoder framework which encodes the code into a hidden space and then decode it into natural language space, suffering from two major drawbacks: a) Their encoders only consider the sequential content of code, ignoring the tree structure which is also critical for the task of code summarization; b) Their decoders are typically trained to predict the next word by maximizing the likelihood of next ground-truth word with previous ground-truth word given. However, it is expected to generate the entire sequence from scratch at test time. This discrepancy can cause an exposure bias issue, making the learnt decoder suboptimal. In this paper, we incorporate an abstract syntax tree structure as well as sequential content of code snippets into a deep reinforcement learning framework (i.e., actor-critic network). The actor network provides the confidence of predicting the next word according to current state. On the other hand, the critic network evaluates the reward value of all possible extensions of the current state and can provide global guidance for explorations. We employ an advantage reward composed of BLEU metric to train both networks. Comprehensive experiments on a real-world dataset show the effectiveness of our proposed model when compared with some state-of-the-art methods.</p>\n", "tags": ["summarization", "documentation"], "tsne_embedding": [11.902809143066406, -9.263405799865723]}, {"key": "wan2019multimodal", "year": "2019", "title": "Multi-Modal Attention Network Learning for Semantic Source Code Retrieval", "abstract": "<p>Code retrieval techniques and tools have been playing a key role in facilitating software developers to retrieve existing code fragments from available open-source repositories given a user query. Despite the existing efforts in improving the effectiveness of code retrieval, there are still two main issues hindering them from being used to accurately retrieve satisfiable code fragments from large-scale repositories when answering complicated queries. First, the existing approaches only consider shallow features of source code such as method names and code tokens, but ignoring structured features such as abstract syntax trees (ASTs) and control-flow graphs (CFGs) of source code, which contains rich and well-defined semantics of source code. Second, although the deep learning-based approach performs well on the representation of source code, it lacks the explainability, making it hard to interpret the retrieval results and almost impossible to understand which features of source code contribute more to the final results.</p>\n\n<p>To tackle the two aforementioned issues, this paper proposes MMAN, a novel Multi-Modal Attention Network for semantic source code retrieval. A comprehensive multi-modal representation is developed for representing unstructured and structured features of source code, with one LSTM for the sequential tokens of code, a Tree-LSTM for the AST of code and a GGNN (Gated Graph Neural Network) for the CFG of code. Furthermore, a multi-modal attention fusion layer is applied to assign weights to different parts of each modality of source code and then integrate them into a single hybrid representation. Comprehensive experiments and analysis on a large-scale real-world dataset show that our proposed model can accurately retrieve code snippets and outperforms the state-of-the-art methods.</p>\n", "tags": ["search"], "tsne_embedding": [-9.281784057617188, -1.338704228401184]}, {"key": "wan2020naturalcc", "year": "2020", "title": "NaturalCC: A Toolkit to Naturalize the Source Code Corpus", "abstract": "<p>We present NaturalCC, an efficient and extensible toolkit to bridge the gap between natural language and programming language, and facilitate the research on big code analysis. Using NaturalCC, researchers both from natural language or programming language communities can quickly and easily reproduce the state-of-the-art baselines and implement their approach. NaturalCC is built upon Fairseq and PyTorch, providing (1) an efficient computation with multi-GPU and mixed-precision data processing for fast model training, (2) a modular and extensible framework that makes it easy to reproduce or implement an approach for big code analysis, and (3) a command line interface and a graphical user interface to demonstrate each model\u2019s performance. Currently, we have included several state-of-the-art baselines across different tasks (e.g., code completion, code comment generation, and code retrieval) for demonstration. The video of this demo is available at https://www.youtube.com/watch?v=q4W5VSI-u3E&amp;t=25s.</p>\n", "tags": ["documentation", "search", "summarization"], "tsne_embedding": [10.501470565795898, 8.853544235229492]}, {"key": "wan2022what", "year": "2022", "title": "What Do They Capture? -- A Structural Analysis of Pre-Trained Language Models for Source Code", "abstract": "<p>Recently, many pre-trained language models for source code have been proposed to model the context of code and serve as a basis for downstream code intelligence tasks such as code completion, code search, and code summarization. These models leverage masked pre-training and Transformer and have achieved promising results. However, currently there is still little progress regarding interpretability of existing pre-trained code models. It is not clear why these models work and what feature correlations they can capture. In this paper, we conduct a thorough structural analysis aiming to provide an interpretation of pre-trained language models for source code (e.g., CodeBERT, and GraphCodeBERT) from three distinctive perspectives: (1) attention analysis, (2) probing on the word embedding, and (3) syntax tree induction. Through comprehensive analysis, this paper reveals several insightful findings that may inspire future studies: (1) Attention aligns strongly with the syntax structure of code. (2) Pre-training language models of code can preserve the syntax structure of code in the intermediate representations of each Transformer layer. (3) The pre-trained models of code have the ability of inducing syntax trees of code. Theses findings suggest that it may be helpful to incorporate the syntax structure of code into the process of pre-training for better code representations.</p>\n", "tags": ["Transformer", "pretraining", "program analysis"], "tsne_embedding": [4.1412739753723145, -1.0008587837219238]}, {"key": "wang2016automatically", "year": "2016", "title": "Automatically Learning Semantic Features for Defect Prediction", "abstract": "<p>Software defect prediction, which predicts defective code regions, can help developers find bugs and prioritize their testing efforts. To build accurate prediction models, previous\nstudies focus on manually designing features that encode the\ncharacteristics of programs and exploring different machine\nlearning algorithms. Existing traditional features often fail\nto capture the semantic differences of programs, and such a\ncapability is needed for building accurate prediction models.</p>\n\n<p>To bridge the gap between programs\u2019 semantics and\ndefect prediction features, this paper proposes to leverage a\npowerful representation-learning algorithm, deep learning,\nto learn semantic representation of programs automatically\nfrom source code. Specifically, we leverage Deep Belief\nNetwork (DBN) to automatically learn semantic features\nfrom token vectors extracted from programs\u2019 Abstract\nSyntax Trees (ASTs).</p>\n\n<p>Our evaluation on ten open source projects shows that\nour automatically learned semantic features significantly improve both within-project defect prediction (WPDP) and\ncross-project defect prediction (CPDP) compared to traditional features. Our semantic features improve WPDP on\naverage by 14.7% in precision, 11.5% in recall, and 14.2%\nin F1. For CPDP, our semantic features based approach\noutperforms the state-of-the-art technique TCA+ with traditional features by 8.9% in F1.</p>\n", "tags": ["defect", "representation"], "tsne_embedding": [-9.35561466217041, -12.552682876586914]}, {"key": "wang2016bugram", "year": "2016", "title": "Bugram: bug detection with n-gram language models", "abstract": "<p>To improve software reliability, many rule-based techniques have been proposed to infer programming rules and detect violations of these rules as bugs. These rule-based approaches often rely on the highly frequent appearances of certain patterns in a project to infer rules. It is known that if a pattern does not appear frequently enough, rules are not learned, thus missing many bugs.</p>\n\n<p>In this paper, we propose a new approach\u2014Bugram\u2014that leverages n-gram language models instead of rules to detect bugs. Bugram models program tokens sequentially, using the n-gram language model. Token sequences from the program are then assessed according to their probability in the learned model, and low probability sequences are marked as potential bugs. The assumption is that low probability token sequences in a program are unusual, which may indicate bugs, bad practices, or unusual/special uses of code of which developers may want to be aware.</p>\n\n<p>We evaluate Bugram in two ways. First, we apply Bugram on the latest versions of 16 open source Java projects. Results show that Bugram detects 59 bugs, 42 of which are manually verified as correct, 25 of which are true bugs and 17 are code snippets that should be refactored. Among the 25 true bugs, 23 cannot be detected by PR-Miner. We have reported these bugs to developers, 7 of which have already been confirmed by developers (4 of them have already been fixed), while the rest await confirmation. Second, we further compare Bugram with three additional graph- and rule-based bug detection tools, i.e., JADET, Tikanga, and GrouMiner. We apply Bugram on 14 Java projects evaluated in these three studies. Bugram detects 21 true bugs, at least 10 of which cannot be detected by these three tools. Our results suggest that Bugram is complementary to existing rule-based bug detection approaches.</p>\n\n", "tags": ["defect", "representation"], "tsne_embedding": [-13.874205589294434, -18.428308486938477]}, {"key": "wang2016neural", "year": "2016", "title": "Neural Code Completion", "abstract": "<p>Code completion, an essential part of modern software development, yet can be\nchallenging for dynamically typed programming languages. In this paper we explore the use of neural network techniques to automatically learn code completion\nfrom a large corpus of dynamically typed JavaScript code. We show different\nneural networks that leverage not only token level information but also structural\ninformation, and evaluate their performance on different prediction tasks. We\ndemonstrate that our models can outperform the state-of-the-art approach, which\nis based on decision tree techniques, on both next non-terminal and next terminal\nprediction tasks by 3.8 points and 0.5 points respectively. We believe that neural\nnetwork techniques can play a transformative role in helping software developers\nmanage the growing complexity of software systems, and we see this work as a\nfirst step in that direction.</p>\n", "tags": ["autocomplete"], "tsne_embedding": [3.6518285274505615, 11.978155136108398]}, {"key": "wang2019learning", "year": "2019", "title": "Learning Scalable and Precise Representation of Program Semantics", "abstract": "<p>Neural program embedding has shown potential in aiding the analysis of large-scale, complicated software. Newly proposed deep neural architectures pride themselves on learning program semantics rather than superficial syntactic features. However, by considering the source code only, the vast majority of neural networks do not capture a deep, precise representation of program semantics. In this paper, we present \\dypro, a novel deep neural network that learns from program execution traces. Compared to the prior dynamic models, not only is \\dypro capable of generalizing across multiple executions for learning a program\u2019s dynamic semantics in its entirety, but \\dypro is also more efficient when dealing with programs yielding long execution traces. For evaluation, we task \\dypro with semantic classification (i.e. categorizing programs based on their semantics) and compared it against two prominent static models: Gated Graph Neural Network and TreeLSTM. We find that \\dypro achieves the highest prediction accuracy among all models. To further reveal the capacity of all aforementioned deep neural architectures, we examine if the models can learn to detect deeper semantic properties of a program. In particular given a task of recognizing loop invariants, we show \\dypro beats all static models by a wide margin.</p>\n", "tags": ["representation", "dynamic"], "tsne_embedding": [-2.9360547065734863, -4.871546745300293]}, {"key": "wang2020blended", "year": "2020", "title": "Blended, precise semantic program embeddings", "abstract": "<p>Learning neural program embeddings is key to utilizing deep neural networks in program languages research \u2014 precise and efficient program representations enable the application of deep models to a wide range of program analysis tasks. Existing approaches predominately learn to embed programs from their source code, and, as a result, they do not capture deep, precise program semantics. On the other hand, models learned from runtime information critically depend on the quality of program executions, thus leading to trained models with highly variant quality. This paper tackles these inherent weaknesses of prior approaches by introducing a new deep neural network, Liger, which learns program representations from a mixture of symbolic and concrete execution traces. We have evaluated Liger on two tasks: method name prediction and semantics classification. Results show that Liger is significantly more accurate than the state-of-the-art static model code2seq in predicting method names, and requires on average around 10x fewer executions covering nearly 4x fewer paths than the state-of-the-art dynamic model DYPRO in both tasks. Liger offers a new, interesting design point in the space of neural program embeddings and opens up this new direction for exploration.</p>\n", "tags": ["dynamic"], "tsne_embedding": [-2.9199512004852295, -4.686142921447754]}, {"key": "wang2020cocogum", "year": "2020", "title": "CoCoGUM: Contextual Code Summarization with Multi-Relational GNN on UMLs", "abstract": "<p>Code summaries are short natural language (NL) descriptions of code snippets that help developers better understand and maintain source code. Due to the pivotal role of code summaries in software development and maintenance, there is a surge of works on automatic code summarization to reduce the heavy burdens of developers. However, contemporary approaches only leverage the information within the boundary of the method being summarized (i.e., local context), and ignore that using broader context could assist with code summarization. In this paper, we explore two global context information, namely intra-class and inter-class context information, and propose the model CoCoGUM: Contextual Code Summarization with Multi-Relational Graph Neural Networks on UMLs. CoCoGUM first incorporates class names as the intra-class context, which is further fed to a Transformer-based sentence embedding model to extract the class lexical embeddings. Then, relevant Unified Modeling Language (UML) class diagrams are extracted as inter-class context and we use a Multi-Relational Graph Neural Network (MR-GNN) to encode the class relational embeddings. Class lexical embeddings and class relational embeddings, together with the outputs from code token encoder and AST encoder, are passed to the decoder armed with a two-level attention mechanism to generate high-quality context-aware code summaries. We conduct extensive experiments to evaluate our approach and compare it with other automatic code summarization models. The experimental results show that CoCoGUM outperforms state-of-the-art methods.</p>\n", "tags": ["summarization"], "tsne_embedding": [9.93327522277832, -10.705652236938477]}, {"key": "wang2020detecting", "year": "2020", "title": "Detecting Code Clones with Graph Neural Network and Flow-Augmented Abstract Syntax Tree", "abstract": "<p>Code clones are semantically similar code fragments pairs that are syntactically similar or different. Detection of code clones can help to reduce the cost of software maintenance and prevent bugs. Numerous approaches of detecting code clones have been proposed previously, but most of them focus on detecting syntactic clones and do not work well on semantic clones with different syntactic features. To detect semantic clones, researchers have tried to adopt deep learning for code clone detection to automatically learn latent semantic features from data. Especially, to leverage grammar information, several approaches used abstract syntax trees (AST) as input and achieved significant progress on code clone benchmarks in various programming languages. However, these AST-based approaches still can not fully leverage the structural information of code fragments, especially semantic information such as control flow and data flow. To leverage control and data flow information, in this paper, we build a graph representation of programs called flow-augmented abstract syntax tree (FA-AST). We construct FA-AST by augmenting original ASTs with explicit control and data flow edges. Then we apply two different types of graph neural networks (GNN) on FA-AST to measure the similarity of code pairs. As far as we have concerned, we are the first to apply graph neural networks on the domain of code clone detection. We apply our FA-AST and graph neural networks on two Java datasets: Google Code Jam and BigCloneBench. Our approach outperforms the state-of-the-art approaches on both Google Code Jam and BigCloneBench tasks.</p>\n", "tags": ["clone", "GNN"], "tsne_embedding": [-12.503803253173828, -3.6928467750549316]}, {"key": "wang2020learning", "year": "2020", "title": "Learning Semantic Program Embeddings with Graph Interval Neural Network", "abstract": "<p>Learning distributed representations of source code has been a challenging task for machine learning models. Earlier works treated programs as text so that natural language methods can be readily applied. Unfortunately, such approaches do not capitalize on the rich structural information possessed by source code. Of late, Graph Neural Network (GNN) was proposed to learn embeddings of programs from their graph representations. Due to the homogeneous and expensive message-passing procedure, GNN can suffer from precision issues, especially when dealing with programs rendered into large graphs. In this paper, we present a new graph neural architecture, called Graph Interval Neural Network (GINN), to tackle the weaknesses of the existing GNN. Unlike the standard GNN, GINN generalizes from a curated graph representation obtained through an abstraction method designed to aid models to learn. In particular, GINN focuses exclusively on intervals for mining the feature representation of a program, furthermore, GINN operates on a hierarchy of intervals for scaling the learning to large graphs. We evaluate GINN for two popular downstream applications: variable misuse prediction and method name prediction. Results show in both cases GINN outperforms the state-of-the-art models by a comfortable margin. We have also created a neural bug detector based on GINN to catch null pointer deference bugs in Java code. While learning from the same 9,000 methods extracted from 64 projects, GINN-based bug detector significantly outperforms GNN-based bug detector on 13 unseen test projects. Next, we deploy our trained GINN-based bug detector and Facebook Infer to scan the codebase of 20 highly starred projects on GitHub. Through our manual inspection, we confirm 38 bugs out of 102 warnings raised by GINN-based bug detector compared to 34 bugs out of 129 warnings for Facebook Infer.</p>\n", "tags": ["GNN", "defect"], "tsne_embedding": [-7.294031620025635, -8.743776321411133]}, {"key": "wang2020learning2", "year": "2020", "title": "Learning to Represent Programs with Heterogeneous Graphs", "abstract": "<p>Program source code contains complex structure information, which can be represented in structured data forms like trees or graphs. To acquire the structural information in source code, most existing researches use abstract syntax trees (AST). A group of works add additional edges to ASTs to convert source code into graphs and use graph neural networks to learn representations for program graphs. Although these works provide additional control or data flow information to ASTs for downstream tasks, they neglect an important aspect of structure information in AST itself: the different types of nodes and edges. In ASTs, different nodes contain different kinds of information like variables or control flow, and the relation between a node and all its children can also be different.</p>\n\n<p>To address the information of node and edge types, we bring the idea of heterogeneous graphs to learning on source code and present a new formula of building heterogeneous program graphs from ASTs with additional type information for nodes and edges. We use the ASDL grammar of programming language to define the node and edge types of program graphs. Then we use heterogeneous graph neural networks to learn on these graphs. We evaluate our approach on two tasks: code comment generation and method naming. Both tasks require reasoning on the semantics of complete code snippets. Experiment results show that our approach outperforms baseline models, including homogeneous graph-based models, showing that leveraging the type information of nodes and edges in program graphs can help in learning program semantics.</p>\n", "tags": ["GNN", "summarization"], "tsne_embedding": [-6.656485557556152, -6.759143352508545]}, {"key": "wang2020modular", "year": "2020", "title": "Modular Tree Network for Source Code Representation Learning", "abstract": "<p>Learning representation for source code is a foundation of many program analysis tasks. In recent years, neural networks have already shown success in this area, but most existing models did not make full use of the unique structural information of programs. Although abstract syntax tree (AST)-based neural models can handle the tree structure in the source code, they cannot capture the richness of different types of substructure in programs. In this article, we propose a modular tree network that dynamically composes different neural network units into tree structures based on the input AST. Different from previous tree-structural neural network models, a modular tree network can capture the semantic differences between types of AST substructures. We evaluate our model on two tasks: program classification and code clone detection. Our model achieves the best performance compared with state-of-the-art approaches in both tasks, showing the advantage of leveraging more elaborate structure information of the source code.</p>\n", "tags": ["grammar", "representation"], "tsne_embedding": [-10.111515998840332, -3.45641827583313]}, {"key": "wang2020trans", "year": "2020", "title": "TranS^3: A Transformer-based Framework for Unifying Code Summarization and Code Search", "abstract": "<p>Code summarization and code search have been widely adopted in sofwaredevelopmentandmaintenance. However, fewstudieshave explored the efcacy of unifying them. In this paper, we propose TranS^3 , a transformer-based framework to integrate code summarization with code search. Specifcally, for code summarization,TranS^3 enables an actor-critic network, where in the actor network, we encode the collected code snippets via transformer- and tree-transformer-based encoder and decode the given code snippet to generate its comment. Meanwhile, we iteratively tune the actor network via the feedback from the critic network for enhancing the quality of the generated comments. Furthermore, we import the generated comments to code search for enhancing its accuracy. To evaluatetheefectivenessof TranS^3 , we conduct a set of experimental studies and case studies where the experimental results suggest that TranS^3 can signifcantly outperform multiple state-of-the-art approaches in both code summarization and code search and the study results further strengthen the efcacy of TranS^3 from the developers\u2019 points of view.</p>\n", "tags": ["search", "documentation"], "tsne_embedding": [5.202101230621338, -7.182087421417236]}, {"key": "wang2021codet5", "year": "2021", "title": "CodeT5: Identifier-aware Unified Pre-trained Encoder-Decoder Models for Code Understanding and Generation", "abstract": "<p>Pre-trained models for Natural Languages (NL) like BERT and GPT have been recently shown to transfer well to Programming Languages (PL) and largely benefit a broad set of code-related tasks. Despite their success, most current methods either rely on an encoder-only (or decoder-only) pre-training that is suboptimal for generation (resp. understanding) tasks or process the code snippet in the same way as NL, neglecting the special characteristics of PL such as token types. We present CodeT5, a unified pre-trained encoder-decoder Transformer model that better leverages the code semantics conveyed from the developer-assigned identifiers. Our model employs a unified framework to seamlessly support both code understanding and generation tasks and allows for multi-task learning. Besides, we propose a novel identifier-aware pre-training task that enables the model to distinguish which code tokens are identifiers and to recover them when they are masked. Furthermore, we propose to exploit the user-written code comments with a bimodal dual generation task for better NL-PL alignment. Comprehensive experiments show that CodeT5 significantly outperforms prior methods on understanding tasks such as code defect detection and clone detection, and generation tasks across various directions including PL-NL, NL-PL, and PL-PL. Further analysis reveals that our model can better capture semantic information from code. Our code and pre-trained models are released at https://github.com/salesforce/CodeT5 .</p>\n", "tags": ["Transformer"], "tsne_embedding": [5.654053211212158, 0.40579530596733093]}, {"key": "wang2021syncobert", "year": "2021", "title": "SynCoBERT: Syntax-Guided Multi-Modal Contrastive Pre-Training for Code Representation", "abstract": "<p>Code representation learning, which aims to encode the semantics of source code into distributed vectors, plays an important role in recent deep-learning-based models for code intelligence. Recently, many pre-trained language models for source code (e.g., CuBERT and CodeBERT) have been proposed to model the context of code and serve as a basis for downstream code intelligence tasks such as code search, code clone detection, and program translation. Current approaches typically consider the source code as a plain sequence of tokens, or inject the structure information (e.g., AST and data-flow) into the sequential model pre-training. To further explore the properties of programming languages, this paper proposes SynCoBERT, a syntax-guided multi-modal contrastive pre-training approach for better code representations. Specially, we design two novel pre-training objectives originating from the symbolic and syntactic properties of source code, i.e., Identifier Prediction (IP) and AST Edge Prediction (TEP), which are designed to predict identifiers, and edges between two nodes of AST, respectively. Meanwhile, to exploit the complementary information in semantically equivalent modalities (i.e., code, comment, AST) of the code, we propose a multi-modal contrastive learning strategy to maximize the mutual information among different modalities. Extensive experiments on four downstream tasks related to code intelligence show that SynCoBERT advances the state-of-the-art with the same pre-training corpus and model size.</p>\n", "tags": ["pretraining"], "tsne_embedding": [3.5929973125457764, -3.152045965194702]}, {"key": "wang2023deepvd", "year": "2023", "title": "DeepVD: Toward Class-Separation Features for Neural Network Vulnerability Detection", "abstract": "<p>The advances of machine learning (ML) including deep learning (DL) have enabled several approaches to implicitly learn vulnerable code patterns to automatically detect software vulnerabilities. A recent study showed that despite successes, the existing ML/DL-based vulnerability detection (VD) models are limited in the ability to distinguish between the two classes of vulnerability and benign code. We propose DeepVD, a graph-based neural network VD model that emphasizes on class-separation features between vulnerability and benign code. DeepVD leverages three types of class-separation features at different levels of abstraction: statement types (similar to Part-of-Speech tagging), Post-Dominator Tree (covering regular flows of execution), and Exception Flow Graph (covering the exception and error-handling flows). We conducted several experiments to evaluate DeepVD in a real-world vulnerability dataset of 303 projects with 13,130 vulnerable methods. Our results show that DeepVD relatively improves over the state-of-the-art ML/DL-based VD approaches 13%\u201329.6% in precision, 15.6%\u201328.9% in recall, and 16.4%\u201325.8% in F-score. Our ablation study confirms that our designed features and components help DeepVD achieve high class-separability for vulnerability and benign code.</p>\n", "tags": ["vulnerability"], "tsne_embedding": [-15.352246284484863, -10.68591022491455]}, {"key": "watson2021systematic", "year": "2021", "title": "A Systematic Literature Review on the Use of Deep Learning in Software Engineering Research", "abstract": "<p>An increasingly popular set of techniques adopted by software engineering (SE) researchers to automate development tasks are those rooted in the concept of Deep Learning (DL). The popularity of such techniques largely stems from their automated feature engineering capabilities, which aid in modeling software artifacts. However, due to the rapid pace at which DL techniques have been adopted, it is difficult to distill the current successes, failures, and opportunities of the current research landscape. In an effort to bring clarity to this crosscutting area of work, from its modern inception to the present, this paper presents a systematic literature review of research at the intersection of SE &amp; DL. The review canvases work appearing in the most prominent SE and DL conferences and journals and spans 128 papers across 23 unique SE tasks. We center our analysis around the components of learning, a set of principles that govern the application of machine learning techniques (ML) to a given problem domain, discussing several aspects of the surveyed work at a granular level. The end result of our analysis is a research roadmap that both delineates the foundations of DL techniques applied to SE research, and highlights likely areas of fertile exploration for the future.</p>\n", "tags": ["survey"], "tsne_embedding": [8.034477233886719, -24.35051727294922]}, {"key": "waunakh2019idbench", "year": "2021", "title": "IdBench: Evaluating Semantic Representations of Identifier Names in Source Code", "abstract": "<p>Identifier names convey useful information about the intended semantics of code. Name-based program analyses use this information, e.g., to detect bugs, to predict types, and to improve the readability of code. At the core of namebased analyses are semantic representations of identifiers, e.g., in the form of learned embeddings. The high-level goal of such a representation is to encode whether two identifiers, e.g., len and size, are semantically similar. Unfortunately, it is currently unclear to what extent semantic representations match the semantic relatedness and similarity perceived by developers. This paper presents IdBench, the first benchmark for evaluating semantic representations against a ground truth created from thousands of ratings by 500 software developers. We use IdBench to study state-of-the-art embedding techniques proposed for natural language, an embedding technique specifically designed for source code, and lexical string distance functions. Our results show that the effectiveness of semantic representations varies significantly and that the best available embeddings successfully represent semantic relatedness. On the downside, no existing technique provides a satisfactory representation of semantic similarities, among other reasons because identifiers with opposing meanings are incorrectly considered to be similar, which may lead to fatal mistakes, e.g., in a refactoring tool. Studying the strengths and weaknesses of the different techniques shows that they complement each other. As a first step toward exploiting this complementarity, we present an ensemble model that combines existing techniques and that clearly outperforms the best available semantic representation.</p>\n", "tags": ["representation"], "tsne_embedding": [-5.258014678955078, 6.765629768371582]}, {"key": "wei2019code", "year": "2019", "title": "Code Generation as a Dual Task of Code Summarization", "abstract": "<p>Code summarization (CS) and code generation (CG) are two crucial tasks in the field of automatic software development. Various neural network-based approaches are proposed to solve these two tasks separately. However, there exists a specific intuitive correlation between CS and CG, which have not been exploited in previous work. In this paper, we apply the relations between two tasks to improve the performance of both tasks. In other words, exploiting the duality between the two tasks, we propose a dual training framework to train the two tasks simultaneously. In this framework, we consider the dualities on probability and attention weights, and design corresponding regularization terms to constrain the duality. We evaluate our approach on two datasets collected from GitHub, and experimental results show that our dual framework can improve the performance of CS and CG tasks over baselines.</p>\n", "tags": ["code generation", "summarization"], "tsne_embedding": [10.656059265136719, -8.147631645202637]}, {"key": "wei2020lambdanet", "year": "2020", "title": "LambdaNet: Probabilistic Type Inference using Graph Neural Networks", "abstract": "<p>As gradual typing becomes increasingly popular in languages like Python and TypeScript, there is a growing need to infer type annotations automatically. While type annotations help with tasks like code completion and static error catching, these annotations cannot be fully inferred by compilers and are tedious to annotate by hand. This paper proposes a probabilistic type inference scheme for TypeScript based on a graph neural network. Our approach first uses lightweight source code analysis to generate a program abstraction called a type dependency graph, which links type variables with logical constraints as well as name and usage information. Given this program abstraction, we then use a graph neural network to propagate information between related type variables and eventually make type predictions. Our neural architecture can predict both standard types, like number or string, as well as user-defined types that have not been encountered during training. Our experimental results show that our approach outperforms prior work in this space by 14% (absolute) on library types, while having the ability to make type predictions that are out of scope for existing techniques.</p>\n", "tags": ["GNN", "types"], "tsne_embedding": [-4.668205738067627, 24.54062271118164]}, {"key": "wei2023typet5", "year": "2023", "title": "TypeT5: Seq2seq Type Inference using Static Analysis", "abstract": "<p>There has been growing interest in automatically predicting missing type annotations in programs written in Python and JavaScript. While prior methods have achieved impressive accuracy when predicting the most common types, they often perform poorly on rare or complex types. In this paper, we present a new type inference method that treats type prediction as a code infilling task by leveraging CodeT5, a state-of-the-art seq2seq pre-trained language model for code. Our method uses static analysis to construct dynamic contexts for each code element whose type signature is to be predicted by the model. We also propose an iterative decoding scheme that incorporates previous type predictions in the model\u2019s input context, allowing information exchange between related code elements. Our evaluation shows that the proposed approach, TypeT5, not only achieves a higher overall accuracy (particularly on rare and complex types) but also produces more coherent results with fewer type errors \u2013 while enabling easy user intervention.</p>\n", "tags": ["types", "Transformer"], "tsne_embedding": [-2.6798789501190186, 23.496919631958008]}, {"key": "white2015toward", "year": "2015", "title": "Toward Deep Learning Software Repositories", "abstract": "<p>Deep learning subsumes algorithms that automatically learn compositional representations. The ability of these\nmodels to generalize well has ushered in tremendous advances\nin many fields such as natural language processing (NLP).\nRecent research in the software engineering (SE) community\nhas demonstrated the usefulness of applying NLP techniques to\nsoftware corpora. Hence, we motivate deep learning for software\nlanguage modeling, highlighting fundamental differences between\nstate-of-the-practice software language models and connectionist\nmodels. Our deep learning models are applicable to source\ncode files (since they only require lexically analyzed source\ncode written in any programming language) and other types\nof artifacts. We show how a particular deep learning model\ncan remember its state to effectively model sequential data,\ne.g., streaming software tokens, and the state is shown to be\nmuch more expressive than discrete tokens in a prefix. Then we\ninstantiate deep learning models and show that deep learning\ninduces high-quality models compared to n-grams and cache-based n-grams on a corpus of Java projects. We experiment\nwith two of the models\u2019 hyperparameters, which govern their\ncapacity and the amount of context they use to inform predictions,\nbefore building several committees of software language models\nto aid generalization. Then we apply the deep learning models to\ncode suggestion and demonstrate their effectiveness at a real SE\ntask compared to state-of-the-practice models. Finally, we propose\navenues for future work, where deep learning can be brought to\nbear to support model-based testing, improve software lexicons,\nand conceptualize software artifacts. Thus, our work serves as\nthe first step toward deep learning software repositories.</p>\n", "tags": ["representation"], "tsne_embedding": [-0.7499336004257202, 0.686514675617218]}, {"key": "white2016deep", "year": "2016", "title": "Deep Learning Code Fragments for Code Clone Detection", "abstract": "<p>Code clone detection is an important problem for software\nmaintenance and evolution. Many approaches consider either structure or identifiers, but none of the existing detection techniques model both sources of information. These\ntechniques also depend on generic, handcrafted features to\nrepresent code fragments. We introduce learning-based detection techniques where everything for representing terms\nand fragments in source code is mined from the repository.\nOur code analysis supports a framework, which relies on\ndeep learning, for automatically linking patterns mined at\nthe lexical level with patterns mined at the syntactic level.\nWe evaluated our novel learning-based approach for code\nclone detection with respect to feasibility from the point\nof view of software maintainers. We sampled and manually\nevaluated 398 file- and 480 method-level pairs across eight\nreal-world Java systems; 93% of the file- and method-level\nsamples were evaluated to be true positives. Among the true\npositives, we found pairs mapping to all four clone types. We\ncompared our approach to a traditional structure-oriented\ntechnique and found that our learning-based approach detected clones that were either undetected or suboptimally\nreported by the prominent tool Deckard. Our results affirm\nthat our learning-based approach is suitable for clone detection and a tenable technique for researchers.</p>\n", "tags": ["clone"], "tsne_embedding": [-13.75634765625, -2.8519370555877686]}, {"key": "white2017sorting", "year": "2017", "title": "Sorting and Transforming Program Repair Ingredients via Deep Learning Code Similarities", "abstract": "<p>In  the  field  of  automated  program  repair,  the  redundancy  assumption  claims  large  programs  contain  the  seeds\nof  their  own  repair.  However,  most  redundancy-based  program\nrepair  techniques  do  not  reason  about  the  repair  ingredients\u2014the code that is reused to craft a patch. We aim to reason about\nthe repair ingredients by using code similarities to prioritize and\ntransform  statements  in  a  codebase  for  patch  generation.  Our\napproach,  DeepRepair,  relies  on  deep  learning  to  reason  about\ncode  similarities.  Code  fragments  at  well-defined  levels  of  granularity in a codebase can be sorted according to their similarity\nto suspicious elements (i.e., code elements that contain suspicious\nstatements) and statements can be transformed by mapping out-of-scope  identifiers  to  similar  identifiers  in  scope.  We  examined\nthese new search strategies for patch generation with respect to\neffectiveness  from  the  viewpoint  of  a  software  maintainer.  Our\ncomparative experiments were executed on six open-source Java\nprojects  including  374  buggy  program  revisions  and  consisted\nof  19,949  trials  spanning  2,616  days  of  computation  time.  DeepRepair\u2019s  search  strategy  using  code  similarities  generally  found\ncompilable  ingredients  faster  than  the  baseline,  jGenProg,  but\nthis improvement neither yielded test-adequate patches in fewer\nattempts (on average) nor found significantly more patches than\nthe  baseline.  Although  the  patch  counts  were  not  statistically\ndifferent,  there  were  notable  differences  between  the  nature  of\nDeepRepair  patches  and  baseline  patches.  The  results  demonstrate that our learning-based approach finds patches that cannot\nbe  found  by  existing  redundancy-based  repair  techniques</p>\n", "tags": ["repair"], "tsne_embedding": [-6.625770092010498, -18.66665267944336]}, {"key": "wong2021leveraging", "year": "2021", "title": "Leveraging Language to Learn Program Abstractions and Search Heuristics", "abstract": "<p>Inductive program synthesis, or inferring programs from examples of desired behavior, offers a general paradigm for building interpretable, robust, and generalizable machine learning systems. Effective program synthesis depends on two key ingredients: a strong library of functions from which to build programs, and an efficient search strategy for finding programs that solve a given task. We introduce LAPS (Language for Abstraction and Program Search), a technique for using natural language annotations to guide joint learning of libraries and neurally-guided search models for synthesis. When integrated into a state-of-the-art library learning system (DreamCoder), LAPS produces higher-quality libraries and improves search efficiency and generalization on three domains \u2013 string editing, image composition, and abstract reasoning about scenes \u2013 even when no natural language hints are available at test time.</p>\n", "tags": ["synthesis", "search"], "tsne_embedding": [16.654664993286133, 15.846090316772461]}, {"key": "wu2021prototransformer", "year": "2021", "title": "ProtoTransformer: A Meta-Learning Approach to Providing Student Feedback", "abstract": "<p>High-quality computer science education is limited by the difficulty of providing instructor feedback to students at scale. While this feedback could in principle be automated, supervised approaches to predicting the correct feedback are bottlenecked by the intractability of annotating large quantities of student code. In this paper, we instead frame the problem of providing feedback as few-shot classification, where a meta-learner adapts to give feedback to student code on a new programming question from just a few examples annotated by instructors. Because data for meta-training is limited, we propose a number of amendments to the typical few-shot learning framework, including task augmentation to create synthetic tasks, and additional side information to build stronger priors about each task. These additions are combined with a transformer architecture to embed discrete sequences (e.g. code) to a prototypical representation of a feedback class label. On a suite of few-shot natural language processing tasks, we match or outperform state-of-the-art performance. Then, on a collection of student solutions to exam questions from an introductory university course, we show that our approach reaches an average precision of 88% on unseen questions, surpassing the 82% precision of teaching assistants. Our approach was successfully deployed to deliver feedback to 16,000 student exam-solutions in a programming course offered by a tier 1 university. This is, to the best of our knowledge, the first successful deployment of a machine learning based feedback to open-ended student code.</p>\n", "tags": ["Transformer", "education"], "tsne_embedding": [19.407278060913086, 21.000423431396484]}, {"key": "xu2019commit", "year": "2019", "title": "Commit Message Generation for Source Code Changes", "abstract": "<p>Commit  messages,  which  summarize  the  source\ncode changes in natural language, are essential for\nprogram comprehension and software evolution understanding.  Unfortunately, due to the lack of direct\nmotivation,  commit  messages  are  sometimes neglected  by  developers,  making  it  necessary  to\nautomatically  generate  such  messages.    State-of-the-art  adopts  learning  based  approaches  such  as\nneural machine translation models for the commitmessage generation problem.  However, they tend\nto  ignore  the  code  structure  information  and  suffer from the out-of-vocabulary issue.\nIn this paper, we  propose  CODISUM to  address  the  above  two limitations. In particular,\nwe first extract both code structure and code semantics from the source code changes, and then\njointly model these two sources of  information  so  as  to  better  learn  the  representations\n of  the  code  changes.   Moreover,  we  augment  the  model  with  copying  mechanism  to  further\nmitigate  the  out-of-vocabulary  issue.   Experimental  evaluations  on  real  data  demonstrate  that\nthe  proposed  approach  significantly  outperforms the state-of-the-art in terms of accurately generating the commit messages.</p>\n", "tags": ["edit", "summarization"], "tsne_embedding": [1.8544466495513916, -17.97397804260254]}, {"key": "xu2019method", "year": "2019", "title": "Method name suggestion with hierarchical attention networks", "abstract": "<p>Method Rename has been a widely used refactoring operation that improves program comprehension and maintenance. Descriptive method names that summarize functionalities of source code can facilitate program comprehension. Much research has been done to suggest method names through source code summarization. However, unlike natural language, a code snippet consists of basic blocks organized by complicated structures. In this work, we observe a hierarchical structure \u2014 tokens form basic blocks and basic blocks form a code snippet. Based on this observation, we exploit a hierarchical attention network to learn the representation of methods. Specifically, we apply two-level attention mechanism to learn the importance of each token in a basic block and that of a basic block in a method respectively. We evaluated our approach on 10 open source repositories and compared it against three state-of-the-art approaches. The results on these open-source data show the superiority of our hierarchical attention networks in terms of effectiveness.</p>\n", "tags": ["naming"], "tsne_embedding": [5.268144607543945, -9.305764198303223]}, {"key": "xu2020incorporating", "year": "2020", "title": "Incorporating External Knowledge through Pre-training for Natural Language to Code Generation", "abstract": "<p>Open-domain code generation aims to generate code in a general-purpose programming language (such as Python) from natural language (NL) intents. Motivated by the intuition that developers usually retrieve resources on the web when writing code, we explore the effectiveness of incorporating two varieties of external knowledge into NL-to-code generation: automatically mined NL-code pairs from the online programming QA forum StackOverflow and programming language API documentation. Our evaluations show that combining the two sources with data augmentation and retrieval-based data re-sampling improves the current state-of-the-art by up to 2.2% absolute BLEU score on the code generation testbed CoNaLa. The code and resources are available at [Open-domain code generation aims to generate code in a general-purpose programming language (such as Python) from natural language (NL) intents. Motivated by the intuition that developers usually retrieve resources on the web when writing code, we explore the effectiveness of incorporating two varieties of external knowledge into NL-to-code generation: automatically mined NL-code pairs from the online programming QA forum StackOverflow and programming language API documentation. Our evaluations show that combining the two sources with data augmentation and retrieval-based data re-sampling improves the current state-of-the-art by up to 2.2% absolute BLEU score on the code generation testbed CoNaLa. The code and resources are available at <a href=\"https://github.com/neulab/external-knowledge-codegen\">https://github.com/neulab/external-knowledge-codegen</a>.</p>\n", "tags": ["bimodal", "code generation"], "tsne_embedding": [11.005104064941406, 0.44112733006477356]}, {"key": "xu2021capturing", "year": "2021", "title": "Capturing Structural Locality in Non-parametric Language Models", "abstract": "<p>Structural locality is a ubiquitous feature of real-world datasets, wherein data points are organized into local hierarchies. Some examples include topical clusters in text or project hierarchies in source code repositories. In this paper, we explore utilizing this structural locality within non-parametric language models, which generate sequences that reference retrieved examples from an external source. We propose a simple yet effective approach for adding locality information into such models by adding learned parameters that improve the likelihood of retrieving examples from local neighborhoods. Experiments on two different domains, Java source code and Wikipedia text, demonstrate that locality features improve model efficacy over models without access to these features, with interesting differences. We also perform an analysis of how and where locality features contribute to improved performance and why the traditionally used contextual similarity metrics alone are not enough to grasp the locality structure.</p>\n", "tags": ["language model"], "tsne_embedding": [-1.9806820154190063, 3.9325308799743652]}, {"key": "xu2022systematic", "year": "2022", "title": "A Systematic Evaluation of Large Language Models of Code", "abstract": "<p>Large language models (LMs) of code have recently shown tremendous promise in completing code and synthesizing code from natural language descriptions. However, the current state-of-the-art code LMs (e.g., Codex (Chen et al., 2021)) are not publicly available, leaving many questions about their model and data design decisions. We aim to fill in some of these blanks through a systematic evaluation of the largest existing models: Codex, GPT-J, GPT-Neo, GPT-NeoX-20B, and CodeParrot, across various programming languages. Although Codex itself is not open-source, we find that existing open-source models do achieve close results in some programming languages, although targeted mainly for natural language modeling. We further identify an important missing piece in the form of a large open-source model trained exclusively on a multi-lingual corpus of code. We release a new model, PolyCoder, with 2.7B parameters based on the GPT-2 architecture, which was trained on 249GB of code across 12 programming languages on a single machine. In the C programming language, PolyCoder outperforms all models including Codex. Our trained models are open-source and publicly available at this https URL, which enables future research and application in this area.</p>\n", "tags": ["Transformer", "language model"], "tsne_embedding": [10.652313232421875, 10.39666748046875]}, {"key": "yadavally2023partial", "year": "2023", "title": "(Partial) Program Dependence Learning", "abstract": "<p>Code fragments from developer forums often migrate to applications due to the code reuse practice. Owing to the incomplete nature of such programs, analyzing them to early determine the presence of potential vulnerabilities is challenging. In this work, we introduce NeuralPDA, a neural network-based program dependence analysis tool for both complete and partial programs. Our tool efficiently incorporates intra-statement and inter-statement contextual features into statement representations, thereby modeling program dependence analysis as a statement-pair dependence decoding task. In the empirical evaluation, we report that NeuralPDA predicts the CFG and PDG edges in complete Java and C/C++ code with combined F-scores of 94.29% and 92.46%, respectively. The F-score values for partial Java and C/C++ code range from 94.29%\u201397.17% and 92.46%\u201396.01%, respectively. We also test the usefulness of the PDGs predicted by NEURALPDA (i.e., PDG<em>) on the downstream task of method-level vulnerability detection. We discover that the performance of the vulnerability detection tool utilizing PDG</em> is only 1.1% less than that utilizing the PDGs generated by a program analysis tool. We also report the detection of 14 real-world vulnerable code snippets from StackOverflow by a machine learning-based vulnerability detection tool that employs the PDGs predicted by NeuralPDA for these code snippets.</p>\n", "tags": ["large language models", "program analysis", "static analysis", "tool"], "tsne_embedding": [-12.446455955505371, -10.09392261505127]}, {"key": "yadid2016extracting", "year": "2016", "title": "Extracting Code from Programming Tutorial Videos", "abstract": "<p>The number of programming tutorial videos on the web\nincreases daily. Video hosting sites such as YouTube host\nmillions of video lectures, with many programming tutorials for various languages and platforms. These videos contain a wealth of valuable information, including code that\nmay be of interest. However, two main challenges have so\nfar prevented the effective indexing of programming tutorial\nvideos: (i) code in tutorials is typically written on-the-fly,\nwith only parts of the code visible in each frame, and (ii) optical character recognition (OCR) is not precise enough to\nproduce quality results from videos.</p>\n\n<p>We present a novel approach for extracting code from\nvideos that is based on: (i) consolidating code across frames,\nand (ii) statistical language models for applying corrections\nat different levels, allowing us to make corrections by choosing the most likely token, combination of tokens that form a\nlikely line structure, and combination of lines that lead to\na likely code fragment in a particular language. We implemented our approach in a tool called ACE , and used it to extract code from 40 Android video tutorials on YouTube . Our\nevaluation shows that ACE extracts code with high accuracy,\nenabling deep indexing of video tutorials.</p>\n", "tags": ["information extraction"], "tsne_embedding": [-11.814733505249023, 1.0921484231948853]}, {"key": "yan2020are", "year": "2020", "title": "Are the Code Snippets What We Are Searching for? A Benchmark and an Empirical Study on Code Search with Natural-Language Queries", "abstract": "<p>Code search methods, especially those that allow programmers to raise queries in a natural language, plays an important role in software development. It helps to improve programmers\u2019 productivity by returning sample code snippets from the Internet and/or source-code repositories for their natural-language queries. Meanwhile, there are many code search methods in the literature that support natural-language queries. Difficulties exist in recognizing the strengths and weaknesses of each method and choosing the right one for different usage scenarios, because (1) the implementations of those methods and the datasets for evaluating them are usually not publicly available, and (2) some methods leverage different training datasets or auxiliary data sources and thus their effectiveness cannot be fairly measured and may be negatively affected in practical uses. To build a common ground for measuring code search methods, this paper builds CosBench, a dataset that consists of 1000 projects, 52 code-independent natural-language queries with ground truths, and a set of scripts for calculating four metrics on code research results. We have evaluated four IR (Information Retrieval)-based and two DL (Deep Learning)-based code search methods on CosBench. The empirical evaluation results clearly show the usefulness of the CosBench dataset and various strengths of each code search method. We found that DL-based methods are more suitable for queries on reusing code, and IR-based ones for queries on resolving bugs and learning API uses.</p>\n", "tags": ["search"], "tsne_embedding": [-13.808533668518066, 7.534484386444092]}, {"key": "yang2017language", "year": "2017", "title": "A Language Model for Statements of Software Code", "abstract": "<p>Building language models for source code enables a large set of improvements on traditional software engineering tasks. One promising application is automatic code completion. State-of-the-art techniques capture code regularities at token level with lexical information. Such language models are more suitable for predicting short token sequences, but become less effective with respect to long statement level predictions. In this paper, we have proposed PCC to optimize the token level based language modeling. Specifically, PCC introduced an intermediate representation (IR) for source code, which puts tokens into groups using lexeme and variable relative order. In this way, PCC is able to handle long token sequences, i.e., group sequences, to suggest a complete statement with the precise synthesizer. Further more, PCC employed a fuzzy matching technique which combined genetic and longest common sub-sequence algorithms to make the prediction more accurate. We have implemented a code completion plugin for Eclipse and evaluated it on open-source Java projects. The results have demonstrated the potential of PCC in generating precise long statement level predictions. In 30%-60% of the cases, it can correctly suggest the complete statement with only six candidates, and 40%-90% of the cases with ten candidates.</p>\n", "tags": ["language model"], "tsne_embedding": [1.4758549928665161, 9.23133659362793]}, {"key": "yang2020survey", "year": "2020", "title": "A Survey on Deep Learning for Software Engineering", "abstract": "<p>In 2006, Geoffrey Hinton proposed the concept of training \u2018\u2018Deep Neural Networks (DNNs)\u2019\u2019 and an improved model training method to break the bottleneck of neural network development. More recently, the introduction of AlphaGo in 2016 demonstrated the powerful learning ability of deep learning and its enormous potential. Deep learning has been increasingly used to develop state-of-the-art software engineering (SE) research tools due to its ability to boost performance for various SE tasks. There are many factors, e.g., deep learning model selection, internal structure differences, and model optimization techniques, that may have an impact on the performance of DNNs applied in SE. Few works to date focus on summarizing, classifying, and analyzing the application of deep learning techniques in SE. To fill this gap, we performed a survey to analyse the relevant studies published since 2006. We first provide an example to illustrate how deep learning techniques are used in SE. We then summarize and classify different deep learning techniques used in SE. We analyzed key optimization technologies used in these deep learning models, and finally describe a range of key research topics using DNNs in SE. Based on our findings, we present a set of current challenges remaining to be investigated and outline a proposed research road map highlighting key opportunities for future work.</p>\n", "tags": ["survey"], "tsne_embedding": [7.602355003356934, -24.31482696533203]}, {"key": "yao2018staqc", "year": "2018", "title": "StaQC: A Systematically Mined Question-Code Dataset from Stack Overflow", "abstract": "<p>Stack Overflow (SO) has been a great source of natural language questions and their code solutions (i.e., question-code pairs), which are critical for many tasks including code retrieval and annotation. In most existing research, question-code pairs were collected heuristically and tend to have low quality. In this paper, we investigate a new problem of systematically mining question-code pairs from Stack Overflow (in contrast to heuristically collecting them). It is formulated as predicting whether or not a code snippet is a standalone solution to a question. We propose a novel Bi-View Hierarchical Neural Network which can capture both the programming content and the textual context of a code snippet (i.e., two views) to make a prediction. On two manually annotated datasets in Python and SQL domain, our framework substantially outperforms heuristic methods with at least 15% higher F1 and accuracy. Furthermore, we present StaQC (Stack Overflow Question-Code pairs), the largest dataset to date of \u223c148K Python and \u223c120K SQL question-code pairs, automatically mined from SO using our framework. Under various case studies, we demonstrate that StaQC can greatly help develop data-hungry models for associating natural language with programming language.</p>\n", "tags": ["dataset"], "tsne_embedding": [-5.74775505065918, 4.301727294921875]}, {"key": "yao2019coacor", "year": "2019", "title": "CoaCor: Code Annotation for Code Retrieval with Reinforcement Learning", "abstract": "<p>To accelerate software development, much research has been performed\nto help people understand and reuse the huge amount of available code\nresources. Two important tasks have been widely studied: code retrieval,\nwhich aims to retrieve code snippets relevant to a given natural language\nquery from a code base, and code annotation, where the goal is to annotate a \ncode snippet with anatural language description. Despite their advancement in recent\nyears, the two tasks are mostly explored separately. In this work, we\ninvestigate a novel perspective of Code annotation for Code retrieval \n(hence called \u201cCoaCor\u201d), where a code annotation model is trained\nto generate a natural language annotation that can represent the\nsemantic meaning of a given code snippet and can be leveraged by\na code retrieval model to better distinguish relevant code snippets\nfrom others. To this end, we propose an effective framework based\non reinforcement learning, which explicitly encourages the code\nannotation model to generate annotations that can be used for the\nretrieval task. Through extensive experiments, we show that code\nannotations generated by our framework are much more detailed\nand more useful for code retrieval, and they can further improve\nthe performance of existing code retrieval models significantly.</p>\n", "tags": ["search"], "tsne_embedding": [-12.686402320861816, 5.444944381713867]}, {"key": "yasunaga2020graph", "year": "2020", "title": "Graph-based, Self-Supervised Program Repair from Diagnostic Feedback", "abstract": "<p>We consider the problem of learning to repair programs from diagnostic feedback (e.g., compiler error messages). Program repair is challenging for two reasons: First, it requires reasoning and tracking symbols across source code and diagnostic feedback. Second, labeled datasets available for program repair are relatively small. In this work, we propose novel solutions to these two challenges. First, we introduce a program-feedback graph, which connects symbols relevant to program repair in source code and diagnostic feedback, and then apply a graph neural network on top to model the reasoning process. Second, we present a self-supervised learning paradigm for program repair that leverages unlabeled programs available online to create a large amount of extra program repair examples, which we use to pre-train our models. We evaluate our proposed approach on two applications: correcting introductory programming assignments (DeepFix dataset) and correcting the outputs of program synthesis (SPoC dataset). Our final system, DrRepair, significantly outperforms prior work, achieving 66.1% full repair rate on DeepFix (+20.8% over the prior best), and 48.0% synthesis success rate on SPoC (+3.3% over the prior best).</p>\n", "tags": ["repair", "edit", "GNN"], "tsne_embedding": [-8.311524391174316, -23.30263900756836]}, {"key": "ye2020leveraging", "year": "2020", "title": "Leveraging Code Generation to Improve Code Retrieval and Summarization via Dual Learning", "abstract": "<p>Code summarization generates brief natural language description given a source code snippet, while code retrieval fetches relevant source code given a natural language query. Since both tasks aim to model the association between natural language and programming language, recent studies have combined these two tasks to improve their performance. However, researchers have yet been able to effectively leverage the intrinsic connection between the two tasks as they train these tasks in a separate or pipeline manner, which means their performance can not be well balanced. In this paper, we propose a novel end-to-end model for the two tasks by introducing an additional code generation task. More specifically, we explicitly exploit the probabilistic correlation between code summarization and code generation with dual learning, and utilize the two encoders for code summarization and code generation to train the code retrieval task via multi-task learning. We have carried out extensive experiments on an existing dataset of SQL and Python, and results show that our model can significantly improve the results of the code retrieval task over the-state-of-art models, as well as achieve competitive performance in terms of BLEU score for the code summarization task.</p>\n", "tags": ["search", "summarization"], "tsne_embedding": [6.654946327209473, -5.463353157043457]}, {"key": "ye2020misim", "year": "2020", "title": "MISIM: An End-to-End Neural Code Similarity System", "abstract": "<p>Code similarity systems are integral to a range of applications from code recommendation to automated construction of software tests and defect mitigation. In this paper, we present Machine Inferred Code Similarity (MISIM), a novel end-to-end code similarity system that consists of two core components. First, MISIM uses a novel context-aware similarity structure, which is designed to aid in lifting semantic meaning from code syntax. Second, MISIM provides a neural-based code similarity scoring system, which can be implemented with various neural network algorithms and topologies with learned parameters. We compare MISIM to three other state-of-the-art code similarity systems: (i) code2vec, (ii) Neural Code Comprehension, and (iii) Aroma. In our experimental evaluation across 45,780 programs, MISIM consistently outperformed all three systems, often by a large factor (upwards of 40.6x).</p>\n", "tags": ["code similarity"], "tsne_embedding": [-15.346502304077148, 1.0747874975204468]}, {"key": "ye2021neural", "year": "2021", "title": "Neural Program Repair with Execution-based Backpropagation", "abstract": "<p>Neural machine translation (NMT) architectures have achieved promising results for automatic program repair. Yet, they have the limitation of generating low-quality patches (e.g., not compilable patches). This is because the existing works only optimize a purely syntactic loss function based on characters and tokens without incorporating program-specific information during neural net weight optimization. In this paper, we propose a novel program repair model called RewardRepair. The core novelty of RewardRepair is to improve NMT-based program repair with a loss function based on program compilation and test execution information, rewarding the network to produce patches that compile and that do not overfit. We conduct several experiments to evaluate RewardRepair showing that it is feasible and effective to use compilation and test execution results to optimize the underlying neural repair model. In total, RewardRepair correctly repairs 43 Defects4J bugs including eight that are fixed for the first time.</p>\n", "tags": ["repair"], "tsne_embedding": [-6.011313438415527, -22.017688751220703]}, {"key": "ye2022selfapr", "year": "2022", "title": "SelfAPR: Self-supervised Program Repair with Test Execution Diagnostics", "abstract": "<p>Neural program repair has achieved good results in a recent series of papers. Yet, we observe that the related work fails to repair some bugs because of a lack of knowledge about 1) the program being repaired, and 2) the actual fault being repaired. In this paper, we solve both problems by changing the learning paradigm from supervised training to self-supervised training in an approach called SelfAPR. First, SelfAPR generates and constructs training samples by perturbing a previous version of the program being repaired, enforcing the neural model to capture project-specific knowledge. This is different from all the existing work based on past commits. Second, SelfAPR extracts and encodes test execution diagnostics into the input representation, steering the neural model to fix the specific kind of fault. This is different from the existing studies that only consider static source code in the input. We implement SelfAPR and evaluate it in a systematic manner. We train SelfAPR with 253 411 training samples obtained by perturbing 17 open-source projects. We evaluate SelfAPR on 818 bugs from Defects4J, SelfAPR correctly repairs 112 of them.</p>\n", "tags": ["repair", "execution"], "tsne_embedding": [-8.806131362915039, -22.840803146362305]}, {"key": "yefet2019adversarial", "year": "2019", "title": "Adversarial Examples for Models of Code", "abstract": "<p>Neural models of code have shown impressive performance for tasks such as predicting method names and identifying certain kinds of bugs. In this paper, we show that these models are vulnerable to adversarial examples, and introduce a novel approach for attacking trained models of code with adversarial examples. The main idea is to force a given trained model to make an incorrect prediction as specified by the adversary by introducing small perturbations that do not change the program\u2019s semantics. To find such perturbations, we present a new technique for Discrete Adversarial Manipulation of Programs (DAMP). DAMP works by deriving the desired prediction with respect to the model\u2019s inputs while holding the model weights constant and following the gradients to slightly modify the code.</p>\n\n<p>To defend a model against such attacks, we propose placing a defensive model (Anti-DAMP) in front of it. Anti-DAMP detects unlikely mutations and masks them before feeding the input to the downstream model.</p>\n\n<p>We show that our DAMP attack is effective across three neural architectures: code2vec, GGNN, and GNN-FiLM, in both Java and C#. We show that DAMP has up to 89% success rate in changing a prediction to the adversary\u2019s choice (\u201ctargeted attack\u201d), and a success rate of up to 94% in changing a given prediction to any incorrect prediction (\u201cnon-targeted attack\u201d). By using Anti-DAMP, the success rate of the attack drops drastically for both targeted and non-targeted attacks, with a minor penalty of 2% relative degradation in accuracy while not performing under attack.</p>\n", "tags": ["adversarial"], "tsne_embedding": [4.081328868865967, 22.24549674987793]}, {"key": "yin2017syntactic", "year": "2017", "title": "A Syntactic Neural Model for General-Purpose Code Generation", "abstract": "<p>We consider the problem of parsing natural language descriptions into source code\nwritten in a general-purpose programming\nlanguage like Python. Existing data-driven methods treat this problem as a language generation task without considering\nthe underlying syntax of the target programming language. Informed by previous work in semantic parsing, in this paper we propose a novel neural architecture\npowered by a grammar model to explicitly\ncapture the target syntax as prior knowledge. Experiments find this an effective\nway to scale up to generation of complex\nprograms from natural language descriptions, achieving state-of-the-art results that\nwell outperform previous code generation\nand semantic parsing approaches.</p>\n", "tags": ["code generation", "grammar", "bimodal"], "tsne_embedding": [14.574246406555176, -4.821473598480225]}, {"key": "yin2018mining", "year": "2018", "title": "Learning to Mine Aligned Code and Natural Language Pairs from Stack Overflow", "abstract": "<p>For tasks like code synthesis from natural language, code retrieval, and code summarization, data-driven models have shown great promise. However, creating these models require parallel data between natural language (NL) and code with fine-grained alignments. Stack Overflow (SO) is a promising source to create such a data set: the questions are diverse and most of them have corresponding answers with high-quality code snippets. However, existing heuristic methods (e.g., pairing the title of a post with the code in the accepted answer) are limited both in their coverage and the correctness of the NL-code pairs obtained. In this paper, we propose a novel method to mine high-quality aligned data from SO using two sets of features: hand-crafted features considering the structure of the extracted snippets, and correspondence features obtained by training a probabilistic model to capture the correlation between NL and code using neural networks. These features are fed into a classifier that determines the quality of mined NL-code pairs. Experiments using Python and Java as test beds show that the proposed method greatly expands coverage and accuracy over existing mining methods, even when using only a small number of labeled examples. Further, we find that reasonable results are achieved even when training the classifier on one language and testing on another, showing promise for scaling NL-code mining to a wide variety of programming languages beyond those for which we are able to annotate data.</p>\n\n", "tags": ["dataset"], "tsne_embedding": [-5.324411392211914, 4.517214298248291]}, {"key": "yin2019learning", "year": "2019", "title": "Learning to Represent Edits", "abstract": "<p>We introduce the problem of learning distributed representations of edits. By combining a\n\u201cneural editor\u201d with an \u201cedit encoder\u201d, our models learn to represent the salient\ninformation of an edit and can be used to apply edits to new inputs.\nWe experiment on natural language and source code edit data. Our evaluation yields\npromising results that suggest that our neural network models learn to capture\nthe structure and semantics of edits. We hope that this interesting task and\ndata source will inspire other researchers to work further on this problem.</p>\n", "tags": ["edit"], "tsne_embedding": [5.505158424377441, -16.544830322265625]}, {"key": "yonai2019mercem", "year": "2019", "title": "Mercem: Method Name Recommendation Based on Call Graph Embedding", "abstract": "<p>Comprehensibility of source code is strongly affected by identifier names, therefore software developers need to give good (e.g. meaningful but short) names to identifiers. On the other hand, giving a good name is sometimes a difficult and time-consuming task even for experienced developers. To support naming identifiers, several techniques for recommending identifier name candidates have been proposed. These techniques, however, still have challenges on the goodness of suggested candidates and limitations on applicable situations. This paper proposes a new approach to recommending method names by applying graph embedding techniques to the method call graph. The evaluation experiment confirms that the proposed technique can suggest more appropriate method name candidates in difficult situations than the state of the art approach.</p>\n", "tags": ["naming", "representation", "refactoring"], "tsne_embedding": [-21.77840232849121, -2.673940658569336]}, {"key": "yuan2017abridging", "year": "2017", "title": "Abridging Source Code", "abstract": "<p>In this paper, we consider the problem of source code abridgment, where the goal is to remove statements from a source code in order to display the source code in a small space, while at the same time leaving the ``important\u2019\u2019 parts of the source code intact, so that an engineer can read the code and quickly understand purpose of the code. To this end, we develop an algorithm that looks at a number of examples, human-created source code abridgments, and learns how to remove lines from the code in order to mimic the human abridger. The learning algorithm takes into account syntactic features of the code, as well as semantic features such as control flow and data dependencies. Through a comprehensive user study, we show that the abridgments that our system produces can decrease the time that a user must look at code in order to understand its functionality, as well as increase the accuracy of the assessment, while displaying the code in a greatly reduced area.</p>\n", "tags": ["summarization"], "tsne_embedding": [3.715242862701416, -8.808819770812988]}, {"key": "zaremba2014learning", "year": "2014", "title": "Learning to Execute", "abstract": "<p>Recurrent Neural Networks (RNNs) with Long Short-Term Memory units (LSTM) are widely used because they are expressive and are easy to train. Our interest lies in empirically evaluating the expressiveness and the learnability of LSTMs in the sequence-to-sequence regime by training them to evaluate short computer programs, a domain that has traditionally been seen as too complex for neural networks. We consider a simple class of programs that can be evaluated with a single left-to-right pass using constant memory. Our main result is that LSTMs can learn to map the character-level representations of such programs to their correct outputs. Notably, it was necessary to use curriculum learning, and while conventional curriculum learning proved ineffective, we developed a new variant of curriculum learning that improved our networks\u2019 performance in all experimental conditions. The improved curriculum had a dramatic impact on an addition problem, making it possible to train an LSTM to add two 9-digit numbers with 99% accuracy.</p>\n", "tags": ["execution", "representation"], "tsne_embedding": [17.388717651367188, -11.169681549072266]}, {"key": "zeng2022extensive", "year": "2022", "title": "An Extensive Study on Pre-trained Models for Program Understanding and Generation", "abstract": "<p>Automatic program understanding and generation techniques could\nsignificantly advance the productivity of programmers and have\nbeen widely studied by academia and industry. Recently, the advent of pre-trained paradigm enlightens researchers to develop\ngeneral-purpose pre-trained models which can be applied for a\nbroad range of program understanding and generation tasks. Such\npre-trained models, derived by self-supervised objectives on large\nunlabelled corpora, can be fine-tuned in downstream tasks (such\nas code search and code generation) with minimal adaptations. Although these pre-trained models claim superiority over the prior\ntechniques, they seldom follow equivalent evaluation protocols, e.g.,\nthey are hardly evaluated on the identical benchmarks, tasks, or settings. Consequently, there is a pressing need for a comprehensive\nstudy of the pre-trained models on their effectiveness, versatility\nas well as the limitations to provide implications and guidance for\nthe future development in this area. To this end, we first perform\nan extensive study of eight open-access pre-trained models over\na large benchmark on seven representative code tasks to assess\ntheir reproducibility. We further compare the pre-trained models\nand domain-specific state-of-the-art techniques for validating pre-trained effectiveness. At last, we investigate the robustness of the\npre-trained models by inspecting their performance variations under adversarial attacks. Through the study, we find that while we\ncan in general replicate the original performance of the pre-train\nmodels on their evaluated tasks and adopted benchmarks, subtle\nperformance fluctuations can refute the findings in their original\npapers. Moreover, none of the existing pre-trained models can dominate over all other models. We also find that the pre-trained models\ncan significantly outperform non-pre-trained state-of-the-art techniques in program understanding tasks. Furthermore, we perform\nthe first study for natural language-programming language pre-trained model robustness via adversarial attacks and find that a\nsimple random attack approach can easily fool the state-of-the-art\npre-trained models and thus incur security issues. At last, we also\nprovide multiple practical guidelines for advancing future research\non pre-trained models for program understanding and generation.</p>\n", "tags": ["Transformer", "evaluation"], "tsne_embedding": [13.403643608093262, 9.145143508911133]}, {"key": "zhang2019learning", "year": "2019", "title": "Learning Uniform Semantic Features for Natural Language and Programming Language Globally, Locally and Sequentially", "abstract": "<p>Semantic feature learning for natural language and programming language is a preliminary step in addressing many software mining tasks. Many existing methods leverage\ninformation in lexicon and syntax to learn features for textual data.\nHowever, such information is inadequate to represent the entire semantics in either text sentence or code snippet. This\nmotivates us to propose a new approach to learn semantic\nfeatures for both languages, through extracting three levels of\ninformation, namely global, local and sequential information,\nfrom textual data. For tasks involving both modalities, we\nproject the data of both types into a uniform feature space so\nthat the complementary knowledge in between can be utilized\nin their representation. In this paper, we build a novel and\ngeneral-purpose feature learning framework called UniEmbed, to uniformly learn comprehensive semantic representation for both natural language and programming language.\nExperimental results on three real-world software mining\ntasks show that UniEmbed outperforms state-of-the-art models in feature learning and prove the capacity and effectiveness of our model.</p>\n", "tags": ["representation", "bimodal"], "tsne_embedding": [-4.291875839233398, 4.074631214141846]}, {"key": "zhang2019novel", "year": "2019", "title": "A Novel Neural Source Code Representation based on Abstract Syntax Tree", "abstract": "<p>Exploiting machine learning techniques for analyzing programs has attracted much attention. One key problem is how to represent code fragments well for follow-up analysis. Traditional information retrieval based methods often treat programs as natural language texts, which could miss important semantic information of source code. Recently, state-of-the-art studies demonstrate that abstract syntax tree (AST) based neural models can better represent source code. However, the sizes of ASTs are usually large and the existing models are prone to the long-term dependency problem. In this paper, we propose a novel AST-based Neural Network (ASTNN) for source code representation. Unlike existing models that work on entire ASTs, ASTNN splits each large AST into a sequence of small statement trees, and encodes the statement trees to vectors by capturing the lexical and syntactical knowledge of statements. Based on the sequence of statement vectors, a bidirectional RNN model is used to leverage the naturalness of statements and finally produce the vector representation of a code fragment. We have applied our neural network based source code representation method to two common program comprehension tasks: source code classification and code clone detection. Experimental results on the two tasks indicate that our model is superior to state-of-the-art approaches.</p>\n", "tags": ["representation", "grammar"], "tsne_embedding": [-9.57864761352539, -3.004723310470581]}, {"key": "zhang2020generating", "year": "2020", "title": "Generating Adversarial Examples for Holding Robustness of Source Code Processing Models", "abstract": "<p>Automated  processing,  analysis,  and  generation  of  source code are among the key activities\nin software and system life-cycle. To this end, while deep learning (DL) exhibits a certain level\nof capability in handling these tasks, the current state-of-the-art DL models still suffer from\nnon-robust issues and can be easily fooled by adversarial attacks.</p>\n\n<p>Different  from  adversarial \nattacks  for  image,  audio,  andnatural  languages,  the  structured  nature  of  programming\nlanguages  brings  new  challenges.  In  this  paper,  we  propose a Metropolis-Hastings\nsampling-based identifier renaming technique, named Metropolis-Hastings Modifier (MHM),\nwhich  generates  adversarial  examples  for  DL  models  specialized for source code processing.\nOur in-depth evaluation on a functionality classification benchmark demonstrates the\neffectiveness  of  MHM  in  generating  adversarial  examples of source code. The higher robustness\nand performance enhanced through our  adversarial training with MHM further confirms the usefulness\nof DL models-based method for future fully automated source code processing.</p>\n", "tags": ["adversarial"], "tsne_embedding": [2.4102838039398193, 22.52058982849121]}, {"key": "zhang2021bag", "year": "2021", "title": "Bag-of-Words Baselines for Semantic Code Search", "abstract": "<p>The task of semantic code search is to retrieve code snippets from a source code corpus based on an information need expressed in natural language. The semantic gap between natural language and programming languages has for long been regarded as one of the most significant obstacles to the effectiveness of keyword-based information retrieval (IR) methods. It is a common assumption that \u201ctraditional\u201d bag-of-words IR methods are poorly suited for semantic code search: our work empirically investigates this assumption. Specifically, we examine the effectiveness of two traditional IR methods, namely BM25 and RM3, on the CodeSearchNet Corpus, which consists of natural language queries paired with relevant code snippets. We find that the two keyword-based methods outperform several pre-BERT neural models. We also compare several code-specific data pre-processing strategies and find that specialized tokenization improves effectiveness.</p>\n", "tags": ["search"], "tsne_embedding": [-13.553844451904297, 6.541263103485107]}, {"key": "zhang2021disentangled.md", "year": "2021", "title": "Disentangled Code Representation Learning for Multiple Programming Languages", "abstract": "<p>Developing effective distributed representations of source code is fundamental yet challenging for many software engineering tasks such as code clone detection, code search, code translation and transformation. However, current code embedding approaches that represent the semantic and syntax of code in a mixed way are less interpretable and the resulting embedding can not be easily generalized across programming languages. In this paper, we propose a disentangled code representation learning approach to separate the semantic from the syntax of source code under a multi-programming-language setting, obtaining better interpretability and generalizability. Specially, we design three losses dedicated to the characteristics of source code to enforce the disentanglement effectively. We conduct comprehensive experiments on a real-world dataset composed of programming exercises implemented by multiple solutions that are semantically identical but grammatically distinguished. The experimental results validate the superiority of our proposed disentangled code representation, compared to several baselines, across three types of downstream tasks, i.e., code clone detection, code translation, and code-to-code search.</p>\n", "tags": ["representation"], "tsne_embedding": [1.6591492891311646, -3.9077413082122803]}, {"key": "zhang2022coditt5", "year": "2022", "title": "CoditT5: Pretraining for Source Code and Natural Language Editing", "abstract": "<p>Pretrained language models have been shown to be effective in many software-related generation tasks; however, they are not well-suited for editing tasks as they are not designed to reason about edits. To address this, we propose a novel pretraining objective which explicitly models edits and use it to build CoditT5, a large language model for software-related editing tasks that is pretrained on large amounts of source code and natural language comments. We fine-tune it on various downstream editing tasks, including comment updating, bug fixing, and automated code review. By outperforming pure generation-based models, we demonstrate the generalizability of our approach and its suitability for editing tasks. We also show how a pure generation model and our edit-based model can complement one another through simple reranking strategies, with which we achieve state-of-the-art performance for the three downstream editing tasks.</p>\n", "tags": ["Transformer", "edit"], "tsne_embedding": [3.3953235149383545, -15.177905082702637]}, {"key": "zhang2023repocoder", "year": "2023", "title": "RepoCoder: Repository-Level Code Completion Through Iterative Retrieval and Generation", "abstract": "<p>The task of repository-level code completion is to continue writing the unfinished code based on a broader context of the repository. While for automated code completion tools, it is difficult to utilize the useful information scattered in different files. We propose RepoCoder, a simple, generic, and effective framework to address the challenge. It streamlines the repository-level code completion process by incorporating a similarity-based retriever and a pre-trained code language model, which allows for the effective utilization of repository-level information for code completion and grants the ability to generate code at various levels of granularity. Furthermore, RepoCoder utilizes a novel iterative retrieval-generation paradigm that bridges the gap between retrieval context and the intended completion target. We also propose a new benchmark RepoEval, which consists of the latest and high-quality real-world repositories covering line, API invocation, and function body completion scenarios. We test the performance of RepoCoder by using various combinations of code retrievers and generators. Experimental results indicate that RepoCoder significantly improves the zero-shot code completion baseline by over 10% in all settings and consistently outperforms the vanilla retrieval-augmented code completion approach. Furthermore, we validate the effectiveness of RepoCoder through comprehensive analysis, providing valuable insights for future research.</p>\n", "tags": ["completion", "Transformer", "retrieval"], "tsne_embedding": [0.9525768756866455, 12.717063903808594]}, {"key": "zhao2018neural", "year": "2018", "title": "Neural-Augumented Static Analysis of Android Communication", "abstract": "<p>We address the problem of discovering communication links between applications in the popular Android mobile operating system, an important problem for security and privacy in Android. Any scalable static analysis in this complex setting is bound to produce an excessive amount of false-positives, rendering it impractical. To improve precision, we propose to augment static analysis with a trained neural-network model that estimates the probability that a communication link truly exists. We describe a neural-network architecture that encodes abstractions of communicating objects in two applications and estimates the probability with which a link indeed exists. At the heart of our architecture are type-directed encoders (TDE), a general framework for elegantly constructing encoders of a compound data type by recursively composing encoders for its constituent types. We evaluate our approach on a large corpus of Android applications, and demonstrate that it achieves very high accuracy. Further, we conduct thorough interpretability studies to understand the internals of the learned neural networks.</p>\n", "tags": ["program analysis"], "tsne_embedding": [-11.746541023254395, 19.040143966674805]}, {"key": "zhao2019neural", "year": "2019", "title": "Neural Networks for Modeling Source Code Edits", "abstract": "<p>Programming languages are emerging as a challenging and interesting domain for machine learning. A core task, which has received significant attention in recent years, is building generative models of source code. However, to our knowledge, previous generative models have always been framed in terms of generating static snapshots of code. In this work, we instead treat source code as a dynamic object and tackle the problem of modeling the edits that software developers make to source code files. This requires extracting intent from previous edits and leveraging it to generate subsequent edits. We develop several neural networks and use synthetic data to test their ability to learn challenging edit patterns that require strong generalization. We then collect and train our models on a large-scale dataset of Google source code, consisting of millions of fine-grained edits from thousands of Python developers. From the modeling perspective, our main conclusion is that a new composition of attentional and pointer network components provides the best overall performance and scalability. From the application perspective, our results provide preliminary evidence of the feasibility of developing tools that learn to predict future edits.</p>\n", "tags": ["edit"], "tsne_embedding": [5.09763240814209, -15.392183303833008]}, {"key": "zhong2018generating", "year": "2018", "title": "Generating Regular Expressions from Natural Language Specifications: Are We There Yet?", "abstract": "<p>Recent  state-of-the-art  approaches  automatically  generate\nregular  expressions  from  natural  language  specifications.\nGiven that these approaches use only synthetic data in both\ntraining datasets and validation/test datasets, a natural question arises: are these approaches effective to address various\nreal-world  situations?  To  explore  this  question,  in  this  paper, we conduct a characteristic study on comparing two synthetic datasets used by the recent research and a real-world\ndataset  collected  from  the  Internet,  and  conduct  an  experimental study on applying a state-of-the-art approach on the\nreal-world dataset. Our study results suggest the existence of\ndistinct characteristics between the synthetic datasets and the\nreal-world  dataset,  and  the  state-of-the-art  approach  (based\non  a  model  trained  from  a  synthetic  dataset)  achieves  extremely low effectiveness when evaluated on real-world data,\nmuch lower than the effectiveness when evaluated on the synthetic  dataset.  We  also  provide  initial  analysis  on  some  of\nthose challenging cases and discuss future directions.</p>\n", "tags": ["bimodal", "code generation"], "tsne_embedding": [21.223936080932617, -0.7360944151878357]}, {"key": "zhong2020semantic", "year": "2020", "title": "Semantic Scaffolds for Pseudocode-to-Code Generation", "abstract": "<p>We propose a method for program generation based on semantic scaffolds, lightweight structures representing the high-level semantic and syntactic composition of a program. By first searching over plausible scaffolds then using these as constraints for a beam search over programs, we achieve better coverage of the search space when compared with existing techniques. We apply our hierarchical search method to the SPoC dataset for pseudocode-to-code generation, in which we are given line-level natural language pseudocode annotations and aim to produce a program satisfying execution-based test cases. By using semantic scaffolds during inference, we achieve a 10% absolute improvement in top-100 accuracy over the previous state-of-the-art. Additionally, we require only 11 candidates to reach the top-3000 performance of the previous best approach when tested against unseen problems, demonstrating a substantial improvement in efficiency.</p>\n", "tags": ["code generation", "synthesis"], "tsne_embedding": [17.298912048339844, 2.717190980911255]}, {"key": "zhou2019devign", "year": "2020", "title": "Devign: Effective Vulnerability Identification by Learning Comprehensive Program Semantics via Graph Neural Networks", "abstract": "<p>Vulnerability identification is crucial to protect the software systems from attacks for cyber security. It is especially important to localize the vulnerable functions among the source code to facilitate the fix. However, it is a challenging and tedious process, and also requires specialized security expertise. Inspired by the work on manually-defined patterns of vulnerabilities from various code representation graphs and the recent advance on graph neural networks, we propose Devign, a general graph neural network based model for graph-level classification through learning on a rich set of code semantic representations. It includes a novel Conv module to efficiently extract useful features in the learned rich node representations for graph-level classification. The model is trained over manually labeled datasets built on 4 diversified large-scale open-source C projects that incorporate high complexity and variety of real source code instead of synthesis code used in previous works. The results of the extensive evaluation on the datasets demonstrate that Devign outperforms the state of the arts significantly with an average of 10.51% higher accuracy and 8.68% F1 score, increases averagely 4.66% accuracy and 6.37% F1 by the Conv module.</p>\n", "tags": ["GNN", "static analysis"], "tsne_embedding": [-15.835976600646973, -9.683307647705078]}, {"key": "zhou2021improving", "year": "2021", "title": "Improving Code Autocompletion with Transfer Learning", "abstract": "<p>Software language models have achieved promising results predicting code completion usages, and several industry studies have described successful IDE integrations. Recently, accuracy in autocompletion prediction improved 12.8% from training on a real-world dataset collected from programmers\u2019 IDE activity. But what if limited examples of IDE autocompletion in the target programming language are available for model training? In this paper, we investigate the efficacy of pretraining autocompletion models on non-IDE, non-autocompletion, and different-language example code sequences. We find that these unsupervised pretrainings improve model accuracy by over 50% on very small fine-tuning datasets and over 10% on 50k labeled examples. We confirm the real-world impact of these pretrainings in an online setting through A/B testing on thousands of IDE autocompletion users, finding that pretraining is responsible for increases of up to 6.63% autocompletion usage.</p>\n", "tags": ["autocomplete", "Transformer"], "tsne_embedding": [5.660480499267578, 12.58328628540039]}, {"key": "zhou2022codebertscore", "year": "2023", "title": "CodeBERTScore: Evaluating Code Generation with Pretrained Models of Code", "abstract": "<p>Since the rise of neural models of code that can generate long expressions and statements rather than a single next-token, one of the major problems has been reliably evaluating their generated output. In this paper, we propose CodeBERTScore: an automatic evaluation metric for code generation, which builds on BERTScore (Zhang et al., 2020). Instead of measuring exact token matching as BLEU, CodeBERTScore computes a soft similarity score between each token in the generated code and in the reference code, using the contextual encodings of large pretrained models. Further, instead of encoding only the generated tokens as in BERTScore, CodeBERTScore also encodes the programmatic context surrounding the generated code. We perform an extensive evaluation of CodeBERTScore across four programming languages. We find that CodeBERTScore achieves a higher correlation with human preference and with functional correctness than all existing metrics. That is, generated code that receives a higher score by CodeBERTScore is more likely to be preferred by humans, as well as to function correctly when executed. Finally, while CodeBERTScore can be used with a multilingual CodeBERT as its base model, we release five language-specific pretrained models to use with our publicly available code at https://github.com/neulab/code-bert-score . Our language-specific models have been downloaded more than 25,000 times from the Huggingface Hub.</p>\n", "tags": ["evaluation", "Transformer"], "tsne_embedding": [6.603870391845703, 1.9108211994171143]}, {"key": "zhou2022docoder", "year": "2022", "title": "DocCoder: Generating Code by Retrieving and Reading Docs", "abstract": "<p>Natural-language-to-code models learn to generate a code snippet given a natural language (NL) intent. However, the rapid growth of both publicly available and proprietary libraries and functions makes it impossible to cover all APIs using training examples, as new libraries and functions are introduced daily. Thus, existing models inherently cannot generalize to using unseen functions and libraries merely through incorporating them into the training data. In contrast, when human programmers write programs, they frequently refer to textual resources such as code manuals, documentation, and tutorials, to explore and understand available library functionality. Inspired by this observation, we introduce DocCoder: an approach that explicitly leverages code manuals and documentation by (1) retrieving the relevant documentation given the NL intent, and (2) generating the code based on the NL intent and the retrieved documentation. Our approach is general, can be applied to any programming language, and is agnostic to the underlying neural model. We demonstrate that DocCoder consistently improves NL-to-code models: DocCoder achieves 11x higher exact match accuracy than strong baselines on a new Bash dataset tldr; on the popular Python CoNaLa benchmark, DocCoder improves over strong baselines by 1.65 BLEU.</p>\n", "tags": ["Transformer", "search", "code generation"], "tsne_embedding": [12.553238868713379, 0.9674846529960632]}, {"key": "zhu2020ocor", "year": "2020", "title": "OCoR: An Overlapping-Aware Code Retriever", "abstract": "<p>Code retrieval helps developers reuse the code snippet in the open-source projects. Given a natural language description, code retrieval aims to search for the most relevant code among a set of code. Existing state-of-the-art approaches apply neural networks to code retrieval. However, these approaches still fail to capture an important feature: overlaps. The overlaps between different names used by different people indicate that two different names may be potentially related (e.g., \u201cmessage\u201d and \u201cmsg\u201d), and the overlaps between identifiers in code and words in natural language descriptions indicate that the code snippet and the description may potentially be related. To address these problems, we propose a novel neural architecture named OCoR, where we introduce two specifically-designed components to capture overlaps: the first embeds identifiers by character to capture the overlaps between identifiers, and the second introduces a novel overlap matrix to represent the degrees of overlaps between each natural language word and each identifier.\nThe evaluation was conducted on two established datasets. The experimental results show that OCoR significantly outperforms the existing state-of-the-art approaches and achieves 13.1% to 22.3% improvements. Moreover, we also conducted several in-depth experiments to help understand the performance of different components in OCoR.</p>\n", "tags": ["search"], "tsne_embedding": [-13.981573104858398, 3.882632255554199]}, {"key": "zhu2921syntax", "year": "2021", "title": "A Syntax-Guided Edit Decoder for Neural Program Repair", "abstract": "<p>Automated Program Repair (APR) helps improve the efficiency of software development and maintenance. Recent APR techniques use deep learning, particularly the encoder-decoder architecture, to generate patches.\nThough existing DL-based APR approaches have proposed different encoder architectures, the decoder remains to be the standard one, which generates a sequence of tokens one by one to replace the faulty statement.\nThis decoder has multiple limitations: 1) allowing to generate syntactically incorrect programs, 2) inefficiently representing small edits, and 3) not being able to generate project-specific identifiers.\nIn this paper, we propose Recoder, a syntax-guided edit decoder with placeholder generation. Recoder is novel in multiple aspects: 1) Recoder generates edits rather than modified code, allowing efficient representation of small edits; 2) Recoder is syntax-guided, with the novel provider/decider architecture to ensure the syntactic correctness of the patched program and accurate generation; 3) Recoder generates placeholders that could be instantiated as project-specific identifiers later.\nWe conduct experiments to evaluate Recoder on 395 bugs from Defects4J v1.2, 420 additional bugs from Defects4J v2.0, 297 bugs from IntroClassJava and 40 bugs from QuixBugs. Our results show that Recoder repairs 53 bugs on Defects4J v1.2, which achieves 26.2% (11 bugs) improvement over the previous state-of-the-art approach for single-hunk bugs (TBar). Importantly, to our knowledge, Recoder is the first DL-based APR approach that has outperformed the traditional APR approaches on this benchmark.</p>\n", "tags": ["edit"], "tsne_embedding": [-6.538028240203857, -19.724653244018555]}, {"key": "ziegler2022productivity", "year": "2022", "title": "Productivity Assessment of Neural Code Completion", "abstract": "<p>Neural code synthesis has reached a point where snippet generation is accurate enough to be considered for integration into human software development workflows. Commercial products aim to increase programmers\u2019 productivity, without being able to measure it directly. In this case study, we asked users of GitHub Copilot about its impact on their productivity, and sought to find a reflection of their perception in directly measurable user data. We find that the rate with which shown suggestions are accepted, rather than more specific metrics regarding the persistence of completions in the code over time, drives developers\u2019 perception of productivity.</p>\n", "tags": ["evaluation", "human evaluation"], "tsne_embedding": [4.665689468383789, 13.87075424194336]}, {"key": "zlotchevski2022exploring", "year": "2022", "title": "Exploring and Evaluating Personalized Models for Code Generation", "abstract": "<p>Large Transformer models achieved the state-of-the-art status for Natural Language Understanding tasks and are increasingly becoming the baseline model architecture for modeling source code. Transformers are usually pre-trained on large unsupervised corpora, learning token representations and transformations relevant to modeling generally available text, and are then fine-tuned on a particular downstream task of interest. While fine-tuning is a tried-and-true method for adapting a model to a new domain \u2013 for example, question-answering on a given topic \u2013 generalization remains an on-going challenge. In this paper, we explore and evaluate transformer model fine-tuning for personalization. In the context of generating unit tests for Java methods, we evaluate learning to personalize to a specific software project using several personalization techniques. We consider three key approaches: (i) custom fine-tuning, which allows all the model parameters to be tuned; (ii) lightweight fine-tuning, which freezes most of the model\u2019s parameters, allowing tuning of the token embeddings and softmax layer only or the final layer alone; (iii) prefix tuning, which keeps model parameters frozen, but optimizes a small project-specific prefix vector. Each of these techniques offers a trade-off in total compute cost and predictive performance, which we evaluate by code and task-specific metrics, training time, and total computational operations. We compare these fine-tuning strategies for code generation and discuss the potential generalization and cost benefits of each in various deployment scenarios.</p>\n", "tags": ["Transformer"], "tsne_embedding": [15.180351257324219, 6.636519432067871]}, {"key": "zugner2021language", "year": "2021", "title": "Language-Agnostic Representation Learning of Source Code from Structure and Context", "abstract": "<p>Source code (Context) and its parsed abstract syntax tree (AST; Structure) are two complementary representations of the same computer program. Traditionally, designers of machine learning models have relied predominantly either on Structure or Context. We propose a new model, which jointly learns on Context and Structure of source code. In contrast to previous approaches, our model uses only language-agnostic features, i.e., source code and features that can be computed directly from the AST. Besides obtaining state-of-the-art on monolingual code summarization on all five programming languages considered in this work, we propose the first multilingual code summarization model. We show that jointly training on non-parallel data from multiple programming languages improves results on all individual languages, where the strongest gains are on low-resource languages. Remarkably, multilingual training only from Context does not lead to the same improvements, highlighting the benefits of combining Structure and Context for representation learning on code.</p>\n", "tags": ["Transformer", "representation"], "tsne_embedding": [8.150574684143066, -6.2134175300598145]}]
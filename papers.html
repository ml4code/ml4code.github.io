<!DOCTYPE html>
<html lang="en-us">

  <head>
  <!-- Global Site Tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-107339008-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments)};
    gtag('js', new Date());
    gtag('config', 'UA-107339008-1');
  </script>

  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="keywords" content="machine learning, source code, big code, naturalness, software engineering, programming languages">

  <title>
    
      Search all Publications on Machine Learning for Source Code &middot; Machine Learning for Big Code and Naturalness
    
  </title>

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="shortcut icon" href="/public/favicon.svg">
  <link rel="search" href="/public/opensearchdescription.xml" 
      type="application/opensearchdescription+xml" 
      title="ML4Code" />

  <script src="https://code.jquery.com/jquery-3.2.1.min.js"
  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
  crossorigin="anonymous"></script>
  
  <link rel="stylesheet" type="text/css" href="//cdn.datatables.net/1.10.16/css/jquery.dataTables.min.css">
  <script type="text/javascript" charset="utf8" src="//cdn.datatables.net/1.10.16/js/jquery.dataTables.min.js"></script>
</head>


  <body class="theme-base-0d layout-reverse">

    <a href='/contributing.html' class='ribbon'>Contribute to ML4Code</a>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Machine Learning for Big Code and Naturalness
        </a>
      </h1>
      <p class="lead">Research on machine learning for source code.</p>      
    </div>

  <nav class="sidebar-nav">
   <div class="sidebar-item"><p style="font-size: 12px">Search related work <input type='text' id='searchTarget' size="16"/> <button onClick="search();">Go</button></p></div>
   <a class="sidebar-nav-item active" href="/papers.html">List of Papers</a>
   <a class="sidebar-nav-item" href="/tags.html">Papers by Tag</a>
   <a class="sidebar-nav-item" href="/tsne-viz.html">2D Map of Papers</a>
   <a class="sidebar-nav-item" href="/topic-viz.html">Topic-based Explorer</a>


  <a class="sidebar-nav-item" href="/resources.html">Resources, Courses &#38; Events</a>
  <a class="sidebar-nav-item" href="/contributing.html">Contributing</a>
  </nav>

  <div class="sidebar-item">
    <p style="font-size: 12px">Contact <a href="https://miltos.allamanis.com">Miltos Allamanis</a> about this survey or website.
    <span style="font-size: 9px">
      Made with <a href="https://jekyllrb.com">Jekyll</a> and <a href="https://github.com/poole/hyde">Hyde</a>.
    </span></p>
  </div>
</div></div>

<script>
$("#searchTarget").keydown(function (e) {	
  if (e.keyCode == 13) {
    search();
  }
});

function search() {
  try {
    ga('send', 'event', 'search', 'search', $("#searchTarget").val());
  } finally {
    window.location = "/papers.html#" + $("#searchTarget").val();
  }
}
</script>


    <div class="content container">
      Search across all paper titles, abstracts, authors by using the search field.
Please consider <a href="/contributing.html">contributing</a> by updating
the information of existing papers or adding new work.

<table id="allPapers">
<thead><th>Year</th><th>Title</th><th>Authors</th><th>Venue</th><th>Abstract</th></thead><tbody>



<tr>
	<td>2024</td>
	<td><a href="/publications/tan2024llm4decompile/">LLM4Decompile: Decompiling Binary Code with Large Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=LLM4Decompile: Decompiling Binary Code with Large Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=LLM4Decompile: Decompiling Binary Code with Large Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hanzhuo Tan, Qi Luo, Jing Li, Yuqun Zhang</td>
	<td></td>
	<td><p>Decompilation aims to restore compiled code to human-readable source code, but struggles with details like names and structure. Large language models (LLMs) show promise for programming tasks, motivating their application to decompilation. However, there does not exist any open-source LLM for decompilation. Moreover, existing decompilation evaluation systems mainly consider token-level accuracy and largely ignore code executability, which is the most important feature of any program. Therefore, we release the first open-access decompilation LLMs ranging from 1B to 33B pre-trained on 4 billion tokens of C source code and the corresponding assembly code. The open-source LLMs can serve as baselines for further development in the field. To ensure practical program evaluation, we introduce Decompile-Eval, the first dataset that considers re-compilability and re-executability for decompilation. The benchmark emphasizes the importance of evaluating the decompilation model from the perspective of program semantics. Experiments indicate that our LLM4Decompile has demonstrated the capability to accurately decompile 21% of the assembly code, which achieves a 50% improvement over GPT-4. Our code, dataset, and models are released at this <a href="https://github.com/albertan017/LLM4Decompile">https URL</a></p>
</td>
	<td>decompilation translation evaluation large language models LLM </td>
</tr>

<tr>
	<td>2024</td>
	<td><a href="/publications/li2024rewriting/">Rewriting the Code: A Simple Method for Large Language Model Augmented Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Rewriting the Code: A Simple Method for Large Language Model Augmented Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Rewriting the Code: A Simple Method for Large Language Model Augmented Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Haochen Li, Xin Zhou, Zhiqi Shen</td>
	<td></td>
	<td><p>In code search, the Generation-Augmented Retrieval (GAR) framework, which generates exemplar code snippets to augment queries, has emerged as a promising strategy to address the principal challenge of modality misalignment between code snippets and natural language queries, particularly with the demonstrated code generation capabilities of Large Language Models (LLMs). Nevertheless, our preliminary investigations indicate that the improvements conferred by such an LLM-augmented framework are somewhat constrained. This limitation could potentially be ascribed to the fact that the generated codes, albeit functionally accurate, frequently display a pronounced stylistic deviation from the ground truth code in the codebase. In this paper, we extend the foundational GAR framework and propose a simple yet effective method that additionally Rewrites the Code (ReCo) within the codebase for style normalization. Experimental results demonstrate that ReCo significantly boosts retrieval accuracy across sparse (up to 35.7%), zero-shot dense (up to 27.6%), and fine-tuned dense (up to 23.6%) retrieval settings in diverse search scenarios. To further elucidate the advantages of ReCo and stimulate research in code style normalization, we introduce Code Style Similarity, the first metric tailored to quantify stylistic similarities in code. Notably, our empirical findings reveal the inadequacy of existing metrics in capturing stylistic nuances.</p>
</td>
	<td>search large language models metrics </td>
</tr>

<tr>
	<td>2024</td>
	<td><a href="/publications/gharibi2024t5apr/">T5APR: Empowering Automated Program Repair across Languages through Checkpoint Ensemble</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=T5APR: Empowering Automated Program Repair across Languages through Checkpoint Ensemble' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=T5APR: Empowering Automated Program Repair across Languages through Checkpoint Ensemble' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Reza Gharibi, Mohammad Hadi Sadreddini, Seyed Mostafa Fakhrahmad</td>
	<td></td>
	<td><p>Automated program repair (APR) using deep learning techniques has become an important area of research in recent years, aiming to automatically generate bug-fixing patches that can improve software reliability and maintainability. However, most existing methods either target a single language or require high computational resources to train multilingual models. In this paper, we propose T5APR, a novel neural program repair approach that provides a unified solution for bug fixing across multiple programming languages. T5APR leverages CodeT5, a powerful pre-trained text-to-text transformer model, and adopts a checkpoint ensemble strategy to improve patch recommendation. We conduct comprehensive evaluations on six well-known benchmarks in four programming languages (Java, Python, C, JavaScript), demonstrating T5APR’s competitiveness against state-of-the-art techniques. T5APR correctly fixes 1,985 bugs, including 1,442 bugs that none of the compared techniques has fixed. We further support the effectiveness of our approach by conducting detailed analyses, such as comparing the correct patch ranking among different techniques. The findings of this study demonstrate the potential of T5APR for use in real-world applications and highlight the importance of multilingual approaches in the field of APR.</p>
</td>
	<td>repair Transformer </td>
</tr>

<tr>
	<td>2024</td>
	<td><a href="/publications/ahmed2024studying/">Studying LLM Performance on Closed- and Open-source Data</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Studying LLM Performance on Closed- and Open-source Data' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Studying LLM Performance on Closed- and Open-source Data' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Toufique Ahmed, Christian Bird, Premkumar Devanbu, Saikat Chakraborty</td>
	<td></td>
	<td><p>Large Language models (LLMs) are finding wide use in software engineering practice. These models are extremely data-hungry, and are largely trained on open-source (OSS) code distributed with permissive licenses. In terms of actual use however, a great deal of software development still occurs in the for-profit/proprietary sphere, where the code under development is not, and never has been, in the public domain; thus, many developers, do their work, and use LLMs, in settings where the models may not be as familiar with the code under development. In such settings, do LLMs work as well as they do for OSS code? If not, what are the differences? When performance differs, what are the possible causes, and are there work-arounds? In this paper, we examine this issue using proprietary, closed-source software data from Microsoft, where most proprietary code is in C# and C++. We find that performance for C# changes little from OSS –&gt; proprietary code, but does significantly reduce for C++; we find that this difference is attributable to differences in identifiers. We also find that some performance degradation, in some cases, can be ameliorated efficiently by in-context learning.</p>
</td>
	<td>Transformers </td>
</tr>



<tr>
	<td>2023</td>
	<td><a href="/publications/wei2023typet5/">TypeT5: Seq2seq Type Inference using Static Analysis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=TypeT5: Seq2seq Type Inference using Static Analysis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=TypeT5: Seq2seq Type Inference using Static Analysis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jiayi Wei, Greg Durrett, Isil Dillig</td>
	<td>ICLR</td>
	<td><p>There has been growing interest in automatically predicting missing type annotations in programs written in Python and JavaScript. While prior methods have achieved impressive accuracy when predicting the most common types, they often perform poorly on rare or complex types. In this paper, we present a new type inference method that treats type prediction as a code infilling task by leveraging CodeT5, a state-of-the-art seq2seq pre-trained language model for code. Our method uses static analysis to construct dynamic contexts for each code element whose type signature is to be predicted by the model. We also propose an iterative decoding scheme that incorporates previous type predictions in the model’s input context, allowing information exchange between related code elements. Our evaluation shows that the proposed approach, TypeT5, not only achieves a higher overall accuracy (particularly on rare and complex types) but also produces more coherent results with fewer type errors – while enabling easy user intervention.</p>
</td>
	<td>types Transformer </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/wang2023deepvd/">DeepVD: Toward Class-Separation Features for Neural Network Vulnerability Detection</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DeepVD: Toward Class-Separation Features for Neural Network Vulnerability Detection' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DeepVD: Toward Class-Separation Features for Neural Network Vulnerability Detection' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Wenbo Wang, Tien N. Nguyen, Shaohua Wang, Yi Li, Jiyuan Zhang, Aashish Yadavally</td>
	<td>ICSE</td>
	<td><p>The advances of machine learning (ML) including deep learning (DL) have enabled several approaches to implicitly learn vulnerable code patterns to automatically detect software vulnerabilities. A recent study showed that despite successes, the existing ML/DL-based vulnerability detection (VD) models are limited in the ability to distinguish between the two classes of vulnerability and benign code. We propose DeepVD, a graph-based neural network VD model that emphasizes on class-separation features between vulnerability and benign code. DeepVD leverages three types of class-separation features at different levels of abstraction: statement types (similar to Part-of-Speech tagging), Post-Dominator Tree (covering regular flows of execution), and Exception Flow Graph (covering the exception and error-handling flows). We conducted several experiments to evaluate DeepVD in a real-world vulnerability dataset of 303 projects with 13,130 vulnerable methods. Our results show that DeepVD relatively improves over the state-of-the-art ML/DL-based VD approaches 13%–29.6% in precision, 15.6%–28.9% in recall, and 16.4%–25.8% in F-score. Our ablation study confirms that our designed features and components help DeepVD achieve high class-separability for vulnerability and benign code.</p>
</td>
	<td>vulnerability </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/wang2023codet5/">CodeT5+: Open Code Large Language Models for Code Understanding and Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeT5+: Open Code Large Language Models for Code Understanding and Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeT5+: Open Code Large Language Models for Code Understanding and Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yue Wang, Hung Le, Akhilesh Deepak Gotmare, Nghi D. Q. Bui, Junnan Li, Steven C. H. Hoi</td>
	<td></td>
	<td><p>Large language models (LLMs) pretrained on vast source code have achieved prominent progress in code intelligence. However, existing code LLMs have two main limitations in terms of architecture and pretraining tasks. First, they often adopt a specific architecture (encoder-only or decoder-only) or rely on a unified encoder-decoder network for different downstream tasks. The former paradigm is limited by inflexibility in applications while in the latter, the model is treated as a single system for all tasks, leading to suboptimal performance on a subset of tasks. Secondly, they often employ a limited set of pretraining objectives which might not be relevant to some downstream tasks and hence result in substantial performance degrade. To address these limitations, we propose ``CodeT5+’’, a family of encoder-decoder LLMs for code in which component modules can be flexibly combined to suit a wide range of downstream code tasks. Such flexibility is enabled by our proposed mixture of pretraining objectives to mitigate the pretrain-finetune discrepancy. These objectives cover span denoising, contrastive learning, text-code matching, and causal LM pretraining tasks, on both unimodal and bimodal multilingual code corpora. Furthermore, we propose to initialize CodeT5+ with frozen off-the-shelf LLMs without training from scratch to efficiently scale up our models, and explore instruction-tuning to align with natural language instructions. We extensively evaluate CodeT5+ on over 20 code-related benchmarks in different settings, including zero-shot, finetuning, and instruction-tuning. We observe state-of-the-art (SoTA) model performance on various code-related tasks, such as code generation and completion, math programming, and text-to-code retrieval tasks. Particularly, our instruction-tuned CodeT5+ 16B achieves new SoTA results on HumanEval code generation task against other open code LLMs.</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/souza2023lexecutor/">LExecutor: Learning-Guided Execution</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=LExecutor: Learning-Guided Execution' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=LExecutor: Learning-Guided Execution' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Beatriz Souza, Michael Pradel</td>
	<td></td>
	<td><p>Executing code is essential for various program analysis tasks, e.g., to detect bugs that manifest through exceptions or to obtain execution traces for further dynamic analysis. However, executing an arbitrary piece of code is often difficult in practice, e.g., because of missing variable definitions, missing user inputs, and missing third-party dependencies. This paper presents LExecutor, a learning-guided approach for executing arbitrary code snippets in an underconstrained way. The key idea is to let a neural model predict missing values that otherwise would cause the program to get stuck, and to inject these values into the execution. For example, LExecutor injects likely values for otherwise undefined variables and likely return values of calls to otherwise missing functions. We evaluate the approach on Python code from popular open-source projects and on code snippets extracted from Stack Overflow. The neural model predicts realistic values with an accuracy between 80.1% and 94.2%, allowing LExecutor to closely mimic real executions. As a result, the approach successfully executes significantly more code than any available technique, such as simply executing the code as-is. For example, executing the open-source code snippets as-is covers only 4.1% of all lines, because the code crashes early on, whereas LExecutor achieves a coverage of 50.1%.</p>

</td>
	<td>execution </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/silva2023repairllama/">RepairLLaMA: Efficient Representations and Fine-Tuned Adapters for Program Repair</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=RepairLLaMA: Efficient Representations and Fine-Tuned Adapters for Program Repair' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=RepairLLaMA: Efficient Representations and Fine-Tuned Adapters for Program Repair' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>André Silva, Sen Fang, Martin Monperrus</td>
	<td></td>
	<td><p>Automated Program Repair (APR) has evolved significantly with the advent of Large Language Models (LLMs). Fine-tuning LLMs for program repair is a recent avenue of research, with many dimensions which have not been explored. Existing work mostly fine-tunes LLMs with naive code representations and is fundamentally limited in its ability to fine-tune larger LLMs. To address this problem, we propose RepairLLaMA, a novel program repair approach that combines 1) code representations for APR and 2) the state-of-the-art parameter-efficient LLM fine-tuning technique called LoRA. This results in RepairLLaMA producing a highly effective `program repair adapter’ for fixing bugs with language models. Our experiments demonstrate the validity of both concepts. First, fine-tuning adapters with program repair specific code representations enables the model to use meaningful repair signals. Second, parameter-efficient fine-tuning helps fine-tuning to converge and contributes to the effectiveness of the repair adapter to fix data-points outside the fine-tuning data distribution. Overall, RepairLLaMA correctly fixes 125 Defects4J v2 and 82 HumanEval-Java bugs, outperforming all baselines.</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/shrivastava2023repofusion/">RepoFusion: Training Code Models to Understand Your Repository</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=RepoFusion: Training Code Models to Understand Your Repository' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=RepoFusion: Training Code Models to Understand Your Repository' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Disha Shrivastava, Denis Kocetkov, Harm de Vries, Dzmitry Bahdanau, Torsten Scholak</td>
	<td></td>
	<td><p>Despite the huge success of Large Language Models (LLMs) in coding assistants like GitHub Copilot, these models struggle to understand the context present in the repository (e.g., imports, parent classes, files with similar names, etc.), thereby producing inaccurate code completions. This effect is more pronounced when using these assistants for repositories that the model has not seen during training, such as proprietary software or work-in-progress code projects. Recent work has shown the promise of using context from the repository during inference. In this work, we extend this idea and propose RepoFusion, a framework to train models to incorporate relevant repository context. Experiments on single-line code completion show that our models trained with repository context significantly outperform much larger code models as CodeGen-16B-multi ($\sim73\times$ larger) and closely match the performance of the $\sim 70\times$ larger StarCoderBase model that was trained with the Fill-in-the-Middle objective. We find these results to be a novel and compelling demonstration of the gains that training with repository context can bring. We carry out extensive ablation studies to investigate the impact of design choices such as context type, number of contexts, context length, and initialization within our framework. Lastly, we release Stack-Repo, a dataset of 200 Java repositories with permissive licenses and near-deduplicated files that are augmented with three types of repository contexts. Additionally, we are making available the code and trained checkpoints for our work. Our released resources can be found at \url{https://huggingface.co/RepoFusion}.</p>
</td>
	<td>completion </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/xia2023universal/">Universal Fuzzing via Large Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Universal Fuzzing via Large Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Universal Fuzzing via Large Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Chunqiu Steven Xia, Matteo Paltenghi, Jia Le Tian, Michael Pradel, Lingming Zhang</td>
	<td></td>
	<td><p>Fuzzing has achieved tremendous success in discovering bugs and vulnerabilities in various software systems. Systems under test (SUTs) that take in programming or formal language as inputs, e.g., compilers, runtime engines, constraint solvers, and software libraries with accessible APIs, are especially important as they are fundamental building blocks of software development. However, existing fuzzers for such systems often target a specific language, and thus cannot be easily applied to other languages or even other versions of the same language. Moreover, the inputs generated by existing fuzzers are often limited to specific features of the input language, and thus can hardly reveal bugs related to other or new features. This paper presents Fuzz4All, the first fuzzer that is universal in the sense that it can target many different input languages and many different features of these languages. The key idea behind Fuzz4All is to leverage large language models (LLMs) as an input generation and mutation engine, which enables the approach to produce diverse and realistic inputs for any practically relevant language. To realize this potential, we present a novel autoprompting technique, which creates LLM prompts that are wellsuited for fuzzing, and a novel LLM-powered fuzzing loop, which iteratively updates the prompt to create new fuzzing inputs. We evaluate Fuzz4All on nine systems under test that take in six different languages (C, C++, Go, SMT2, Java and Python) as inputs. The evaluation shows, across all six languages, that universal fuzzing achieves higher coverage than existing, language-specific fuzzers. Furthermore, Fuzz4All has identified 76 bugs in widely used systems, such as GCC, Clang, Z3, CVC5, OpenJDK, and the Qiskit quantum computing platform, with 47 bugs already confirmed by developers as previously unknown.</p>
</td>
	<td>fuzzing </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/saberi2023model/">Model-Agnostic Syntactical Information for Pre-Trained Programming Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Model-Agnostic Syntactical Information for Pre-Trained Programming Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Model-Agnostic Syntactical Information for Pre-Trained Programming Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Iman Saberi, Fateme H. Fard</td>
	<td>MSR</td>
	<td><p>Pre-trained Programming Language Models (PPLMs) achieved many recent states of the art results for many code-related software engineering tasks. Though some studies use data flow or propose tree-based models that utilize Abstract Syntax Tree (AST), most PPLMs do not fully utilize the rich syntactical information in source code. Still, the input is considered a sequence of tokens. There are two issues; the first is computational inefficiency due to the quadratic relationship between input length and attention complexity. Second, any syntactical information, when needed as an extra input to the current PPLMs, requires the model to be pre-trained from scratch, wasting all the computational resources already used for pre-training the current models. In this work, we propose Named Entity Recognition (NER) adapters, lightweight modules that can be inserted into Transformer blocks to learn type information extracted from the AST. These adapters can be used with current PPLMs such as CodeBERT, GraphCodeBERT, and CodeT5. We train the NER adapters using a novel Token Type Classification objective function (TTC). We insert our proposed work in CodeBERT, building CodeBERTER, and evaluate the performance on two tasks of code refinement and code summarization. CodeBERTER improves the accuracy of code refinement from 16.4 to 17.8 while using 20% of training parameter budget compared to the fully fine-tuning approach, and the BLEU score of code summarization from 14.75 to 15.90 while reducing 77% of training parameters compared to the fully fine-tuning approach.</p>
</td>
	<td>Transformer repair summarization </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/peng2023generative/">Generative Type Inference for Python</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Generative Type Inference for Python' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Generative Type Inference for Python' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yun Peng, Chaozheng Wang, Wenxuan Wang, Cuiyun Gao, Michael R. Lyu</td>
	<td></td>
	<td><p>Python is a popular dynamic programming language, evidenced by its ranking as the second most commonly used language on GitHub. However, its dynamic type system can lead to potential type errors, leading researchers to explore automatic type inference approaches for Python programs. The rule-based type inference approaches can ensure the accuracy of predicted variable types, but they suffer from low coverage problems. Supervised type inference approaches, while feature-agnostic, require large, high-quality annotated datasets and are limited to pre-defined types. As zero-shot approaches, the cloze-style approaches reformulate the type inference problem into a fill-in-the-blank problem. However, their performance is limited.   This paper introduces TypeGen, a few-shot generative type inference approach that incorporates static domain knowledge from static analysis. TypeGen creates chain-of-thought (COT) prompts by translating the type inference steps of static analysis into prompts based on the type dependency graphs (TDGs), enabling language models to learn from how static analysis infers types. By combining COT prompts with code slices and type hints, TypeGen constructs example prompts from human annotations. TypeGen only requires very few annotated examples to teach language models to generate similar COT prompts via in-context learning. Moreover, TypeGen enhances the interpretability of results through the use of the input-explanation-output strategy. Experiments show that TypeGen outperforms the best baseline Type4Py by 10.0% for argument type prediction and 22.5% in return value type prediction in terms of top-1 Exact Match by using only five examples. Furthermore, TypeGen achieves substantial improvements of 27% to 84% compared to the zero-shot performance of large language models with parameter sizes ranging from 1.3B to 175B in terms of top-1 Exact Match.</p>
</td>
	<td>types </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/olausson2023demystifying/">Demystifying GPT Self-Repair for Code Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Demystifying GPT Self-Repair for Code Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Demystifying GPT Self-Repair for Code Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Theo X. Olausson, Jeevana Priya Inala, Chenglong Wang, Jianfeng Gao, Armando Solar-Lezama</td>
	<td></td>
	<td><p>Large Language Models (LLMs) have shown remarkable aptitude in code generation but still struggle on challenging programming tasks. Self-repair – in which the model debugs and fixes mistakes in its own code – has recently become a popular way to boost performance in these settings. However, only very limited studies on how and when self-repair works effectively exist in the literature, and one might wonder to what extent a model is really capable of providing accurate feedback on why the code is wrong when that code was generated by the same model. In this paper, we analyze GPT-3.5 and GPT-4’s ability to perform self-repair on APPS, a challenging dataset consisting of diverse coding challenges. To do so, we first establish a new evaluation strategy dubbed pass@t that measures the pass rate of the tasks against the total number of tokens sampled from the model, enabling a fair comparison to purely sampling-based approaches. With this evaluation strategy, we find that the effectiveness of self-repair is only seen in GPT-4. We also observe that self-repair is bottlenecked by the feedback stage; using GPT-4 to give feedback on the programs generated by GPT-3.5 and using expert human programmers to give feedback on the programs generated by GPT-4, we unlock significant performance gains.</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/nijkamp2023codegen2/">CodeGen2: Lessons for Training LLMs on Programming and Natural Languages</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeGen2: Lessons for Training LLMs on Programming and Natural Languages' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeGen2: Lessons for Training LLMs on Programming and Natural Languages' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Erik Nijkamp, Hiroaki Hayashi, Caiming Xiong, Silvio Savarese, Yingbo Zhou</td>
	<td></td>
	<td><p>Large language models (LLMs) have demonstrated remarkable abilities in representation learning for program synthesis and understanding tasks. The quality of the learned representations appears to be dictated by the neural scaling laws as a function of the number of model parameters and observations, while imposing upper bounds on the model performance by the amount of available data and compute, which is costly.</p>

<p>In this study, we attempt to render the training of LLMs for program synthesis more efficient by unifying four key components: (1) model architectures, (2) learning methods, (3) infill sampling, and, (4) data distributions. Specifically, for the model architecture, we attempt to unify encoder and decoder-based models into a single prefix-LM. For learning methods, (i) causal language modeling, (ii) span corruption, (iii) infilling are unified into a simple learning algorithm. For infill sampling, we explore the claim of a “free lunch” hypothesis. For data distributions, the effect of a mixture distribution of programming and natural languages on model performance is explored.</p>

<p>We conduct a comprehensive series of empirical experiments on 1B LLMs, for which failures and successes of this exploration are distilled into four lessons. We will provide a final recipe for training and release CodeGen2 models in size 1B, 3.7B, 7B, and, 16B parameters, along with the training framework as open-source: https://github.com/salesforce/CodeGen2</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/muennighoff2023octopack/">OctoPack: Instruction Tuning Code Large Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=OctoPack: Instruction Tuning Code Large Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=OctoPack: Instruction Tuning Code Large Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Niklas Muennighoff, Qian Liu, Armel Zebaze, Qinkai Zheng, Binyuan Hui, Terry Yue Zhuo, Swayam Singh, Xiangru Tang, Leandro von Werra, Shayne Longpre</td>
	<td></td>
	<td><p>Finetuning large language models (LLMs) on instructions leads to vast performance improvements on natural language tasks. We apply instruction tuning using code, leveraging the natural structure of Git commits, which pair code changes with human instructions. We compile CommitPack: 4 terabytes of Git commits across 350 programming languages. We benchmark CommitPack against other natural and synthetic code instructions (xP3x, Self-Instruct, OASST) on the 16B parameter StarCoder model, and achieve state-of-the-art performance among models not trained on OpenAI outputs, on the HumanEval Python benchmark (46.2% pass@1). We further introduce HumanEvalPack, expanding the HumanEval benchmark to a total of 3 coding tasks (Code Repair, Code Explanation, Code Synthesis) across 6 languages (Python, JavaScript, Java, Go, C++, Rust). Our models, OctoCoder and OctoGeeX, achieve the best performance across HumanEvalPack among all permissive models, demonstrating CommitPack’s benefits in generalizing to a wider set of languages and natural coding tasks. Code, models and data are freely available at https://github.com/bigcode-project/octopack.</p>
</td>
	<td>dataset instruction tuning </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/mohajer2023skipanalyzer/">SkipAnalyzer: A Tool for Static Code Analysis with Large Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=SkipAnalyzer: A Tool for Static Code Analysis with Large Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=SkipAnalyzer: A Tool for Static Code Analysis with Large Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Mohammad Mahdi Mohajer, Reem Aleithan, Nima Shiri Harzevili, Moshi Wei, Alvine Boaye Belle, Hung Viet Pham, Song Wang</td>
	<td></td>
	<td><p>We introduce SkipAnalyzer, a large language model (LLM)-powered tool for static code analysis. SkipAnalyzer has three components: 1) an LLM-based static bug detector that scans source code and reports specific types of bugs, 2) an LLM-based false-positive filter that can identify false-positive bugs in the results of static bug detectors (e.g., the result of step 1) to improve detection accuracy, and 3) an LLM-based patch generator that can generate patches for the detected bugs above. As a proof-of-concept, SkipAnalyzer is built on ChatGPT, which has exhibited outstanding performance in various software engineering tasks. To evaluate SkipAnalyzer, we focus on two types of typical and critical bugs that are targeted by static bug detection, i.e., Null Dereference and Resource Leak as subjects. We employ Infer to aid the gathering of these two bug types from 10 open-source projects. Consequently, our experiment dataset contains 222 instances of Null Dereference bugs and 46 instances of Resource Leak bugs. Our study demonstrates that SkipAnalyzer achieves remarkable performance in the mentioned static analysis tasks, including bug detection, false-positive warning removal, and bug repair. In static bug detection, SkipAnalyzer achieves accuracy values of up to 68.37% for detecting Null Dereference bugs and 76.95% for detecting Resource Leak bugs, improving the precision of the current leading bug detector, Infer, by 12.86% and 43.13%, respectively. For removing false-positive warnings, SkipAnalyzer can reach a precision of up to 93.88% for Null Dereference bugs and 63.33% for Resource Leak bugs. Additionally, SkipAnalyzer surpasses state-of-the-art false-positive warning removal tools. Furthermore, in bug repair, SkipAnalyzer can generate syntactically correct patches to fix its detected bugs with a success rate of up to 97.30%.</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/lomshakov2023fine/">Fine-Tuning Large Language Models for Answering Programming Questions with Code Snippets</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Fine-Tuning Large Language Models for Answering Programming Questions with Code Snippets' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Fine-Tuning Large Language Models for Answering Programming Questions with Code Snippets' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>V. Lomshakov, S. Kovalchuk, M. Omelchenko, S. Nikolenko, A. Aliev</td>
	<td>ICCS</td>
	<td><p>We study the ability of pretrained large language models (LLM) to answer questions from online question answering fora such as Stack Overflow. We consider question-answer pairs where the main part of the answer consists of source code. On two benchmark datasets — CoNaLa and a newly collected dataset based on Stack Overflow — we investigate how a closed-book question answering system can be improved by fine-tuning the LLM for the downstream task, prompt engineering, and data preprocessing. We use publicly available autoregressive language models such as GPT-Neo, CodeGen, and PanGu-Coder, and after the proposed fine-tuning achieve a BLEU score of 0.4432 on the CoNaLa test set, significantly exceeding previous state of the art for this task.</p>
</td>
	<td>program synthesis question answering large language models </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/liu2023code/">Code Execution with Pre-trained Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Code Execution with Pre-trained Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Code Execution with Pre-trained Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Chenxiao Liu, Shuai Lu, Weizhu Chen, Daxin Jiang, Alexey Svyatkovskiy, Shengyu Fu, Neel Sundaresan, Nan Duan</td>
	<td></td>
	<td><p>Code execution is a fundamental aspect of programming language semantics that reflects the exact behavior of the code. However, most pre-trained models for code intelligence ignore the execution trace and only rely on source code and syntactic structures. In this paper, we investigate how well pre-trained models can understand and perform code execution. We develop a mutation-based data augmentation technique to create a large-scale and realistic Python dataset and task for code execution, which challenges existing models such as Codex. We then present CodeExecutor, a Transformer model that leverages code execution pre-training and curriculum learning to enhance its semantic comprehension. We evaluate CodeExecutor on code execution and show its promising performance and limitations. We also demonstrate its potential benefits for code intelligence tasks such as zero-shot code-to-code search and text-to-code generation. Our analysis provides insights into the learning and generalization abilities of pre-trained models for code execution.</p>
</td>
	<td>Transformer execution </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/li2023think/">Think Outside the Code: Brainstorming Boosts Large Language Models in Code Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Think Outside the Code: Brainstorming Boosts Large Language Models in Code Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Think Outside the Code: Brainstorming Boosts Large Language Models in Code Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xin-Ye Li, Jiang-Tian Xue, Zheng Xie, Ming Li</td>
	<td></td>
	<td><p>Code generation aims to automatically generate source code from high-level task specifications, which can significantly increase productivity of software engineering. Recently, approaches based on large language models (LLMs) have shown remarkable code generation abilities on simple tasks. However, generate code for more complex tasks, such as competition-level problems, remains challenging. In this paper, we introduce Brainstorm framework for code generation. It leverages a brainstorming step that generates and selects diverse thoughts on the problem to facilitate algorithmic reasoning, where the thoughts are possible blueprint of solving the problem. We demonstrate that Brainstorm significantly enhances the ability of LLMs to solve competition-level programming problems, resulting in a more than 50% increase in the pass@$k$ metrics for ChatGPT on the CodeContests benchmark, achieving state-of-the-art performance. Furthermore, our experiments conducted on LeetCode contests show that our framework boosts the ability of ChatGPT to a level comparable to that of human programmers.</p>
</td>
	<td>generation Transformer </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/li2023rethinking/">Rethinking Negative Pairs in Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Rethinking Negative Pairs in Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Rethinking Negative Pairs in Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Haochen Li, Xin Zhou, Luu Anh Tuan, Chunyan Miao</td>
	<td>EMNLP</td>
	<td><p>Recently, contrastive learning has become a key component in fine-tuning code search models for software development efficiency and effectiveness. It pulls together positive code snippets while pushing negative samples away given search queries. Among contrastive learning, InfoNCE is the most widely used loss function due to its better performance. However, the following problems in negative samples of InfoNCE may deteriorate its representation learning: 1) The existence of false negative samples in large code corpora due to duplications. 2). The failure to explicitly differentiate between the potential relevance of negative samples. As an example, a bubble sorting algorithm example is less ``negative’’ than a file saving function for the quick sorting algorithm query. In this paper, we tackle the above problems by proposing a simple yet effective Soft-InfoNCE loss that inserts weight terms into InfoNCE. In our proposed loss function, we apply three methods to estimate the weights of negative pairs and show that the vanilla InfoNCE loss is a special case of Soft-InfoNCE. Theoretically, we analyze the effects of Soft-InfoNCE on controlling the distribution of learnt code representations and on deducing a more precise mutual information estimation. We furthermore discuss the superiority of proposed loss functions with other design alternatives. Extensive experiments demonstrate the effectiveness of Soft-InfoNCE and weights estimation methods under state-of-the-art code search models on a large-scale public dataset consisting of six programming languages.</p>
</td>
	<td>search Transformer retrieval optimization representation </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/li2023hitchhiker/">The Hitchhiker's Guide to Program Analysis: A Journey with Large Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=The Hitchhiker's Guide to Program Analysis: A Journey with Large Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=The Hitchhiker's Guide to Program Analysis: A Journey with Large Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Haonan Li, Yu Hao, Yizhuo Zhai, Zhiyun Qian</td>
	<td></td>
	<td><p>Static analysis is a widely used technique in software engineering for identifying and mitigating bugs. However, a significant hurdle lies in achieving a delicate balance between precision and scalability. Large Language Models (LLMs) offer a promising alternative, as recent advances demonstrate remarkable capabilities in comprehending, generating, and even debugging code. Yet, the logic of bugs can be complex and require sophisticated reasoning and a large analysis scope spanning multiple functions. Therefore, at this point, LLMs are better used in an assistive role to complement static analysis. In this paper, we take a deep dive into the open space of LLM-assisted static analysis, using use-before-initialization (UBI) bugs as a case study. To this end, we develop LLift, a fully automated agent that interfaces with both a static analysis tool and an LLM. By carefully designing the agent and the prompts, we are able to overcome a number of challenges, including bug-specific modeling, the large problem scope, the non-deterministic nature of LLMs, etc. Tested in a real-world scenario analyzing nearly a thousand potential UBI bugs produced by static analysis, LLift demonstrates an extremely potent capability, showcasing a high precision (50%) and recall rate (100%). It even identified 13 previously unknown UBI bugs in the Linux kernel. This research paves the way for new opportunities and methodologies in the use of LLMs for bug discovery in extensive, real-world datasets.</p>
</td>
	<td>static analysis </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/li2023starcoder/">StarCoder: may the source be with you!</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=StarCoder: may the source be with you!' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=StarCoder: may the source be with you!' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Raymond Li, Loubna Ben Allal, Yangtian Zi, Niklas Muennighoff, Denis Kocetkov, Chenghao Mou, Marc Marone, Christopher Akiki, Jia Li, Jenny Chim, Qian Liu, Evgenii Zheltonozhskii, Terry Yue Zhuo, Thomas Wang, Olivier Dehaene, Mishig Davaadorj, Joel Lamy-Poirier, João Monteiro, Oleh Shliazhko, Nicolas Gontier, Nicholas Meade, Armel Zebaze, Ming-Ho Yee, Logesh Kumar Umapathi, Jian Zhu, Benjamin Lipkin, Muhtasham Oblokulov, Zhiruo Wang, Rudra Murthy, Jason Stillerman, Siva Sankalp Patel, Dmitry Abulkhanov, Marco Zocca, Manan Dey, Zhihan Zhang, Nour Fahmy, Urvashi Bhattacharyya, Wenhao Yu, Swayam Singh, Sasha Luccioni, Paulo Villegas, Maxim Kunakov, Fedor Zhdanov, Manuel Romero, Tony Lee, Nadav Timor, Jennifer Ding, Claire Schlesinger, Hailey Schoelkopf, Jan Ebert, Tri Dao, Mayank Mishra, Alex Gu, Jennifer Robinson, Carolyn Jane Anderson, Brendan Dolan-Gavitt, Danish Contractor, Siva Reddy, Daniel Fried, Dzmitry Bahdanau, Yacine Jernite, Carlos Muñoz Ferrandis, Sean Hughes, Thomas Wolf, Arjun Guha, Leandro von Werra, Harm de Vries</td>
	<td></td>
	<td><p>The BigCode community, an open-scientific collaboration working on the responsible development of Large Language Models for Code (Code LLMs), introduces StarCoder and StarCoderBase: 15.5B parameter models with 8K context length, infilling capabilities and fast large-batch inference enabled by multi-query attention. StarCoderBase is trained on 1 trillion tokens sourced from The Stack, a large collection of permissively licensed GitHub repositories with inspection tools and an opt-out process. We fine-tuned StarCoderBase on 35B Python tokens, resulting in the creation of StarCoder. We perform the most comprehensive evaluation of Code LLMs to date and show that StarCoderBase outperforms every open Code LLM that supports multiple programming languages and matches or outperforms the OpenAI <code class="language-plaintext highlighter-rouge">code-cushman-001</code> model. Furthermore, StarCoder outperforms every model that is fine-tuned on Python, can be prompted to achieve 40% pass@1 on HumanEval, and still retains its performance on other programming languages. We take several important steps towards a safe open-access model release, including an improved PII redaction pipeline and a novel attribution tracing tool, and make the StarCoder models publicly available under a more commercially viable version of the Open Responsible AI Model license.</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/kovalchuk2023test/">Test-based and metric-based evaluation of code generation models for practical question answering</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Test-based and metric-based evaluation of code generation models for practical question answering' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Test-based and metric-based evaluation of code generation models for practical question answering' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>S. Kovalchuk, D. Fedrushkov, V. Lomshakov, A. Aliev</td>
	<td>ICCQ</td>
	<td><p>We performed a comparative analysis of code generation model performance with evaluation using common NLP metrics in comparison to a test-based evaluation. The investigation was performed in the context of question answering with code (test-to-code problem) and was aimed at applicability checking both ways for generated code evaluation in a fully automatic manner. We used CodeGen and GPTNeo pretrained models applied to a problem of question answering using Stack Overflow-based corpus (APIzation). For test-based evaluation, industrial test-generation solutions (Machinet, UTBot) were used for providing automatically generated tests. The analysis showed that the performance evaluation based solely on NLP metrics or on tests provides a rather limited assessment of generated code quality. We see the evidence that predictions with both high and low NLP metrics exist that pass and don’t pass tests. With the early results of our empirical study being discussed in this paper, we believe that the combination of both approaches may increase possible ways for building, evaluating, and training code generation models.</p>
</td>
	<td>code generation test generation natural language generation evaluation metrics natural language processing </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/jesse2023large/">Large Language Models and Simple, Stupid Bugs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Large Language Models and Simple, Stupid Bugs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Large Language Models and Simple, Stupid Bugs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Kevin Jesse, Toufique Ahmed, Premkumar T. Devanbu, Emily Morgan</td>
	<td></td>
	<td><p>With the advent of powerful neural language models, AI-based systems to assist developers in coding tasks are becoming widely available; Copilot is one such system. Copilot uses Codex, a large language model (LLM), to complete code conditioned on a preceding “prompt”. Codex, however, is trained on public GitHub repositories, viz., on code that may include bugs and vulnerabilities. Previous studies [1], [2] show Codex reproduces vulnerabilities seen in training. In this study, we examine how prone Codex is to generate an interesting bug category, single statement bugs, commonly referred to as simple, stupid bugs or SStuBs in the MSR community. We find that Codex and similar LLMs do help avoid some SStuBs, but do produce known, verbatim SStuBs as much as 2x as likely than known, verbatim correct code. We explore the consequences of the Codex generated SStuBs and propose avoidance strategies that suggest the possibility of reducing the production of known, verbatim SStubs, and increase the possibility of producing known, verbatim fixes.</p>
</td>
	<td>Transformer defect </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/gupta2023grace/">Grace: Language Models Meet Code Edits</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Grace: Language Models Meet Code Edits' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Grace: Language Models Meet Code Edits' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Priyanshu Gupta, Avishree Khare, Yasharth Bajpai, Saikat Chakraborty, Sumit Gulwani, Aditya Kanade, Arjun Radhakrishna, Gustavo Soares, Ashish Tiwari</td>
	<td>FSE</td>
	<td><p>Developers spend a significant amount of time in editing code for a variety of reasons such as bug fixing or adding new features. Designing effective methods to predict code edits has been an active yet challenging area of research due to the diversity of code edits and the difficulty of capturing the developer intent. In this work, we address these challenges by endowing pre-trained large language models (LLMs) with the knowledge of relevant prior associated edits, which we call the Grace (Generation conditioned on Associated Code Edits) method. The generative capability of the LLMs helps address the diversity in code changes and conditioning code generation on prior edits helps capture the latent developer intent. We evaluate two well-known LLMs, codex and CodeT5, in zero-shot and fine-tuning settings respectively. In our experiments with two datasets, Grace boosts the performance of the LLMs significantly, enabling them to generate 29% and 54% more correctly edited code in top-1 suggestions relative to the current state-of-the-art symbolic and neural approaches, respectively.</p>
</td>
	<td>editing </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/eniser2023automatically/">Automatically Testing Functional Properties of Code Translation Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Automatically Testing Functional Properties of Code Translation Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Automatically Testing Functional Properties of Code Translation Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hasan Ferit Eniser, Valentin Wüstholz, Maria Christakis</td>
	<td>AAAI</td>
	<td><p>Large language models are becoming increasingly practical for translating code across programming languages, a process known as $transpiling$. Even though automated transpilation significantly boosts developer productivity, a key concern is whether the generated code is correct. Existing work initially used manually crafted test suites to test the translations of a small corpus of programs; these test suites were later automated. In contrast, we devise the first approach for automated, functional, property-based testing of code translation models. Our general, user-provided specifications about the transpiled code capture a range of properties, from purely syntactic to purely semantic ones. As shown by our experiments, this approach is very effective in detecting property violations in popular code translation models, and therefore, in evaluating model quality with respect to given properties. We also go a step further and explore the usage scenario where a user simply aims to obtain a correct translation of some code with respect to certain properties without necessarily being concerned about the overall quality of the model. To this purpose, we develop the first property-guided search procedure for code translation models, where a model is repeatedly queried with slightly different parameters to produce alternative and potentially more correct translations. Our results show that this search procedure helps to obtain significantly better code translations.</p>
</td>
	<td>translation </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/ding2023static/">A Static Evaluation of Code Completion by Large Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Static Evaluation of Code Completion by Large Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Static Evaluation of Code Completion by Large Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hantian Ding, Varun Kumar, Yuchen Tian, Zijian Wang, Rob Kwiatkowski, Xiaopeng Li, Murali Krishna Ramanathan, Baishakhi Ray, Parminder Bhatia, Sudipta Sengupta, Dan Roth, Bing Xiang</td>
	<td></td>
	<td><p>Large language models trained on code have shown great potential to increase productivity of software developers. Several execution-based benchmarks have been proposed to evaluate functional correctness of model-generated code on simple programming problems. Nevertheless, it is expensive to perform the same evaluation on complex real-world projects considering the execution cost. On the contrary, static analysis tools such as linters, which can detect errors without running the program, haven’t been well explored for evaluating code generation models. In this work, we propose a static evaluation framework to quantify static errors in Python code completions, by leveraging Abstract Syntax Trees. Compared with execution-based evaluation, our method is not only more efficient, but also applicable to code in the wild. For experiments, we collect code context from open source repos to generate one million function bodies using public models. Our static analysis reveals that Undefined Name and Unused Variable are the most common errors among others made by language models. Through extensive studies, we also show the impact of sampling temperature, model size, and context on static errors in code completions.</p>
</td>
	<td>LLM static analysis </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/dong2023codescore/">CodeScore: Evaluating Code Generation by Learning Code Execution</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeScore: Evaluating Code Generation by Learning Code Execution' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeScore: Evaluating Code Generation by Learning Code Execution' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yihong Dong, Jiazheng Ding, Xue Jiang, Zhuo Li, Ge Li, Zhi Jin</td>
	<td></td>
	<td><p>A proper code evaluation metric (CEM) profoundly impacts the evolution of code generation, which is an important research field in NLP and software engineering. Prevailing CEMs can be categorized into match-based CEMs (e.g., BLEU, Accuracy, and CodeBLEU) and execution-based CEMs (e.g., AvgPassRatio and Pass@k), but both of them suffer from some issues. The former only measures differences in surface form regardless of the functional equivalence of codes, while the latter has huge execution overheads, including collecting expensive test cases, resolving tedious execution dependencies, and enormous execution time. To address these issues, in this paper, we propose CodeScore, an efficient and effective CEM for code generation, which estimates test case PassRatio of generated code without executing code. We also present a framework named UniCE for training unified code evaluation models by learning code execution, i.e., learning PassRatio and Executability of generated code. In order to learn code execution comprehensively, we construct more than 100 test cases for each task in several popular benchmark datasets, covering MBPP, APPS, and HumanEval. Experimental results show that CodeScore has obtained a state-of-the-art correlation with execution-based CEMs. CodeScore is strongly correlated with AvgPassPatio, and binary CodeScore is moderately correlated with Pass@1. In particular, CodeScore eliminates the need for test cases and execution dependencies in inference, and CodeScore reduces execution time by three orders of magnitude compared to AvgPassPatio and Pass@1.</p>
</td>
	<td>Transformer evaluation </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/chen2023supersonic/">Supersonic: Learning to Generate Source Code Optimizations in C/C++</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Supersonic: Learning to Generate Source Code Optimizations in C/C++' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Supersonic: Learning to Generate Source Code Optimizations in C/C++' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zimin Chen, Sen Fang, Martin Monperrus</td>
	<td></td>
	<td><p>Software optimization refines programs for resource efficiency while preserving functionality. Traditionally, it is a process done by developers and compilers. This paper introduces a third option, automated optimization at the source code level. We present Supersonic, a neural approach targeting minor source code modifications for optimization. Using a seq2seq model, Supersonic is trained on C/C++ program pairs ($x_{t}$, $x_{t+1}$), where $x_{t+1}$ is an optimized version of $x_{t}$, and outputs a diff. Supersonic’s performance is benchmarked against OpenAI’s GPT-3.5-Turbo and GPT-4 on competitive programming tasks. The experiments show that Supersonic not only outperforms both models on the code optimization task but also minimizes the extent of the change with a model more than 600x smaller than GPT-3.5-Turbo and 3700x smaller than GPT-4.</p>
</td>
	<td>optimization </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/chen2023diversevul/">DiverseVul: A New Vulnerable Source Code Dataset for Deep Learning Based Vulnerability Detection</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DiverseVul: A New Vulnerable Source Code Dataset for Deep Learning Based Vulnerability Detection' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DiverseVul: A New Vulnerable Source Code Dataset for Deep Learning Based Vulnerability Detection' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yizheng Chen, Zhoujie Ding, Xinyun Chen, David Wagner</td>
	<td></td>
	<td><p>We propose and release a new vulnerable source code dataset. We curate the dataset by crawling security issue websites, extracting vulnerability-fixing commits and source codes from the corresponding projects. Our new dataset contains 150 CWEs, 26,635 vulnerable functions, and 352,606 non-vulnerable functions extracted from 7,861 commits. Our dataset covers 305 more projects than all previous datasets combined. We show that increasing the diversity and volume of training data improves the performance of deep learning models for vulnerability detection.
Combining our new dataset with previous datasets, we present an analysis of the challenges and promising research directions of using deep learning for detecting software vulnerabilities. We study 11 model architectures belonging to 4 families. Our results show that deep learning is still not ready for vulnerability detection, due to high false positive rate, low F1 score, and difficulty of detecting hard CWEs. In particular, we demonstrate an important generalization challenge for the deployment of deep learning-based models.
However, we also identify hopeful future research directions. We demonstrate that large language models (LLMs) are the future for vulnerability detection, outperforming Graph Neural Networks (GNNs) with manual feature engineering. Moreover, developing source code specific pre-training objectives is a promising research direction to improve the vulnerability detection performance.</p>
</td>
	<td>dataset Transformer vulnerability </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/chow2023beware/">Beware of the Unexpected: Bimodal Taint Analysis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Beware of the Unexpected: Bimodal Taint Analysis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Beware of the Unexpected: Bimodal Taint Analysis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yiu Wai Chow, Max Schäfer, Michael Pradel</td>
	<td>ISSTA</td>
	<td><p>Static analysis is a powerful tool for detecting security vulnerabilities and other programming problems. Global taint tracking, in particular, can spot vulnerabilities arising from complicated data flow across multiple functions. However, precisely identifying which flows are problematic is challenging, and sometimes depends on factors beyond the reach of pure program analysis, such as conventions and informal knowledge. For example, learning that a parameter <code class="language-plaintext highlighter-rouge">name</code> of an API function <code class="language-plaintext highlighter-rouge">locale</code> ends up in a file path is surprising and potentially problematic. In contrast, it would be completely unsurprising to find that a parameter <code class="language-plaintext highlighter-rouge">command</code> passed to an API function <code class="language-plaintext highlighter-rouge">execaCommand</code> is eventually interpreted as part of an operating-system command. This paper presents Fluffy, a bimodal taint analysis that combines static analysis, which reasons about data flow, with machine learning, which probabilistically determines which flows are potentially problematic. The key idea is to let machine learning models predict from natural language information involved in a taint flow, such as API names, whether the flow is expected or unexpected, and to inform developers only about the latter. We present a general framework and instantiate it with four learned models, which offer different trade-offs between the need to annotate training data and the accuracy of predictions. We implement Fluffy on top of the CodeQL analysis framework and apply it to 250K JavaScript projects. Evaluating on five common vulnerability types, we find that Fluffy achieves an F1 score of 0.85 or more on four of them across a variety of datasets.</p>
</td>
	<td>static analysis </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/bouzenia2023tracefixer/">TraceFixer: Execution Trace-Driven Program Repair</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=TraceFixer: Execution Trace-Driven Program Repair' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=TraceFixer: Execution Trace-Driven Program Repair' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Islem Bouzenia, Yangruibo Ding, Kexin Pei, Baishakhi Ray, Michael Pradel</td>
	<td></td>
	<td><p>When debugging unintended program behavior, developers can often identify the point in the execution where the actual behavior diverges from the desired behavior. For example, a variable may get assigned a wrong value, which then negatively influences the remaining computation. Once a developer identifies such a divergence, how to fix the code so that it provides the desired behavior? This paper presents TraceFixer, a technique for predicting how to edit source code so that it does not diverge from the expected behavior anymore. The key idea is to train a neural program repair model that not only learns from source code edits but also exploits excerpts of runtime traces. The input to the model is a partial execution trace of the incorrect code, which can be obtained automatically through code instrumentation, and the correct state that the program should reach at the divergence point, which the user provides, e.g., in an interactive debugger. Our approach fundamentally differs from current program repair techniques, which share a similar goal but exploit neither execution traces nor information about the desired program state. We evaluate TraceFixer on single-line mistakes in Python code. After training the model on hundreds of thousands of code edits created by a neural model that mimics real-world bugs, we find that exploiting execution traces improves the bug-fixing ability by 13% to 20% (depending on the dataset, within the top-10 predictions) compared to a baseline that learns from source code edits only. Applying TraceFixer to 20 real-world Python bugs shows that the approach successfully fixes 10 of them.</p>
</td>
	<td>Transformer repair dynamic </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/ahmed2033improving/">Improving Few-Shot Prompts with Relevant Static Analysis Products</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Improving Few-Shot Prompts with Relevant Static Analysis Products' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Improving Few-Shot Prompts with Relevant Static Analysis Products' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Toufique Ahmed, Kunal Suresh Pai, Premkumar Devanbu, Earl T. Barr</td>
	<td></td>
	<td><p>Large Language Models (LLM) are a new class of computation engines, “programmed” via prompt engineering. We are still learning how to best “program” these LLMs to help developers. We start with the intuition that developers tend to consciously and unconsciously have a collection of semantics facts in mind when working on coding tasks. Mostly these are shallow, simple facts arising from a quick read. For a function, examples of facts might include parameter and local variable names, return expressions, simple pre- and post-conditions, and basic control and data flow, etc.</p>

<p>One might assume that the powerful multi-layer architecture of transformer-style LLMs makes them inherently capable of doing this simple level of “code analysis” and extracting such information, implicitly, while processing code: but are they, really? If they aren’t, could explicitly adding this information help? Our goal here is to investigate this question, using the code summarization task and evaluate whether automatically augmenting an LLM’s prompt with semantic facts explicitly, actually helps.</p>

<p>Prior work shows that LLM performance on code summarization benefits from few-shot samples drawn either from the same-project or from examples found via information retrieval methods (such as BM25). While summarization performance has steadily increased since the early days, there is still room for improvement: LLM performance on code summarization still lags its performance on natural-language tasks like translation and text summarization.</p>

<p>We find that adding semantic facts actually does help! This approach improves performance in several different settings suggested by prior work, including for two different Large Language Models. In most cases, improvement nears or exceeds 2 BLEU; for the PHP language in the challenging CodeSearchNet dataset, this augmentation actually yields performance surpassing 30 BLEU.</p>
</td>
	<td>summarization Transformer </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/agrawal2023monitor/">Monitor-Guided Decoding of Code LMs with Static Analysis of Repository Context</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Monitor-Guided Decoding of Code LMs with Static Analysis of Repository Context' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Monitor-Guided Decoding of Code LMs with Static Analysis of Repository Context' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Lakshya A Agrawal, Aditya Kanade, Navin Goyal, Shuvendu K Lahiri, Sriram Rajamani</td>
	<td>NeurIPS</td>
	<td><p>Language models of code (LMs) work well when the surrounding code provides sufficient context. This is not true when it becomes necessary to use types, functionality or APIs defined elsewhere in the repository or a linked library, especially those not seen during training. LMs suffer from limited awareness of such global context and end up hallucinating.</p>

<p>Integrated development environments (IDEs) assist developers in understanding repository context using static analysis. We extend this assistance, enjoyed by developers, to LMs. We propose monitor-guided decoding (MGD) where a monitor uses static analysis to guide the decoding. We construct a repository-level dataset PragmaticCode for method-completion in Java and evaluate MGD on it. On models of varying parameter scale, by monitoring for type-consistent object dereferences, MGD consistently improves compilation rates and agreement with ground truth. Further, LMs with fewer parameters, when augmented with MGD, can outperform larger LMs. With MGD, SantaCoder-1.1B achieves better compilation rate and next-identifier match than the much larger text-davinci-003 model.</p>

<p>We also conduct a generalizability study to evaluate the ability of MGD to generalize to multiple programming languages (Java, C# and Rust), coding scenarios (e.g., correct number of arguments to method calls), and to enforce richer semantic constraints (e.g., stateful API protocols). Our data and implementation are available at https://github.com/microsoft/monitors4codegen.</p>
</td>
	<td>autocomplete benchmark code completion code generation compilation completion dataset evaluation language model large language models program analysis static analysis tool </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/zhou2022codebertscore/">CodeBERTScore: Evaluating Code Generation with Pretrained Models of Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeBERTScore: Evaluating Code Generation with Pretrained Models of Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeBERTScore: Evaluating Code Generation with Pretrained Models of Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shuyan Zhou, Uri Alon, Sumit Agarwal, Graham Neubig</td>
	<td></td>
	<td><p>Since the rise of neural models of code that can generate long expressions and statements rather than a single next-token, one of the major problems has been reliably evaluating their generated output. In this paper, we propose CodeBERTScore: an automatic evaluation metric for code generation, which builds on BERTScore (Zhang et al., 2020). Instead of measuring exact token matching as BLEU, CodeBERTScore computes a soft similarity score between each token in the generated code and in the reference code, using the contextual encodings of large pretrained models. Further, instead of encoding only the generated tokens as in BERTScore, CodeBERTScore also encodes the programmatic context surrounding the generated code. We perform an extensive evaluation of CodeBERTScore across four programming languages. We find that CodeBERTScore achieves a higher correlation with human preference and with functional correctness than all existing metrics. That is, generated code that receives a higher score by CodeBERTScore is more likely to be preferred by humans, as well as to function correctly when executed. Finally, while CodeBERTScore can be used with a multilingual CodeBERT as its base model, we release five language-specific pretrained models to use with our publicly available code at https://github.com/neulab/code-bert-score . Our language-specific models have been downloaded more than 25,000 times from the Huggingface Hub.</p>
</td>
	<td>evaluation Transformer </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/zhang2023repocoder/">RepoCoder: Repository-Level Code Completion Through Iterative Retrieval and Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=RepoCoder: Repository-Level Code Completion Through Iterative Retrieval and Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=RepoCoder: Repository-Level Code Completion Through Iterative Retrieval and Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Fengji Zhang, Bei Chen, Yue Zhang, Jin Liu, Daoguang Zan, Yi Mao, Jian-Guang Lou, Weizhu Chen</td>
	<td></td>
	<td><p>The task of repository-level code completion is to continue writing the unfinished code based on a broader context of the repository. While for automated code completion tools, it is difficult to utilize the useful information scattered in different files. We propose RepoCoder, a simple, generic, and effective framework to address the challenge. It streamlines the repository-level code completion process by incorporating a similarity-based retriever and a pre-trained code language model, which allows for the effective utilization of repository-level information for code completion and grants the ability to generate code at various levels of granularity. Furthermore, RepoCoder utilizes a novel iterative retrieval-generation paradigm that bridges the gap between retrieval context and the intended completion target. We also propose a new benchmark RepoEval, which consists of the latest and high-quality real-world repositories covering line, API invocation, and function body completion scenarios. We test the performance of RepoCoder by using various combinations of code retrievers and generators. Experimental results indicate that RepoCoder significantly improves the zero-shot code completion baseline by over 10% in all settings and consistently outperforms the vanilla retrieval-augmented code completion approach. Furthermore, we validate the effectiveness of RepoCoder through comprehensive analysis, providing valuable insights for future research.</p>
</td>
	<td>completion Transformer retrieval </td>
</tr>

<tr>
	<td>2023</td>
	<td><a href="/publications/yadavally2023partial/">(Partial) Program Dependence Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=(Partial) Program Dependence Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=(Partial) Program Dependence Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Aashish Yadavally, Wenbo Wang, Shaohua Wang, Tien N. Nguyen</td>
	<td>ICSE</td>
	<td><p>Code fragments from developer forums often migrate to applications due to the code reuse practice. Owing to the incomplete nature of such programs, analyzing them to early determine the presence of potential vulnerabilities is challenging. In this work, we introduce NeuralPDA, a neural network-based program dependence analysis tool for both complete and partial programs. Our tool efficiently incorporates intra-statement and inter-statement contextual features into statement representations, thereby modeling program dependence analysis as a statement-pair dependence decoding task. In the empirical evaluation, we report that NeuralPDA predicts the CFG and PDG edges in complete Java and C/C++ code with combined F-scores of 94.29% and 92.46%, respectively. The F-score values for partial Java and C/C++ code range from 94.29%–97.17% and 92.46%–96.01%, respectively. We also test the usefulness of the PDGs predicted by NEURALPDA (i.e., PDG<em>) on the downstream task of method-level vulnerability detection. We discover that the performance of the vulnerability detection tool utilizing PDG</em> is only 1.1% less than that utilizing the PDGs generated by a program analysis tool. We also report the detection of 14 real-world vulnerable code snippets from StackOverflow by a machine learning-based vulnerability detection tool that employs the PDGs predicted by NeuralPDA for these code snippets.</p>
</td>
	<td>large language models program analysis static analysis tool </td>
</tr>



<tr>
	<td>2022</td>
	<td><a href="/publications/mastropaolo2022using/">Using Deep Learning to Generate Complete Log Statements</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Using Deep Learning to Generate Complete Log Statements' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Using Deep Learning to Generate Complete Log Statements' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Antonio Mastropaolo, Luca Pascarella, Gabriele Bavota</td>
	<td></td>
	<td><p>Logging is a practice widely adopted in several phases of the software lifecycle. For example, during software development log statements allow engineers to verify and debug the system by exposing fine-grained information of the running software. While the benefits of logging are undisputed, taking proper decisions about where to inject log statements, what information to log, and at which log level (e.g., error, warning) is crucial for the logging effectiveness. In this paper, we present LANCE (Log stAtemeNt reCommEnder), the first approach supporting developers in all these decisions. LANCE features a Text-To-Text-Transfer-Transformer (T5) model that has been trained on 6,894,456 Java methods. LANCE takes as input a Java method and injects in it a full log statement, including a human-comprehensible logging message and properly choosing the needed log level and the statement location. Our results show that LANCE is able to (i) properly identify the location in the code where to inject the statement in 65.9% of Java methods requiring it; (ii) selecting the proper log level in 66.2% of cases; and (iii) generate a completely correct log statement including a meaningful logging message in 15.2% of cases.</p>
</td>
	<td>Transformer logging </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/lu2022reacc/">ReACC: A Retrieval-Augmented Code Completion Framework</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=ReACC: A Retrieval-Augmented Code Completion Framework' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=ReACC: A Retrieval-Augmented Code Completion Framework' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shuai Lu, Nan Duan, Hojae Han, Daya Guo, Seung-won Hwang, Alexey Svyatkovskiy</td>
	<td></td>
	<td><p>Code completion, which aims to predict the following code token(s) according to the code context, can improve the productivity of software development. Recent work has proved that statistical language modeling with transformers can greatly improve the performance in the code completion task via learning from large-scale source code datasets. However, current approaches focus only on code context within the file or project, i.e. internal context. Our distinction is utilizing “external” context, inspired by human behaviors of copying from the related code snippets when writing code. Specifically, we propose a retrieval-augmented code completion framework, leveraging both lexical copying and referring to code with similar semantics by retrieval. We adopt a stage-wise training approach that combines a source code retriever and an auto-regressive language model for programming language. We evaluate our approach in the code completion task in Python and Java programming languages, achieving a state-of-the-art performance on CodeXGLUE benchmark.</p>
</td>
	<td>Transformer autocomplete </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/liu2022open/">Open-ended Knowledge Tracing</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Open-ended Knowledge Tracing' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Open-ended Knowledge Tracing' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Naiming Liu, Zichao Wang, Richard G. Baraniuk, Andrew Lan</td>
	<td></td>
	<td><p>In education applications, knowledge tracing refers to the problem of estimating students’ time-varying concept/skill mastery level from their past responses to questions and predicting their future performance. One key limitation of most existing knowledge tracing methods is that they treat student responses to questions as binary-valued, i.e., whether they are correct or incorrect. Response correctness analysis/prediction ignores important information on student knowledge contained in the exact content of the responses, especially for open-ended questions. In this paper, we conduct the first exploration into open-ended knowledge tracing (OKT) by studying the new task of predicting students’ exact open-ended responses to questions. Our work is grounded in the domain of computer science education with programming questions. We develop an initial solution to the OKT problem, a student knowledge-guided code generation approach, that combines program synthesis methods using language models with student knowledge tracing methods. We also conduct a series of quantitative and qualitative experiments on a real-world student code dataset to validate OKT and demonstrate its promise in educational applications.</p>
</td>
	<td>education code generation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/zeng2022extensive/">An Extensive Study on Pre-trained Models for Program Understanding and Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=An Extensive Study on Pre-trained Models for Program Understanding and Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=An Extensive Study on Pre-trained Models for Program Understanding and Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zhengran Zeng, Hanzhuo Tan, Haotian Zhang, Jing Li, Yuqun Zhang, Lingming Zhang</td>
	<td>ISSTA</td>
	<td><p>Automatic program understanding and generation techniques could
significantly advance the productivity of programmers and have
been widely studied by academia and industry. Recently, the advent of pre-trained paradigm enlightens researchers to develop
general-purpose pre-trained models which can be applied for a
broad range of program understanding and generation tasks. Such
pre-trained models, derived by self-supervised objectives on large
unlabelled corpora, can be fine-tuned in downstream tasks (such
as code search and code generation) with minimal adaptations. Although these pre-trained models claim superiority over the prior
techniques, they seldom follow equivalent evaluation protocols, e.g.,
they are hardly evaluated on the identical benchmarks, tasks, or settings. Consequently, there is a pressing need for a comprehensive
study of the pre-trained models on their effectiveness, versatility
as well as the limitations to provide implications and guidance for
the future development in this area. To this end, we first perform
an extensive study of eight open-access pre-trained models over
a large benchmark on seven representative code tasks to assess
their reproducibility. We further compare the pre-trained models
and domain-specific state-of-the-art techniques for validating pre-trained effectiveness. At last, we investigate the robustness of the
pre-trained models by inspecting their performance variations under adversarial attacks. Through the study, we find that while we
can in general replicate the original performance of the pre-train
models on their evaluated tasks and adopted benchmarks, subtle
performance fluctuations can refute the findings in their original
papers. Moreover, none of the existing pre-trained models can dominate over all other models. We also find that the pre-trained models
can significantly outperform non-pre-trained state-of-the-art techniques in program understanding tasks. Furthermore, we perform
the first study for natural language-programming language pre-trained model robustness via adversarial attacks and find that a
simple random attack approach can easily fool the state-of-the-art
pre-trained models and thus incur security issues. At last, we also
provide multiple practical guidelines for advancing future research
on pre-trained models for program understanding and generation.</p>
</td>
	<td>Transformer evaluation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/lherondelle2022topical/">Topical: Learning Repository Embeddings from Source Code using Attention</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Topical: Learning Repository Embeddings from Source Code using Attention' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Topical: Learning Repository Embeddings from Source Code using Attention' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Agathe Lherondelle, Yash Satsangi, Fran Silavong, Shaltiel Eloul, Sean Moran</td>
	<td>Arxiv</td>
	<td><p>Machine learning on source code (MLOnCode) promises to transform how software is delivered. By mining the context and relationship between software artefacts, MLOnCode
augments the software developer’s capabilities with code autogeneration, code recommendation, code auto-tagging and other data-driven enhancements. For many of these tasks a script level
representation of code is sufficient, however, in many cases a repository level representation that takes into account various dependencies and repository structure is imperative, for example,
auto-tagging repositories with topics or auto-documentation of repository code etc. Existing methods for computing repository level representations suffer from (a) reliance on natural language
documentation of code (for example, README files) (b) naive aggregation of method/script-level representation, for example, by concatenation or averaging. This paper introduces Topical a
deep neural network to generate repository level embeddings of publicly available GitHub code repositories directly from source code. Topical incorporates an attention mechanism that projects the source code, the full dependency graph and the
script level textual information into a dense repository-level representation. To compute the repository-level representations, Topical is trained to predict the topics associated with a repository, on a dataset of publicly available GitHub repositories that
were crawled along with their ground truth topic tags. Our experiments show that the embeddings computed by Topical are able to outperform multiple baselines, including baselines
that naively combine the method-level representations through averaging or concatenation at the task of repository auto-tagging. Furthermore, we show that Topical’s attention mechanism outperforms naive aggregation methods when computing repositorylevel representations from script-level representation generated
by existing methods. Topical is a lightweight framework for computing repository-level representation of code repositories that scales efficiently with the number of topics and dataset size.</p>
</td>
	<td>representation topic modelling </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/li2022codereviewer/">CodeReviewer: Pre-Training for Automating Code Review Activities</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeReviewer: Pre-Training for Automating Code Review Activities' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeReviewer: Pre-Training for Automating Code Review Activities' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zhiyu Li, Shuai Lu, Daya Guo, Nan Duan, Shailesh Jannu, Grant Jenks, Deep Majumder, Jared Green, Alexey Svyatkovskiy, Shengyu Fu, Neel Sundaresan</td>
	<td></td>
	<td><p>Code review is an essential part to software development lifecycle since it aims at guaranteeing the quality of codes. Modern code review activities necessitate developers viewing, understanding and even running the programs to assess logic, functionality, latency, style and other factors. It turns out that developers have to spend far too much time reviewing the code of their peers. Accordingly, it is in significant demand to automate the code review process. In this research, we focus on utilizing pre-training techniques for the tasks in the code review scenario. We collect a large-scale dataset of real world code changes and code reviews from open-source projects in nine of the most popular programming languages. To better understand code diffs and reviews, we propose CodeReviewer, a pre-trained model that utilizes four pre-training tasks tailored specifically for the code review senario. To evaluate our model, we focus on three key tasks related to code review activities, including code change quality estimation, review comment generation and code refinement. Furthermore, we establish a high-quality benchmark dataset based on our collected data for these three tasks and conduct comprehensive experiments on it. The experimental results demonstrate that our model outperforms the previous state-of-the-art pre-training approaches in all tasks. Further analysis show that our proposed pre-training tasks and the multilingual pre-training dataset benefit the model on the understanding of code changes and reviews.</p>
</td>
	<td>review </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/kocetkov2022stack/">The Stack: 3TB of permissively licensed source code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=The Stack: 3TB of permissively licensed source code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=The Stack: 3TB of permissively licensed source code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Denis Kocetkov, Raymond Li, Loubna Ben Allal, Jia Li, Chenghao Mou, Carlos Muñoz Ferrandis, Sean Hughes, Thomas Wolf, Dzmitry Bahdanau, Leandro von Werra, Harm de Vries</td>
	<td></td>
	<td><p>Large Language Models (LLMs) play an ever-increasing role in the field of
Artificial Intelligence (AI)–not only for natural language processing but also
for code understanding and generation. To stimulate open and responsible
research on LLMs for code, we introduce The Stack, a 3.1 TB dataset
consisting of permissively licensed source code in 30 programming languages.
We describe how we collect the full dataset, construct a permissively licensed
subset, and present promising results on text2code benchmarks by training 350M-parameter decoders on different Python subsets. We find that
(1) near-deduplicating the data significantly boosts performance across all
experiments, and (2) it is possible to match previously reported HumanEval
and MBPP performance using only permissively licensed data. We make the
dataset available at https://hf.co/BigCode and give developers the possi-
bility to have their code removed from the dataset by following the instruc-
tions at https://www.bigcode-project.org/docs/about/the-stack/.</p>
</td>
	<td>dataset </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/kovalchuk2022human/">Human perceiving behavior modeling in evaluation of code generation models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Human perceiving behavior modeling in evaluation of code generation models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Human perceiving behavior modeling in evaluation of code generation models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>S. Kovalchuk, V. Lomshakov, A. Aliev</td>
	<td>GEM</td>
	<td><p>Within this study, we evaluated a series of code generation models based on CodeGen and GPTNeo to compare the metric-based performance and human evaluation. For a deeper analysis of human perceiving within the evaluation procedure we’ve implemented a 5-level Likert scale assessment of the model output using a perceiving model based on the Theory of Planned Behavior (TPB). Through such analysis, we showed an extension of model assessment as well as a deeper understanding of the quality and applicability of generated code for practical question answering. The approach was evaluated with several model settings in order to assess diversity in quality and style of answer. With the TPB-based model, we showed a different level of perceiving the model result, namely personal understanding, agreement level, and readiness to use the particular code. With such analysis, we investigate a series of issues in code generation as natural language generation (NLG) problems observed in a practical context of programming question-answering with code.</p>
</td>
	<td>code generation evaluation human evaluation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/key2022speak/">I Speak, You Verify: Toward Trustworthy Neural Program Synthesis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=I Speak, You Verify: Toward Trustworthy Neural Program Synthesis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=I Speak, You Verify: Toward Trustworthy Neural Program Synthesis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Darren Key, Wen-Ding Li, Kevin Ellis</td>
	<td></td>
	<td><p>We develop an approach for improving the trustworthiness and overall accuracy of program synthesizers based on large language models for source code. Given a natural language description of a programming problem, our method samples both candidate programs as well as candidate predicates specifying how the program should behave. We learn to analyze the agreement between programs and predicates to judge both which program is most likely to be correct, and also judge whether the language model is able to solve the programming problem in the first place. This latter capacity allows favoring high precision over broad recall: fostering trust by only proposing a program when the system is certain that it is correct.</p>
</td>
	<td>synthesis </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/karmakar2022jemma/">JEMMA: An Extensible Java Dataset for ML4Code Applications</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=JEMMA: An Extensible Java Dataset for ML4Code Applications' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=JEMMA: An Extensible Java Dataset for ML4Code Applications' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Anjan Karmakar, Miltiadis Allamanis, Romain Robbes</td>
	<td>EMSE</td>
	<td><p>Machine Learning for Source Code (ML4Code) is an active research field in which extensive experimentation is needed to discover how to best use source code’s richly structured information. With this in mind, we introduce JEMMA, an Extensible Java Dataset for ML4Code Applications, which is a large-scale, diverse, and high-quality dataset targeted at ML4Code. Our goal with JEMMA is to lower the barrier to entry in ML4Code by providing the building blocks to experiment with source code models and tasks. JEMMA comes with a considerable amount of pre-processed information such as metadata, representations (e.g., code tokens, ASTs, graphs), and several properties (e.g., metrics, static analysis results) for 50,000 Java projects from the 50KC dataset, with over 1.2 million classes and over 8 million methods. JEMMA is also extensible allowing users to add new properties and representations to the dataset, and evaluate tasks on them. Thus, JEMMA becomes a workbench that researchers can use to experiment with novel representations and tasks operating on source code. To demonstrate the utility of the dataset, we also report results from two empirical studies on our data, ultimately showing that significant work lies ahead in the design of context-aware source code models that can reason over a broader network of source code entities in a software project, the very task that JEMMA is designed to help with.</p>
</td>
	<td>dataset </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/kharkar2022learning/">Learning to Reduce False Positives in Analytic Bug Detectors</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Reduce False Positives in Analytic Bug Detectors' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Reduce False Positives in Analytic Bug Detectors' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Anant Kharkar, Roshanak Zilouchian Moghaddam, Matthew Jin, Xiaoyu Liu, Xin Shi, Colin Clement, Neel Sundaresan</td>
	<td>ICSE</td>
	<td><p>Due to increasingly complex software design and rapid iterative development, code defects and security vulnerabilities are prevalent in modern software. In response, programmers rely on static analysis tools to regularly scan their codebases and find potential bugs. In order to maximize coverage, however, these tools generally tend to report a significant number of false positives, requiring developers to manually verify each warning. To address this problem, we propose a Transformer-based learning approach to identify false positive bug warnings. We demonstrate that our models can improve the precision of static analysis by 17.5%. In addition, we validated the generalizability of this approach across two major bug types: null dereference and resource leak.</p>
</td>
	<td>Transformer static analysis </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/li2022exploring/">Exploring Representation-Level Augmentation for Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Exploring Representation-Level Augmentation for Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Exploring Representation-Level Augmentation for Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Haochen Li, Chunyan Miao, Cyril Leung, Yanxian Huang, Yuan Huang, Hongyu Zhang, Yanlin Wang</td>
	<td>EMNLP</td>
	<td><p>Code search, which aims at retrieving the most relevant code fragment for a given natural language query, is a common activity in software development practice. Recently, contrastive learning is widely used in code search research, where many data augmentation approaches for source code (e.g., semantic-preserving program transformation) are proposed to learn better representations.  However, these augmentations are at the raw-data level, which requires additional code analysis in the preprocessing stage and additional training costs in the training stage. In this paper, we explore augmentation methods that augment data (both code and query) at representation level which does not require additional data processing and training, and based on this we propose a general format of representation-level augmentation that unifies existing methods. Then, we propose three new augmentation methods (linear extrapolation, binary interpolation, and Gaussian scaling) based on the general format. Furthermore, we theoretically analyze the advantages of the proposed augmentation methods over traditional contrastive learning methods on code search. We experimentally evaluate the proposed representation-level augmentation methods with state-of-the-art code search models on a large-scale public dataset consisting of six programming languages. The experimental results show that our approach can consistently boost the performance of the studied code search models.</p>
</td>
	<td>search Transformer </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/jian2022assemble/">Assemble Foundation Models for Automatic Code Summarization</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Assemble Foundation Models for Automatic Code Summarization' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Assemble Foundation Models for Automatic Code Summarization' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jian Gu, Pasquale Salza, Harald C. Gall</td>
	<td>SANER</td>
	<td><p>Automatic code summarization is beneficial to software development and maintenance since it reduces the burden of manual tasks. Currently, artificial intelligence is undergoing a paradigm shift. The foundation models pretrained on massive data and finetuned to downstream tasks surpass specially customized models. This trend inspired us to consider reusing foundation models instead of learning from scratch. Based on this, we propose a flexible and robust approach for automatic code summarization based on neural networks. We assemble available foundation models, such as CodeBERT and GPT-2, into a single model named AdaMo. Moreover, we utilize Gaussian noise as the simulation of contextual information to optimize the latent representation. Furthermore, we introduce two adaptive schemes from the perspective of knowledge transfer, namely continuous pretraining and intermediate finetuning, and design intermediate stage tasks for general sequence-to-sequence learning. Finally, we evaluate AdaMo against a benchmark dataset for code summarization, by comparing it with state-of-the-art models.</p>
</td>
	<td>summarization documentation language model </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/jesse2022learning/">Learning To Predict User-Defined Types</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning To Predict User-Defined Types' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning To Predict User-Defined Types' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Kevin Jesse, Premkumar T. Devanbu, Anand Sawant</td>
	<td>TSE</td>
	<td><p>TypeScript is a widely adopted gradual typed language where developers can optionally type variables, functions, parameters and more. Probabilistic type inference approaches with ML (machine learning) work well especially for commonly occurring types such as boolean, number, and string. TypeScript permits a wide range of types including developer defined class names and type interfaces. These developer defined types, termed user-defined types, can be written within the realm of language naming conventions. The set of user-defined types is boundless and existing bounded type guessing approaches are an imperfect solution. Existing works either under perform in user-defined types or ignore user-defined types altogether. This work leverages a BERT-style pre-trained model, with multi-task learning objectives, to learn how to type user-defined classes and interfaces. Thus we present DIVERSETYPER, a solution that explores the diverse set of user-defined types by uniquely aligning classes and interfaces declarations to the places in which they are used. DIVERSETYPER surpasses all existing works including those that model user-defined types.</p>
</td>
	<td>Transformer types </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/ye2022selfapr/">SelfAPR: Self-supervised Program Repair with Test Execution Diagnostics</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=SelfAPR: Self-supervised Program Repair with Test Execution Diagnostics' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=SelfAPR: Self-supervised Program Repair with Test Execution Diagnostics' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>He Ye, Matias Martinez, Xiapu Luo, Tao Zhang, Martin Monperrus</td>
	<td></td>
	<td><p>Neural program repair has achieved good results in a recent series of papers. Yet, we observe that the related work fails to repair some bugs because of a lack of knowledge about 1) the program being repaired, and 2) the actual fault being repaired. In this paper, we solve both problems by changing the learning paradigm from supervised training to self-supervised training in an approach called SelfAPR. First, SelfAPR generates and constructs training samples by perturbing a previous version of the program being repaired, enforcing the neural model to capture project-specific knowledge. This is different from all the existing work based on past commits. Second, SelfAPR extracts and encodes test execution diagnostics into the input representation, steering the neural model to fix the specific kind of fault. This is different from the existing studies that only consider static source code in the input. We implement SelfAPR and evaluate it in a systematic manner. We train SelfAPR with 253 411 training samples obtained by perturbing 17 open-source projects. We evaluate SelfAPR on 818 bugs from Defects4J, SelfAPR correctly repairs 112 of them.</p>
</td>
	<td>repair execution </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/he2022distribution/">On Distribution Shift in Learning-based Bug Detectors</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=On Distribution Shift in Learning-based Bug Detectors' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=On Distribution Shift in Learning-based Bug Detectors' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jingxuan He, Luca Beurer-Kellner, Martin Vechev</td>
	<td></td>
	<td><p>Deep learning has recently achieved initial success in program analysis tasks such as bug detection. Lacking real bugs, most existing works construct training and test data by injecting synthetic bugs into correct programs. Despite achieving high test accuracy (e.g. &gt;90%), the resulting bug detectors are found to be surprisingly unusable in practice, i.e., &lt;10% precision when used to scan real software repositories. In this work, we argue that this massive performance difference is caused by distribution shift, i.e., a fundamental mismatch between the real bug distribution and the synthetic bug distribution used to train and evaluate the detectors. To address this key challenge, we propose to train a bug detector in two phases, first on a synthetic bug distribution to adapt the model to the bug detection domain, and then on a real bug distribution to drive the model towards the real distribution. During these two phases, we leverage a multi-task hierarchy, focal loss, and contrastive learning to further boost performance. We evaluate our approach extensively on three widely studied bug types, for which we construct new datasets carefully designed to capture the real bug distribution. The results demonstrate that our approach is practically effective and successfully mitigates the distribution shift: our learned detectors are highly performant on both our constructed test set and the latest version of open source repositories.</p>
</td>
	<td>defect </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/haque2022semantic/">Semantic Similarity Metrics for Evaluating Source Code Summarization</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Semantic Similarity Metrics for Evaluating Source Code Summarization' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Semantic Similarity Metrics for Evaluating Source Code Summarization' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sakib Haque, Zachary Eberhart, Aakash Bansal, Collin McMillan</td>
	<td></td>
	<td><p>Source code summarization involves creating brief descriptions of source code in natural language. These descriptions are a key component of software documentation such as JavaDocs. Automatic code summarization is a prized target of software engineering research, due to the high value summaries have to programmers and the simultaneously high cost of writing and maintaining documentation by hand. Current work is almost all based on machine models trained via big data input. Large datasets of examples of code and summaries of that code are used to train an e.g. encoder-decoder neural model. Then the output predictions of the model are evaluated against a set of reference summaries. The input is code not seen by the model, and the prediction is compared to a reference. The means by which a prediction is compared to a reference is essentially word overlap, calculated via a metric such as BLEU or ROUGE. The problem with using word overlap is that not all words in a sentence have the same importance, and many words have synonyms. The result is that calculated similarity may not match the perceived similarity by human readers. In this paper, we conduct an experiment to measure the degree to which various word overlap metrics correlate to human-rated similarity of predicted and reference summaries. We evaluate alternatives based on current work in semantic similarity metrics and propose recommendations for evaluation of source code summarization.</p>
</td>
	<td>human evaluation evaluation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/guo2022learning/">Learning to Complete Code with Sketches</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Complete Code with Sketches' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Complete Code with Sketches' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Daya Guo, Alexey Svyatkovskiy, Jian Yin, Nan Duan, Marc Brockschmidt, Miltiadis Allamanis</td>
	<td>ICLR</td>
	<td><p>Code completion is usually cast as a language modelling problem, i.e., continuing an input in a left-to-right fashion. However, in practice, some parts of the completion (e.g., string literals) may be very hard to predict, whereas subsequent parts directly follow from the context. To handle this, we instead consider the scenario of generating code completions with “holes” inserted in places where a model is uncertain. We develop Grammformer, a Transformer-based model that guides code generation by the programming language grammar, and compare it to a variety of more standard sequence models.</p>

<p>We train the models on code completion for C# and Python given partial code context. To evaluate models, we consider both ROUGE as well as a new metric RegexAcc that measures success of generating completions matching long outputs with as few holes as possible. In our experiments, Grammformer generates 10-50% more accurate completions compared to traditional generative models and 37-50% longer sketches compared to sketch-generating baselines trained with similar techniques.</p>
</td>
	<td>Transformer language model grammar </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/guo2022unixcoder/">UniXcoder: Unified Cross-Modal Pre-training for Code Representation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=UniXcoder: Unified Cross-Modal Pre-training for Code Representation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=UniXcoder: Unified Cross-Modal Pre-training for Code Representation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Daya Guo, Shuai Lu, Nan Duan, Yanlin Wang, Ming Zhou, Jian Yin</td>
	<td></td>
	<td><p>Pre-trained models for programming languages have recently demonstrated great success on code intelligence. To support both code-related understanding and generation tasks, recent works attempt to pre-train unified encoder-decoder models. However, such encoder-decoder framework is sub-optimal for auto-regressive tasks, especially code completion that requires a decoder-only manner for efficient inference. In this paper, we present UniXcoder, a unified cross-modal pre-trained model for programming language. The model utilizes mask attention matrices with prefix adapters to control the behavior of the model and leverages cross-modal contents like AST and code comment to enhance code representation. To encode AST that is represented as a tree in parallel, we propose a one-to-one mapping method to transform AST in a sequence structure that retains all structural information from the tree. Furthermore, we propose to utilize multi-modal contents to learn representation of code fragment with contrastive learning, and then align representations among programming languages using a cross-modal generation task. We evaluate UniXcoder on five code-related tasks over nine datasets. To further evaluate the performance of code fragment representation, we also construct a dataset for a new task, called zero-shot code-to-code search. Results show that our model achieves state-of-the-art performance on most tasks and analysis reveals that comment and AST can both enhance UniXcoder.</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/gui2022cross/">Cross-Language Binary-Source Code Matching with Intermediate Representations</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Cross-Language Binary-Source Code Matching with Intermediate Representations' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Cross-Language Binary-Source Code Matching with Intermediate Representations' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yi Gui, Yao Wan, Hongyu Zhang, Huifang Huang, Yulei Sui, Guandong Xu, Zhiyuan Shao, Hai Jin</td>
	<td>SANER</td>
	<td><p>Binary-source code matching plays an important role in many security and software engineering related tasks such as malware detection, reverse engineering and vulnerability assessment. Currently, several approaches have been proposed for binary-source code matching by jointly learning the embeddings of binary code and source code in a common vector space. Despite much effort, existing approaches target on matching the binary code and source code written in a single programming language. However, in practice, software applications are often written in different programming languages to cater for different requirements and computing platforms. Matching binary and source code across programming languages introduces additional challenges when maintaining multi-language and multi-platform applications. To this end, this paper formulates the problem of cross-language binary-source code matching, and develops a new dataset for this new problem. We present a novel approach XLIR, which is a Transformer-based neural network by learning the intermediate representations for both binary and source code. To validate the effectiveness of XLIR, comprehensive experiments are conducted on two tasks of cross-language binary-source code matching, and cross-language source-source code matching, on top of our curated dataset. Experimental results and analysis show that our proposed XLIR with intermediate representations significantly outperforms other state-of-the-art models in both of the two tasks.</p>
</td>
	<td>code similarity clone </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/fried2022incoder/">InCoder: A Generative Model for Code Infilling and Synthesis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=InCoder: A Generative Model for Code Infilling and Synthesis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=InCoder: A Generative Model for Code Infilling and Synthesis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Daniel Fried, Armen Aghajanyan, Jessy Lin, Sida Wang, Eric Wallace, Freda Shi, Ruiqi Zhong, Wen-tau Yih, Luke Zettlemoyer, Mike Lewis</td>
	<td></td>
	<td><p>Code is seldom written in a single left-to-right pass and is instead repeatedly edited and refined. We introduce InCoder, a unified generative model that can perform program synthesis (via left-to-right generation) as well as editing (via infilling). InCoder is trained to generate code files from a large corpus of permissively licensed code, where regions of code have been randomly masked and moved to the end of each file, allowing code infilling with bidirectional context. Our model is the first generative model that is able to directly perform zero-shot code infilling, which we evaluate on challenging tasks such as type inference, comment generation, and variable re-naming. We find that the ability to condition on bidirectional context substantially improves performance on these tasks, while still performing comparably on standard program synthesis benchmarks in comparison to left-to-right only models pretrained at similar scale. The InCoder models and code are publicly released at https://sites.google.com/view/incoder-code-models</p>
</td>
	<td>Transformer code generation naming summarization </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/garg2022deepperf/">DeepPERF: A Deep Learning-Based Approach For Improving Software Performance</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DeepPERF: A Deep Learning-Based Approach For Improving Software Performance' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DeepPERF: A Deep Learning-Based Approach For Improving Software Performance' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Spandan Garg, Roshanak Zilouchian Moghaddam, Colin B. Clement, Neel Sundaresan, Chen Wu</td>
	<td></td>
	<td><p>Improving software performance is an important yet challenging part of the software development cycle. Today, the majority of performance inefficiencies are identified and patched by performance experts. Recent advancements in deep learning approaches and the wide-spread availability of open source data creates a great opportunity to automate the identification and patching of performance problems. In this paper, we present DeepPERF, a transformer-based approach to suggest performance improvements for C# applications. We pretrain DeepPERF on English and Source code corpora and followed by finetuning for the task of generating performance improvement patches for C# applications. Our evaluation shows that our model can generate the same performance improvement suggestion as the developer fix in ~53% of the cases, getting ~34% of them verbatim in our expert-verified dataset of performance changes made by C# developers. Additionally, we evaluate DeepPERF on 50 open source C# repositories on GitHub using both benchmark and unit tests and find that our model is able to suggest valid performance improvements that can improve both CPU usage and Memory allocations. So far we’ve submitted 19 pull-requests with 28 different performance optimizations and 11 of these PRs have been approved by the project owners.</p>
</td>
	<td>Transformer optimization </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/eghbali2022crystalbleu/">CrystalBLEU: Precisely and Efficiently Measuring the Similarity of Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CrystalBLEU: Precisely and Efficiently Measuring the Similarity of Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CrystalBLEU: Precisely and Efficiently Measuring the Similarity of Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Aryaz Eghbali, Michael Pradel</td>
	<td>ASE</td>
	<td><p>Recent years have brought a surge of work on predicting pieces
of source code, e.g., for code completion, code migration, program
repair, or translating natural language into code. All this work faces
the challenge of evaluating the quality of a prediction w.r.t. some
oracle, typically in the form of a reference solution. A common
evaluation metric is the BLEU score, an n-gram-based metric originally proposed for evaluating natural language translation, but
adopted in software engineering because it can be easily computed
on any programming language and enables automated evaluation at
scale. However, a key difference between natural and programming
languages is that in the latter, completely unrelated pieces of code
may have many common n-grams simply because of the syntactic
verbosity and coding conventions of programming languages. We
observe that these trivially shared n-grams hamper the ability of
the metric to distinguish between truly similar code examples and
code examples that are merely written in the same language. This
paper presents CrystalBLEU, an evaluation metric based on BLEU,
that allows for precisely and efficiently measuring the similarity of
code. Our metric preserves the desirable properties of BLEU, such
as being language-agnostic, able to handle incomplete or partially
incorrect code, and efficient, while reducing the noise caused by
trivially shared n-grams. We evaluate CrystalBLEU on two datasets
from prior work and on a new, labeled dataset of semantically equivalent programs. Our results show that CrystalBLEU can distinguish
similar from dissimilar code examples 1.9–4.5 times more effectively, when compared to the original BLEU score and a previously
proposed variant of BLEU for code.</p>
</td>
	<td>evaluation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/doderlein2022piloting/">Piloting Copilot and Codex: Hot Temperature, Cold Prompts, or Black Magic?</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Piloting Copilot and Codex: Hot Temperature, Cold Prompts, or Black Magic?' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Piloting Copilot and Codex: Hot Temperature, Cold Prompts, or Black Magic?' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jean-Baptiste Döderlein, Mathieu Acher, Djamel Eddine Khelladi, Benoit Combemale</td>
	<td></td>
	<td><p>Language models are promising solutions for tackling increasing complex problems. In software engineering, they recently attracted attention in code assistants, with programs automatically written in a given programming language from a programming task description in natural language. They have the potential to save time and effort when writing code. However, these systems are currently poorly understood, preventing them from being used optimally. In this paper, we investigate the various input parameters of two language models, and conduct a study to understand if variations of these input parameters (e.g. programming task description and the surrounding context, creativity of the language model, number of generated solutions) can have a significant impact on the quality of the generated programs. We design specific operators for varying input parameters and apply them over two code assistants (Copilot and Codex) and two benchmarks representing algorithmic problems (HumanEval and LeetCode). Our results showed that varying the input parameters can significantly improve the performance of language models. However, there is a tight dependency when varying the temperature, the prompt and the number of generated solutions, making potentially hard for developers to properly control the parameters to obtain an optimal result. This work opens opportunities to propose (automated) strategies for improving performance.</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/dinella2022toga/">TOGA: A Neural Method for Test Oracle Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=TOGA: A Neural Method for Test Oracle Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=TOGA: A Neural Method for Test Oracle Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Elizabeth Dinella, Gabriel Ryan, Todd Mytkowicz, Shuvendu K. Lahiri</td>
	<td>ICSE</td>
	<td><p>Testing is widely recognized as an important stage of the software
development lifecycle. Effective software testing can provide benefits such as bug finding, preventing regressions, and documentation.
In terms of documentation, unit tests express a unit’s intended
functionality, as conceived by the developer. A test oracle, typically expressed as an condition, documents the intended behavior
of a unit under a given test prefix. Synthesizing a functional test
oracle is a challenging problem, as it must capture the intended
functionality rather than the implemented functionality.
In this paper, we propose TOGA (a neural method for Test Oracle
GenerAtion), a unified transformer-based neural approach to infer
both exceptional and assertion test oracles based on the context of
the focal method. Our approach can handle units with ambiguous
or missing documentation, and even units with a missing implementation. We evaluate our approach on both oracle inference accuracy
and functional bug-finding. Our technique improves accuracy by
33% over existing oracle inference approaches, achieving 96% overall accuracy on a held out test dataset. Furthermore, we show that
when integrated with a automated test generation tool (EvoSuite),
our approach finds 57 real world bugs in large-scale Java programs,
including 30 bugs that are not found by any other automated testing
method in our evaluation</p>
</td>
	<td>code generation Transformer test generation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/deze2022bridging/">Bridging Pre-trained Models and Downstream Tasks for Source Code Understanding</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Bridging Pre-trained Models and Downstream Tasks for Source Code Understanding' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Bridging Pre-trained Models and Downstream Tasks for Source Code Understanding' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Deze Wang, Zhouyang Jia, Shanshan Li, Yue Yu, Yun Xiong, Wei Dong, Xiangke Liao</td>
	<td>ICSE</td>
	<td><p>With the great success of pre-trained models, the pretrain-then-finetune paradigm has been widely adopted on downstream tasks for source code understanding. However, compared to costly training a large-scale model from scratch, how to effectively adapt pre-trained models to a new task has not been fully explored. In this paper, we propose an approach to bridge pre-trained models and code-related tasks. We exploit semantic-preserving transformation to enrich downstream data diversity, and help pre-trained models learn semantic features that are invariant to these semantically equivalent transformations. Further, we introduce curriculum learning to organize the transformed data in an easy-to-hard manner to fine-tune existing pre-trained models.</p>

<p>We apply our approach to a range of pre-trained models, and they significantly outperform the state-of-the-art models on tasks for source code understanding, such as algorithm classification, code clone detection, and code search. Our experiments even show that without heavy pre-training on code data, natural language pre-trained model RoBERTa fine-tuned with our lightweight approach could outperform or rival existing code pre-trained models fine-tuned on the above tasks, such as CodeBERT and GraphCodeBERT. This finding suggests that there is still much room for improvement in code pre-trained models.</p>
</td>
	<td>representation language model </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/henkel2020semantic/">Semantic Robustness of Models of Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Semantic Robustness of Models of Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Semantic Robustness of Models of Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jordan Henkel, Goutham Ramakrishnan, Zi Wang, Aws Albarghouthi, Somesh Jha, Thomas Reps</td>
	<td>SANER</td>
	<td><p>Deep neural networks are vulnerable to adversarial examples - small input perturbations that result in incorrect predictions. We study this problem for models of source code, where we want the neural network to be robust to source-code modifications that preserve code functionality. To facilitate training robust models, we define a powerful and generic adversary that can employ sequences of parametric, semantics-preserving program transformations. We then explore how, with such an adversary, one can train models that are robust to adversarial program transformations. We conduct a thorough evaluation of our approach and find several surprising facts: we find robust training to beat dataset augmentation in every evaluation we performed; we find that a state-of-the-art architecture (code2seq) for models of code is harder to make robust than a simpler baseline; additionally, we find code2seq to have surprising weaknesses not present in our simpler baseline model; finally, we find that robust models perform better against unseen data from different sources (as one might hope) - however, we also find that robust models are not clearly better in the cross-language transfer task. To the best of our knowledge, we are the first to study the interplay between robustness of models of code and the domain-adaptation and cross-language transfer tasks.</p>
</td>
	<td>adversarial naming </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/chen2022codet/">CodeT: Code Generation with Generated Tests</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeT: Code Generation with Generated Tests' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeT: Code Generation with Generated Tests' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Bei Chen, Fengji Zhang, Anh Nguyen, Daoguang Zan, Zeqi Lin, Jian-Guang Lou, Weizhu Chen</td>
	<td></td>
	<td><p>Given a programming problem, pre-trained language models such as Codex have demonstrated the ability to generate multiple different code solutions via sampling. However, selecting a correct or best solution from those samples still remains a challenge. While an easy way to verify the correctness of a code solution is through executing test cases, producing high-quality test cases is prohibitively expensive. In this paper, we explore the use of pre-trained language models to automatically generate test cases, calling our method CodeT: Code generation with generated Tests. CodeT executes the code solutions using the generated test cases, and then chooses the best solution based on a dual execution agreement with both the generated test cases and other generated solutions. We evaluate CodeT on five different pre-trained models with both HumanEval and MBPP benchmarks. Extensive experimental results demonstrate CodeT can achieve significant, consistent, and surprising improvements over previous methods. For example, CodeT improves the pass@1 on HumanEval to 65.8%, an increase of absolute 18.8% on the code-davinci-002 model, and an absolute 20+% improvement over previous state-of-the-art results.</p>
</td>
	<td>synthesis Transformer execution </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/ziegler2022productivity/">Productivity Assessment of Neural Code Completion</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Productivity Assessment of Neural Code Completion' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Productivity Assessment of Neural Code Completion' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Albert Ziegler, Eirini Kalliamvakou, Shawn Simister, Ganesh Sittampalam, Alice Li, Andrew Rice, Devon Rifkin, Edward Aftandilian</td>
	<td>MAPS</td>
	<td><p>Neural code synthesis has reached a point where snippet generation is accurate enough to be considered for integration into human software development workflows. Commercial products aim to increase programmers’ productivity, without being able to measure it directly. In this case study, we asked users of GitHub Copilot about its impact on their productivity, and sought to find a reflection of their perception in directly measurable user data. We find that the rate with which shown suggestions are accepted, rather than more specific metrics regarding the persistence of completions in the code over time, drives developers’ perception of productivity.</p>
</td>
	<td>evaluation human evaluation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/zhou2022docoder/">DocCoder: Generating Code by Retrieving and Reading Docs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DocCoder: Generating Code by Retrieving and Reading Docs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DocCoder: Generating Code by Retrieving and Reading Docs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shuyan Zhou, Uri Alon, Frank F. Xu, Zhengbao JIang, Graham Neubig</td>
	<td></td>
	<td><p>Natural-language-to-code models learn to generate a code snippet given a natural language (NL) intent. However, the rapid growth of both publicly available and proprietary libraries and functions makes it impossible to cover all APIs using training examples, as new libraries and functions are introduced daily. Thus, existing models inherently cannot generalize to using unseen functions and libraries merely through incorporating them into the training data. In contrast, when human programmers write programs, they frequently refer to textual resources such as code manuals, documentation, and tutorials, to explore and understand available library functionality. Inspired by this observation, we introduce DocCoder: an approach that explicitly leverages code manuals and documentation by (1) retrieving the relevant documentation given the NL intent, and (2) generating the code based on the NL intent and the retrieved documentation. Our approach is general, can be applied to any programming language, and is agnostic to the underlying neural model. We demonstrate that DocCoder consistently improves NL-to-code models: DocCoder achieves 11x higher exact match accuracy than strong baselines on a new Bash dataset tldr; on the popular Python CoNaLa benchmark, DocCoder improves over strong baselines by 1.65 BLEU.</p>
</td>
	<td>Transformer search code generation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/bieber2022static/">Static Prediction of Runtime Errors by Learning to Execute Programs with External Resource Descriptions</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Static Prediction of Runtime Errors by Learning to Execute Programs with External Resource Descriptions' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Static Prediction of Runtime Errors by Learning to Execute Programs with External Resource Descriptions' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>David Bieber, Rishab Goel, Daniel Zheng, Hugo Larochelle, Daniel Tarlow</td>
	<td></td>
	<td><p>The execution behavior of a program often depends on external resources, such as program inputs or file contents, and so cannot be run in isolation. Nevertheless, software developers benefit from fast iteration loops where automated tools identify errors as early as possible, even before programs can be compiled and run. This presents an interesting machine learning challenge: can we predict runtime errors in a “static” setting, where program execution is not possible? Here, we introduce a real-world dataset and task for predicting runtime errors, which we show is difficult for generic models like Transformers. We approach this task by developing an interpreter-inspired architecture with an inductive bias towards mimicking program executions, which models exception handling and “learns to execute” descriptions of the contents of external resources. Surprisingly, we show that the model can also predict the location of the error, despite being trained only on labels indicating the presence/absence and kind of error. In total, we present a practical and difficult-yet-approachable challenge problem related to learning program execution and we demonstrate promising new capabilities of interpreter-inspired machine learning models for code.</p>
</td>
	<td>dataset defect </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/bibaev2022all/">All You Need Is Logs: Improving Code Completion by Learning from Anonymous IDE Usage Logs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=All You Need Is Logs: Improving Code Completion by Learning from Anonymous IDE Usage Logs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=All You Need Is Logs: Improving Code Completion by Learning from Anonymous IDE Usage Logs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vitaliy Bibaev, Alexey Kalina, Vadim Lomshakov, Yaroslav Golubev, Alexander Bezzubov, Nikita Povarov, Timofey Bryksin</td>
	<td>ESEC/FSE</td>
	<td><p>We propose an approach for collecting completion usage logs from the users in an IDE and using them to train a machine learning based model for ranking completion candidates.
We developed a set of features that describe completion candidates and their context, and deployed their anonymized collection in the Early Access Program of IntelliJ-based IDEs.
We used the logs to collect a dataset of code completions from users, and employed it to train a ranking CatBoost model.
Then, we evaluated it in two settings: on a held-out set of the collected completions and in a separate A/B test on two different groups of users in the IDE.
Our evaluation shows that using a simple ranking model trained on the past user behavior logs significantly improved code completion experience.
Compared to the default heuristics-based ranking, our model demonstrated a decrease in the number of typing actions necessary to perform the completion in the IDE from 2.073 to 1.832.
The approach adheres to privacy requirements and legal constraints, since it does not require collecting personal information, performing all the necessary anonymization on the client’s side.
Importantly, it can be improved continuously: implementing new features, collecting new data, and evaluating new models - this way, we have been using it in production since the end of 2020.</p>
</td>
	<td>autocomplete </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/sharma2022exploratory/">An Exploratory Study on Code Attention in BERT</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=An Exploratory Study on Code Attention in BERT' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=An Exploratory Study on Code Attention in BERT' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rishab Sharma, Fuxiang Chen, Fatemeh H. Fard, David Lo</td>
	<td>ICPC</td>
	<td><p>Many recent models in software engineering introduced deep neural models based on the Transformer architecture or use transformer-based Pre-trained Language Models (PLM) trained on code. Although these models achieve the state of the arts results in many downstream tasks such as code summarization and bug detection, they are based on Transformer and PLM, which are mainly studied in the Natural Language Processing (NLP) field. The current studies rely on the reasoning and practices from NLP for these models in code, despite the differences between natural languages and programming languages. There is also limited literature on explaining how code is modeled. Here, we investigate the attention behavior of PLM on code and compare it with natural language. We pre-trained BERT, a Transformer based PLM, on code and explored what kind of information it learns, both semantic and syntactic. We run several experiments to analyze the attention values of code constructs on each other and what BERT learns in each layer. Our analyses show that BERT pays more attention to syntactic entities, specifically identifiers and separators, in contrast to the most attended token [CLS] in NLP. This observation motivated us to leverage identifiers to represent the code sequence instead of the [CLS] token when used for code clone detection. Our results show that employing embeddings from identifiers increases the performance of BERT by 605% and 4% F1-score in its lower layers and the upper layers, respectively. When identifiers’ embeddings are used in CodeBERT, a code-based PLM, the performance is improved by 21–24% in the F1-score of clone detection. The findings can benefit the research community by using code-specific representations instead of applying the common embeddings used in NLP, and open new directions for developing smaller models with similar performance.</p>

</td>
	<td>Transformer representation language model interpretability pretraining clone </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/sharma2022lamner/">LAMNER: Code Comment Generation Using Character Language Model and Named Entity Recognition</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=LAMNER: Code Comment Generation Using Character Language Model and Named Entity Recognition' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=LAMNER: Code Comment Generation Using Character Language Model and Named Entity Recognition' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rishab Sharma, Fuxiang Chen, Fatemeh H. Fard</td>
	<td>ICPC</td>
	<td><p>Code comment generation is the task of generating a high-level natural language description for a given code method/function. Although researchers have been studying multiple ways to generate code comments automatically, previous work mainly considers representing a code token in its entirety semantics form only (e.g., a language model is used to learn the semantics of a code token), and additional code properties such as the tree structure of a code are included as an auxiliary input to the model. There are two limitations: 1) Learning the code token in its entirety form may not be able to capture information succinctly in source code, and 2)The code token does not contain additional syntactic information, inherently important in programming languages. In this paper, we present LAnguage Model and Named Entity Recognition (LAMNER), a code comment generator capable of encoding code constructs effectively and capturing the structural property of a code token. A character-level language model is used to learn the semantic representation to encode a code token. For the structural property of a token, a Named Entity Recognition model is trained to learn the different types of code tokens. These representations are then fed into an encoder-decoder architecture to generate code comments. We evaluate the generated comments from LAMNER and other baselines on a popular Java dataset with four commonly used metrics. Our results show that LAMNER is effective and improves over the best baseline model in BLEU-1, BLEU-2, BLEU-3, BLEU-4, ROUGE-L, METEOR, and CIDEr by 14.34%, 18.98%, 21.55%, 23.00%, 10.52%, 1.44%, and 25.86%, respectively. Additionally, we fused LAMNER’s code representation with the baseline models, and the fused models consistently showed improvement over the nonfused models. The human evaluation further shows that LAMNER produces high-quality code comments.</p>

</td>
	<td>summarization documentation language model types representation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/sarkar2022what/">What is it like to program with artificial intelligence?</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=What is it like to program with artificial intelligence?' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=What is it like to program with artificial intelligence?' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Advait Sarkar, Andrew D. Gordon, Carina Negreanu, Christian Poelitz, Sruti Srinivasa Ragavan, Ben Zorn</td>
	<td></td>
	<td><p>Large language models, such as OpenAI’s codex and Deepmind’s AlphaCode, can generate code to solve a variety of problems expressed in natural language. This technology has already been commercialised in at least one widely-used programming editor extension: GitHub Copilot.</p>

<p>In this paper, we explore how programming with large language models (LLM-assisted programming) is similar to, and differs from, prior conceptualisations of programmer assistance. We draw upon publicly available experience reports of LLM-assisted programming, as well as prior usability and design studies. We find that while LLM-assisted programming shares some properties of compilation, pair programming, and programming via search and reuse, there are fundamental differences both in the technical possibilities as well as the practical experience. Thus, LLM-assisted programming ought to be viewed as a new way of programming with its own distinct properties and challenges.</p>

<p>Finally, we draw upon observations from a user study in which non-expert end user programmers use LLM-assisted tools for solving data tasks in spreadsheets. We discuss the issues that might arise, and open research challenges, in applying large language models to end-user programming, particularly with users who have little or no programming expertise.</p>
</td>
	<td>human evaluation review </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/sahu2022learning/">Learning to Answer Semantic Queries over Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Answer Semantic Queries over Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Answer Semantic Queries over Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Surya Prakash Sahu, Madhurima Mandal, Shikhar Bharadwaj, Aditya Kanade, Petros Maniatis, Shirish Shevade</td>
	<td></td>
	<td><p>During software development, developers need answers to queries about semantic aspects of code. Even though extractive question-answering using neural approaches has been studied widely in natural languages, the problem of answering semantic queries over code using neural networks has not yet been explored. This is mainly because there is no existing dataset with extractive question and answer pairs over code involving complex concepts and long chains of reasoning. We bridge this gap by building a new, curated dataset called CodeQueries, and proposing a neural question-answering methodology over code.
We build upon state-of-the-art pre-trained models of code to predict answer and supporting-fact spans. Given a query and code, only some of the code may be relevant to answer the query. We first experiment under an ideal setting where only the relevant code is given to the model and show that our models do well. We then experiment under three pragmatic considerations: (1) scaling to large-size code, (2) learning from a limited number of examples and (3) robustness to minor syntax errors in code. Our results show that while a neural model can be resilient to minor syntax errors in code, increasing size of code, presence of code that is not relevant to the query, and reduced number of training examples limit the model performance. We are releasing our data and models to facilitate future work on the proposed problem of answering semantic queries over code.</p>
</td>
	<td>static analysis Transformer </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/shi2022cv4code/">CV4Code: Sourcecode Understanding via Visual Code Representations</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CV4Code: Sourcecode Understanding via Visual Code Representations' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CV4Code: Sourcecode Understanding via Visual Code Representations' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ruibo Shi, Lili Tao, Rohan Saphal, Fran Silavong, Sean J. Moran</td>
	<td></td>
	<td><p>We present CV4Code, a compact and effective computer vision method for sourcecode understanding. Our method leverages the contextual and the structural information available from the code snippet by treating each snippet as a two-dimensional image, which naturally encodes the context and retains the underlying structural information through an explicit spatial representation. To codify snippets as images, we propose an ASCII codepoint-based image representation that facilitates fast generation of sourcecode images and eliminates redundancy in the encoding that would arise from an RGB pixel representation. Furthermore, as sourcecode is treated as images, neither lexical analysis (tokenisation) nor syntax tree parsing is required, which makes the proposed method agnostic to any particular programming language and lightweight from the application pipeline point of view. CV4Code can even featurise syntactically incorrect code which is not possible from methods that depend on the Abstract Syntax Tree (AST). We demonstrate the effectiveness of CV4Code by learning Convolutional and Transformer networks to predict the functional task, i.e. the problem it solves, of the source code directly from its two-dimensional representation, and using an embedding from its latent space to derive a similarity score of two code snippets in a retrieval setup. Experimental results show that our approach achieves state-of-the-art performance in comparison to other methods with the same task and data configurations. For the first time we show the benefits of treating sourcecode understanding as a form of image processing task.</p>
</td>
	<td>code similarity Transformer </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/richter2022can/">Can we learn from developer mistakes? Learning to localize and repair real bugs from real bug fixes</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Can we learn from developer mistakes? Learning to localize and repair real bugs from real bug fixes' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Can we learn from developer mistakes? Learning to localize and repair real bugs from real bug fixes' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Cedric Richter, Heike Wehrheim</td>
	<td></td>
	<td><p>Real bug fixes found in open source repositories seem to be the perfect source for learning to localize and repair real bugs. However, the absence of large scale bug fix collections has made it difficult to effectively exploit real bug fixes in the training of larger neural models in the past. In contrast, artificial bugs – produced by mutating existing source code – can be easily obtained at a sufficient scale and are therefore often preferred in the training of existing approaches. Still, localization and repair models that are trained on artificial bugs usually underperform when faced with real bugs. This raises the question whether bug localization and repair models trained on real bug fixes are more effective in localizing and repairing real bugs.</p>

<p>We address this question by introducing RealiT, a pre-train-and-fine-tune approach for effectively learning to localize and repair real bugs from real bug fixes. RealiT is first pre-trained on a large number of artificial bugs produced by traditional mutation operators and then fine-tuned on a smaller set of real bug fixes. Fine-tuning does not require any modifications of the learning algorithm and hence can be easily adopted in various training scenarios for bug localization or repair (even when real training data is scarce). In addition, we found that training on real bug fixes with RealiT is empirically powerful by nearly doubling the localization performance of an existing model on real bugs while maintaining or even improving the repair performance.</p>
</td>
	<td>Transformer repair defect </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/reid2022learning/">Learning to Model Editing Processes</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Model Editing Processes' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Model Editing Processes' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Machel Reid, Graham Neubig</td>
	<td></td>
	<td><p>Most existing sequence generation models produce outputs in one pass, usually left-to-right. However, this is in contrast with a more natural approach that humans use in generating content; iterative refinement and editing. Recent work has introduced edit-based models for various tasks (such as neural machine translation and text style transfer), but these generally model a single edit step. In this work, we propose modeling editing processes, modeling the whole process of iteratively generating sequences. We form a conceptual framework to describe the likelihood of multi-step edits, and describe neural models that can learn a generative model of sequences based on these multistep edits. We introduce baseline results and metrics on this task, finding that modeling editing processes improves performance on a variety of axes on both our proposed task and related downstream tasks compared to previous single-step models of edits.</p>
</td>
	<td>Transformer edit </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/ramakrishnan2020backdoors/">Backdoors in Neural Models of Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Backdoors in Neural Models of Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Backdoors in Neural Models of Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Goutham Ramakrishnan, Aws Albarghouthi</td>
	<td>ICPR</td>
	<td><p>Deep neural networks are vulnerable to a range of adversaries. A particularly pernicious class of vulnerabilities are backdoors, where model predictions diverge in the presence of subtle triggers in inputs. An attacker can implant a backdoor by poisoning the training data to yield a desired target prediction on triggered inputs. We study backdoors in the context of deep-learning for source code. (1) We define a range of backdoor classes for source-code tasks and show how to poison a dataset to install such backdoors. (2) We adapt and improve recent algorithms from robust statistics for our setting, showing that backdoors leave a spectral signature in the learned representation of source code, thus enabling detection of poisoned data. (3) We conduct a thorough evaluation on different architectures and languages, showing the ease of injecting backdoors and our ability to eliminate them.</p>
</td>
	<td>adversarial </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/rabin2022understanding/">Syntax-Guided Program Reduction for Understanding Neural Code Intelligence Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Syntax-Guided Program Reduction for Understanding Neural Code Intelligence Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Syntax-Guided Program Reduction for Understanding Neural Code Intelligence Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Md Rafiqul Islam Rabin, Aftab Hussain, Mohammad Amin Alipour</td>
	<td>MAPS</td>
	<td><p>Neural code intelligence (CI) models are opaque black-boxes and offer little insight on the features they use in making predictions. This opacity may lead to distrust in their prediction and hamper their wider adoption in safety-critical applications. Recently, input program reduction techniques have been proposed to identify key features in the input programs to improve the transparency of CI models. However, this approach is syntax-unaware and does not consider the grammar of the programming language. In this paper, we apply a syntax-guided program reduction technique that considers the grammar of the input programs during reduction. Our experiments on multiple models across different types of input programs show that the syntax-guided program reduction technique is faster and provides smaller sets of key tokens in reduced programs. We also show that the key tokens could be used in generating adversarial examples for up to 65% of the input programs.</p>
</td>
	<td>interpretability refactoring adversarial </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/rabin2022memorization/">Memorization and Generalization in Neural Code Intelligence Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Memorization and Generalization in Neural Code Intelligence Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Memorization and Generalization in Neural Code Intelligence Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Md Rafiqul Islam Rabin, Aftab Hussain, Mohammad Amin Alipour, Vincent J. Hellendoorn</td>
	<td>IST</td>
	<td><p>Deep Neural Networks (DNNs) are increasingly being used in software engineering and code intelligence tasks. These are powerful tools that are capable of learning highly generalizable patterns from large datasets through millions of parameters. At the same time, their large capacity can render them prone to memorizing data points. Recent work suggests that the memorization risk manifests especially strongly when the training dataset is noisy, involving many ambiguous or questionable samples, and memorization is the only recourse. The goal of this paper is to evaluate and compare the extent of memorization and generalization in neural code intelligence models. It aims to provide insights on how memorization may impact the learning behavior of neural models in code intelligence systems. To observe the extent of memorization in models, we add random noise to the original training dataset and use various metrics to quantify the impact of noise on various aspects of training and testing. We evaluate several state-of-the-art neural code intelligence models and benchmarks based on Java, Python, and Ruby codebases. Our results highlight important risks: millions of trainable parameters allow the neural networks to memorize anything, including noisy data, and provide a false sense of generalization. We observed all models manifest some forms of memorization. This can be potentially troublesome in most code intelligence tasks where they rely on rather noise-prone and repetitive data sources, such as code from GitHub. To the best of our knowledge, we provide the first study to quantify memorization effects in the domain of software engineering and code intelligence systems. This work raises awareness and provides new insights into important issues of training neural models in code intelligence systems that are usually overlooked by software engineering researchers.</p>
</td>
	<td>evaluation memorization generalizability refactoring language model </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/poesia2022synchromesh/">Synchromesh: Reliable code generation from pre-trained language models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Synchromesh: Reliable code generation from pre-trained language models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Synchromesh: Reliable code generation from pre-trained language models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Gabriel Poesia, Oleksandr Polozov, Vu Le, Ashish Tiwari, Gustavo Soares, Christopher Meek, Sumit Gulwani</td>
	<td>ICLR</td>
	<td><p>Large pre-trained language models have been used to generate code,providing a flexible interface for synthesizing programs from natural language specifications. However, they often violate syntactic and semantic rules of their output language, limiting their practical usability. In this paper, we propose Synchromesh: a framework for substantially improving the reliability of pre-trained models for code generation. Synchromesh comprises two components. First, it retrieves few-shot examples from a training bank using Target Similarity Tuning (TST), a novel method for semantic example selection. TST learns to recognize utterances that describe similar target programs despite differences in surface natural language features. Then, Synchromesh feeds the examples to a pre-trained language model and samples programs using Constrained Semantic Decoding (CSD): a general framework for constraining the output to a set of valid programs in the target language. CSD leverages constraints on partial outputs to sample complete correct programs, and needs neither re-training nor fine-tuning of the language model. We evaluate our methods by synthesizing code from natural language descriptions using GPT-3 and Codex in three real-world languages: SQL queries, Vega-Lite visualizations and SMCalFlow programs. These domains showcase rich constraints that CSD is able to enforce, including syntax, scope, typing rules, and contextual logic. We observe substantial complementary gains from CSD and TST in prediction accuracy and in effectively preventing run-time errors.</p>
</td>
	<td>Transformer language model </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/patil2022exploring/">Exploring Dimensions of Generalizability and Few-shot Transfer for Text-to-SQL Semantic Parsing</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Exploring Dimensions of Generalizability and Few-shot Transfer for Text-to-SQL Semantic Parsing' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Exploring Dimensions of Generalizability and Few-shot Transfer for Text-to-SQL Semantic Parsing' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rajaswa Patil, Manasi Patwardhan, Shirish Karande, Lovekesh Vig, Gautam Shroff</td>
	<td>The 1st Transfer Learning for Natural Language Processing Workshop (TL4NLP 2022)</td>
	<td><p>Existing work on generalization in Text-to-SQL semantic parsing has been restricted to a zero-shot cross-domain setting. In this paper, we introduce Spider-Gen: a Text-to-SQL benchmark to develop a paradigm of transfer learning across distinct dimensions of generalization in Text-to-SQL semantic parsing. The Spider-Gen benchmark focuses on few-shot adaption for Cross-domain, Lexical, and Structural generalization of Text-to-SQL models. Through our experiments with the Spider-Gen dataset, we show that Seq2Seq language models struggle to generalize against change in data distribution, lexical changes in database schema, and changes in SQL query complexity. Our experiments also reveal that performing few-shot fine-tuning helps Text-to-SQL models to generalize across these changes. However, such few-shot adaptation comes with a negative effect on the knowledge learnt during training. Hence, we also explore Parameter-efficient Fine-tuning methods to overcome the limitations of Seq2Seq Text-to-SQL models. We release the Spider-Gen dataset publicly to facilitate further research in generalization and transfer learning across various dimensions in Text-to-SQL semantic parsing.</p>
</td>
	<td>dataset evaluation Transformer benchmark generalizability </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/pashakhanloo2022codetrek/">CodeTrek: Flexible Modeling of Code using an Extensible Relational Representation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeTrek: Flexible Modeling of Code using an Extensible Relational Representation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeTrek: Flexible Modeling of Code using an Extensible Relational Representation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Pardis Pashakhanloo, Aaditya Naik, Yuepeng Wang, Hanjun Dai, Petros Maniatis, Mayur Naik</td>
	<td>ICLR</td>
	<td><p>Designing a suitable representation for code-reasoning tasks is challenging in aspects such as the kinds of program information to model, how to combine them, and how much context to consider. We propose CodeTrek, a deep learning approach that addresses these challenges by representing codebases as databases that conform to rich relational schemas. The relational representation not only allows CodeTrek to uniformly represent diverse kinds of program information, but also to leverage program-analysis queries to derive new semantic relations, which can be readily incorporated without further architectural engineering. CodeTrek embeds this relational representation using a set of walks that can traverse different relations in an unconstrained fashion, and incorporates all relevant attributes along the way. We evaluate CodeTrek on four diverse and challenging Python tasks: variable misuse, exception prediction, unused definition, and variable shadowing.
CodeTrek achieves an accuracy of 91%, 63%, 98%, and 94% on these tasks respectively, and outperforms state-of-the-art neural models by 2-19% points.</p>
</td>
	<td>representation variable misuse </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/parisi2022making/">Making the Most of Scarce Input Data in Deep Learning-Based Source Code Classification for Heterogeneous Device Mapping</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Making the Most of Scarce Input Data in Deep Learning-Based Source Code Classification for Heterogeneous Device Mapping' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Making the Most of Scarce Input Data in Deep Learning-Based Source Code Classification for Heterogeneous Device Mapping' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Emanuele Parisi, Francesco Barchi, Andrea Bartolini, Andrea Acquaviva</td>
	<td></td>
	<td><p>Despite its relatively recent history, deep learning (DL)-based source code analysis is already a cornerstone in machine learning for compiler optimization. When applied to the classification of pieces of code to identify the best computational unit in a heterogeneous Systems-on-Chip, it can be effective in supporting decisions that a programmer has otherwise to take manually. Several techniques have been proposed exploiting different networks and input information, prominently sequence-based and graph-based representations, complemented by auxiliary information typically related to payload and device configuration. While the accuracy of DL methods strongly depends on the training and test datasets, so far no exhaustive and statistically meaningful analysis has been done on its impact on the results and on how to effectively extract the available information. This is relevant also considering the scarce availability of source code datasets that can be labeled by profiling on heterogeneous compute units. In this article, we first present such a study, which leads us to devise the contribution of code sequences and auxiliary inputs separately. Starting from this analysis, we then demonstrate that by using the normalization of auxiliary information, it is possible to improve state-of-the-art results in terms of accuracy. Finally, we propose a novel approach exploiting Siamese networks that further improve mapping accuracy by increasing the cardinality of the dataset, thus compensating for its relatively small size.</p>
</td>
	<td>optimization program analysis static analysis language model </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/panthaplackel2022using/">Using Developer Discussions to Guide Fixing Bugs in Software</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Using Developer Discussions to Guide Fixing Bugs in Software' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Using Developer Discussions to Guide Fixing Bugs in Software' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sheena Panthaplackel, Milos Gligoric, Junyi Jessy Li, Raymond J. Mooney</td>
	<td>EMNLP</td>
	<td><p>Automatically fixing software bugs is a challenging task. While recent work showed that natural language context is useful in guiding bug-fixing models, the approach required prompting developers to provide this context, which was simulated through commit messages written after the bug-fixing code changes were made. We instead propose using bug report discussions, which are available before the task is performed and are also naturally occurring, avoiding the need for any additional information from developers. For this, we augment standard bug-fixing datasets with bug report discussions. Using these newly compiled datasets, we demonstrate that various forms of natural language context derived from such discussions can aid bug-fixing, even leading to improved performance over using commit messages corresponding to the oracle bug-fixing commits.</p>
</td>
	<td>Transformer repair </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/niu2022spt-code/">SPT-Code: Sequence-to-Sequence Pre-Training for Learning Source Code Representations</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=SPT-Code: Sequence-to-Sequence Pre-Training for Learning Source Code Representations' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=SPT-Code: Sequence-to-Sequence Pre-Training for Learning Source Code Representations' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Changan Niu, Chuanyi Li, Vincent Ng, Jidong Ge, Liguo Huang, Bin Luo</td>
	<td>ICSE</td>
	<td><p>Recent years have seen the successful application of large pre-trained modelsto code representation learning, resulting in substantial improvements on many code-related downstream tasks. But there are issues surrounding theirapplication to SE tasks. First, the majority of the pre-trained models focus on pre-training only the encoder of the Transformer. For generation tasks that are addressed using models with the encoder-decoder architecture, however, there is no reason why the decoder should be left out during pre-training. Second, many existing pre-trained models, including state-of-the-art models such as T5-learning, simply reuse the pre-training tasks designed for natural languages. Moreover, to learn the natural language description of source code needed eventually for code-related tasks such as code summarization, existingpre-training tasks require a bilingual corpus composed of source code and the associated natural language description, which severely limits the amount of data for pre-training. To this end, we propose SPT-Code, a sequence-to-sequence pre-trained model for source code. In order to pre-train SPT-Code in a sequence-to-sequence manner and address the aforementioned weaknesses associated with existing pre-training tasks, we introduce three pre-training tasks that are specifically designed to enable SPT-Code to learn knowledge of source code, the corresponding code structure, as well as a natural language description of the code without relying on any bilingual corpus, and eventually exploit these three sources of information when it is applied to downstreamt asks. Experimental results demonstrate that SPT-Code achieves state-of-the-artperformance on five code-related downstream tasks after fine-tuning.</p>
</td>
	<td>Transformer representation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/nijkamp2022conversational/">A Conversational Paradigm for Program Synthesis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Conversational Paradigm for Program Synthesis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Conversational Paradigm for Program Synthesis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Erik Nijkamp, Bo Pang, Hiroaki Hayashi, Lifu Tu, Huan Wang, Yingbo Zhou, Silvio Savarese, Caiming Xiong</td>
	<td></td>
	<td><p>Program synthesis strives to generate a computer program as a solution to a given problem specification. We propose a conversational program synthesis approach via large language models, which addresses the challenges of searching over a vast program space and user intent specification faced in prior approaches. Our new approach casts the process of writing a specification and program as a multi-turn conversation between a user and a system. It treats program synthesis as a sequence prediction problem, in which the specification is expressed in natural language and the desired program is conditionally sampled. We train a family of large language models, called CodeGen, on natural language and programming language data. With weak supervision in the data and the scaling up of data size and model size, conversational capacities emerge from the simple autoregressive language modeling. To study the model behavior on conversational program synthesis, we develop a multi-turn programming benchmark (MTPB), where solving each problem requires multi-step synthesis via multi-turn conversation between the user and the model. Our findings show the emergence of conversational capabilities and the effectiveness of the proposed conversational program synthesis paradigm. In addition, our model CodeGen (with up to 16B parameters trained on TPU-v4) outperforms OpenAI’s Codex on the HumanEval benchmark. We make the training library JaxFormer including checkpoints available as open source contribution: https://github.com/salesforce/CodeGen.</p>
</td>
	<td>Transformer synthesis </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/nadeem2022codedsi/">CodeDSI: Differentiable Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeDSI: Differentiable Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeDSI: Differentiable Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Usama Nadeem, Noah Ziems, Shaoen Wu</td>
	<td></td>
	<td><p>Reimplementing solutions to previously solved software engineering problems is not only inefficient but also introduces inadequate and error-prone code. Many existing methods achieve impressive performance on this issue by using autoregressive text-generation models trained on code. However, these methods are not without their flaws. The generated code from these models can be buggy, lack documentation, and introduce vulnerabilities that may go unnoticed by developers. An alternative to code generation – neural code search – is a field of machine learning where a model takes natural language queries as input and, in turn, relevant code samples from a database are returned. Due to the nature of this pre-existing database, code samples can be documented, tested, licensed, and checked for vulnerabilities before being used by developers in production. In this work, we present CodeDSI, an end-to-end unified approach to code search. CodeDSI is trained to directly map natural language queries to their respective code samples, which can be retrieved later. In an effort to improve the performance of code search, we have investigated docid representation strategies, impact of tokenization on docid structure, and dataset sizes on overall code search performance. Our results demonstrate CodeDSI strong performance, exceeding conventional robust baselines by 2-6% across varying dataset sizes.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/naik2022probing/">Probing Semantic Grounding in Language Models of Code with Representational Similarity Analysis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Probing Semantic Grounding in Language Models of Code with Representational Similarity Analysis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Probing Semantic Grounding in Language Models of Code with Representational Similarity Analysis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shounak Naik, Rajaswa Patil, Swati Agarwal, Veeky Baths</td>
	<td>International Conference on Advanced Data Mining and Applications (ADMA 2022)</td>
	<td><p>Representational Similarity Analysis is a method from cognitive neuroscience, which helps in comparing representations from two different sources of data. In this paper, we propose using Representational Similarity Analysis to probe the semantic grounding in language models of code. We probe representations from the CodeBERT model for semantic grounding by using the data from the IBM CodeNet dataset. Through our experiments, we show that current pre-training methods do not induce semantic grounding in language models of code, and instead focus on optimizing form-based patterns. We also show that even a little amount of fine-tuning on semantically relevant tasks increases the semantic grounding in CodeBERT significantly. Our ablations with the input modality to the CodeBERT model show that using bimodal inputs (code and natural language) over unimodal inputs (only code) gives better semantic grounding and sample efficiency during semantic fine-tuning. Finally, our experiments with semantic perturbations in code reveal that CodeBERT is able to robustly distinguish between semantically correct and incorrect code.</p>
</td>
	<td>interpretability language model evaluation Transformer </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/vaithilingam2022expectation/">Expectation vs. Experience: Evaluating the Usability of Code Generation Tools Powered by Large Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Expectation vs. Experience: Evaluating the Usability of Code Generation Tools Powered by Large Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Expectation vs. Experience: Evaluating the Usability of Code Generation Tools Powered by Large Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Priyan Vaithilingam, Tianyi Zhang, Elena Glassman</td>
	<td>CHI</td>
	<td><p>Recent advances in Large Language Models (LLM) have made automatic code generation possible for real-world programming tasks in
general-purpose programming languages such as Python. However,
there are few human studies on the usability of these tools and how
they fit the programming workflow. In this work, we conducted
a within-subjects user study with 24 participants to understand
how programmers use and perceive Copilot, a LLM-based code
generation tool. We found that, while Copilot did not necessarily
improve the task completion time or success rate, most participants preferred to use Copilot in daily programming tasks, since
Copilot often provided a useful starting point and saved the effort
of searching online. However, participants did face difficulties in
understanding, editing, and debugging code snippets generated
by Copilot, which significantly hindered their task-solving effectiveness. Finally, we highlighted several promising directions for
improving the design of Copilot based on our observations and
participants’ feedback.</p>
</td>
	<td>human evaluation code generation language model </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/szafraniec2022code/">Code Translation with Compiler Representations</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Code Translation with Compiler Representations' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Code Translation with Compiler Representations' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Marc Szafraniec, Baptiste Roziere, Hugh Leather, Francois Charton, Patrick Labatut, Gabriel Synnaeve</td>
	<td></td>
	<td><p>In this paper, we leverage low-level compiler intermediate representations (IR) to improve code translation. Traditional transpilers rely on syntactic information and handcrafted rules, which limits their applicability and produces unnatural-looking code. Applying neural machine translation (NMT) approaches to code has successfully broadened the set of programs on which one can get a natural-looking translation. However, they treat the code as sequences of text tokens, and still do not differentiate well enough between similar pieces of code which have different semantics in different languages. The consequence is low quality translation, reducing the practicality of NMT, and stressing the need for an approach significantly increasing its accuracy. Here we propose to augment code translation with IRs, specifically LLVM IR, with results on the C++, Java, Rust, and Go languages. Our method improves upon the state of the art for unsupervised code translation, increasing the number of correct translations by 11% on average, and up to 79% for the Java - Rust pair. We extend previous test sets for code translation, by adding hundreds of Go and Rust functions. Additionally, we train models with high performance on the problem of IR decompilation, generating programming source code from IR, and study using IRs as intermediary pivot for translation.</p>
</td>
	<td>Transformer migration decompilation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/siow2022learning/">Learning Program Semantics with Code Representations: An Empirical Study</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Program Semantics with Code Representations: An Empirical Study' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Program Semantics with Code Representations: An Empirical Study' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jing Kai Siow, Shangqing Liu, Xiaofei Xie, Guozhu Meng, Yang Liu</td>
	<td>SANER</td>
	<td><p>Program semantics learning is the core and fundamental for various code intelligent tasks e.g., vulnerability detection, clone detection. A considerable amount of existing works propose diverse approaches to learn the program semantics for different tasks and these works have achieved state-of-the-art performance. However, currently, a comprehensive and systematic study on evaluating different program representation techniques across diverse tasks is still missed.</p>

<p>From this starting point, in this paper, we conduct an empirical study to evaluate different program representation techniques. Specifically, we categorize current mainstream code representation techniques into four categories i.e., Feature-based, Sequence-based, Tree-based, and Graph-based program representation technique and evaluate its performance on three diverse and popular code intelligent tasks i.e., {Code Classification}, Vulnerability Detection, and Clone Detection on the public released benchmark. We further design three {research questions (RQs)} and conduct a comprehensive analysis to investigate the performance. By the extensive experimental results, we conclude that (1) The graph-based representation is superior to the other selected techniques across these tasks. (2) Compared with the node type information used in tree-based and graph-based representations, the node textual information is more critical to learning the program semantics. (3) Different tasks require the task-specific semantics to achieve their highest performance, however combining various program semantics from different dimensions such as control dependency, data dependency can still produce promising results.</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/silavong2022senatus/">Senatus - A Fast and Accurate Code-to-Code Recommendation Engine</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Senatus - A Fast and Accurate Code-to-Code Recommendation Engine' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Senatus - A Fast and Accurate Code-to-Code Recommendation Engine' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Fran Silavong, Sean Moran, Antonios Georgiadis, Rohan Saphal, Robert Otter</td>
	<td>MSR</td>
	<td><p>Machine learning on source code (MLOnCode) is a popular research field that has been driven by the availability of large-scale code repositories and the development of powerful probabilistic and deep learning models for mining source code. Code-to-code recommendation is a task in MLOnCode that aims to recommend relevant, diverse and concise code snippets that usefully extend the code currently being written by a developer in their development environment (IDE). Code-to-code recommendation engines hold the promise of increasing developer productivity by reducing context switching from the IDE and increasing code-reuse. Existing code-to-code recommendation engines do not scale gracefully to large codebases, exhibiting a linear growth in query time as the code repository increases in size. In addition, existing code-to-code recommendation engines fail to account for the global statistics of code repositories in the ranking function, such as the distribution of code snippet lengths, leading to sub-optimal retrieval results. We address both of these weaknesses with Senatus, a new code-to-code recommendation engine. At the core of Senatus is De-Skew LSH a new locality sensitive hashing (LSH) algorithm that indexes the data for fast (sub-linear time) retrieval while also counteracting the skewness in the snippet length distribution using novel abstract syntax tree-based feature scoring and selection algorithms. We evaluate Senatus and find the recommendations to be of higher quality than competing baselines, while achieving faster search. For example on the CodeSearchNet dataset Senatus improves performance by 31.21% F1 and  147.9x faster query time compared to Facebook Aroma. Senatus also outperforms standard MinHash LSH by 29.2% F1 and 51.02x faster query time.</p>
</td>
	<td>code similarity search </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/shrivastava2020repository/">Repository-Level Prompt Generation for Large Language Models of Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Repository-Level Prompt Generation for Large Language Models of Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Repository-Level Prompt Generation for Large Language Models of Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Disha Shrivastava, Hugo Larochelle, Daniel Tarlow</td>
	<td></td>
	<td><p>With the success of large language models (LLMs) of code and their use as code assistants (e.g. Codex used in GitHub Copilot), techniques for introducing domain-specific knowledge in the prompt design process become important. In this work, we propose a framework called Repo-Level Prompt Generator that learns to generate example-specific prompts using a set of rules. These rules take context from the entire repository, thereby incorporating both the structure of the repository and the context from other relevant files (e.g. imports, parent class files). Our technique doesn’t require any access to the weights of the LLM, making it applicable in cases where we only have black-box access to the LLM. We conduct experiments on the task of single-line code-autocompletion using code repositories taken from Google Code archives. We demonstrate that an oracle constructed from our proposed rules gives up to 36% relative improvement over Codex, showing the quality of the rules. Further, we show that when we train a model to select the best rule, we can achieve significant performance gains over Codex. The code for our work can be found at: https://github.com/shrivastavadisha/repo_level_prompt_generation .</p>
</td>
	<td>Transformer code completion </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/wan2022what/">What Do They Capture? -- A Structural Analysis of Pre-Trained Language Models for Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=What Do They Capture? -- A Structural Analysis of Pre-Trained Language Models for Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=What Do They Capture? -- A Structural Analysis of Pre-Trained Language Models for Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yao Wan, Wei Zhao, Hongyu Zhang, Yulei Sui, Guandong Xu, Hai Jin</td>
	<td>ICSE</td>
	<td><p>Recently, many pre-trained language models for source code have been proposed to model the context of code and serve as a basis for downstream code intelligence tasks such as code completion, code search, and code summarization. These models leverage masked pre-training and Transformer and have achieved promising results. However, currently there is still little progress regarding interpretability of existing pre-trained code models. It is not clear why these models work and what feature correlations they can capture. In this paper, we conduct a thorough structural analysis aiming to provide an interpretation of pre-trained language models for source code (e.g., CodeBERT, and GraphCodeBERT) from three distinctive perspectives: (1) attention analysis, (2) probing on the word embedding, and (3) syntax tree induction. Through comprehensive analysis, this paper reveals several insightful findings that may inspire future studies: (1) Attention aligns strongly with the syntax structure of code. (2) Pre-training language models of code can preserve the syntax structure of code in the intermediate representations of each Transformer layer. (3) The pre-trained models of code have the ability of inducing syntax trees of code. Theses findings suggest that it may be helpful to incorporate the syntax structure of code into the process of pre-training for better code representations.</p>
</td>
	<td>Transformer pretraining program analysis </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/xu2022systematic/">A Systematic Evaluation of Large Language Models of Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Systematic Evaluation of Large Language Models of Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Systematic Evaluation of Large Language Models of Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Frank F. Xu, Uri Alon, Graham Neubig, Vincent J. Hellendoorn</td>
	<td></td>
	<td><p>Large language models (LMs) of code have recently shown tremendous promise in completing code and synthesizing code from natural language descriptions. However, the current state-of-the-art code LMs (e.g., Codex (Chen et al., 2021)) are not publicly available, leaving many questions about their model and data design decisions. We aim to fill in some of these blanks through a systematic evaluation of the largest existing models: Codex, GPT-J, GPT-Neo, GPT-NeoX-20B, and CodeParrot, across various programming languages. Although Codex itself is not open-source, we find that existing open-source models do achieve close results in some programming languages, although targeted mainly for natural language modeling. We further identify an important missing piece in the form of a large open-source model trained exclusively on a multi-lingual corpus of code. We release a new model, PolyCoder, with 2.7B parameters based on the GPT-2 architecture, which was trained on 249GB of code across 12 programming languages on a single machine. In the C programming language, PolyCoder outperforms all models including Codex. Our trained models are open-source and publicly available at this https URL, which enables future research and application in this area.</p>
</td>
	<td>Transformer language model </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/yin2022natural/">Natural Language to Code Generation in Interactive Data Science Notebooks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Natural Language to Code Generation in Interactive Data Science Notebooks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Natural Language to Code Generation in Interactive Data Science Notebooks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Pengcheng Yin, Wen-Ding Li, Kefan Xiao, Abhishek Rao, Yeming Wen, Kensen Shi, Joshua Howland, Paige Bailey, Michele Catasta, Henryk Michalewski, Alex Polozov, Charles Sutton</td>
	<td></td>
	<td><p>Computational notebooks, such as Jupyter notebooks, are interactive computing environments that are ubiquitous among data scientists to perform data wrangling and analytic tasks. To measure the performance of AI pair programmers that automatically synthesize programs for those tasks given natural language (NL) intents from users, we build ARCADE, a benchmark of 1082 code generation problems using the pandas data analysis framework in data science notebooks. ARCADE features multiple rounds of NL-to-code problems from the same notebook. It requires a model to understand rich multi-modal contexts, such as existing notebook cells and their execution states as well as previous turns of interaction. To establish a strong baseline on this challenging task, we develop PaChiNCo, a 62B code language model (LM) for Python computational notebooks, which significantly outperforms public code LMs. Finally, we explore few-shot prompting strategies to elicit better code with step-by-step decomposition and NL explanation, showing the potential to improve the diversity and explainability of model predictions.</p>
</td>
	<td>notebook evaluation </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/bareiss2022code/">Code Generation Tools (Almost) for Free? A Study of Few-Shot, Pre-Trained Language Models on Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Code Generation Tools (Almost) for Free? A Study of Few-Shot, Pre-Trained Language Models on Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Code Generation Tools (Almost) for Free? A Study of Few-Shot, Pre-Trained Language Models on Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Patrick Bareiß, Beatriz Souza, Marcelo d'Amorim, Michael Pradel</td>
	<td></td>
	<td><p>Few-shot learning with large-scale, pre-trained language models is a powerful way to answer questions about code, e.g., how to complete a given code example, or even generate code snippets from scratch. The success of these models raises the question whether they could serve as a basis for building a wide range code generation tools. Traditionally, such tools are built manually and separately for each task. Instead, few-shot learning may allow to obtain different tools from a single pre-trained language model by simply providing a few examples or a natural language description of the expected tool behavior. This paper studies to what extent a state-of-the-art, pre-trained language model of code, Codex, may serve this purpose. We consider three code manipulation and code generation tasks targeted by a range of traditional tools: (i) code mutation; (ii) test oracle generation from natural language documentation; and (iii) test case generation. For each task, we compare few-shot learning to a manually built tool. Our results show that the model-based tools complement (code mutation), are on par (test oracle generation), or even outperform their respective traditionally built tool (test case generation), while imposing far less effort to develop them. By comparing the effectiveness of different variants of the model-based tools, we provide insights on how to design an appropriate input (“prompt”) to the model and what influence the size of the model has. For example, we find that providing a small natural language description of the code generation task is an easy way to improve predictions. Overall, we conclude that few-shot language models are surprisingly effective, yet there is still more work to be done, such as exploring more diverse ways of prompting and tackling even more involved tasks.</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/barchi2022deep/">Deep Learning Approaches to Source Code Analysis for Optimization of Heterogeneous Systems: Recent Results, Challenges and Opportunities</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Learning Approaches to Source Code Analysis for Optimization of Heterogeneous Systems: Recent Results, Challenges and Opportunities' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Learning Approaches to Source Code Analysis for Optimization of Heterogeneous Systems: Recent Results, Challenges and Opportunities' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Francesco Barchi, Emanuele Parisi, Andrea Bartolini, Andrea Acquaviva</td>
	<td></td>
	<td><p>To cope with the increasing complexity of digital systems programming, deep learning techniques have recently been proposed to enhance software deployment by analysing source code for different purposes, ranging from performance and energy improvement to debugging and security assessment. As embedded platforms for cyber-physical systems are characterised by increasing heterogeneity and parallelism, one of the most challenging and specific problems is efficiently allocating computational kernels to available hardware resources. In this field, deep learning applied to source code can be a key enabler to face this complexity. However, due to the rapid development of such techniques, it is not easy to understand which of those are suitable and most promising for this class of systems. For this purpose, we discuss recent developments in deep learning for source code analysis, and focus on techniques for kernel mapping on heterogeneous platforms, highlighting recent results, challenges and opportunities for their applications to cyber-physical systems.</p>
</td>
	<td>optimization review </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/barke2022grounded/">Grounded Copilot: How Programmers Interact with Code-Generating Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Grounded Copilot: How Programmers Interact with Code-Generating Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Grounded Copilot: How Programmers Interact with Code-Generating Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shraddha Barke, Michael B. James, Nadia Polikarpova</td>
	<td></td>
	<td><p>Powered by recent advances in code-generating models, AI assistants like Github Copilot promise to change the face of programming forever. But what is this new face of programming? We present the first grounded theory analysis of how programmers interact with Copilot, based on observing 20 participants–with a range of prior experience using the assistant–as they solve diverse programming tasks across four languages. Our main finding is that interactions with programming assistants are bimodal: in acceleration mode, the programmer knows what to do next and uses Copilot to get there faster; in exploration mode, the programmer is unsure how to proceed and uses Copilot to explore their options. Based on our theory, we provide recommendations for improving the usability of future AI programming assistants.</p>
</td>
	<td>human evaluation synthesis </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/allal2022santacoder/">SantaCoder: don’t reach for the stars!</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=SantaCoder: don’t reach for the stars!' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=SantaCoder: don’t reach for the stars!' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Loubna Ben Allal, Raymond Li, Denis Kocetkov, Chenghao Mou, Christopher Akiki, Carlos Munoz Ferrandis, Niklas Muenninghoff, Mayank Mishra, Alex Gu, Manan Den, Longesh Kumar Umapathi, Carolyn Jane Anderson, Yangtian Zi, Joel Lamy Poirier, Hailey Schoelkopf, Sergey Troshin, Dmitry Abulkhanov, Manuel Romero, Terry Yue Zhuo, Francesco De Toni, Bernanrdo Garcia del Rio, Qian Liu, Shamik Bose, Urvashi Bhattacharyya, Michael Lappert, Ian Yu, Paulo Villegas, Jia Li, David Lansy, Huu Nguyen, Danish Contractor, Luis Villa, Daniel Fried, Dzmitry Bahdanau, Yacine Jernite, Sean Hughes, Arjun Guha, Harm de Vries, Leonadro von Werra</td>
	<td></td>
	<td><p>The BigCode project is an open-scientific collaboration working on the responsible development of large language models for code.1 This tech report describes the progress of the collaboration until December 2022, outlining the current state of the Personally Identifiable Information (PII)
redaction pipeline, the experiments conducted to de-risk the model architecture, and the experiments investigating better preprocessing methods for the training data. We train 1.1B parameter models on the Java,
JavaScript, and Python subsets of The Stack (Kocetkov et al., 2022) and
evaluate the models on MultiPL-E (Cassano et al., 2022), a text2code
benchmark available in 18 programming languages. We find that more
aggressive filtering of near-duplicates can further boost performance and,
surprisingly, that selecting files from repositories with 5+ GitHub stars
deteriorates performance significantly. Our best model outperforms previous open-source multilingual code generation models (InCoder-6.7B and
CodeGen-Multi-2.7B) in both left-to-right generation and infilling on the
Java, JavaScript, and Python portions of MultiPL-E, despite being a substantially smaller model. All models are released under an OpenRAIL
license at https://hf.co/bigcode</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/bavarian2022efficient/">Efficient Training of Language Models to Fill in the Middle</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Efficient Training of Language Models to Fill in the Middle' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Efficient Training of Language Models to Fill in the Middle' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Mohammad Bavarian, Heewoo Jun, Nikolas Tezak, John Schulman, Christine McLeavey, Jerry Tworek, Mark Chen</td>
	<td></td>
	<td><p>We show that autoregressive language models can learn to infill text after we apply a straightforward transformation to the dataset, which simply moves a span of text from the middle of a document to its end. While this data augmentation has garnered much interest in recent years, we provide extensive evidence that training models with a large fraction of data transformed in this way does not harm the original left-to-right generative capability, as measured by perplexity and sampling evaluations across a wide range of scales. Given the usefulness, simplicity, and efficiency of training models to fill-in-the-middle (FIM), we suggest that future autoregressive language models be trained with FIM by default. To this end, we run a series of ablations on key hyperparameters, such as the data transformation frequency, the structure of the transformation, and the method of selecting the infill span. We use these ablations to prescribe strong default settings and best practices to train FIM models. We have released our best infilling model trained with best practices in our API, and release our infilling benchmarks to aid future research.</p>
</td>
	<td>Transformer language model </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/ahmed2022learning/">Learning code summarization from a small and local dataset</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning code summarization from a small and local dataset' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning code summarization from a small and local dataset' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Toufique Ahmed, Premkumar Devanbu</td>
	<td></td>
	<td><p>Foundation models (e.g., CodeBERT, GraphCodeBERT, CodeT5) work well for many software engineering tasks. These models are pre-trained (using self-supervision) with billions of code tokens, and then fine-tuned with hundreds of thousands of labeled examples, typically drawn from many projects. However, software phenomena can be very project-specific. Vocabulary, and other phenomena vary substantially with each project. Thus, training on project-specific data, and testing on the same project, is a promising idea. This hypothesis has to be evaluated carefully, e.g., in a time-series setting, to prevent training-test leakage. We compare several models and training approaches, including same-project training, cross-project training, training a model especially designed to be sample efficient (and thus prima facie well-suited for learning in a limited-sample same-project setting) and a maximalist hybrid approach, fine-tuning first on many projects in many languages and then training on the same-project. We find that the maximalist hybrid setting provides consistent, substantial gains over the state-of-the-art, on many different projects in both Java and Python.</p>
</td>
	<td>Transformer summarization </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/zlotchevski2022exploring/">Exploring and Evaluating Personalized Models for Code Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Exploring and Evaluating Personalized Models for Code Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Exploring and Evaluating Personalized Models for Code Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Andrei Zlotchevski, Dawn Drain, Alexey Svyatkovskiy, Colin Clement, Neel Sundaresan, Michele Tufano</td>
	<td>FSE</td>
	<td><p>Large Transformer models achieved the state-of-the-art status for Natural Language Understanding tasks and are increasingly becoming the baseline model architecture for modeling source code. Transformers are usually pre-trained on large unsupervised corpora, learning token representations and transformations relevant to modeling generally available text, and are then fine-tuned on a particular downstream task of interest. While fine-tuning is a tried-and-true method for adapting a model to a new domain – for example, question-answering on a given topic – generalization remains an on-going challenge. In this paper, we explore and evaluate transformer model fine-tuning for personalization. In the context of generating unit tests for Java methods, we evaluate learning to personalize to a specific software project using several personalization techniques. We consider three key approaches: (i) custom fine-tuning, which allows all the model parameters to be tuned; (ii) lightweight fine-tuning, which freezes most of the model’s parameters, allowing tuning of the token embeddings and softmax layer only or the final layer alone; (iii) prefix tuning, which keeps model parameters frozen, but optimizes a small project-specific prefix vector. Each of these techniques offers a trade-off in total compute cost and predictive performance, which we evaluate by code and task-specific metrics, training time, and total computational operations. We compare these fine-tuning strategies for code generation and discuss the potential generalization and cost benefits of each in various deployment scenarios.</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2022</td>
	<td><a href="/publications/zhang2022coditt5/">CoditT5: Pretraining for Source Code and Natural Language Editing</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CoditT5: Pretraining for Source Code and Natural Language Editing' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CoditT5: Pretraining for Source Code and Natural Language Editing' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jiyang Zhang, Sheena Panthaplackel, Pengyu Nie, Junyi Jessy Li, Milos Gligoric</td>
	<td></td>
	<td><p>Pretrained language models have been shown to be effective in many software-related generation tasks; however, they are not well-suited for editing tasks as they are not designed to reason about edits. To address this, we propose a novel pretraining objective which explicitly models edits and use it to build CoditT5, a large language model for software-related editing tasks that is pretrained on large amounts of source code and natural language comments. We fine-tune it on various downstream editing tasks, including comment updating, bug fixing, and automated code review. By outperforming pure generation-based models, we demonstrate the generalizability of our approach and its suitability for editing tasks. We also show how a pure generation model and our edit-based model can complement one another through simple reranking strategies, with which we achieve state-of-the-art performance for the three downstream editing tasks.</p>
</td>
	<td>Transformer edit </td>
</tr>



<tr>
	<td>2021</td>
	<td><a href="/publications/mahmud2021code/">Code to Comment Translation: A Comparative Study on Model Effectiveness & Errors</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Code to Comment Translation: A Comparative Study on Model Effectiveness & Errors' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Code to Comment Translation: A Comparative Study on Model Effectiveness & Errors' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Junayed Mahmud, Fahim Faisal, Raihan Islam Arnob, Antonios Anastasopoulos, Kevin Moran</td>
	<td>NLP4Prog</td>
	<td><p>Automated source code summarization is a popular software engineering research topic wherein machine translation models are employed to “translate” code snippets into relevant natural language descriptions. Most evaluations of such models are conducted using automatic reference-based metrics. However, given the relatively large semantic gap between programming languages and natural language, we argue that this line of research would benefit from a qualitative investigation into the various error modes of current state-of-the-art models. Therefore, in this work, we perform both a quantitative and qualitative comparison of three recently proposed source code summarization models. In our quantitative evaluation, we compare the models based on the smoothed BLEU-4, METEOR, and ROUGE-L machine translation metrics, and in our qualitative evaluation, we perform a manual open-coding of the most common errors committed by the models when compared to ground truth captions. Our investigation reveals new insights into the relationship between metric-based performance and model prediction errors grounded in an error taxonomy that can be used to drive future research efforts.</p>
</td>
	<td>survey summarization Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/lu2021codexglue/">CodeXGLUE: A Machine Learning Benchmark Dataset for Code Understanding and Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeXGLUE: A Machine Learning Benchmark Dataset for Code Understanding and Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeXGLUE: A Machine Learning Benchmark Dataset for Code Understanding and Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shuai Lu, Daya Guo, Shuo Ren, Junjie Huang, Alexey Svyatkovskiy, Ambrosio Blanco, Colin Clement, Dawn Drain, Daxin Jiang, Duyu Tang, Ge Li, Lidong Zhou, Linjun Shou, Long Zhou, Michele Tufano, Ming Gong, Ming Zhou, Nan Duan, Neel Sundaresan, Shao Kun Deng, Shengyu Fu, Shujie Liu</td>
	<td></td>
	<td><p>Benchmark datasets have a significant impact on accelerating research in programming language tasks. In this paper, we introduce CodeXGLUE, a benchmark dataset to foster machine learning research for program understanding and generation. CodeXGLUE includes a collection of 10 tasks across 14 datasets and a platform for model evaluation and comparison. CodeXGLUE also features three baseline systems, including the BERT-style, GPT-style, and Encoder-Decoder models, to make it easy for researchers to use the platform. The availability of such data and baselines can help the development and validation of new methods that can be applied to various program understanding and generation problems.</p>
</td>
	<td>benchmark Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/zhang2021bag/">Bag-of-Words Baselines for Semantic Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Bag-of-Words Baselines for Semantic Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Bag-of-Words Baselines for Semantic Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xinyu Zhang, Ji Xin, Andrew Yates, Jimmy Lin</td>
	<td>NLP4Prog</td>
	<td><p>The task of semantic code search is to retrieve code snippets from a source code corpus based on an information need expressed in natural language. The semantic gap between natural language and programming languages has for long been regarded as one of the most significant obstacles to the effectiveness of keyword-based information retrieval (IR) methods. It is a common assumption that “traditional” bag-of-words IR methods are poorly suited for semantic code search: our work empirically investigates this assumption. Specifically, we examine the effectiveness of two traditional IR methods, namely BM25 and RM3, on the CodeSearchNet Corpus, which consists of natural language queries paired with relevant code snippets. We find that the two keyword-based methods outperform several pre-BERT neural models. We also compare several code-specific data pre-processing strategies and find that specialized tokenization improves effectiveness.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/liguori2021shellcode_ia32/">Shellcode_IA32: A Dataset for Automatic Shellcode Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Shellcode_IA32: A Dataset for Automatic Shellcode Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Shellcode_IA32: A Dataset for Automatic Shellcode Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Pietro Liguori, Erfan Al-Hossami, Domenico Cotroneo, Roberto Natella, Bojan Cukic, Samira Shaikh</td>
	<td>NLP4Prog</td>
	<td><p>We take the first step to address the task of automatically generating shellcodes, i.e., small pieces of code used as a payload in the exploitation of a software vulnerability, starting from natural language comments. We assemble and release a novel dataset (Shellcode_IA32), consisting of challenging but common assembly instructions with their natural language descriptions. We experiment with standard methods in neural machine translation (NMT) to establish baseline performance levels on this task.</p>
</td>
	<td>code generation dataset </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/wu2021prototransformer/">ProtoTransformer: A Meta-Learning Approach to Providing Student Feedback</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=ProtoTransformer: A Meta-Learning Approach to Providing Student Feedback' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=ProtoTransformer: A Meta-Learning Approach to Providing Student Feedback' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Mike Wu, Noah D. Goodman, Chris Piech, Chelsea Finn</td>
	<td></td>
	<td><p>High-quality computer science education is limited by the difficulty of providing instructor feedback to students at scale. While this feedback could in principle be automated, supervised approaches to predicting the correct feedback are bottlenecked by the intractability of annotating large quantities of student code. In this paper, we instead frame the problem of providing feedback as few-shot classification, where a meta-learner adapts to give feedback to student code on a new programming question from just a few examples annotated by instructors. Because data for meta-training is limited, we propose a number of amendments to the typical few-shot learning framework, including task augmentation to create synthetic tasks, and additional side information to build stronger priors about each task. These additions are combined with a transformer architecture to embed discrete sequences (e.g. code) to a prototypical representation of a feedback class label. On a suite of few-shot natural language processing tasks, we match or outperform state-of-the-art performance. Then, on a collection of student solutions to exam questions from an introductory university course, we show that our approach reaches an average precision of 88% on unseen questions, surpassing the 82% precision of teaching assistants. Our approach was successfully deployed to deliver feedback to 16,000 student exam-solutions in a programming course offered by a tier 1 university. This is, to the best of our knowledge, the first successful deployment of a machine learning based feedback to open-ended student code.</p>
</td>
	<td>Transformer education </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/li2021learning/">Learning to Extend Program Graphs to Work-in-Progress Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Extend Program Graphs to Work-in-Progress Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Extend Program Graphs to Work-in-Progress Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xuechen Li, Chris J. Maddison, Daniel Tarlow</td>
	<td></td>
	<td><p>Source code spends most of its time in a broken or incomplete state during software development. This presents a challenge to machine learning for code, since high-performing models typically rely on graph structured representations of programs derived from traditional program analyses. Such analyses may be undefined for broken or incomplete code. We extend the notion of program graphs to work-in-progress code by learning to predict edge relations between tokens, training on well-formed code before transferring to work-in-progress code. We consider the tasks of code completion and localizing and repairing variable misuse in a work-in-process scenario. We demonstrate that training relation-aware models with fine-tuned edges consistently leads to improved performance on both tasks.</p>
</td>
	<td>Transformer autocomplete repair </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/li2021toward/">Toward Less Hidden Cost of Code Completion with Acceptance and Ranking Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Toward Less Hidden Cost of Code Completion with Acceptance and Ranking Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Toward Less Hidden Cost of Code Completion with Acceptance and Ranking Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jingxuan Li, Rui Huang, Wei Li, Kai Yao, Weiguo Tan</td>
	<td>ICSME</td>
	<td><p>Code completion is widely used by software developers to provide coding suggestions given a partially written code snippet. Apart from the traditional code completion methods, which only support single token completion at minimal positions, recent studies show the ability to provide longer code completion at more flexible positions. However, such frequently triggered and longer completion results reduce the overall precision as they generate more invalid results. Moreover, different studies are mostly incompatible with each other. Thus, it is vital to develop an ensemble framework that can combine results from multiple models to draw merits and offset defects of each model.
This paper conducts a coding simulation to collect data from code context and different code completion models and then apply the data in two tasks. First, we introduce an acceptance model which can dynamically control whether to display completion results to the developer. It uses simulation features to predict whether correct results exist in the output of these models. Our best model reduces the percentage of false-positive completion from 55.09% to 17.44%. Second, we design a fusion ranking scheme that can automatically identify the priority of the completion results and reorder the candidates from multiple code completion models. This scheme is flexible in dealing with various models, regardless of the type or the length of their completion results. We integrate this ranking scheme with two frequency models and a GPT-2 styled language model, along with the acceptance model to yield 27.80% and 37.64% increase in TOP1 and TOP5 accuracy, respectively. In addition, we propose a new code completion evaluation metric, Benefit-Cost Ratio(BCR), taking into account the benefit of keystrokes saving and hidden cost of completion list browsing, which is closer to real coder experience scenario.</p>
</td>
	<td>autocomplete language model optimization Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/lee2021cotraining/">Co-Training for Commit Classification</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Co-Training for Commit Classification' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Co-Training for Commit Classification' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jian Yi, David Lee, Hai Leong Chieu</td>
	<td>EMNLP WNUT</td>
	<td><p>Commits in version control systems (e.g. Git) track changes in a software project. Commits comprise noisy user-generated natural language and code patches. Automatic commit classification (CC) has been used to determine the type of code maintenance activities performed, as well as to detect bug fixes in code repositories. Much prior work occurs in the fully-supervised setting – a setting that can be a stretch in resource-scarce situations presenting difficulties in labeling commits. In this paper, we apply co-training, a semi-supervised learning method, to take advantage of the two views available – the commit message (natural language) and the code changes (programming language) – to improve commit classification.</p>
</td>
	<td>Transformer bimodal defect </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/korbak2021energy/">Energy-Based Models for Code Generation under Compilability Constraints</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Energy-Based Models for Code Generation under Compilability Constraints' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Energy-Based Models for Code Generation under Compilability Constraints' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Tomasz Korbak, Hady Elsahar, Marc Dymetman, Germán Kruszewski</td>
	<td>ACL</td>
	<td><p>Neural language models can be successfully trained on source code, leading to applications such as code completion. However, their versatile autoregressive self-supervision objective overlooks important global sequence-level features that are present in the data such as syntactic correctness or compilability. In this work, we pose the problem of learning to generate compilable code as constraint satisfaction. We define an Energy-Based Model (EBM) representing a pre-trained generative model with an imposed constraint of generating only compilable sequences. We then use the KL-Adaptive Distributional Policy Gradient algorithm (Khalifa et al., 2021) to train a generative model approximating the EBM. We conduct experiments showing that our proposed approach is able to improve compilability rates without sacrificing diversity and complexity of the generated samples.</p>
</td>
	<td>code generation </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/waunakh2019idbench/">IdBench: Evaluating Semantic Representations of Identifier Names in Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=IdBench: Evaluating Semantic Representations of Identifier Names in Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=IdBench: Evaluating Semantic Representations of Identifier Names in Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yaza Wainakh, Moiz Rauf, Michael Pradel</td>
	<td>ICSE</td>
	<td><p>Identifier names convey useful information about the intended semantics of code. Name-based program analyses use this information, e.g., to detect bugs, to predict types, and to improve the readability of code. At the core of namebased analyses are semantic representations of identifiers, e.g., in the form of learned embeddings. The high-level goal of such a representation is to encode whether two identifiers, e.g., len and size, are semantically similar. Unfortunately, it is currently unclear to what extent semantic representations match the semantic relatedness and similarity perceived by developers. This paper presents IdBench, the first benchmark for evaluating semantic representations against a ground truth created from thousands of ratings by 500 software developers. We use IdBench to study state-of-the-art embedding techniques proposed for natural language, an embedding technique specifically designed for source code, and lexical string distance functions. Our results show that the effectiveness of semantic representations varies significantly and that the best available embeddings successfully represent semantic relatedness. On the downside, no existing technique provides a satisfactory representation of semantic similarities, among other reasons because identifiers with opposing meanings are incorrectly considered to be similar, which may lead to fatal mistakes, e.g., in a refactoring tool. Studying the strengths and weaknesses of the different techniques shows that they complement each other. As a first step toward exploiting this complementarity, we present an ensemble model that combines existing techniques and that clearly outperforms the best available semantic representation.</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/karmakar2021what/">What do pre-trained code models know about code?</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=What do pre-trained code models know about code?' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=What do pre-trained code models know about code?' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Anjan Karmakar, Romain Robbes</td>
	<td></td>
	<td><p>Pre-trained models of code built on the transformer architecture have performed well on software engineering (SE) tasks such as predictive code generation, code summarization, among others. However, whether the vector representations from these pre-trained models comprehensively encode characteristics of source code well enough to be applicable to a broad spectrum of downstream tasks remains an open question.</p>

<p>One way to investigate this is with diagnostic tasks called probes. In this paper, we construct four probing tasks (probing for surface-level, syntactic, structural, and semantic information) for pre-trained code models. We show how probes can be used to identify whether models are deficient in (understanding) certain code properties, characterize different model layers, and get insight into the model sample-efficiency.</p>

<p>We probe four models that vary in their expected knowledge of code properties: BERT (pre-trained on English), CodeBERT and CodeBERTa (pre-trained on source code, and natural language documentation), and GraphCodeBERT (pre-trained on source code with dataflow). While GraphCodeBERT performs more consistently overall, we find that BERT performs surprisingly well on some code tasks, which calls for further investigation.</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/wong2021leveraging/">Leveraging Language to Learn Program Abstractions and Search Heuristics</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Leveraging Language to Learn Program Abstractions and Search Heuristics' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Leveraging Language to Learn Program Abstractions and Search Heuristics' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Catherine Wong, Kevin Ellis, Joshua B. Tenenbaum, Jacob Andreas</td>
	<td>Thirty-eighth International Conference on Machine Learning (ICML 2021)</td>
	<td><p>Inductive program synthesis, or inferring programs from examples of desired behavior, offers a general paradigm for building interpretable, robust, and generalizable machine learning systems. Effective program synthesis depends on two key ingredients: a strong library of functions from which to build programs, and an efficient search strategy for finding programs that solve a given task. We introduce LAPS (Language for Abstraction and Program Search), a technique for using natural language annotations to guide joint learning of libraries and neurally-guided search models for synthesis. When integrated into a state-of-the-art library learning system (DreamCoder), LAPS produces higher-quality libraries and improves search efficiency and generalization on three domains – string editing, image composition, and abstract reasoning about scenes – even when no natural language hints are available at test time.</p>
</td>
	<td>synthesis search </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/jung2021commitbert/">CommitBERT: Commit Message Generation Using Pre-Trained Programming Language Model</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CommitBERT: Commit Message Generation Using Pre-Trained Programming Language Model' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CommitBERT: Commit Message Generation Using Pre-Trained Programming Language Model' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Tae Hwan Jung</td>
	<td>NLP4Prog</td>
	<td><p>Commit message is a document that summarizes source code changes in natural language. A good commit message clearly shows the source code changes, so this enhances collaboration between developers. Therefore, our work is to develop a model that automatically writes the commit message. To this end, we release 345K datasets consisting of code modification and commit messages in six programming languages (Python, PHP, Go, Java, JavaScript, and Ruby). Similar to the neural machine translation (NMT) model, using our dataset, we feed the code modification to the encoder input and the commit message to the decoder input and measure the result of the generated commit message with BLEU-4. Also, we propose the following two training methods to improve the result of generating the commit message: (1) A method of preprocessing the input to feed the code modification to the encoder input. (2) A method that uses an initial weight suitable for the code domain to reduce the gap in contextual representation between programming language (PL) and natural language (NL).</p>
</td>
	<td>dataset language model Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/jian2021multimodal/">Multimodal Representation for Neural Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Multimodal Representation for Neural Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Multimodal Representation for Neural Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jian Gu, Zimin Chen, Martin Monperrus</td>
	<td>ICSME</td>
	<td><p>Semantic code search is about finding semantically relevant code snippets for a given natural language query. In the state-of-the-art approaches, the semantic similarity between code and query is quantified as the distance of their representation in the shared vector space. In this paper, to improve the vector space, we introduce tree-serialization methods on a simplified form of AST and build the multimodal representation for the code data. We conduct extensive experiments using a single corpus that is large-scale and multi-language: CodeSearchNet. Our results show that both our tree-serialized representations and multimodal learning model improve the performance of code search. Last, we define intuitive quantification metrics oriented to the completeness of semantic and syntactic information of the code data, to help understand the experimental findings.</p>
</td>
	<td>search representation </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/jiang2021treebert/">TreeBERT: A Tree-Based Pre-Trained Model for Programming Language</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=TreeBERT: A Tree-Based Pre-Trained Model for Programming Language' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=TreeBERT: A Tree-Based Pre-Trained Model for Programming Language' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xue Jiang, Zhuoran Zheng, Chen Lyu, Liang Li, Lei Lyu</td>
	<td>UAI</td>
	<td><p>Source code can be parsed into the abstract syntax tree (AST) based on defined syntax rules. However, in pre-training, little work has considered the incorporation of tree structure into the learning process. In this paper, we present TreeBERT, a tree-based pre-trained model for improving programming language-oriented generation tasks. To utilize tree structure, TreeBERT represents the AST corresponding to the code as a set of composition paths and introduces node position embedding. The model is trained by tree masked language modeling (TMLM) and node order prediction (NOP) with a hybrid objective. TMLM uses a novel masking strategy designed according to the tree’s characteristics to help the model understand the AST and infer the missing semantics of the AST. With NOP, TreeBERT extracts the syntactical structure by learning the order constraints of nodes in AST. We pre-trained TreeBERT on datasets covering multiple programming languages. On code summarization and code documentation tasks, TreeBERT outperforms other pre-trained models and state-of-the-art models designed for these tasks. Furthermore, TreeBERT performs well when transferred to the pre-trained unseen programming language.</p>
</td>
	<td>grammar Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/jesse2021learning/">Learning Type Annotation: Is Big Data Enough?</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Type Annotation: Is Big Data Enough?' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Type Annotation: Is Big Data Enough?' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Kevin Jesse, Premkumar Devanbu, Toufique Ahmed</td>
	<td>FSE</td>
	<td><p>TypeScript is a widely used optionally-typed language where developers can adopt “pay as you go” typing: they can add types as
desired, and benefit from static typing. The “type annotation tax”
or manual effort required to annotate new or existing TypeScript
can be reduced by a variety of automatic methods. Probabilistic
machine-learning (ML) approaches work quite well. ML approaches
use different inductive biases, ranging from simple token sequences
to complex graphical neural network (GNN) models capturing syntax and semantic relations. More sophisticated inductive biases are
hand-engineered to exploit the formal nature of software. Rather
than deploying fancy inductive biases for code, can we just use “big
data” to learn natural patterns relevant to typing? We find evidence
suggesting that this is the case. We present TypeBert, demonstrating that even with simple token-sequence inductive bias used in
BERT-style models and enough data, type-annotation performance
of the most sophisticated models can be surpassed.</p>
</td>
	<td>Transformer types </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/huang2021cosqa/">CoSQA: 20,000+ Web Queries for Code Search and Question Answering</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CoSQA: 20,000+ Web Queries for Code Search and Question Answering' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CoSQA: 20,000+ Web Queries for Code Search and Question Answering' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Junjie Huang, Duyu Tang, Linjun Shou, Ming Gong, Ke Xu, Daxin Jiang, Ming Zhou, Nan Duan</td>
	<td>ACL</td>
	<td><p>Finding codes given natural language query is beneficial to the productivity of software developers.
Future progress towards better semantic matching between query and code requires richer supervised training resources.
To remedy this, we introduce the CoSQA dataset. It includes 20,604 labels for pairs of natural language queries and codes,
each annotated by at least 3 human annotators. We further introduce a contrastive learning method dubbed CoCLR to enhance query-code matching, which works as a data augmenter to bring more artificially generated training instances. We show that evaluated on CodeXGLUE with the same CodeBERT model, training on CoSQA improves the accuracy of code question answering by 5.1%, and incorporating CoCLR brings a further improvement of 10.5%.</p>
</td>
	<td>dataset search </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/hong2021fix/">Fix-Filter-Fix: Intuitively Connect Any Models for Effective Bug Fixing</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Fix-Filter-Fix: Intuitively Connect Any Models for Effective Bug Fixing' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Fix-Filter-Fix: Intuitively Connect Any Models for Effective Bug Fixing' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Haiwen Hong, Jingfeng Zhang, Yin Zhang, Yao Wan, Yulei Sui</td>
	<td>EMNLP</td>
	<td><p>Locating and fixing bugs is a time-consuming task. Most neural machine translation (NMT) based approaches for automatically bug fixing lack generality and do not make full use of the rich information in the source code. In NMT-based bug fixing, we find some predicted code identical to the input buggy code (called unchanged fix) in NMT-based approaches due to high similarity between buggy and fixed code (e.g., the difference may only appear in one particular line). Obviously, unchanged fix is not the correct fix because it is the same as the buggy code that needs to be fixed. Based on these, we propose an intuitive yet effective general framework (called Fix-Filter-Fix or Fˆ3) for bug fixing. Fˆ3 connects models with our filter mechanism to filter out the last model’s unchanged fix to the next. We propose an Fˆ3 theory that can quantitatively and accurately calculate the Fˆ3 lifting effect. To evaluate, we implement the Seq2Seq Transformer (ST) and the AST2Seq Transformer (AT) to form some basic Fˆ3 instances, called Fˆ3_ST+AT and Fˆ3_AT+ST. Comparing them with single model approaches and many model connection baselines across four datasets validates the effectiveness and generality of Fˆ3 and corroborates our findings and methodology.</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/sivaraman2021mining/">Mining Idioms in the Wild</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Mining Idioms in the Wild' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Mining Idioms in the Wild' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Aishwarya Sivaraman, Rui Abreu, Andrew Scott, Tobi Akomolede, Satish Chandra</td>
	<td></td>
	<td><p>Existing code repositories contain numerous instances of code patterns that are idiomatic ways of accomplishing a particular programming task. Sometimes, the programming language in use supports specific operators or APIs that can express the same idiomatic imperative code much more succinctly. However, those code patterns linger in repositories because the developers may be unaware of the new APIs or have not gotten around to them. Detection of idiomatic code can also point to the need for new APIs.</p>

<p>We share our experiences in mine idiomatic patterns from the Hack repo at Facebook. We found that existing techniques either cannot identify meaningful patterns from syntax trees or require test-suite-based dynamic analysis to incorporate semantic properties to mine useful patterns. The key insight of the approach proposed in this paper – Jezero – is that semantic idioms from a large codebase can be learned from canonicalized dataflow trees. We propose a scalable, lightweight static analysis-based approach to construct such a tree that is well suited to mine semantic idioms using nonparametric Bayesian methods.</p>

<p>Our experiments with Jezero on Hack code shows a clear advantage of adding canonicalized dataflow information to ASTs: Jezero was significantly more effective than a baseline that did not have the dataflow augmentation in being able to effectively find refactoring opportunities from unannotated legacy code.</p>
</td>
	<td>pattern mining refactoring </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/hazoom2021text/">Text-to-SQL in the Wild: A Naturally-Occurring Dataset Based on Stack Exchange Data</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Text-to-SQL in the Wild: A Naturally-Occurring Dataset Based on Stack Exchange Data' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Text-to-SQL in the Wild: A Naturally-Occurring Dataset Based on Stack Exchange Data' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Moshe Hazoom, Vibhor Malik, Ben Bogin</td>
	<td>NLP4Prog</td>
	<td><p>Most available semantic parsing datasets, comprising of pairs of natural utterances and logical forms, were collected solely for the purpose of training and evaluation of natural language understanding systems. As a result, they do not contain any of the richness and variety of natural-occurring utterances, where humans ask about data they need or are curious about. In this work, we release SEDE, a dataset with 12,023 pairs of utterances and SQL queries collected from real usage on the Stack Exchange website. We show that these pairs contain a variety of real-world challenges which were rarely reflected so far in any other semantic parsing dataset, propose an evaluation metric based on comparison of partial query clauses that is more suitable for real-world queries, and conduct experiments with strong baselines, showing a large gap between the performance on SEDE compared to other common datasets.</p>
</td>
	<td>dataset </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/he2021learning/">Learning to Find Naming Issues with Big Code and Small Supervision</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Find Naming Issues with Big Code and Small Supervision' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Find Naming Issues with Big Code and Small Supervision' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jingxuan He, Cheng-Chun Lee, Veselin Raychev, Martin Vechev</td>
	<td>PLDI</td>
	<td><p>We introduce a new approach for finding and fixing naming
issues in source code. The method is based on a careful
combination of unsupervised and supervised procedures: (i)
unsupervised mining of patterns from Big Code that express
common naming idioms. Program fragments violating such
idioms indicates likely naming issues, and (ii) supervised
learning of a classifier on a small labeled dataset which filters
potential false positives from the violations.</p>

<p>We implemented our method in a system called
Namer and evaluated it on a large number of Python and Java programs.
We demonstrate that Namer is effective in finding naming mistakes
in real world repositories with high precision (∼70%).
Perhaps surprisingly, we also show that existing deep learning methods
are not practically effective and achieve low precision in finding naming issues (up to ∼16%).</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/gholamian2021naturalness/">On the Naturalness and Localness of Software Logs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=On the Naturalness and Localness of Software Logs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=On the Naturalness and Localness of Software Logs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sina Gholamian, Paul A. S. Ward</td>
	<td></td>
	<td><p>Logs are an essential part  of  the  development  and
maintenance  of  large  and  complex  software  systems  as  they
contain rich information pertaining to the dynamic content and
state  of  the  system.  As  such,  developers  and  practitioners  rely
heavily  on  the  logs  to  monitor  their  systems.  In  parallel,  the
increasing  volume  and  scale  of  the  logs,  due  to  the  growing
complexity  of  modern  software  systems,  renders  the  traditional
way  of  manual  log  inspection  insurmountable.  Consequently,  to
handle  large  volumes  of  logs  efficiently  and  effectively,  various
prior research aims to automate the analysis of log files. Thus, in
this paper, we begin with the hypothesis that log files are natural
and local and these attributes can be applied for automating log
analysis tasks. We guide our research with six research questions
with regards to the naturalness and localness of the log files, and
present  a  case  study  on  anomaly  detection  and  introduce  a  tool
for anomaly detection, called ANALOG, to demonstrate how our
new  findings  facilitate  the  automated  analysis  of  logs.</p>
</td>
	<td>logging language model </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/ellis2021dreamcoder/">DreamCoder: bootstrapping inductive program synthesis with wake-sleep library learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DreamCoder: bootstrapping inductive program synthesis with wake-sleep library learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DreamCoder: bootstrapping inductive program synthesis with wake-sleep library learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Kevin Ellis, Catherine Wong, Maxwell Nye, Mathias Sable-Meyer, Luc Cary, Lucas Morales, Luke Hewitt, Armando Solar-Lezama, Joshua B. Tenenbaum</td>
	<td>42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation (PLDI 2021)</td>
	<td><p>We present a system for inductive program synthesis called DreamCoder, which inputs a corpus of synthesis problems each specified by one or a few examples, and automatically derives a library of program components and a neural search policy that can be used to efficiently solve other similar synthesis problems. The library and search policy bootstrap each other iteratively through a variant of “wake-sleep” approximate Bayesian learning. A new refactoring algorithm based on E-graph matching identifies common sub-components across synthesized programs, building a progressively deepening library of abstractions capturing the structure of the input domain. We evaluate on eight domains including classic program synthesis areas and AI tasks such as planning, inverse graphics, and equation discovery. We show that jointly learning the library and neural search policy leads to solving more problems, and solving them more quickly.</p>
</td>
	<td>synthesis search </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/elnaggar2021codetrans/">CodeTrans: Towards Cracking the Language of Silicon's Code Through Self-Supervised Deep Learning and High Performance Computing</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeTrans: Towards Cracking the Language of Silicon's Code Through Self-Supervised Deep Learning and High Performance Computing' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeTrans: Towards Cracking the Language of Silicon's Code Through Self-Supervised Deep Learning and High Performance Computing' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ahmed Elnaggar, Wei Ding, Llion Jones, Tom Gibbs, Tamas Feher, Christoph Angerer, Silvia Severini, Florian Matthes, Burkhard Rost</td>
	<td></td>
	<td><p>Currently, a growing number of mature natural language processing applications make people’s life more convenient. Such applications are built by source code - the language in software engineering. However, the applications for understanding source code language to ease the software engineering process are under-researched. Simultaneously, the transformer model, especially its combination with transfer learning, has been proven to be a powerful technique for natural language processing tasks. These breakthroughs point out a promising direction for process source code and crack software engineering tasks. This paper describes CodeTrans - an encoder-decoder transformer model for tasks in the software engineering domain, that explores the effectiveness of encoder-decoder transformer models for six software engineering tasks, including thirteen sub-tasks. Moreover, we have investigated the effect of different training strategies, including single-task learning, transfer learning, multi-task learning, and multi-task learning with fine-tuning. CodeTrans outperforms the state-of-the-art models on all the tasks. To expedite future works in the software engineering domain, we have published our pre-trained models of CodeTrans.</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/mir2021manytypes4py/">ManyTypes4Py: A Benchmark Python Dataset for Machine Learning-based Type Inference</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=ManyTypes4Py: A Benchmark Python Dataset for Machine Learning-based Type Inference' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=ManyTypes4Py: A Benchmark Python Dataset for Machine Learning-based Type Inference' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Amir M. Mir, Evaldas Latoskinas, Georgios Gousios</td>
	<td>MSR</td>
	<td><p>In this paper, we present ManyTypes4Py, a large Python dataset for machine learning (ML)-based type inference. The dataset contains a total of 5,382 Python projects with more than 869K type annotations. Duplicate source code files were removed to eliminate the negative effect of the duplication bias. To facilitate training and evaluation of ML models, the dataset was split into training, validation and test sets by files. To extract type information from abstract syntax trees (ASTs), a lightweight static analyzer pipeline is developed and accompanied with the dataset. Using this pipeline, the collected Python projects were analyzed and the results of the AST analysis were stored in JSON-formatted files. The ManyTypes4Py dataset is shared on zenodo and its tools are publicly available on GitHub.</p>
</td>
	<td>dataset types </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/drain2021deepdebug/">DeepDebug: Fixing Python Bugs Using Stack Traces, Backtranslation, and Code Skeletons</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DeepDebug: Fixing Python Bugs Using Stack Traces, Backtranslation, and Code Skeletons' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DeepDebug: Fixing Python Bugs Using Stack Traces, Backtranslation, and Code Skeletons' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Dawn Drain, Colin B. Clement, Guillermo Serrato, Neel Sundaresan</td>
	<td></td>
	<td><p>The joint task of bug localization and program repair is an integral part of the software development process. In this work we present DeepDebug, an approach to automated debugging using large, pretrained transformers. We begin by training a bug-creation model on reversed commit data for the purpose of generating synthetic bugs. We apply these synthetic bugs toward two ends. First, we directly train a backtranslation model on all functions from 200K repositories. Next, we focus on 10K repositories for which we can execute tests, and create buggy versions of all functions in those repositories that are covered by passing tests. This provides us with rich debugging information such as stack traces and print statements, which we use to finetune our model which was pretrained on raw source code. Finally, we strengthen all our models by expanding the context window beyond the buggy function itself, and adding a skeleton consisting of that function’s parent class, imports, signatures, docstrings, and method bodies, in order of priority. On the QuixBugs benchmark, we increase the total number of fixes found by over 50%, while also decreasing the false positive rate from 35% to 5% and decreasing the timeout from six hours to one minute. On our own benchmark of executable tests, our model fixes 68% of all bugs on its first attempt without using traces, and after adding traces it fixes 75% on first attempt. We will open-source our framework and validation set for evaluating on executable tests.</p>
</td>
	<td>repair Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/drain2021generating/">Generating Bug-Fixes Using Pretrained Transformers</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Generating Bug-Fixes Using Pretrained Transformers' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Generating Bug-Fixes Using Pretrained Transformers' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Dawn Drain, Chen Wu, Alexey Svyatkovskiy, Neel Sundaresan</td>
	<td></td>
	<td><p>Detecting and fixing bugs are two of the most important yet frustrating parts of the software development cycle. Existing bug detection tools are based mainly on static analyzers, which rely on mathematical logic and symbolic reasoning about the program execution to detect common types of bugs. Fixing bugs is typically left out to the developer. In this work we introduce DeepDebug: a data-driven program repair approach which learns to detect and fix bugs in Java methods mined from real-world GitHub repositories. We frame bug-patching as a sequence-to-sequence learning task consisting of two steps: (i) denoising pretraining, and (ii) supervised finetuning on the target translation task. We show that pretraining on source code programs improves the number of patches found by 33% as compared to supervised training from scratch, while domain-adaptive pretraining from natural language to code further improves the accuracy by another 32%. We refine the standard accuracy evaluation metric into non-deletion and deletion-only fixes, and show that our best model generates 75% more non-deletion fixes than the previous state of the art. In contrast to prior work, we attain our best results when generating raw code, as opposed to working with abstracted code that tends to only benefit smaller capacity models. Finally, we observe a subtle improvement from adding syntax embeddings along with the standard positional embeddings, as well as with adding an auxiliary task to predict each token’s syntactic class. Despite focusing on Java, our approach is language agnostic, requiring only a general-purpose parser such as tree-sitter.</p>
</td>
	<td>Transformer repair </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/zhang2021disentangled/">Disentangled Code Representation Learning for Multiple Programming Languages</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Disentangled Code Representation Learning for Multiple Programming Languages' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Disentangled Code Representation Learning for Multiple Programming Languages' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jingfeng Zhang, Haiwen Hong, Yin Zhang, Yao Wan, Ye Liu, Yulei Sui</td>
	<td>ACL</td>
	<td><p>Developing effective distributed representations of source code is fundamental yet challenging for many software engineering tasks such as code clone detection, code search, code translation and transformation. However, current code embedding approaches that represent the semantic and syntax of code in a mixed way are less interpretable and the resulting embedding can not be easily generalized across programming languages. In this paper, we propose a disentangled code representation learning approach to separate the semantic from the syntax of source code under a multi-programming-language setting, obtaining better interpretability and generalizability. Specially, we design three losses dedicated to the characteristics of source code to enforce the disentanglement effectively. We conduct comprehensive experiments on a real-world dataset composed of programming exercises implemented by multiple solutions that are semantically identical but grammatically distinguished. The experimental results validate the superiority of our proposed disentangled code representation, compared to several baselines, across three types of downstream tasks, i.e., code clone detection, code translation, and code-to-code search.</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/dinella2021deepmerge/">DeepMerge: Learning to Merge Programs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DeepMerge: Learning to Merge Programs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DeepMerge: Learning to Merge Programs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Elizabeth Dinella, Todd Mytkowicz, Alexey Svyatkovskiy, Christian Bird, Mayur Naik, Shuvendu K. Lahiri</td>
	<td></td>
	<td><p>Program merging is ubiquitous in modern software development. Although commonly used in most version control systems, text-based merge algorithms are prone to producing spurious merge conflicts: they report a conflict even when program changes do not interfere with each other semantically. Spurious merge conflicts are costly to development as the need for manual intervention stalls modern continuous integration pipelines. We propose a novel data-driven approach to identify and resolve spurious merge conflicts with a sequence-to-sequence machine learning model. We realize our approach in a tool DeepMerge that uses a novel combination of (i) an edit-aware embedding of merge inputs and (ii) a variation of pointer networks to construct resolutions from input segments. We also propose an algorithm to extract ground truth manual resolutions from a code corpus and employ it to curate a dataset comprising 10,729 non-trivial resolutions in Javascript programs. Our evaluation shows that DeepMerge can predict correct resolutions with high precision (72%) and modest recall (34%) on the dataset overall, and high recall (78%) on merges comprising of upto 3 lines that comprise 24% of the dataset.</p>
</td>
	<td>edit repair </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/zhou2021improving/">Improving Code Autocompletion with Transfer Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Improving Code Autocompletion with Transfer Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Improving Code Autocompletion with Transfer Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Wen Zhou, Seohyun Kim, Vijayaraghavan Murali, Gareth Ari Aye</td>
	<td></td>
	<td><p>Software language models have achieved promising results predicting code completion usages, and several industry studies have described successful IDE integrations. Recently, accuracy in autocompletion prediction improved 12.8% from training on a real-world dataset collected from programmers’ IDE activity. But what if limited examples of IDE autocompletion in the target programming language are available for model training? In this paper, we investigate the efficacy of pretraining autocompletion models on non-IDE, non-autocompletion, and different-language example code sequences. We find that these unsupervised pretrainings improve model accuracy by over 50% on very small fine-tuning datasets and over 10% on 50k labeled examples. We confirm the real-world impact of these pretrainings in an online setting through A/B testing on thousands of IDE autocompletion users, finding that pretraining is responsible for increases of up to 6.63% autocompletion usage.</p>
</td>
	<td>autocomplete Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/deze2021mulcode/">MulCode: A Multi-task Learning Approach for Source Code Understanding</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=MulCode: A Multi-task Learning Approach for Source Code Understanding' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=MulCode: A Multi-task Learning Approach for Source Code Understanding' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Deze Wang, Yue Yu, Shanshan Li, Wei Dong, Ji Wang, Liao Qing</td>
	<td>SANER</td>
	<td><p>Recent years have witnessed the significant rise of Deep Learning (DL) techniques applied to source code. Researchers exploit DL for a multitude of tasks and achieve impressive results. However, most tasks are explored separately, resulting in a lack of generalization of the solutions. In this work, we propose MulCode, a multi-task learning approach for source code understanding that learns unified representation space for tasks, with the pre-trained BERT model for the token sequence and the Tree-LSTM model for abstract syntax trees. Furthermore, we integrate two source code views into a hybrid representation via the attention mechanism and set learnable uncertainty parameters to adjust the tasks’ relationship. We train and evaluate MulCode in three downstream tasks: comment classification, author attribution, and duplicate function detection. In all tasks, MulCode outperforms the state-of-theart techniques. Moreover, experiments on three unseen tasks demonstrate the generalization ability of MulCode compared with state-of-the-art embedding methods.</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/ding2021contrastive/">Contrastive Learning for Source Code with Structural and Functional Properties</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Contrastive Learning for Source Code with Structural and Functional Properties' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Contrastive Learning for Source Code with Structural and Functional Properties' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yangruibo Ding, Luca Buratti, Saurabh Pujar, Alessandro Morari, Baishakhi Ray, Saikat Chakraborty</td>
	<td></td>
	<td><p>Pre-trained transformer models have recently shown promises for understanding the source code. Most existing works expect to understand code from the textual features and limited structural knowledge of code. However, the program functionalities sometimes cannot be fully revealed by the code sequence, even with structure information. Programs can contain very different tokens and structures while sharing the same functionality, but changing only one or a few code tokens can introduce unexpected or malicious program behaviors while preserving the syntax and most tokens. In this work, we present BOOST, a novel self-supervised model to focus pre-training based on the characteristics of source code. We first employ automated, structure-guided code transformation algorithms that generate (i.) functionally equivalent code that looks drastically different from the original one, and (ii.) textually and syntactically very similar code that is functionally distinct from the original. We train our model in a way that brings the functionally equivalent code closer and distinct code further through a contrastive learning objective. To encode the structure information, we introduce a new node-type masked language model objective that helps the model learn about structural context. We pre-train BOOST with a much smaller dataset than the state-of-the-art models, but our small models can still match or outperform these large models in code understanding and generation tasks.</p>
</td>
	<td>representation pretraining Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/villmow2021contest/">ConTest: A Unit Test Completion Benchmark featuring Context</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=ConTest: A Unit Test Completion Benchmark featuring Context' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=ConTest: A Unit Test Completion Benchmark featuring Context' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Johannes Villmow, Jonas Depoix, Adrian Ulges</td>
	<td>NLP4Prog</td>
	<td><p>We introduce CONTEST, a benchmark for NLP-based unit test completion, the task of predicting a test’s assert statements given its setup and focal method, i.e. the method to be tested. ConTest is large-scale (with 365k datapoints). Besides the test code and tested code, it also features context code called by either. We found context to be crucial for accurately predicting assertions. We also introduce baselines based on transformer encoder-decoders, and study the effects of including syntactic information and context. Overall, our models achieve a BLEU score of 38.2, while only generating unparsable code in 1.92% of cases.</p>
</td>
	<td>benchmark dataset verification Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/clement2021long/">Long-Range Modeling of Source Code Files with eWASH: Extended Window Access by Syntax Hierarchy</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Long-Range Modeling of Source Code Files with eWASH: Extended Window Access by Syntax Hierarchy' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Long-Range Modeling of Source Code Files with eWASH: Extended Window Access by Syntax Hierarchy' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Colin B. Clement, Shuai Lu, Xiaoyu Liu, Michele Tufano, Dawn Drain, Nan Duan, Neel Sundaresan, Alexey Svyatkovskiy</td>
	<td></td>
	<td><p>Statistical language modeling and translation with transformers have found many successful applications in program understanding and generation tasks, setting high benchmarks for tools in modern software development environments. The finite context window of these neural models means, however, that they will be unable to leverage the entire relevant context of large files and packages for any given task. While there are many efforts to extend the context window, we introduce an architecture-independent approach for leveraging the syntactic hierarchies of source code for incorporating entire file-level context into a fixed-length window. Using concrete syntax trees of each source file we extract syntactic hierarchies and integrate them into context window by selectively removing from view more specific, less relevant scopes for a given task. We evaluate this approach on code generation tasks and joint translation of natural language and source code in Python programming language, achieving a new state-of-the-art in code completion and summarization for Python in the CodeXGLUE benchmark. We also introduce new CodeXGLUE benchmarks for user-experience-motivated tasks: code completion with normalized literals, method body completion/code summarization conditioned on file-level context.</p>
</td>
	<td>Transformer language model code generation </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/clement2021distilling/">Distilling Transformers for Neural Cross-Domain Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Distilling Transformers for Neural Cross-Domain Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Distilling Transformers for Neural Cross-Domain Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Colin B. Clement, Chen Wu, Dawn Drain, Neel Sundaresan</td>
	<td></td>
	<td><p>Pre-trained transformers have recently clinched top spots in the gamut of natural language tasks and pioneered solutions to software engineering tasks. Even information retrieval has not been immune to the charm of the transformer, though their large size and cost is generally a barrier to deployment. While there has been much work in streamlining, caching, and modifying transformer architectures for production, here we explore a new direction: distilling a large pre-trained translation model into a lightweight bi-encoder which can be efficiently cached and queried. We argue from a probabilistic perspective that sequence-to-sequence models are a conceptually ideal—albeit highly impractical—retriever. We derive a new distillation objective, implementing it as a data augmentation scheme. Using natural language source code search as a case study for cross-domain search, we demonstrate the validity of this idea by significantly improving upon the current leader of the CodeSearchNet challenge, a recent natural language code search benchmark.</p>
</td>
	<td>search Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/chirkova2021embeddings/">On the Embeddings of Variables in Recurrent Neural Networks for Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=On the Embeddings of Variables in Recurrent Neural Networks for Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=On the Embeddings of Variables in Recurrent Neural Networks for Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Nadezhda Chirkova</td>
	<td>NAACL</td>
	<td><p>Source code processing heavily relies on the methods widely used in natural language processing (NLP), but involves specifics that need to be taken into account to achieve higher quality. An example of this specificity is that the semantics of a variable is defined not only by its name but also by the contexts in which the variable occurs. In this work, we develop dynamic embeddings, a recurrent mechanism that adjusts the learned semantics of the variable when it obtains more information about the variable’s role in the program. We show that using the proposed dynamic embeddings significantly improves the performance of the recurrent neural network, in code completion and bug fixing tasks.</p>
</td>
	<td>autocomplete </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/chen2021evaluating/">Evaluating Large Language Models Trained on Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Evaluating Large Language Models Trained on Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Evaluating Large Language Models Trained on Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde, Jared Kaplan, Harri Edwards, Yura Burda, Nicholas Joseph, Greg Brockman, Alex Ray, Raul Puri, Gretchen Krueger, Michael Petrov, Heidy Khlaaf, Girish Sastry, Pamela Mishkin, Brooke Chan, Scott Gray, Nick Ryder, Mikhail Pavlov, Alethea Power, Lukasz Kaiser, Mohammad Bavarian, Clemens Winter, Philippe Tillet, Felipe Such, Dave Cummings, Matthias Plappert, Fotios Chantzis, Elizabeth Barnes, Ariel Herbert-Voss, Will Guss, Alex Nichol, Igor Babuschkin, Suchir Balaji, Shantanu Jain, Andrew Carr, Jan Leike, Josh Achiam, Vedant Misra, Evan Morikawa, Alec Radford, Matthew Knight, Miles Brundage, Mira Murati, Katie Mayer, Peter Welinder, Bob McGrew, Dario Amodei, Sam McCandlish, Ilya Sutskever, Wojciech Zaremba</td>
	<td></td>
	<td><p>We introduce Codex, a GPT language model fine-tuned on publicly available code from GitHub, and study its Python code-writing capabilities. A distinct production version of Codex powers GitHub Copilot. On HumanEval, a new evaluation set we release to measure functional correctness for synthesizing programs from docstrings, our model solves 28.8% of the problems, while GPT-3 solves 0% and GPT-J solves 11.4%. Furthermore, we find that repeated sampling from the model is a surprisingly effective strategy for producing working solutions to difficult prompts. Using this method, we solve 70.2% of our problems with 100 samples per problem. Careful investigation of our model reveals its limitations, including difficulty with docstrings describing long chains of operations and with binding operations to variables. Finally, we discuss the potential broader impacts of deploying powerful code generation technologies, covering safety, security, and economics.</p>
</td>
	<td>language model synthesis </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/chen2021plur/">PLUR: A Unifying, Graph-Based View of Program Learning, Understanding, and Repair</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=PLUR: A Unifying, Graph-Based View of Program Learning, Understanding, and Repair' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=PLUR: A Unifying, Graph-Based View of Program Learning, Understanding, and Repair' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zimin Chen, Vincent J Hellendoorn, Pascal Lamblin, Petros Maniatis, Pierre-Antoine Manzagol, Daniel Tarlow, Subhodeep Moitra</td>
	<td>NeurIPS</td>
	<td><p>Machine learning for understanding and editing source code has recently attracted significant interest, with many developments in new models, new code representations, and new tasks.This proliferation can appear disparate and disconnected, making each approach seemingly unique and incompatible, thus obscuring the core machine learning challenges and contributions.In this work, we demonstrate that the landscape can be significantly simplified by taking a general approach of mapping a graph to a sequence of tokens and pointers.Our main result is to show that 16 recently published tasks of different shapes can be cast in this form, based on which a single model architecture achieves near or above state-of-the-art results on nearly all tasks, outperforming custom models like code2seq and alternative generic models like Transformers.This unification further enables multi-task learning and a series of cross-cutting experiments about the importance of different modeling choices for code understanding and repair tasks.The full framework, called PLUR, is easily extensible to more tasks, and will be open-sourced (https://github.com/google-research/plur).</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/zhu2921syntax/">A Syntax-Guided Edit Decoder for Neural Program Repair</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Syntax-Guided Edit Decoder for Neural Program Repair' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Syntax-Guided Edit Decoder for Neural Program Repair' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Qihao Zhu, Zeyu Sun, Yuan-an Xiao, Wenjie Zhang, Kang Yuan, Yingfei Xiong, Lu Zhang</td>
	<td>FSE</td>
	<td><p>Automated Program Repair (APR) helps improve the efficiency of software development and maintenance. Recent APR techniques use deep learning, particularly the encoder-decoder architecture, to generate patches.
Though existing DL-based APR approaches have proposed different encoder architectures, the decoder remains to be the standard one, which generates a sequence of tokens one by one to replace the faulty statement.
This decoder has multiple limitations: 1) allowing to generate syntactically incorrect programs, 2) inefficiently representing small edits, and 3) not being able to generate project-specific identifiers.
In this paper, we propose Recoder, a syntax-guided edit decoder with placeholder generation. Recoder is novel in multiple aspects: 1) Recoder generates edits rather than modified code, allowing efficient representation of small edits; 2) Recoder is syntax-guided, with the novel provider/decider architecture to ensure the syntactic correctness of the patched program and accurate generation; 3) Recoder generates placeholders that could be instantiated as project-specific identifiers later.
We conduct experiments to evaluate Recoder on 395 bugs from Defects4J v1.2, 420 additional bugs from Defects4J v2.0, 297 bugs from IntroClassJava and 40 bugs from QuixBugs. Our results show that Recoder repairs 53 bugs on Defects4J v1.2, which achieves 26.2% (11 bugs) improvement over the previous state-of-the-art approach for single-hunk bugs (TBar). Importantly, to our knowledge, Recoder is the first DL-based APR approach that has outperformed the traditional APR approaches on this benchmark.</p>
</td>
	<td>edit </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/chakraborty2020deep/">Deep Learning based Vulnerability Detection: Are We There Yet?</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Learning based Vulnerability Detection: Are We There Yet?' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Learning based Vulnerability Detection: Are We There Yet?' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Saikat Chakraborty, Rahul Krishna, Yangruibo Ding, Baishakhi Ray</td>
	<td>TSE</td>
	<td><p>Automated detection of software vulnerabilities is a fundamental problem in software security. Existing program analysis techniques either suffer from high false positives or false negatives. Recent progress in Deep Learning (DL) has resulted in a surge of interest in applying DL for automated vulnerability detection. Several recent studies have demonstrated promising results achieving an accuracy of up to 95% at detecting vulnerabilities. In this paper, we ask, “how well do the state-of-the-art DL-based techniques perform in a real-world vulnerability prediction scenario?”. To our surprise, we find that their performance drops by more than 50%. A systematic investigation of what causes such precipitous performance drop reveals that existing DL-based vulnerability prediction approaches suffer from challenges with the training data (e.g., data duplication, unrealistic distribution of vulnerable classes, etc.) and with the model choices (e.g., simple token-based models). As a result, these approaches often do not learn features related to the actual cause of the vulnerabilities. Instead, they learn unrelated artifacts from the dataset (e.g., specific variable/function names, etc.). Leveraging these empirical findings, we demonstrate how a more principled approach to data collection and model design, based on realistic settings of vulnerability prediction, can lead to better solutions. The resulting tools perform significantly better than the studied baseline: up to 33.57% boost in precision and 128.38% boost in recall compared to the best performing model in the literature. Overall, this paper elucidates existing DL-based vulnerability prediction systems’ potential issues and draws a roadmap for future DL-based vulnerability prediction research. In that spirit, we make available all the artifacts supporting our results: https://git.io/Jf6IA</p>
</td>
	<td>defect survey </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/chakraborty2021multimodal/">On Multi-Modal Learning of Editing Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=On Multi-Modal Learning of Editing Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=On Multi-Modal Learning of Editing Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Saikat Chakraborty, Baishakhi Ray</td>
	<td></td>
	<td><p>In recent years, Neural Machine Translator (NMT) has shown promise in automatically editing source code. Typical NMT based code editor only considers the code that needs to be changed as input and suggests developers with a ranked list of patched code to choose from - where the correct one may not always be at the top of the list. While NMT based code editing systems generate a broad spectrum of plausible patches, the correct one depends on the developers’ requirement and often on the context where the patch is applied. Thus, if developers provide some hints, using natural language, or providing patch context, NMT models can benefit from them. As a proof of concept, in this research, we leverage three modalities of information: edit location, edit code context, commit messages (as a proxy of developers’ hint in natural language) to automatically generate edits with NMT models. To that end, we build MODIT, a multi-modal NMT based code editing engine. With in-depth investigation and analysis, we show that developers’ hint as an input modality can narrow the search space for patches and outperform state-of-the-art models to generate correctly patched code in top-1 position.</p>
</td>
	<td>Transformer edit </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/bui2021efficient/">Self-Supervised Contrastive Learning for Code Retrieval and Summarization via Semantic-Preserving Transformations</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Self-Supervised Contrastive Learning for Code Retrieval and Summarization via Semantic-Preserving Transformations' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Self-Supervised Contrastive Learning for Code Retrieval and Summarization via Semantic-Preserving Transformations' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Nghi D. Q. Bui, Yijun Yu, Lingxiao Jiang</td>
	<td>SIGIR</td>
	<td><p>We propose Corder, a self-supervised contrastive learning framework for source code model. Corder is designed to alleviate the need of labeled data for code retrieval and code summarization tasks. The pre-trained model of Corder can be used in two ways: (1) it can produce vector representation of code which can be applied to code retrieval tasks that do not have labeled data; (2) it can be used in a fine-tuning process for tasks that might still require label data such as code summarization. The key innovation is that we train the source code model by asking it to recognize similar and dissimilar code snippets through a contrastive learning objective. To do so, we use a set of semantic-preserving transformation operators to generate code snippets that are syntactically diverse but semantically equivalent. Through extensive experiments, we have shown that the code models pretrained by Corder substantially outperform the other baselines for code-to-code retrieval, text-to-code retrieval, and code-to-text summarization tasks.</p>
</td>
	<td>pretraining search </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/bui2021infercode/">InferCode: Self-Supervised Learning of Code Representations by Predicting Subtrees</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=InferCode: Self-Supervised Learning of Code Representations by Predicting Subtrees' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=InferCode: Self-Supervised Learning of Code Representations by Predicting Subtrees' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Nghi D. Q. Bui, Yijun Yu, Lingxiao Jiang</td>
	<td>ICSE</td>
	<td><p>Building deep learning models on source code has found many successful software engineering applications, such as code search, code comment generation, bug detection, code migration, and so on. Current learning techniques, however, have a major drawback that these models are mostly trained on datasets labeled for particular downstream tasks, and code representations may not be suitable for other tasks. While some techniques produce representations from unlabeled code, they are far from satisfactory when applied to downstream tasks. Although certain techniques generate representations from unlabeled code when applied to downstream tasks they are far from satisfactory. This paper proposes InferCode to overcome the limitation by adapting the self-supervised learning mechanism to build source code model. The key novelty lies in training code representations by predicting automatically identified subtrees from the context of the ASTs. Subtrees in ASTs are treated with InferCode as the labels for training code representations without any human labeling effort or the overhead of expensive graph construction, and the trained representations are no longer tied to any specific downstream tasks or code units. We trained an InferCode model instance using the Tree-based CNN as the encoder of a large set of Java code and applied it to downstream unsupervised tasks such as code clustering, code clone detection, cross-language code search or reused under a transfer learning scheme to continue training the model weights for supervised tasks such as code classification and method name prediction. Compared to previous code learning techniques applied to the same downstream tasks, such as Code2Vec, Code2Seq, ASTNN, higher performance results are achieved using our pre-trained InferCode model with a significant margin for most tasks including those involving different programming languages.</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/berabi2021tfix/">TFix: Learning to Fix Coding Errors with a Text-to-Text Transformer</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=TFix: Learning to Fix Coding Errors with a Text-to-Text Transformer' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=TFix: Learning to Fix Coding Errors with a Text-to-Text Transformer' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Berkay Berabi, Jingxuan He, Veselin Raychev, Martin Vechev</td>
	<td>ICML</td>
	<td><p>The problem of fixing errors in programs has attracted substantial interest over the years. The
key challenge for building an effective code fixing tool is to capture a wide range of errors and
meanwhile maintain high accuracy. In this paper, we address this challenge and present a new
learning-based system, called TFix. TFix works
directly on program text and phrases the problem of code fixing as a text-to-text task. In turn,
this enables it to leverage a powerful Transformer
based model pre-trained on natural language and
fine-tuned to generate code fixes (via a large, high-quality dataset obtained from GitHub commits).
TFix is not specific to a particular programming
language or class of defects and, in fact, improved
its precision by simultaneously fine-tuning on 52
different error types reported by a popular static
analyzer. Our evaluation on a massive dataset of
JavaScript programs shows that TFix is practically
effective: it is able to synthesize code that fixes
the error in ∼67 percent of cases and significantly
outperforms existing learning-based approaches.</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/xu2021capturing/">Capturing Structural Locality in Non-parametric Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Capturing Structural Locality in Non-parametric Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Capturing Structural Locality in Non-parametric Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Frank F. Xu, Junxian He, Graham Neubig, Vincent J. Hellendoorn</td>
	<td></td>
	<td><p>Structural locality is a ubiquitous feature of real-world datasets, wherein data points are organized into local hierarchies. Some examples include topical clusters in text or project hierarchies in source code repositories. In this paper, we explore utilizing this structural locality within non-parametric language models, which generate sequences that reference retrieved examples from an external source. We propose a simple yet effective approach for adding locality information into such models by adding learned parameters that improve the likelihood of retrieving examples from local neighborhoods. Experiments on two different domains, Java source code and Wikipedia text, demonstrate that locality features improve model efficacy over models without access to these features, with interesting differences. We also perform an analysis of how and where locality features contribute to improved performance and why the traditionally used contextual similarity metrics alone are not enough to grasp the locality structure.</p>
</td>
	<td>language model </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/ye2021neural/">Neural Program Repair with Execution-based Backpropagation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Program Repair with Execution-based Backpropagation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Program Repair with Execution-based Backpropagation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>He Ye, Matias Martinez, Monperrus Martin</td>
	<td></td>
	<td><p>Neural machine translation (NMT) architectures have achieved promising results for automatic program repair. Yet, they have the limitation of generating low-quality patches (e.g., not compilable patches). This is because the existing works only optimize a purely syntactic loss function based on characters and tokens without incorporating program-specific information during neural net weight optimization. In this paper, we propose a novel program repair model called RewardRepair. The core novelty of RewardRepair is to improve NMT-based program repair with a loss function based on program compilation and test execution information, rewarding the network to produce patches that compile and that do not overfit. We conduct several experiments to evaluate RewardRepair showing that it is feasible and effective to use compilation and test execution results to optimize the underlying neural repair model. In total, RewardRepair correctly repairs 43 Defects4J bugs including eight that are fixed for the first time.</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/barchi2021exploration/">Exploration of Convolutional Neural Network models for source code classification</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Exploration of Convolutional Neural Network models for source code classification' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Exploration of Convolutional Neural Network models for source code classification' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Francesco Barchi, Emanuele Parisi, Gianvito Urgese, Elisa Ficarra, Andrea Acquaviva</td>
	<td></td>
	<td><p>The application of Artificial Intelligence is becoming common in many engineering fields. Among them, one of the newest and rapidly evolving is software generation, where AI can be used to automatically optimise the implementation of an algorithm for a given computing platform. In particular, Deep Learning technologies can be used to the decide how to allocate pieces of code to hardware platforms with multiple cores and accelerators, that are common in high performance and edge computing applications. In this work, we explore the use of Convolutional Neural Networks (CNN)s to analyse the application source code and decide the best compute unit to minimise the execution time. We demonstrate that CNN models can be successfully applied to source code classification, providing higher accuracy with consistently reduced learning time with respect to state-of-the-art methods. Moreover, we show the robustness of the method with respect to source code pre-processing, compiler options and hyper-parameters selection.</p>
</td>
	<td>optimization static analysis program analysis language model </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/bai2021jointly/">Jointly Learning to Repair Code and Generate Commit Message</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Jointly Learning to Repair Code and Generate Commit Message' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Jointly Learning to Repair Code and Generate Commit Message' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jiaqi Bai, Long Zhou, Ambrosio Blanco, Shujie Liu, Furu Wei, Ming Zhou, Zhoujun Li</td>
	<td></td>
	<td><p>We propose a novel task of jointly repairing program codes and generating commit messages. Code repair and commit message generation are two essential and related tasks for software development. However, existing work usually performs the two tasks independently. We construct a multilingual triple dataset including buggy code, fixed code, and commit messages for this novel task. We provide the cascaded models as baseline, which are enhanced with different training approaches, including the teacher-student method, the multi-task method, and the back-translation method. To deal with the error propagation problem of the cascaded method, the joint model is proposed that can both repair the code and generate the commit message in a unified framework. Experimental results show that the enhanced cascaded model with teacher-student method and multitask-learning method achieves the best score on different metrics of automated code repair, and the joint model behaves better than the cascaded model on commit message generation.</p>
</td>
	<td>edit Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/allamanis2021self/">Self-Supervised Bug Detection and Repair</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Self-Supervised Bug Detection and Repair' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Self-Supervised Bug Detection and Repair' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Miltiadis Allamanis, Henry Jackson-Flux, Marc Brockschmidt</td>
	<td>NeurIPS</td>
	<td><p>Machine learning-based program analyses have recently shown the promise of integrating formal and probabilistic reasoning towards aiding software development. However, in the absence of large annotated corpora, training these analyses is challenging. Towards addressing this, we present BugLab, an approach for self-supervised learning of bug detection and repair. BugLab co-trains two models: (1) a detector model that learns to detect and repair bugs in code, (2) a selector model that learns to create buggy code for the detector to use as training data. A Python implementation of BugLab improves by up to 30% upon baseline methods on a test dataset of 2374 real-life bugs and finds 19 previously unknown bugs in open-source software.</p>
</td>
	<td>GNN Transformer defect repair </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/alet2021largescale/">A large-scale benchmark for few-shot program induction and synthesis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A large-scale benchmark for few-shot program induction and synthesis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A large-scale benchmark for few-shot program induction and synthesis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ferran Alet, Javier Lopez-Contreras,  James Koppel,  Maxwell Nye,   Armando Solar-Lezama,  Tomas Lozano-Perez,  Leslie Kaelbling, Joshua Tenenbaum</td>
	<td>ICML</td>
	<td><p>A landmark challenge for AI is to learn flexible, powerful representations from small numbers of examples. 
On an important class of tasks, hypotheses in the form of programs provide extreme generalization capabilities from surprisingly few examples. However, whereas large natural few-shot learning image benchmarks have spurred progress in meta-learning for deep networks, there is no comparably big, natural program-synthesis dataset that can play a similar role. This is because, whereas images are relatively easy to label from internet meta-data or annotated by non-experts, generating meaningful input-output examples for program induction has proven hard to scale. In this work, we propose a new way of leveraging unit tests and natural inputs for small programs as meaningful input-output examples for each sub-program of the overall program. This allows us to create a large-scale naturalistic few-shot program-induction benchmark and propose new challenges in this domain. The evaluation of multiple program induction and synthesis algorithms points to shortcomings of current methods and suggests multiple avenues for future work.</p>
</td>
	<td>dataset synthesis </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/ahmad2021unified/">Unified Pre-training for Program Understanding and Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Unified Pre-training for Program Understanding and Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Unified Pre-training for Program Understanding and Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Wasi Uddin Ahmad, Saikat Chakraborty, Baishakhi Ray, Kai-Wei Chang</td>
	<td>NAACL</td>
	<td><p>Code summarization and generation empower conversion between programming language (PL) and natural language (NL), while code translation avails the migration of legacy code from one PL to another. This paper introduces PLBART, a sequence-to-sequence model capable of performing a broad spectrum of program and language understanding and generation tasks. PLBART is pre-trained on an extensive collection of Java and Python functions and associated NL text via denoising autoencoding. Experiments on language generation tasks, including code summarization, generation, translation in seven programming languages show that PLBART outperforms or rivals state-of-the-art models. Moreover, experiments on discriminative tasks, e.g., program repair, clone detection, and vulnerable code detection demonstrate PLBART’s effectiveness in program understanding. Furthermore, analysis reveals that PLBART learns program syntax, style (e.g., identifier naming convention), logical flow (e.g., if block inside an else block is equivalent to else if block) that are crucial to program semantics and thus excels even with limited annotations.</p>
</td>
	<td>pretraining Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/watson2021systematic/">A Systematic Literature Review on the Use of Deep Learning in Software Engineering Research</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Systematic Literature Review on the Use of Deep Learning in Software Engineering Research' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Systematic Literature Review on the Use of Deep Learning in Software Engineering Research' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Cody Watson, Nathan Cooper, David Nader Palacio, Kevin Moran, Denys Poshyvanyk</td>
	<td>TSE</td>
	<td><p>An increasingly popular set of techniques adopted by software engineering (SE) researchers to automate development tasks are those rooted in the concept of Deep Learning (DL). The popularity of such techniques largely stems from their automated feature engineering capabilities, which aid in modeling software artifacts. However, due to the rapid pace at which DL techniques have been adopted, it is difficult to distill the current successes, failures, and opportunities of the current research landscape. In an effort to bring clarity to this crosscutting area of work, from its modern inception to the present, this paper presents a systematic literature review of research at the intersection of SE &amp; DL. The review canvases work appearing in the most prominent SE and DL conferences and journals and spans 128 papers across 23 unique SE tasks. We center our analysis around the components of learning, a set of principles that govern the application of machine learning techniques (ML) to a given problem domain, discussing several aspects of the surveyed work at a granular level. The end result of our analysis is a research roadmap that both delineates the foundations of DL techniques applied to SE research, and highlights likely areas of fertile exploration for the future.</p>
</td>
	<td>survey </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/spirin2021psiminer/">PSIMiner: A Tool for Mining Rich Abstract Syntax Trees from Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=PSIMiner: A Tool for Mining Rich Abstract Syntax Trees from Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=PSIMiner: A Tool for Mining Rich Abstract Syntax Trees from Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Egor Spirin, Egor Bogomolov, Vladimir Kovalenko, Timofey Bryksin</td>
	<td>MSR</td>
	<td><p>The application of machine learning algorithms to source code has grown in the past years. Since these algorithms are quite sensitive to input data, it is not surprising that researchers experiment with input representations. Nowadays, a popular starting point to represent code is abstract syntax trees (ASTs). Abstract syntax trees have been used for a long time in various software engineering domains, and in particular in IDEs. The API of modern IDEs allows to manipulate and traverse ASTs, resolve references between code elements, etc. Such algorithms can enrich ASTs with new data and therefore may be useful in ML-based code analysis. In this work, we present PSIMINER— a tool for processing PSI trees from the IntelliJ Platform. PSI trees contain code syntax trees as well as functions to work with them, and therefore can be used to enrich code representation using static analysis algorithms of modern IDEs. To showcase this idea, we use our tool to infer types of identifiers in Java ASTs and extend the code2seq model for the method name prediction problem.</p>
</td>
	<td>tool </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/pravilov2021unsupervised/">Unsupervised Learning of General-Purpose Embeddings for Code Changes</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Unsupervised Learning of General-Purpose Embeddings for Code Changes' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Unsupervised Learning of General-Purpose Embeddings for Code Changes' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Mikhail Pravilov, Egor Bogomolov, Yaroslav Golubev, Timofey Bryksin</td>
	<td></td>
	<td><p>Applying machine learning to tasks that operate with code changes requires their numerical representation. In this work, we propose an approach for obtaining such representations during pre-training and evaluate them on two different downstream tasks - applying changes to code and commit message generation. During pre-training, the model learns to apply the given code change in a correct way. This task requires only code changes themselves, which makes it unsupervised. In the task of applying code changes, our model outperforms baseline models by 5.9 percentage points in accuracy. As for the commit message generation, our model demonstrated the same results as supervised models trained for this specific task, which indicates that it can encode code changes well and can be improved in the future by pre-training on a larger dataset of easily gathered code changes.</p>
</td>
	<td>edit representation </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/phan2021cotext/">CoTexT: Multi-task Learning with Code-Text Transformer</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CoTexT: Multi-task Learning with Code-Text Transformer' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CoTexT: Multi-task Learning with Code-Text Transformer' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Long Phan, Hieu Tran, Daniel Le, Hieu Nguyen, James Anibal, Alec Peltekian, Yanfang Ye</td>
	<td>NLP4Prog</td>
	<td><p>We present CoTexT, a transformer-based architecture encoder-decoder pre-trained model that learns the representative context between natural language (NL) and programming language (PL) through multi-task learning. CoTexT is pre-trained, in self-supervised fashion, based on large programming language corpus to learn general-purpose understanding and code-text generation supporting downstream NL-PL task such as code summarizing/documentation, code generation, defect detection, code debugging, etc. We train CoTexT on different combination of available PL corpus including both “bimodal” and “unimodal” data where the former is the combinations of both natural texts and their corresponding code snippets in an input sequence and the latter is merely code snippets. We evaluate multi-task learning CoTexT on different generation and classification tasks on CodeXGLUE and it achieves state-of-the-art on all downstream tasks.</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/popov2021time/">Time-Efficient Code Completion Model for the R Programming Language</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Time-Efficient Code Completion Model for the R Programming Language' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Time-Efficient Code Completion Model for the R Programming Language' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Artem Popov, Dmitrii Orekhov, Denis Litvinov, Nikolay Korolev, Gleb Morgachev</td>
	<td>NLP4Prog</td>
	<td><p>In this paper we present a deep learning code completion model for the R language. We introduce several techniques to utilize language modeling based architecture in the code completion task. With these techniques, the model requires low resources, but still achieves high quality. We also present an evaluation dataset for the R language completion task. Our dataset contains multiple autocompletion usage contexts that provides robust validation results. The dataset is publicly available.</p>
</td>
	<td>dataset language model code generation Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/patra2021semantic/">A Semantic Bug Seeding: A Learning-Based Approach for Creating Realistic Bugs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Semantic Bug Seeding: A Learning-Based Approach for Creating Realistic Bugs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Semantic Bug Seeding: A Learning-Based Approach for Creating Realistic Bugs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jibesh Patra, Michael Pradel</td>
	<td>FSE</td>
	<td><p>When working on techniques to address the wide-spread problem
of software bugs, one often faces the need for a large number of
realistic bugs in real-world programs. Such bugs can either help
evaluate an approach, e.g., in form of a bug benchmark or a suite
of program mutations, or even help build the technique, e.g., in
learning-based bug detection. Because gathering a large number ofreal bugs is difficult,
a common approach is to rely on automatically
seeded bugs. Prior work seeds bugs based on syntactic transformation patterns,
which often results in unrealistic bugs and typically 
cannot introduce new, application-specific code tokens. This paper
presents SemSeed, a technique for automatically seeding bugs in
a semantics-aware way. The key idea is to imitate how a given
real-world bug would look like in other programs by semantically
adapting the bug pattern to the local context. To reason about the
semantics of pieces of code, our approach builds on learned token embeddings
that encode the semantic similarities of identifiers and literals. Our
evaluation with real-world JavaScript softwares
hows that the approach effectively reproduces real bugs and clearly
outperforms a semantics-unaware approach. The seeded bugs are
useful as training data for learning-based bug detection, where
they significantly improve the bug detection ability. Moreover, we
show that SemSeed-created bugs complement existing mutation
testing operators, and that our approach is efficient enough to seed
hundreds of thousands of bugs within an hour.</p>
</td>
	<td>repair edit </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/pearce2021empirical/">An Empirical Cybersecurity Evaluation of GitHub Copilot's Code Contributions</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=An Empirical Cybersecurity Evaluation of GitHub Copilot's Code Contributions' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=An Empirical Cybersecurity Evaluation of GitHub Copilot's Code Contributions' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hammond Pearce, Baleegh Ahmad, Benjamin Tan, Brendan Dolan-Gavitt, Ramesh Karri</td>
	<td></td>
	<td><p>There is burgeoning interest in designing AI-based systems to assist humans in designing computing systems, including tools that automatically generate computer code. The most notable of these comes in the form of the first self-described `AI pair programmer’, GitHub Copilot, a language model trained over open-source GitHub code. However, code often contains bugs - and so, given the vast quantity of unvetted code that Copilot has processed, it is certain that the language model will have learned from exploitable, buggy code. This raises concerns on the security of Copilot’s code contributions. In this work, we systematically investigate the prevalence and conditions that can cause GitHub Copilot to recommend insecure code. To perform this analysis we prompt Copilot to generate code in scenarios relevant to high-risk CWEs (e.g. those from MITRE’s “Top 25” list). We explore Copilot’s performance on three distinct code generation axes – examining how it performs given diversity of weaknesses, diversity of prompts, and diversity of domains. In total, we produce 89 different scenarios for Copilot to complete, producing 1,692 programs. Of these, we found approximately 40% to be vulnerable.</p>
</td>
	<td>Transformer language model </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/parisi2021source/">Source Code Classification for Energy Efficiency in Parallel Ultra Low-Power Microcontrollers</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Source Code Classification for Energy Efficiency in Parallel Ultra Low-Power Microcontrollers' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Source Code Classification for Energy Efficiency in Parallel Ultra Low-Power Microcontrollers' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Emanuele Parisi, Francesco Barchi, Andrea Bartolini, Giuseppe Tagliavini, Andrea Acquaviva</td>
	<td>DATE</td>
	<td><p>The analysis of source code through machine learning techniques is an increasingly explored research topic aiming at increasing smartness in the software toolchain to exploit modern architectures in the best possible way. In the case of low-power, parallel embedded architectures, this means finding the configuration, for instance in terms of the number of cores, leading to minimum energy consumption. Depending on the kernel to be executed, the energy optimal scaling configuration is not trivial. While recent work has focused on general-purpose systems to learn and predict the best execution target in terms of the execution time of a snippet of code or kernel (e.g. offload OpenCL kernel on multicore CPU or GPU), in this work we focus on static compile-time features to assess if they can be successfully used to predict the minimum energy configuration on PULP, an ultra-low-power architecture featuring an on-chip cluster of RISC-V processors. Experiments show that using machine learning models on the source code to select the best energy scaling configuration automatically is viable and has the potential to be used in the context of automatic system configuration for energy minimisation.</p>
</td>
	<td>optimization program analysis </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/peng2021how/">How could Neural Networks understand Programs?</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=How could Neural Networks understand Programs?' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=How could Neural Networks understand Programs?' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Dinglan Peng, Shuxin Zheng, Yatao Li, Guolin Ke, Di He, Tie-Yan Liu</td>
	<td>ICML</td>
	<td><p>Semantic understanding of programs is a fundamental problem for programming language processing (PLP). Recent works that learn representations of code based on pre-training techniques in NLP have pushed the frontiers in this direction. However, the semantics of PL and NL have essential differences. These being ignored, we believe it is difficult to build a model to better understand programs, by either directly applying off-the-shelf NLP pre-training techniques to the source code, or adding features to the model by the heuristic. In fact, the semantics of a program can be rigorously defined by formal semantics in PL theory. For example, the operational semantics, describes the meaning of a valid program as updating the environment (i.e., the memory address-value function) through fundamental operations, such as memory I/O and conditional branching. Inspired by this, we propose a novel program semantics learning paradigm, that the model should learn from information composed of (1) the representations which align well with the fundamental operations in operational semantics, and (2) the information of environment transition, which is indispensable for program understanding. To validate our proposal, we present a hierarchical Transformer-based pre-training model called OSCAR to better facilitate the understanding of programs. OSCAR learns from intermediate representation (IR) and an encoded representation derived from static analysis, which are used for representing the fundamental operations and approximating the environment transitions respectively. OSCAR empirically shows the outstanding capability of program semantics understanding on many practical software engineering tasks.</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/panthaplackel2021learning/">Learning to Describe Solutions for Bug Reports Based on Developer Discussions</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Describe Solutions for Bug Reports Based on Developer Discussions' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Describe Solutions for Bug Reports Based on Developer Discussions' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sheena Panthaplackel, Junyi Jessy Li, Milos Gligoric, Raymond J. Mooney</td>
	<td></td>
	<td><p>When a software bug is reported, developers engage in a discussion to collaboratively resolve it. While the solution is likely formulated within the discussion, it is often buried in a large amount of text, making it difficult to comprehend, which delays its implementation. To expedite bug resolution, we propose generating a concise natural language description of the solution by synthesizing relevant content within the discussion, which encompasses both natural language and source code. Furthermore, to support generating an informative description during an ongoing discussion, we propose a secondary task of determining when sufficient context about the solution emerges in real-time. We construct a dataset for these tasks with a novel technique for obtaining noisy supervision from repository changes linked to bug reports. We establish baselines for generating solution descriptions, and develop a classifier which makes a prediction following each new utterance on whether or not the necessary context for performing generation is available. Through automated and human evaluation, we find these tasks to form an ideal testbed for complex reasoning in long, bimodal dialogue context.</p>
</td>
	<td>summarization documentation </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/parvez2021retrieval/">Retrieval Augmented Code Generation and Summarization</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Retrieval Augmented Code Generation and Summarization' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Retrieval Augmented Code Generation and Summarization' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Md Rizwan Parvez, Wasi Uddin Ahmad, Saikat Chakraborty, Baishakhi Ray, Kai-Wei Chang</td>
	<td>EMNLP-Findings</td>
	<td><p>Software developers write a lot of source code and documentation during software development. Intrinsically, developers often recall parts of source code or code summaries that they had written in the past while implementing software or documenting them. To mimic developers’ code or summary generation behavior, we propose a retrieval augmented framework, REDCODER, that retrieves relevant code or summaries from a retrieval database and provides them as a supplement to code generation or summarization models. REDCODER has a couple of uniqueness. First, it extends the state-of-the-art dense retrieval technique to search for relevant code or summaries. Second, it can work with retrieval databases that include unimodal (only code or natural language description) or bimodal instances (code-description pairs). We conduct experiments and extensive analysis on two benchmark datasets of code generation and summarization in Java and Python, and the promising results endorse the effectiveness of our proposed retrieval augmented framework.</p>
</td>
	<td>Transformer summarization code generation </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/roziere2021dobf/">DOBF: A Deobfuscation Pre-Training Objective for Programming Languages</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DOBF: A Deobfuscation Pre-Training Objective for Programming Languages' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DOBF: A Deobfuscation Pre-Training Objective for Programming Languages' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Baptiste Roziere, Marie-Anne Lachaux, Marc Szafraniec, Guillaume Lample</td>
	<td></td>
	<td><p>Recent advances in self-supervised learning have dramatically improved the state of the art on a wide variety of tasks. However, research in language model pre-training has mostly focused on natural languages, and it is unclear whether models like BERT and its variants provide the best pre-training when applied to other modalities, such as source code. In this paper, we introduce a new pre-training objective, DOBF, that leverages the structural aspect of programming languages and pre-trains a model to recover the original version of obfuscated source code. We show that models pre-trained with DOBF significantly outperform existing approaches on multiple downstream tasks, providing relative improvements of up to 13% in unsupervised code translation, and 24% in natural language code search. Incidentally, we found that our pre-trained model is able to de-obfuscate fully obfuscated source files, and to suggest descriptive variable names.</p>
</td>
	<td>pretraining </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/wang2021codet5/">CodeT5: Identifier-aware Unified Pre-trained Encoder-Decoder Models for Code Understanding and Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeT5: Identifier-aware Unified Pre-trained Encoder-Decoder Models for Code Understanding and Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeT5: Identifier-aware Unified Pre-trained Encoder-Decoder Models for Code Understanding and Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yue Wang, Weishi Wang, Shafiq Joty, Steven C.H. Hoi</td>
	<td>EMNLP</td>
	<td><p>Pre-trained models for Natural Languages (NL) like BERT and GPT have been recently shown to transfer well to Programming Languages (PL) and largely benefit a broad set of code-related tasks. Despite their success, most current methods either rely on an encoder-only (or decoder-only) pre-training that is suboptimal for generation (resp. understanding) tasks or process the code snippet in the same way as NL, neglecting the special characteristics of PL such as token types. We present CodeT5, a unified pre-trained encoder-decoder Transformer model that better leverages the code semantics conveyed from the developer-assigned identifiers. Our model employs a unified framework to seamlessly support both code understanding and generation tasks and allows for multi-task learning. Besides, we propose a novel identifier-aware pre-training task that enables the model to distinguish which code tokens are identifiers and to recover them when they are masked. Furthermore, we propose to exploit the user-written code comments with a bimodal dual generation task for better NL-PL alignment. Comprehensive experiments show that CodeT5 significantly outperforms prior methods on understanding tasks such as code defect detection and clone detection, and generation tasks across various directions including PL-NL, NL-PL, and PL-PL. Further analysis reveals that our model can better capture semantic information from code. Our code and pre-trained models are released at https://github.com/salesforce/CodeT5 .</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/roziere2021leveraging/">Leveraging Automated Unit Tests for Unsupervised Code Translation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Leveraging Automated Unit Tests for Unsupervised Code Translation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Leveraging Automated Unit Tests for Unsupervised Code Translation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Baptiste Roziere, Jie M. Zhang, Francois Charton, Mark Harman, Gabriel Synnaeve, Guillaume Lample</td>
	<td></td>
	<td><p>With little to no parallel data available for programming languages, unsupervised methods are well-suited to source code translation. However, the majority of unsupervised machine translation approaches rely on back-translation, a method developed in the context of natural language translation and one that inherently involves training on noisy inputs. Unfortunately, source code is highly sensitive to small changes; a single token can result in compilation failures or erroneous programs, unlike natural languages where small inaccuracies may not change the meaning of a sentence. To address this issue, we propose to leverage an automated unit-testing system to filter out invalid translations, thereby creating a fully tested parallel corpus. We found that fine-tuning an unsupervised model with this filtered data set significantly reduces the noise in the translations so-generated, comfortably outperforming the state-of-the-art for all language pairs studied. In particular, for Java → Python and Python → C++ we outperform the best previous methods by more than 16% and 24% respectively, reducing the error rate by more than 35%.</p>
</td>
	<td>migration </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/rabin2021generalizability/">On the Generalizability of Neural Program Models with respect to Semantic-Preserving Program Transformations</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=On the Generalizability of Neural Program Models with respect to Semantic-Preserving Program Transformations' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=On the Generalizability of Neural Program Models with respect to Semantic-Preserving Program Transformations' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Md Rafiqul Islam Rabin, Nghi D. Q. Bui, Ke Wang, Yijun Yu, Lingxiao Jiang, Mohammad Amin Alipour</td>
	<td>IST</td>
	<td><p>With the prevalence of publicly available source code repositories to train deep neural network models, neural program models can do well in source code analysis tasks such as predicting method names in given programs that cannot be easily done by traditional program analysis techniques. Although such neural program models have been tested on various existing datasets, the extent to which they generalize to unforeseen source code is largely unknown. Since it is very challenging to test neural program models on all unforeseen programs, in this paper, we propose to evaluate the generalizability of neural program models with respect to semantic-preserving transformations: a generalizable neural program model should perform equally well on programs that are of the same semantics but of different lexical appearances and syntactical structures. We compare the results of various neural program models for the method name prediction task on programs before and after automated semantic-preserving transformations. We use three Java datasets of different sizes and three state-of-the-art neural network models for code, namely code2vec, code2seq, and GGNN, to build nine such neural program models for evaluation. Our results show that even with small semantically preserving changes to the programs, these neural program models often fail to generalize their performance. Our results also suggest that neural program models based on data and control dependencies in programs generalize better than neural program models based only on abstract syntax trees. On the positive side, we observe that as the size of the training dataset grows and diversifies the generalizability of correct predictions produced by the neural program models can be improved too. Our results on the generalizability of neural program models provide insights to measure their limitations and provide a stepping stone for their improvement.</p>
</td>
	<td>evaluation adversarial generalizability refactoring summarization </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/puri2021project/">Project CodeNet: A Large-Scale AI for Code Dataset for Learning a Diversity of Coding Tasks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Project CodeNet: A Large-Scale AI for Code Dataset for Learning a Diversity of Coding Tasks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Project CodeNet: A Large-Scale AI for Code Dataset for Learning a Diversity of Coding Tasks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ruchir Puri, David S. Kung, Geert Janssen, Wei Zhang, Giacomo Domeniconi, Vladmir Zolotov, Julian Dolby, Jie Chen, Mihir Choudhury, Lindsey Decker, Veronika Thost, Luca Buratti, Saurabh Pujar, Ulrich Finkler</td>
	<td></td>
	<td><p>Advancements in deep learning and machine learning algorithms have enabled
breakthrough progress in computer vision, speech recognition, natural language
processing and beyond.  In addition, over the last several decades, software has
been built into the fabric of every aspect of our society.   Together,  these two
trends have generated new interest in the fast-emerging research area of “AI for
Code”. As software development becomes ubiquitous across all industries and code
infrastructure of enterprise legacy applications ages, it is more critical than ever
to increase software development productivity and modernize legacy applications.
Over the last decade, datasets like ImageNet, with its large scale and diversity,
have played a pivotal role in algorithmic advancements from computer vision to
language and speech understanding. In this paper, we present “Project CodeNet”,
a first-of-its-kind, very large scale, diverse, and high-quality dataset to accelerate
the algorithmic advancements in AI for Code.  It consists of 14M code samples
and about 500M lines of code in 55 different programming languages.  Project
CodeNet is not only unique in its scale, but also in the diversity of coding tasks
it can help benchmark:  from code similarity and classification for advances in
code recommendation algorithms, and code translation between a large variety
programming languages, to advances in code performance (both runtime, and
memory) improvement techniques. CodeNet also provides sample input and output
test sets for over 7M code samples, which can be critical for determining code
equivalence in different languages. As a usability feature, we provide several 
preprocessing tools in Project CodeNet to transform source codes into representations
that can be readily used as inputs into machine learning models.</p>
</td>
	<td>dataset </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/schuster2021you/">You Autocomplete Me: Poisoning Vulnerabilities in Neural Code Completion</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=You Autocomplete Me: Poisoning Vulnerabilities in Neural Code Completion' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=You Autocomplete Me: Poisoning Vulnerabilities in Neural Code Completion' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Roei Schuster, Congzheng Song, Eran Tromer, Vitaly Shmatikov</td>
	<td>USENIX Security</td>
	<td><p>Code autocompletion is an integral feature of modern code editors and IDEs. The latest generation of autocompleters uses neural language models, trained on public open-source code repositories, to suggest likely (not just statically feasible) completions given the current context.</p>

<p>We demonstrate that neural code autocompleters are vulnerable to poisoning attacks. By adding a few specially-crafted files to the autocompleter’s training corpus (data poisoning), or else by directly fine-tuning the autocompleter on these files (model poisoning), the attacker can influence its suggestions for attacker-chosen contexts. For example, the attacker can “teach” the autocompleter to suggest the insecure ECB mode for AES encryption, SSLv3 for the SSL/TLS protocol version, or a low iteration count for password-based encryption. Moreover, we show that these attacks can be targeted: an autocompleter poisoned by a targeted attack is much more likely to suggest the insecure completion for files from a specific repo or specific developer.</p>

<p>We quantify the efficacy of targeted and untargeted data- and model-poisoning attacks against state-of-the-art autocompleters based on Pythia and GPT-2. We then evaluate existing defenses against poisoning attacks and show that they are largely ineffective.</p>
</td>
	<td>autocomplete adversarial </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/rabin2021understanding/">Understanding Neural Code Intelligence Through Program Simplification</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Understanding Neural Code Intelligence Through Program Simplification' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Understanding Neural Code Intelligence Through Program Simplification' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Md Rafiqul Islam Rabin, Vincent J. Hellendoorn, Mohammad Amin Alipour</td>
	<td>ESEC/FSE</td>
	<td><p>A wide range of code intelligence (CI) tools, powered by deep neural networks, have been developed recently to improve programming productivity and perform program analysis. To reliably use such tools, developers often need to reason about the behavior of the underlying models and the factors that affect them. This is especially challenging for tools backed by deep neural networks. Various methods have tried to reduce this opacity in the vein of “transparent/interpretable-AI”. However, these approaches are often specific to a particular set of network architectures, even requiring access to the network’s parameters. This makes them difficult to use for the average programmer, which hinders the reliable adoption of neural CI systems. In this paper, we propose a simple, model-agnostic approach to identify critical input features for models in CI systems, by drawing on software debugging research, specifically delta debugging. Our approach, SIVAND, uses simplification techniques that reduce the size of input programs of a CI model while preserving the predictions of the model. We show that this approach yields remarkably small outputs and is broadly applicable across many model architectures and problem domains. We find that the models in our experiments often rely heavily on just a few syntactic features in input programs. We believe that SIVAND’s extracted features may help understand neural CI systems’ predictions and learned behavior.</p>
</td>
	<td>interpretability refactoring information extraction </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/orlanski2021reading/">Reading StackOverflow Encourages Cheating: Adding Question Text Improves Extractive Code Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Reading StackOverflow Encourages Cheating: Adding Question Text Improves Extractive Code Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Reading StackOverflow Encourages Cheating: Adding Question Text Improves Extractive Code Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Gabriel Orlanski, Alex Gittens</td>
	<td>NLP4Prog</td>
	<td><p>Answering a programming question with only its title is difficult as salient contextual information is left out. To address this, we present a corpus of over 40,000 StackOverflow question texts to be used in conjunction with the corresponding intents from the CoNaLa dataset (Yin et al., 2018). Using both the intent and the question body, we use BART to establish a baseline BLEU score of 34.35 for this new task. We then find further improvements of 2.8% by combining the mined CoNaLa data with the labeled data to achieve a 35.32 BLEU score. We then evaluate the prior state-of-the-art CoNaLa models with this additional data. We find that our proposed method of using the body and mined data beats that of the previous state-of-the-art by a 71.96% BLEU score. Finally, we perform ablations that prove that BART is an unsupervised multimodal learner and examine its extractive behavior.</p>
</td>
	<td>dataset Transformer </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/nye2021program/">Program Synthesis with Large Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Program Synthesis with Large Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Program Synthesis with Large Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jacob Austin, Augustus Odena, Maxwell Nye, Maarten Bosma, Henryk Michalewski, David Dohan, Ellen Jiang, Carrie Cai, Michael Terry, Quoc Le, Charles Sutton</td>
	<td></td>
	<td><p>This paper explores the limits of the current generation of large language models for program synthesis in general purpose programming languages. We evaluate a collection of such models (with between 244M and 137B parameters) on two new benchmarks, MBPP and MathQA-Python, in both the few-shot and fine-tuning regimes. Our benchmarks are designed to measure the ability of these models to synthesize short Python programs from natural language descriptions. The Mostly Basic Programming Problems (MBPP) dataset contains 974 programming tasks, designed to be solvable by entry-level programmers. The MathQA-Python dataset, a Python version of the MathQA benchmark, contains 23914 problems that evaluate the ability of the models to synthesize code from more complex text. On both datasets, we find that synthesis performance scales log-linearly with model size. Our largest models, even without finetuning on a code dataset, can synthesize solutions to 59.6 percent of the problems from MBPP using few-shot learning with a well-designed prompt. Fine-tuning on a held-out portion of the dataset improves performance by about 10 percentage points across most model sizes. On the MathQA-Python dataset, the largest fine-tuned model achieves 83.8 percent accuracy. Going further, we study the model’s ability to engage in dialog about code, incorporating human feedback to improve its solutions. We find that natural language feedback from a human halves the error rate compared to the model’s initial prediction. Additionally, we conduct an error analysis to shed light on where these models fall short and what types of programs are most difficult to generate. Finally, we explore the semantic grounding of these models by fine-tuning them to predict the results of program execution. We find that even our best models are generally unable to predict the output of a program given a specific input.</p>
</td>
	<td>Transformer synthesis </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/nye2021show/">Show Your Work: Scratchpads for Intermediate Computation with Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Show Your Work: Scratchpads for Intermediate Computation with Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Show Your Work: Scratchpads for Intermediate Computation with Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Maxwell Nye, Anders Johan Andreassen, Guy Gur-Ari, Henryk Michalewski, Jacob Austin, David Bieber, David Dohan, Aitor Lewkowycz, Maarten Bosma, David Luan, Charles Sutton, Augustus Odena</td>
	<td></td>
	<td><p>Large pre-trained language models perform remarkably well on tasks that can be done “in one pass”, such as generating realistic text or synthesizing computer programs. However, they struggle with tasks that require unbounded multi-step computation, such as adding integers or executing programs. Surprisingly, we find that these same models are able to perform complex multi-step computations – even in the few-shot regime – when asked to perform the operation “step by step”, showing the results of intermediate computations. In particular, we train transformers to perform multi-step computations by asking them to emit intermediate computation steps into a “scratchpad”. On a series of increasingly complex tasks ranging from long addition to the execution of arbitrary programs, we show that scratchpads dramatically improve the ability of language models to perform multi-step computations.</p>
</td>
	<td>Transformer execution </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/zugner2021language/">Language-Agnostic Representation Learning of Source Code from Structure and Context</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Language-Agnostic Representation Learning of Source Code from Structure and Context' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Language-Agnostic Representation Learning of Source Code from Structure and Context' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Daniel Zügner, Tobias Kirschstein, Michele Catasta, Jure Leskovec, Stephan Günnemann</td>
	<td>ICLR</td>
	<td><p>Source code (Context) and its parsed abstract syntax tree (AST; Structure) are two complementary representations of the same computer program. Traditionally, designers of machine learning models have relied predominantly either on Structure or Context. We propose a new model, which jointly learns on Context and Structure of source code. In contrast to previous approaches, our model uses only language-agnostic features, i.e., source code and features that can be computed directly from the AST. Besides obtaining state-of-the-art on monolingual code summarization on all five programming languages considered in this work, we propose the first multilingual code summarization model. We show that jointly training on non-parallel data from multiple programming languages improves results on all individual languages, where the strongest gains are on low-resource languages. Remarkably, multilingual training only from Context does not lead to the same improvements, highlighting the benefits of combining Structure and Context for representation learning on code.</p>
</td>
	<td>Transformer representation </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/nitin2021direct/">DIRECT : A Transformer-based Model for Decompiled Identifier Renaming</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DIRECT : A Transformer-based Model for Decompiled Identifier Renaming' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DIRECT : A Transformer-based Model for Decompiled Identifier Renaming' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vikram Nitin, Anthony Saieva, Baishakhi Ray, Gail Kaiser</td>
	<td>NLP4Prog</td>
	<td><p>Decompiling binary executables to high-level code is an important step in reverse engineering scenarios, such as malware analysis and legacy code maintenance. However, the generated high-level code is difficult to understand since the original variable names are lost. In this paper, we leverage transformer models to reconstruct the original variable names from decompiled code. Inherent differences between code and natural language present certain challenges in applying conventional transformer-based architectures to variable name recovery. We propose DIRECT, a novel transformer-based architecture customized specifically for the task at hand. We evaluate our model on a dataset of decompiled functions and find that DIRECT outperforms the previous state-of-the-art model by up to 20%. We also present ablation studies evaluating the impact of each of our modifications. We make the source code of DIRECT available to encourage reproducible research.</p>
</td>
	<td>Transformer decompilation </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/nie2021evaluation/">Impact of Evaluation Methodologies on Code Summarization</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Impact of Evaluation Methodologies on Code Summarization' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Impact of Evaluation Methodologies on Code Summarization' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Pengyu Nie, Jiyang Zhang, Junyi Jessy Li, Raymond J. Mooney, Milos Gligoric</td>
	<td>ACL</td>
	<td><p>There has been a growing interest in developing machine learning (ML) models for code summarization tasks, e.g., comment generation and method naming. Despite substantial increase in the effectiveness of ML models, the evaluation methodologies, i.e., the way people split datasets into training, validation, and test sets, were not well studied. Specifically, no prior work on code summarization considered the timestamps of code and comments during evaluation. This may lead to evaluations that are inconsistent with the intended use cases. In this paper, we introduce the time-segmented evaluation methodology, which is novel to the code summarization research community, and compare it with the mixed-project and cross-project methodologies that have been commonly used. Each methodology can be mapped to some use cases, and the time-segmented methodology should be adopted in the evaluation of ML models for code summarization. To assess the impact of methodologies, we collect a dataset of (code, comment) pairs with timestamps to train and evaluate several recent ML models for code summarization. Our experiments show that different methodologies lead to conflicting evaluation results. We invite the community to expand the set of methodologies used in evaluations.</p>
</td>
	<td>evaluation dataset </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/mukherjee2021neural/">Neural Program Generation Modulo Static Analysis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Program Generation Modulo Static Analysis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Program Generation Modulo Static Analysis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rohan Mukherjee, Yeming Wen, Dipak Chaudhari, Thomas W. Reps, Swarat Chaudhuri, Chris Jermaine</td>
	<td>NeurIPS</td>
	<td><p>State-of-the-art neural models of source code tend to be evaluated on the generation
of individual expressions and lines of code, and commonly fail on long-horizon
tasks such as the generation of entire method bodies. We propose to address this
deficiency using weak supervision from a static program analyzer. Our neurosymbolic method allows a deep generative model to symbolically compute, using calls
to a static-analysis tool, long-distance semantic relationships in the code that it
has already generated. During training, the model observes these relationships
and learns to generate programs conditioned on them. We apply our approach to
the problem of generating entire Java methods given the remainder of the class
that contains the method. Our experiments show that the approach substantially
outperforms state-of-the-art transformers and a model that explicitly tries to learn
program semantics on this task, both in terms of producing programs free of basic
semantic errors and in terms of syntactically matching the ground truth.</p>
</td>
	<td>synthesis language model </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/monperrus2021megadiff/">Megadiff: A Dataset of 600k Java Source Code Changes Categorized by Diff Size</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Megadiff: A Dataset of 600k Java Source Code Changes Categorized by Diff Size' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Megadiff: A Dataset of 600k Java Source Code Changes Categorized by Diff Size' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Martin Monperrus, Matias Martinez, He Ye, Fernanda Madeiral, Thomas Durieux, Zhongxing Yu</td>
	<td></td>
	<td><p>This paper presents Megadiff, a dataset of source code diffs. It focuses on Java, with strict inclusion criteria based on commit message and diff size. Megadiff contains 663 029 Java diffs that can be used for research on commit comprehension, fault localization, automated program repair, and machine learning on code changes.</p>
</td>
	<td>dataset edit </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/mir2021type4py/">Type4Py: Deep Similarity Learning-Based Type Inference for Python</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Type4Py: Deep Similarity Learning-Based Type Inference for Python' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Type4Py: Deep Similarity Learning-Based Type Inference for Python' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Amir M. Mir, Evaldas Latoskinas, Sebastian Proksch, Georgios Gousios</td>
	<td></td>
	<td><p>Dynamic languages, such as Python and Javascript, trade static typing for developer flexibility. While this allegedly enables greater productivity, lack of static typing can cause runtime exceptions, type inconsistencies, and is a major factor for weak IDE support. To alleviate these issues, PEP 484 introduced optional type annotations for Python. As retrofitting types to existing codebases is error-prone and laborious, learning-based approaches have been proposed to enable automatic type annotations based on existing, partially annotated codebases. However, the prediction of rare and user-defined types is still challenging. In this paper, we present Type4Py, a deep similarity learning-based type inference model for Python. We design a hierarchical neural network model that learns to discriminate between types of the same kind and dissimilar types in a high-dimensional space, which results in clusters of types. Nearest neighbor search suggests likely type signatures of given Python functions. The types visible to analyzed modules are surfaced using lightweight dependency analysis. The results of quantitative and qualitative evaluation indicate that Type4Py significantly outperforms state-of-the-art approaches at the type prediction task. Considering the Top-1 prediction, Type4Py obtains 19.33% and 13.49% higher precision than Typilus and TypeWriter, respectively, while utilizing a much bigger vocabulary.</p>
</td>
	<td>types </td>
</tr>

<tr>
	<td>2021</td>
	<td><a href="/publications/wang2021syncobert/">SynCoBERT: Syntax-Guided Multi-Modal Contrastive Pre-Training for Code Representation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=SynCoBERT: Syntax-Guided Multi-Modal Contrastive Pre-Training for Code Representation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=SynCoBERT: Syntax-Guided Multi-Modal Contrastive Pre-Training for Code Representation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xin Wang, Yasheng Wang, Fei Mi, Pingyi Zhou, Yao Wan, Xiao Liu, Li Li, Hao Wu, Jin Liu, Xin Jiang</td>
	<td></td>
	<td><p>Code representation learning, which aims to encode the semantics of source code into distributed vectors, plays an important role in recent deep-learning-based models for code intelligence. Recently, many pre-trained language models for source code (e.g., CuBERT and CodeBERT) have been proposed to model the context of code and serve as a basis for downstream code intelligence tasks such as code search, code clone detection, and program translation. Current approaches typically consider the source code as a plain sequence of tokens, or inject the structure information (e.g., AST and data-flow) into the sequential model pre-training. To further explore the properties of programming languages, this paper proposes SynCoBERT, a syntax-guided multi-modal contrastive pre-training approach for better code representations. Specially, we design two novel pre-training objectives originating from the symbolic and syntactic properties of source code, i.e., Identifier Prediction (IP) and AST Edge Prediction (TEP), which are designed to predict identifiers, and edges between two nodes of AST, respectively. Meanwhile, to exploit the complementary information in semantically equivalent modalities (i.e., code, comment, AST) of the code, we propose a multi-modal contrastive learning strategy to maximize the mutual information among different modalities. Extensive experiments on four downstream tasks related to code intelligence show that SynCoBERT advances the state-of-the-art with the same pre-training corpus and model size.</p>
</td>
	<td>pretraining </td>
</tr>



<tr>
	<td>2020</td>
	<td><a href="/publications/pradel2020neural/">Neural Software Analysis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Software Analysis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Software Analysis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Michael Pradel, Satish Chandra</td>
	<td></td>
	<td><p>Many software development problems can be addressed by program analysis tools, which traditionally are based on precise, logical reasoning and heuristics to ensure that the tools are practical. Recent work has shown tremendous success through an alternative way of creating developer tools, which we call neural software analysis. The key idea is to train a neural machine learning model on numerous code examples, which, once trained, makes predictions about previously unseen code. In contrast to traditional program analysis, neural software analysis naturally handles fuzzy information, such as coding conventions and natural language embedded in code, without relying on manually encoded heuristics. This article gives an overview of neural software analysis, discusses when to (not) use it, and presents three example analyses. The analyses address challenging software development problems: bug detection, type prediction, and code completion. The resulting tools complement and outperform traditional program analyses, and are used in industrial practice.</p>
</td>
	<td>program analysis survey </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/haque2020improved/">Improved Automatic Summarization of Subroutines via Attention to File Context</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Improved Automatic Summarization of Subroutines via Attention to File Context' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Improved Automatic Summarization of Subroutines via Attention to File Context' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sakib Haque, Alexander LeClair, Lingfei Wu, Collin McMillan</td>
	<td></td>
	<td><p>Software documentation largely consists of short, natural language summaries of the subroutines in the software. These summaries help programmers quickly understand what a subroutine does without having to read the source code him or herself. The task of writing these descriptions is called “source code summarization” and has been a target of research for several years. Recently, AI-based approaches have superseded older, heuristic-based approaches. Yet, to date these AI-based approaches assume that all the content needed to predict summaries is inside subroutine itself. This assumption limits performance because many subroutines cannot be understood without surrounding context. In this paper, we present an approach that models the file context of subroutines (i.e. other subroutines in the same file) and uses an attention mechanism to find words and concepts to use in summaries. We show in an experiment that our approach extends and improves several recent baselines.</p>
</td>
	<td>summarization </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/haldar2020multiperspective/">A Multi-Perspective Architecture for Semantic Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Multi-Perspective Architecture for Semantic Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Multi-Perspective Architecture for Semantic Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rajarshi Haldar, Lingfei Wu, Jinjun Xiong, Julia Hockenmaier</td>
	<td>ACL</td>
	<td><p>The ability to match pieces of code to their corresponding natural language descriptions and vice versa is fundamental for natural language search interfaces to software repositories. In this paper, we propose a novel multi-perspective cross-lingual neural framework for code–text matching, inspired in part by a previous model for monolingual text-to-text matching, to capture both global and local similarities. Our experiments on the CoNaLa dataset show that our proposed model yields better performance on this cross-lingual text-to-code matching task than previous approaches that map code and text to a single joint embedding space.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/guo2020graphcodebert/">GraphCodeBERT: Pre-training Code Representations with Data Flow</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=GraphCodeBERT: Pre-training Code Representations with Data Flow' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=GraphCodeBERT: Pre-training Code Representations with Data Flow' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Daya Guo, Shuo Ren, Shuai Lu, Zhangyin Feng, Duyu Tang, Shujie Liu, Long Zhou, Nan Duan, Jian Yin, Daxin Jiang, Ming Zhou</td>
	<td></td>
	<td><p>Pre-trained models for programming language have achieved dramatic empirical improvements on a variety of code-related tasks such as code search, code completion, code summarization, etc. However, existing pre-trained models regard a code snippet as a sequence of tokens, while ignoring the inherent structure of code, which provides crucial code semantics and would enhance the code understanding process. We present GraphCodeBERT, a pre-trained model for programming language that considers the inherent structure of code. Instead of taking syntactic-level structure of code like abstract syntax tree (AST), we use data flow in the pre-training stage, which is a semantic-level structure of code that encodes the relation of “where-the-value-comes-from” between variables. Such a semantic-level structure is neat and does not bring an unnecessarily deep hierarchy of AST, the property of which makes the model more efficient. We develop GraphCodeBERT based on Transformer. In addition to using the task of masked language modeling, we introduce two structure-aware pre-training tasks. One is to predict code structure edges, and the other is to align representations between source code and code structure. We implement the model in an efficient way with a graph-guided masked attention function to incorporate the code structure. We evaluate our model on four tasks, including code search, clone detection, code translation, and code refinement. Results show that code structure and newly introduced pre-training tasks can improve GraphCodeBERT and achieves state-of-the-art performance on the four downstream tasks. We further show that the model prefers structure-level attentions over token-level attentions in the task of code search.</p>
</td>
	<td>pretraining </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/hellendoorn2020global/">Global Relational Models of Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Global Relational Models of Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Global Relational Models of Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vincent J. Hellendoorn, Charles Sutton, Rishab Singh, Petros Maniatis, David Bieber</td>
	<td>ICLR</td>
	<td><p>Models of code can learn distributed representations of a program’s syntax and semantics to predict many non-trivial properties of a program. Recent state-of-the-art models leverage highly structured representations of programs, such as trees, graphs and paths therein (e.g. data-flow relations), which are precise and abundantly available for code. This provides a strong inductive bias towards semantically meaningful relations, yielding more generalizable representations than classical sequence-based models. Unfortunately, these models primarily rely on graph-based message passing to represent relations in code, which makes them de facto local due to the high cost of message-passing steps, quite in contrast to modern, global sequence-based models, such as the Transformer. In this work, we bridge this divide between global and structured models by introducing two new hybrid model families that are both global and incorporate structural bias: Graph Sandwiches, which wrap traditional (gated) graph message-passing layers in sequential message-passing layers; and Graph Relational Embedding Attention Transformers (GREAT for short), which bias traditional Transformers with relational information from graph edge types. By studying a popular, non-trivial program repair task, variable-misuse identification, we explore the relative merits of traditional and hybrid model families for code representation. Starting with a  graph-based model that already improves upon the prior state-of-the-art for this task by 20%, we show that our proposed hybrid models improve an additional 10-15%, while training both faster and using fewer parameters.</p>
</td>
	<td>variable misuse defect GNN Transformer </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/zhong2020semantic/">Semantic Scaffolds for Pseudocode-to-Code Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Semantic Scaffolds for Pseudocode-to-Code Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Semantic Scaffolds for Pseudocode-to-Code Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ruiqi Zhong, Mitchell Stern, Dan Klein</td>
	<td></td>
	<td><p>We propose a method for program generation based on semantic scaffolds, lightweight structures representing the high-level semantic and syntactic composition of a program. By first searching over plausible scaffolds then using these as constraints for a beam search over programs, we achieve better coverage of the search space when compared with existing techniques. We apply our hierarchical search method to the SPoC dataset for pseudocode-to-code generation, in which we are given line-level natural language pseudocode annotations and aim to produce a program satisfying execution-based test cases. By using semantic scaffolds during inference, we achieve a 10% absolute improvement in top-100 accuracy over the previous state-of-the-art. Additionally, we require only 11 candidates to reach the top-3000 performance of the previous best approach when tested against unseen problems, demonstrating a substantial improvement in efficiency.</p>
</td>
	<td>code generation synthesis </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/tufano2020generating/">Generating Accurate Assert Statements for Unit Test Cases using Pretrained Transformers</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Generating Accurate Assert Statements for Unit Test Cases using Pretrained Transformers' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Generating Accurate Assert Statements for Unit Test Cases using Pretrained Transformers' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Michele Tufano, Dawn Drain, Alexey Svyatkovskiy, Shao Kun Deng, Neel Sundaresan</td>
	<td>ICSE</td>
	<td><p>Unit testing represents the foundational basis of the software testing pyramid, beneath integration and end-to-end testing. Automated software testing researchers have proposed a variety of techniques to assist developers in this time-consuming task. In this paper we present an approach to support developers in writing unit test cases by generating accurate and useful assert statements. Our approach is based on a state-of-the-art transformer model initially pretrained on an English textual corpus. This semantically rich model is then trained in a semi-supervised fashion on a large corpus of source code. Finally, we finetune this model on the task of generating assert statements for unit tests. The resulting model is able to generate accurate assert statements for a given method under test. In our empirical evaluation, the model was able to predict the exact assert statements written by developers in 62% of the cases in the first attempt. The results show 80% relative improvement for top-1 accuracy over the previous RNN-based approach in the literature. We also show the substantial impact of the pretraining process on the performances of our model, as well as comparing it with assert auto-completion task. Finally, we demonstrate how our approach can be used to augment EvoSuite test cases, with additional asserts leading to improved test coverage.</p>
</td>
	<td>code generation synthesis test generation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/gros2020code/">Code to Comment "Translation": Data, Metrics, Baselining & Evaluation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Code to Comment "Translation": Data, Metrics, Baselining & Evaluation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Code to Comment "Translation": Data, Metrics, Baselining & Evaluation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>David Gros, Hariharan Sezhiyan, Premkumar Devanbu, Zhou Yu</td>
	<td></td>
	<td><p>The relationship of comments to code, and in particular, the task of generating useful comments given the code, has long been of interest. The earliest approaches have been based on strong syntactic theories of comment-structures, and relied on textual templates. More recently, researchers have applied deep learning methods to this task, and specifically, trainable generative translation models which are known to work very well for Natural Language translation (e.g., from German to English). We carefully examine the underlying assumption here: that the task of generating comments sufficiently resembles the task of translating between natural languages, and so similar models and evaluation metrics could be used. We analyze several recent code-comment datasets for this task: CodeNN, DeepCom, FunCom, and DocString. We compare them with WMT19, a standard dataset frequently used to train state of the art natural language translators. We found some interesting differences between the code-comment data and the WMT19 natural language data. Next, we describe and conduct some studies to calibrate BLEU (which is commonly used as a measure of comment quality). using “affinity pairs” of methods, from different projects, in the same project, in the same class, etc; Our study suggests that the current performance on some datasets might need to be improved substantially. We also argue that fairly naive information retrieval (IR) methods do well enough at this task to be considered a reasonable baseline. Finally, we make some suggestions on how our findings might be used in future research in this area.</p>
</td>
	<td>bimodal documentation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/wang2020learning/">Learning Semantic Program Embeddings with Graph Interval Neural Network</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Semantic Program Embeddings with Graph Interval Neural Network' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Semantic Program Embeddings with Graph Interval Neural Network' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yu Wang, Fengjuan Gao, Linzhang Wang, Ke Wang</td>
	<td></td>
	<td><p>Learning distributed representations of source code has been a challenging task for machine learning models. Earlier works treated programs as text so that natural language methods can be readily applied. Unfortunately, such approaches do not capitalize on the rich structural information possessed by source code. Of late, Graph Neural Network (GNN) was proposed to learn embeddings of programs from their graph representations. Due to the homogeneous and expensive message-passing procedure, GNN can suffer from precision issues, especially when dealing with programs rendered into large graphs. In this paper, we present a new graph neural architecture, called Graph Interval Neural Network (GINN), to tackle the weaknesses of the existing GNN. Unlike the standard GNN, GINN generalizes from a curated graph representation obtained through an abstraction method designed to aid models to learn. In particular, GINN focuses exclusively on intervals for mining the feature representation of a program, furthermore, GINN operates on a hierarchy of intervals for scaling the learning to large graphs. We evaluate GINN for two popular downstream applications: variable misuse prediction and method name prediction. Results show in both cases GINN outperforms the state-of-the-art models by a comfortable margin. We have also created a neural bug detector based on GINN to catch null pointer deference bugs in Java code. While learning from the same 9,000 methods extracted from 64 projects, GINN-based bug detector significantly outperforms GNN-based bug detector on 13 unseen test projects. Next, we deploy our trained GINN-based bug detector and Facebook Infer to scan the codebase of 20 highly starred projects on GitHub. Through our manual inspection, we confirm 38 bugs out of 102 warnings raised by GINN-based bug detector compared to 34 bugs out of 129 warnings for Facebook Infer.</p>
</td>
	<td>GNN defect </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/feng2020codebert/">CodeBERT: A Pre-Trained Model for Programming and Natural Languages</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeBERT: A Pre-Trained Model for Programming and Natural Languages' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeBERT: A Pre-Trained Model for Programming and Natural Languages' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zhangyin Feng, Daya Guo, Duyu Tang, Nan Duan, Xiaocheng Feng, Ming Gong, Linjun Shou, Bing Qin, Ting Liu, Daxin Jiang, Ming Zhou</td>
	<td></td>
	<td><p>We present CodeBERT, a bimodal pre-trained model for programming language (PL) and nat-ural language (NL). CodeBERT learns general-purpose representations that support downstream NL-PL applications such as natural language codesearch, code documentation generation, etc. We develop CodeBERT with Transformer-based neural architecture, and train it with a hybrid objective function that incorporates the pre-training task of replaced token detection, which is to detect plausible alternatives sampled from generators. This enables us to utilize both bimodal data of NL-PL pairs and unimodal data, where the former provides input tokens for model training while the latter helps to learn better generators. We evaluate CodeBERT on two NL-PL applications by fine-tuning model parameters. Results show that CodeBERT achieves state-of-the-art performance on both natural language code search and code documentation generation tasks. Furthermore, to investigate what type of knowledge is learned in CodeBERT, we construct a dataset for NL-PL probing, and evaluate in a zero-shot setting where parameters of pre-trained models are fixed. Results show that CodeBERT performs better than previous pre-trained models on NL-PL probing.</p>
</td>
	<td>pretraining </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/wang2020trans/">TranS^3: A Transformer-based Framework for Unifying Code Summarization and Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=TranS^3: A Transformer-based Framework for Unifying Code Summarization and Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=TranS^3: A Transformer-based Framework for Unifying Code Summarization and Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Wenhua Wang, Yuqun Zhang, Zhengran Zeng, Guandong Xu</td>
	<td></td>
	<td><p>Code summarization and code search have been widely adopted in sofwaredevelopmentandmaintenance. However, fewstudieshave explored the efcacy of unifying them. In this paper, we propose TranS^3 , a transformer-based framework to integrate code summarization with code search. Specifcally, for code summarization,TranS^3 enables an actor-critic network, where in the actor network, we encode the collected code snippets via transformer- and tree-transformer-based encoder and decode the given code snippet to generate its comment. Meanwhile, we iteratively tune the actor network via the feedback from the critic network for enhancing the quality of the generated comments. Furthermore, we import the generated comments to code search for enhancing its accuracy. To evaluatetheefectivenessof TranS^3 , we conduct a set of experimental studies and case studies where the experimental results suggest that TranS^3 can signifcantly outperform multiple state-of-the-art approaches in both code summarization and code search and the study results further strengthen the efcacy of TranS^3 from the developers’ points of view.</p>
</td>
	<td>search documentation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/tufano2020unit/">Unit Test Case Generation with Transformers</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Unit Test Case Generation with Transformers' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Unit Test Case Generation with Transformers' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Michele Tufano, Dawn Drain, Alexey Svyatkovskiy, Shao Kun Deng, Neel Sundaresan</td>
	<td>ICSE</td>
	<td><p>Automated Unit Test Case generation has been the focus of extensive literature within the research community. Existing approaches are usually guided by the test coverage criteria, generating synthetic test cases that are often difficult to read or understand for developers. In this paper we propose AthenaTest, an approach that aims at generating unit test cases by learning from real-world, developer-written test cases. Our approach relies on a state-of-the-art sequence-to-sequence transformer model which is able to write useful test cases for a given method under test (i.e., focal method). We also introduce methods2test - the largest publicly available supervised parallel corpus of unit test case methods and corresponding focal methods in Java, which comprises 630k test cases mined from 70k open-source repositories hosted on GitHub. We use this dataset to train a transformer model to translate focal methods into the corresponding test cases. We evaluate the ability of our model in generating test cases using natural language processing as well as code-specific criteria. First, we assess the quality of the translation compared to the target test case, then we analyze properties of the test case such as syntactic correctness and number and variety of testing APIs (e.g., asserts). We execute the test cases, collect test coverage information, and compare them with test cases generated by EvoSuite and GPT-3. Finally, we survey professional developers on their preference in terms of readability, understandability, and testing effectiveness of the generated test cases.</p>
</td>
	<td>code generation synthesis test generation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/dinella2020hoppity/">Hoppity: Learning Bug Detection and Repair</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Hoppity: Learning Bug Detection and Repair' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Hoppity: Learning Bug Detection and Repair' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Elizabeth Dinella, Hanjun Dai, Ziyang Li, Mayur Naik, Le Song, Ke Wang</td>
	<td>ICLR</td>
	<td><p>We present a learning-based approach to detect and fix a broad range of bugs in Javascript programs. We frame the problem in terms of learning a sequence of graph transformations: given a buggy program modeled by a graph structure, our model makes a sequence of predictions including the position of bug nodes and corresponding graph edits to produce a fix. Unlike previous works that use deep neural networks, our approach targets bugs that are more complex and semantic in nature (i.e.~bugs that require adding or deleting statements to fix). We have realized our approach in a tool called HOPPITY. By training on 338,877 Javascript code change commits on Github, HOPPITY correctly detects and fixes bugs in 9,612 out of 42,365 programs in an end-to-end fashion. Given the bug location and type of the fix, HOPPITY also outperforms the baseline approach by a wide margin.</p>
</td>
	<td>edit repair </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/devanbu2020deep/">Deep Learning & Software Engineering: State of Research and Future Directions</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Learning & Software Engineering: State of Research and Future Directions' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Learning & Software Engineering: State of Research and Future Directions' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Prem Devanbu, Matthew Dwyer, Sebastian Elbaum, Michael Lowry, Kevin Moran, Denys Poshyvanyk, Baishakhi Ray, Rishabh Singh, Xiangyu Zhang</td>
	<td></td>
	<td><p>Given the current transformative potential of research that sits at the intersection of Deep Learning (DL) and Software Engineering (SE), an NSF-sponsored community workshop was conducted in co-location with the 34th IEEE/ACM International Conference on Automated Software Engineering (ASE’19) in San Diego, California. The goal of this workshop was to outline high priority areas for cross-cutting research. While a multitude of exciting directions for future work were identified, this report provides a general summary of the research areas representing the areas of highest priority which were discussed at the workshop. The intent of this report is to serve as a potential roadmap to guide future work that sits at the intersection of SE &amp; DL.</p>
</td>
	<td>survey </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/ye2020misim/">MISIM: An End-to-End Neural Code Similarity System</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=MISIM: An End-to-End Neural Code Similarity System' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=MISIM: An End-to-End Neural Code Similarity System' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Fangke Ye, Shengtian Zhou, Anand Venkat, Ryan Marcus, Nesime Tatbul, Jesmin Jahan Tithi, Paul Petersen, Timothy Mattson, Tim Kraska, Pradeep Dubey, Vivek Sarkar, Justin Gottschlich</td>
	<td></td>
	<td><p>Code similarity systems are integral to a range of applications from code recommendation to automated construction of software tests and defect mitigation. In this paper, we present Machine Inferred Code Similarity (MISIM), a novel end-to-end code similarity system that consists of two core components. First, MISIM uses a novel context-aware similarity structure, which is designed to aid in lifting semantic meaning from code syntax. Second, MISIM provides a neural-based code similarity scoring system, which can be implemented with various neural network algorithms and topologies with learned parameters. We compare MISIM to three other state-of-the-art code similarity systems: (i) code2vec, (ii) Neural Code Comprehension, and (iii) Aroma. In our experimental evaluation across 45,780 programs, MISIM consistently outperformed all three systems, often by a large factor (upwards of 40.6x).</p>
</td>
	<td>code similarity </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/rabin2020demystifying/">Towards Demystifying Dimensions of Source Code Embeddings</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Towards Demystifying Dimensions of Source Code Embeddings' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Towards Demystifying Dimensions of Source Code Embeddings' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Md Rafiqul Islam Rabin, Arjun Mukherjee, Omprakash Gnawali, Mohammad Amin Alipour</td>
	<td>RL+SE&PL (Co-located with ESEC/FSE)</td>
	<td><p>Source code representations are key in applying machine learning techniques for processing and analyzing programs. A popular approach in representing source code is neural source code embeddings that represents programs with high-dimensional vectors computed by training deep neural networks on a large volume of programs. Although successful, there is little known about the contents of these vectors and their characteristics. In this paper, we present our preliminary results towards better understanding the contents of code2vec neural source code embeddings. In particular, in a small case study, we use the code2vec embeddings to create binary SVM classifiers and compare their performance with the handcrafted features. Our results suggest that the handcrafted features can perform very close to the highly-dimensional code2vec embeddings, and the information gains are more evenly distributed in the code2vec embeddings compared to the handcrafted features. We also find that the code2vec embeddings are more resilient to the removal of dimensions with low information gains than the handcrafted features. We hope our results serve a stepping stone toward principled analysis and evaluation of these code representations.</p>
</td>
	<td>evaluation representation naming interpretability </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/li2020learning/">Learning Code-Query Interaction for Enhancing Code Searches</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Code-Query Interaction for Enhancing Code Searches' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Code-Query Interaction for Enhancing Code Searches' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Wei Li, Haozhe Qin, Shuhan Yan, Beijun Shen, Yuting Chen</td>
	<td>ICSME</td>
	<td><p>Code search plays an important role in software development and maintenance. In recent years, deep learning (DL) has achieved a great success in this domain-several DL-based code search methods, such as DeepCS and UNIF, have been proposed for exploring deep, semantic correlations between code and queries; each method usually embeds source code and natural language queries into real vectors followed by computing their vector distances representing their semantic correlations. Meanwhile, deep learning-based code search still suffers from three main problems, i.e., the OOV (Out of Vocabulary) problem, the independent similarity matching problem, and the small training dataset problem. To tackle the above problems, we propose CQIL, a novel, deep learning-based code search method. CQIL learns code-query interactions and uses a CNN (Convolutional Neural Network) to compute semantic correlations between queries and code snippets. In particular, CQIL employs a hybrid representation to model code-query correlations, which solves the OOV problem. CQIL also deeply learns the code-query interaction for enhancing code searches, which solves the independent similarity matching and the small training dataset problems. We evaluate CQIL on two datasets (CODEnn and CosBench). The evaluation results show the strengths of CQIL-it achieves the MAP@1 values, 0.694 and 0.574, on CODEnn and CosBench, respectively. In particular, it outperforms DeepCS and UNIF, two state-of-the-art code search methods, by 13.6% and 18.1% in MRR, respectively, when the training dataset is insufficient.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/li2020dlfix/">DLFix: Context-based Code Transformation Learning for Automated Program Repair</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DLFix: Context-based Code Transformation Learning for Automated Program Repair' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DLFix: Context-based Code Transformation Learning for Automated Program Repair' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yi Li, Shaohua Wang, Tien N. Nguyen</td>
	<td>ICSE</td>
	<td><p>Automated Program Repair (APR) is very useful in helping developers in the process of software development and maintenance. Despite recent advances in deep learning (DL), the DL-based APR approaches still have limitations in learning bug-fixing code changes and the context of the surrounding source code of the bug-fixing code changes. These limitations lead to incorrect fixing locations or fixes. In this paper, we introduce DLFix, a two-tier DL model that treats APR as code transformation learning from the prior bug fixes and the surrounding code contexts of the fixes. The first layer is a tree-based RNN model that learns the contexts of bug fixes and its result is used as an additional weighting input for the second layer designed to learn the bug-fixing code transformations.</p>

<p>We conducted several experiments to evaluate DLFix in two benchmarks: Defect4J and Bugs.jar, and a newly built bug datasets with a total of +20K real-world bugs in eight projects. We compared DLFix against a total of 13 state-of-the-art pattern-based APR tools. Our results show that DLFix can auto-fix more bugs than 11 of them, and is comparable and complementary to the top two pattern-based APR tools in which there are 7 and 11 unique bugs that they cannot detect, respectively, but we can. Importantly, DLFix is fully automated and data-driven, and does not require hard-coding of bug-fixing patterns as in those tools. We compared DLFix against 4 state-of-the-art deep learning based APR models. DLFix is able to fix 2.5 times more bugs than the best performing~baseline.</p>
</td>
	<td>edit repair grammar </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/lee2020montage/">Montage: A Neural Network Language Model-Guided JavaScript Engine Fuzzer</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Montage: A Neural Network Language Model-Guided JavaScript Engine Fuzzer' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Montage: A Neural Network Language Model-Guided JavaScript Engine Fuzzer' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Suyoung Lee, HyungSeok Han, Sang Kil Cha, Sooel Son</td>
	<td>USENIX</td>
	<td><p>JavaScript (JS) engine vulnerabilities pose significant security threats affecting billions of web browsers. While fuzzing is a prevalent technique for finding such vulnerabilities, there have been few studies that leverage the recent advances in neural network language models (NNLMs). In this paper, we present Montage, the first NNLM-guided fuzzer for finding JS engine vulnerabilities. The key aspect of our technique is to transform a JS abstract syntax tree (AST) into a sequence of AST subtrees that can directly train prevailing NNLMs. We demonstrate that Montage is capable of generating valid JS tests, and show that it outperforms previous studies in terms of finding vulnerabilities. Montage found 37 real-world bugs, including three CVEs, in the latest JS engines, demonstrating its efficacy in finding JS engine bugs.</p>
</td>
	<td>fuzzing language model </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/leclair2020improved/">Improved Code Summarization via a Graph Neural Network</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Improved Code Summarization via a Graph Neural Network' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Improved Code Summarization via a Graph Neural Network' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Alexander LeClair, Sakib Haque, Lingfei Wu, Collin McMillan</td>
	<td></td>
	<td><p>Automatic source code summarization is the task of generating natural language descriptions for source code. Automatic code summarization is a rapidly expanding research area, especially as the community has taken greater advantage of advances in neural network and AI technologies. In general, source code summarization techniques use the source code as input and outputs a natural language description. Yet a strong consensus is developing that using structural information as input leads to improved performance. The first approaches to use structural information flattened the AST into a sequence. Recently, more complex approaches based on random AST paths or graph neural networks have improved on the models using flattened ASTs. However, the literature still does not describe the using a graph neural network together with source code sequence as separate inputs to a model. Therefore, in this paper, we present an approach that uses a graph-based neural architecture that better matches the default structure of the AST to generate these summaries. We evaluate our technique using a data set of 2.1 million Java method-comment pairs and show improvement over four baseline techniques, two from the software engineering literature, and two from machine learning literature.</p>
</td>
	<td>summarization </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/kurbatova2020recommendation/">Recommendation of Move Method Refactoring Using Path-Based Representation of Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Recommendation of Move Method Refactoring Using Path-Based Representation of Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Recommendation of Move Method Refactoring Using Path-Based Representation of Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zarina Kurbatova, Ivan Veselov, Yaroslav Golubev, Timofey Bryksin</td>
	<td></td>
	<td><p>Software refactoring plays an important role in increasing code quality. One of the most popular refactoring types is the Move Method refactoring. It is usually applied when a method depends more on members of other classes than on its own original class. Several approaches have been proposed to recommend Move Method refactoring automatically. Most of them are based on heuristics and have certain limitations (e.g., they depend on the selection of metrics and manually-defined thresholds). In this paper, we propose an approach to recommend Move Method refactoring based on a path-based representation of code called code2vec that is able to capture the syntactic structure and semantic information of a code fragment. We use this code representation to train a machine learning classifier suggesting to move methods to more appropriate classes. We evaluate the approach on two publicly available datasets: a manually compiled dataset of well-known open-source projects and a synthetic dataset with automatically injected code smell instances. The results show that our approach is capable of recommending accurate refactoring opportunities and outperforms JDeodorant and JMove, which are state of the art tools in this field.</p>
</td>
	<td>refactoring </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/lachaux2020unsupervised/">Unsupervised Translation of Programming Languages</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Unsupervised Translation of Programming Languages' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Unsupervised Translation of Programming Languages' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Marie-Anne Lachaux, Baptiste Roziere, Lowik Chanussot, Guillaume Lample</td>
	<td></td>
	<td><p>A transcompiler, also known as source-to-source translator, is a system that converts source code from a high-level programming language (such as C++ or Python) to another. Transcompilers are primarily used for interoperability, and to port codebases written in an obsolete or deprecated language (e.g. COBOL, Python 2) to a modern one. They typically rely on handcrafted rewrite rules, applied to the source code abstract syntax tree. Unfortunately, the resulting translations often lack readability, fail to respect the target language conventions, and require manual modifications in order to work properly. The overall translation process is timeconsuming and requires expertise in both the source and target languages, making code-translation projects expensive. Although neural models significantly outperform their rule-based counterparts in the context of natural language translation, their applications to transcompilation have been limited due to the scarcity of parallel data in this domain. In this paper, we propose to leverage recent approaches in unsupervised machine translation to train a fully unsupervised neural transcompiler. We train our model on source code from open source GitHub projects, and show that it can translate functions between C++, Java, and Python with high accuracy. Our method relies exclusively on monolingual source code, requires no expertise in the source or target languages, and can easily be generalized to other programming languages. We also build and release a test set composed of 852 parallel functions, along with unit tests to check the correctness of translations. We show that our model outperforms rule-based commercial baselines by a significant margin.</p>
</td>
	<td>migration </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/svyatkovskiy2020fast/">Fast and Memory-Efficient Neural Code Completion</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Fast and Memory-Efficient Neural Code Completion' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Fast and Memory-Efficient Neural Code Completion' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Alexey Svyatkovskiy, Sebastian Lee, Anna Hadjitofi, Maik Riechert, Juliana Franco, Miltiadis Allamanis</td>
	<td></td>
	<td><p>Code completion is one of the most widely used features of modern integrated development environments (IDEs). Deep learning has recently made significant progress in the statistical prediction of source code. However, state-of-the-art neural network models consume prohibitively large amounts of memory, causing computational burden to the development environment, especially when deployed in lightweight client devices.</p>

<p>In this work, we reframe neural code completion from a generation task to a task of learning to rank the valid completion suggestions computed from static analyses. By doing so, we are able to design and test a variety of deep neural network model configurations. One of our best models consumes 6 MB of RAM, computes a single suggestion in 8 ms, and achieves 90% recall in its top five suggestions. Our models outperform standard language modeling code completion techniques in terms of predictive performance, computational speed, and memory efficiency. Furthermore, they learn about code semantics from the natural language aspects of the code (e.g. identifier names) and can generalize better to previously unseen code.</p>
</td>
	<td>autocomplete </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/panthaplackel2020copy/">Copy that! Editing Sequences by Copying Spans</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Copy that! Editing Sequences by Copying Spans' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Copy that! Editing Sequences by Copying Spans' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sheena Panthaplackel, Miltiadis Allamanis, Marc Brockschmidt</td>
	<td></td>
	<td><p>Neural sequence-to-sequence models are finding increasing use in editing of documents, for example in correcting a text document or repairing source code. In this paper, we argue that common seq2seq models (with a facility to copy single tokens) are not a natural fit for such tasks, as they have to explicitly copy each unchanged token. We present an extension of seq2seq models capable of copying entire spans of the input to the output in one step, greatly reducing the number of decisions required during inference. This extension means that there are now many ways of generating the same output, which we handle by deriving a new objective for training and a variation of beam search for inference that explicitly handle this problem.</p>

<p>In our experiments on a range of editing tasks of natural language and source code, we show that our new model consistently outperforms simpler baselines.</p>
</td>
	<td>edit </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/panthaplackel2020learning/">Learning to Update Natural Language Comments Based on Code Changes</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Update Natural Language Comments Based on Code Changes' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Update Natural Language Comments Based on Code Changes' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sheena Panthaplackel, Pengyu Nie, Milos Gligoric, Raymond J. Mooney, Junyi Jessy Li</td>
	<td>ACL</td>
	<td><p>We formulate the novel task of automatically updating an existing natural language comment based on changes in the body of code it accompanies. We propose an approach that learns to correlate changes across two distinct language representations, to generate a sequence of edits that are applied to the existing comment to reflect the source code modifications. We train and evaluate our model using a dataset that we collected from commit histories of open-source software projects, with each example consisting of a concurrent update to a method and its corresponding comment. We compare our approach against multiple baselines using both automatic metrics and human evaluation. Results reflect the challenge of this task and that our model outperforms baselines with respect to making edits.</p>
</td>
	<td>bimodal edit documentation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/kim2020code/">Code Prediction by Feeding Trees to Transformers</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Code Prediction by Feeding Trees to Transformers' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Code Prediction by Feeding Trees to Transformers' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Seohyun Kim, Jinman Zhao, Yuchi Tian, Satish Chandra</td>
	<td></td>
	<td><p>In this paper, we describe how to leverage Transformer, a recent neural architecture for learning from sequential data (such as text), for code completion. As in the realm of natural language processing, Transformers surpass the prediction accuracy achievable by RNNs; we provide an experimental confirmation of this over a Python dataset.</p>

<p>Furthermore, we show that the way to obtain even better accuracy from Transformers is to expose the syntactic structure of code, which is easily recovered by parsing, to the neural network. This works significantly better than presenting the code as a linear token sequence, which is how Transformers were originally intended to be used.</p>

<p>To accomplish this, we propose a novel enhancement to the self-attention mechanism of the Transformer. We enable the mechanism to learn weights—that is, how much to focus on each preceding token in the input—not only on the basis of a token’s value, but also on the basis of the spatial relationships, as in their positions in the abstract syntax tree, between each pair of tokens.</p>

<p>We provide comprehensive experimental evaluation of our proposal, along with alternative design choices, on a standard Python dataset, as well as on a Python corpus internal to Facebook.</p>
</td>
	<td>autocomplete </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/tian2020evaluating/">Evaluating Representation Learning of Code Changes for Predicting Patch Correctness in Program Repair</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Evaluating Representation Learning of Code Changes for Predicting Patch Correctness in Program Repair' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Evaluating Representation Learning of Code Changes for Predicting Patch Correctness in Program Repair' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Haoye Tian, Kui Liu, Abdoul Kader Kaboreé, Anil Koyuncu, Li Li, Jacques Klein, Tegawendé F. Bissyandé</td>
	<td></td>
	<td><p>A large body of the literature of automated program repair develops approaches where patches are generated to be validated against an oracle (e.g., a test suite). Because such an oracle can be imperfect, the generated patches, although validated by the oracle, may actually be incorrect. While the state of the art explore research directions that require dynamic information or rely on manually-crafted heuristics, we study the benefit of learning code representations to learn deep features that may encode the properties of patch correctness. Our work mainly investigates different representation learning approaches for code changes to derive embeddings that are amenable to similarity computations. We report on findings based on embeddings produced by pre-trained and re-trained neural networks. Experimental results demonstrate the potential of embeddings to empower learning algorithms in reasoning about patch correctness: a machine learning predictor with BERT transformer-based embeddings associated with logistic regression yielded an AUC value of about 0.8 in predicting patch correctness on a deduplicated dataset of 1000 labeled patches. Our study shows that learned representations can lead to reasonable performance when comparing against the state-of-the-art, PATCH-SIM, which relies on dynamic information. These representations may further be complementary to features that were carefully (manually) engineered in the literature.</p>
</td>
	<td>repair Transformer </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/yasunaga2020graph/">Graph-based, Self-Supervised Program Repair from Diagnostic Feedback</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Graph-based, Self-Supervised Program Repair from Diagnostic Feedback' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Graph-based, Self-Supervised Program Repair from Diagnostic Feedback' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Michihiro Yasunaga, Percy Liang</td>
	<td></td>
	<td><p>We consider the problem of learning to repair programs from diagnostic feedback (e.g., compiler error messages). Program repair is challenging for two reasons: First, it requires reasoning and tracking symbols across source code and diagnostic feedback. Second, labeled datasets available for program repair are relatively small. In this work, we propose novel solutions to these two challenges. First, we introduce a program-feedback graph, which connects symbols relevant to program repair in source code and diagnostic feedback, and then apply a graph neural network on top to model the reasoning process. Second, we present a self-supervised learning paradigm for program repair that leverages unlabeled programs available online to create a large amount of extra program repair examples, which we use to pre-train our models. We evaluate our proposed approach on two applications: correcting introductory programming assignments (DeepFix dataset) and correcting the outputs of program synthesis (SPoC dataset). Our final system, DrRepair, significantly outperforms prior work, achieving 66.1% full repair rate on DeepFix (+20.8% over the prior best), and 48.0% synthesis success rate on SPoC (+3.3% over the prior best).</p>
</td>
	<td>repair edit GNN </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/karampatsis2020big/">Big Code != Big Vocabulary: Open-Vocabulary Models for Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Big Code != Big Vocabulary: Open-Vocabulary Models for Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Big Code != Big Vocabulary: Open-Vocabulary Models for Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rafael-Michael Karampatsis, Hlib Babii, Romain Robbes Charles Sutton, Andrea Janes</td>
	<td>ICSE</td>
	<td><p>Statistical language modeling techniques have successfully been applied to large source code corpora, yielding a variety of new software development tools, such as tools for code suggestion, improving readability, and API migration. A major issue with these techniques is that code introduces new vocabulary at a far higher rate than natural language, as new identifier names proliferate. Both large vocabularies and out-of-vocabulary issues severely affect Neural Language Models (NLMs) of source code, degrading their performance and rendering them unable to scale. In this paper, we address this issue by: 1) studying how various modelling choices impact the resulting vocabulary on a large-scale corpus of 13,362 projects; 2) presenting an open vocabulary source code NLM that can scale to such a corpus, 100 times larger than in previous work; and 3) showing that such models outperform the state of the art on three distinct code corpora (Java, C, Python). To our knowledge, these are the largest NLMs for code that have been reported.</p>
</td>
	<td>language model </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/karampatsis2020scelmo/">SCELMo: Source Code Embeddings from Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=SCELMo: Source Code Embeddings from Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=SCELMo: Source Code Embeddings from Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rafael-Michael Karampatsis, Charles Sutton</td>
	<td></td>
	<td><p>Continuous embeddings of tokens in computer programs have been used to support a variety of software development tools, including readability, code search, and program repair. Contextual embeddings are common in natural language processing but have not been previously applied in software engineering. We introduce a new set of deep contextualized word representations for computer programs based on language models. We train a set of embeddings using the ELMo (embeddings from language models) framework of Peters et al (2018). We investigate whether these embeddings are effective when fine-tuned for the downstream task of bug detection. We show that even a low-dimensional embedding trained on a relatively small corpus of programs can improve a state-of-the-art machine learning system for bug detection.</p>
</td>
	<td>pretraining defect </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/tabassum2020code/">Code and Named Entity Recognition in StackOverflow</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Code and Named Entity Recognition in StackOverflow' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Code and Named Entity Recognition in StackOverflow' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jeniya Tabassum, Mounica Maddela, Wei Xu, Alan Ritter</td>
	<td>ACL</td>
	<td><p>There is an increasing interest in studying natural language and computer code together, as large corpora of programming texts become readily available on the Internet. For example, StackOverflow currently has over 15 million programming related questions written by 8.5 million users. Meanwhile, there is still a lack of fundamental NLP techniques for identifying code tokens or software-related named entities that appear within natural language sentences. In this paper, we introduce a new named entity recognition (NER) corpus for the computer programming domain, consisting of 15,372 sentences annotated with 20 fine-grained entity types. We trained in-domain BERT representations (BERTOverflow) on 152 million sentences from StackOverflow, which lead to an absolute increase of +10 F-1 score over off-the-shelf BERT. We also present the SoftNER model which achieves an overall 79.10 F1 score for code and named entity recognition on StackOverflow data. Our SoftNER model incorporates a context-independent code token classifier with corpus-level features to improve the BERT-based tagging model.</p>
</td>
	<td>dataset information extraction </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/johnson2020learning/">Learning Graph Structure With A Finite-State Automaton Layer</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Graph Structure With A Finite-State Automaton Layer' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Graph Structure With A Finite-State Automaton Layer' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Daniel D. Johnson, Hugo Larochelle, Daniel Tarlow</td>
	<td></td>
	<td><p>Graph-based neural network models are producing strong results in a number of domains, in part because graphs provide flexibility to encode domain knowledge in the form of relational structure (edges) between nodes in the graph. In practice, edges are used both to represent intrinsic structure (e.g., abstract syntax trees of programs) and more abstract relations that aid reasoning for a downstream task (e.g., results of relevant program analyses). In this work, we study the problem of learning to derive abstract relations from the intrinsic graph structure. Motivated by their power in program analyses, we consider relations defined by paths on the base graph accepted by a finite-state automaton. We show how to learn these relations end-to-end by relaxing the problem into learning finite-state automata policies on a graph-based POMDP and then training these policies using implicit differentiation. The result is a differentiable Graph Finite-State Automaton (GFSA) layer that adds a new edge type (expressed as a weighted adjacency matrix) to a base graph. We demonstrate that this layer can find shortcuts in grid-world graphs and reproduce simple static analyses on Python programs. Additionally, we combine the GFSA layer with a larger graph-based model trained end-to-end on the variable misuse program understanding task, and find that using the GFSA layer leads to better performance than using hand-engineered semantic edges or other baseline methods for adding learned edge types.</p>
</td>
	<td>GNN program analysis </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/kanade2020pretrained/">Pre-trained Contextual Embedding of Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Pre-trained Contextual Embedding of Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Pre-trained Contextual Embedding of Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Aditya Kanade, Petros Maniatis, Gogul Balakrishnan, Kensen Shi</td>
	<td>ICML</td>
	<td><p>The source code of a program not only serves as a formal description of an executable task, but it also serves to communicate developer intent in a human-readable form. To facilitate this, developers use meaningful identifier names and natural-language documentation. This makes it possible to successfully apply sequence-modeling approaches, shown to be effective in natural-language processing, to source code. A major advancement in natural-language understanding has been the use of pre-trained token embeddings; BERT and other works have further shown that pre-trained contextual embeddings can be extremely powerful and can be fine-tuned effectively for a variety of downstream supervised tasks. Inspired by these developments, we present the first attempt to replicate this success on source code. We curate a massive corpus of Python programs from GitHub to pre-train a BERT model, which we call Code Understanding BERT (CuBERT). We also pre-train Word2Vec embeddings on the same dataset. We create a benchmark of five classification tasks and compare fine-tuned CuBERT against sequence models trained with and without the Word2Vec embeddings. Our results show that CuBERT outperforms the baseline methods by a margin of 2.9-22%. We also show its superiority when fine-tuned with smaller datasets, and over fewer epochs. We further evaluate CuBERT’s effectiveness on a joint classification, localization and repair task involving prediction of two pointers.</p>
</td>
	<td>pretraining </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/zhu2020ocor/">OCoR: An Overlapping-Aware Code Retriever</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=OCoR: An Overlapping-Aware Code Retriever' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=OCoR: An Overlapping-Aware Code Retriever' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Qihao Zhu, Zeyu Sun, Xiran Liang, Yingfei Xiong, Lu Zhang</td>
	<td>ASE</td>
	<td><p>Code retrieval helps developers reuse the code snippet in the open-source projects. Given a natural language description, code retrieval aims to search for the most relevant code among a set of code. Existing state-of-the-art approaches apply neural networks to code retrieval. However, these approaches still fail to capture an important feature: overlaps. The overlaps between different names used by different people indicate that two different names may be potentially related (e.g., “message” and “msg”), and the overlaps between identifiers in code and words in natural language descriptions indicate that the code snippet and the description may potentially be related. To address these problems, we propose a novel neural architecture named OCoR, where we introduce two specifically-designed components to capture overlaps: the first embeds identifiers by character to capture the overlaps between identifiers, and the second introduces a novel overlap matrix to represent the degrees of overlaps between each natural language word and each identifier.
The evaluation was conducted on two established datasets. The experimental results show that OCoR significantly outperforms the existing state-of-the-art approaches and achieves 13.1% to 22.3% improvements. Moreover, we also conducted several in-depth experiments to help understand the performance of different components in OCoR.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/jain2020contrastive/">Contrastive Code Representation Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Contrastive Code Representation Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Contrastive Code Representation Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Paras Jain, Ajay Jain, Tianjun Zhang, Pieter Abbeel, Joseph E. Gonzalez, Ion Stoica</td>
	<td></td>
	<td><p>Machine-aided programming tools such as type predictors and code summarizers
are increasingly learning-based. However, most code representation learning approaches rely on supervised learning with task-specific annotated datasets. We propose Contrastive Code Representation Learning (ContraCode), a self-supervised
algorithm for learning task-agnostic semantic representations of programs via contrastive learning. Our approach uses no human-provided labels, relying only on
the raw text of programs. In particular, we design an unsupervised pretext task by
generating textually divergent copies of source functions via automated source-tosource compiler transforms that preserve semantics. We train a neural model to
identify variants of an anchor program within a large batch of negatives. To solve
this task, the network must extract program features representing the functionality,
not form, of the program. This is the first application of instance discrimination
to code representation learning to our knowledge. We pre-train models over 1.8m
unannotated JavaScript methods mined from GitHub. ContraCode pre-training
improves code summarization accuracy by 7.9% over supervised approaches and
4.8% over RoBERTa pre-training. Moreover, our approach is agnostic to model architecture; for a type inference task, contrastive pre-training consistently improves
the accuracy of existing baselines.</p>
</td>
	<td>representation pretraining </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/hoang2020cc2vec/">CC2Vec: Distributed Representations of Code Changes</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CC2Vec: Distributed Representations of Code Changes' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CC2Vec: Distributed Representations of Code Changes' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Thong Hoang, Hong Jin Kang, Julia Lawall, David Lo</td>
	<td>ICSE</td>
	<td><p>Existing work on software patches often use features specific to a single task. These works often rely on manually identified features, and human effort is required to identify these features for each task. In this work, we propose CC2Vec, a neural network model that learns a representation of code changes guided by their accompanying log messages, which represent the semantic intent of the code changes. CC2Vec models the hierarchical structure of a code change with the help of the attention mechanism and uses multiple comparison functions to identify the differences between the removed and added code.</p>

<p>To evaluate if CC2Vec can produce a distributed representation of code changes that is general and useful for multiple tasks on software patches, we use the vectors produced by CC2Vec for three tasks: log message generation, bug fixing patch identification, and just-in-time defect prediction. In all tasks, the models using CC2Vec outperform the state-of-the-art techniques.</p>
</td>
	<td>edit </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/svyatkovskiy2020intellicode/">IntelliCode Compose: Code Generation Using Transformer</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=IntelliCode Compose: Code Generation Using Transformer' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=IntelliCode Compose: Code Generation Using Transformer' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Alexey Svyatkovskiy, Shao Kun Deng, Shengyu Fu, Neel Sundaresan</td>
	<td></td>
	<td><p>In software development through integrated development environments (IDEs), code completion is one of the most widely used features. Nevertheless, majority of integrated development environments only support completion of methods and APIs, or arguments.
In this paper, we introduce IntelliCode Compose − a general-purpose multilingual code completion tool which is capable of predicting sequences of code tokens of arbitrary types, generating up to entire lines of syntactically correct code. It leverages state-of-the-art generative transformer model trained on 1.2 billion lines of source code in Python, C#, JavaScript and TypeScript programming languages. IntelliCode Compose is deployed as a cloud-based web service. It makes use of client-side tree-based caching, efficient parallel implementation of the beam search decoder, and compute graph optimizations to meet edit-time completion suggestion requirements in the Visual Studio Code IDE and Azure Notebook.
Our best model yields an average edit similarity of 86.7% and a perplexity of 1.82 for Python programming language.</p>
</td>
	<td>autocomplete code generation synthesis language model pretraining </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/louis2020where/">Where should I comment my code? A dataset and model for predicting locations that need comments</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Where should I comment my code? A dataset and model for predicting locations that need comments' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Where should I comment my code? A dataset and model for predicting locations that need comments' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Annie Louis, Santanu Kumar Dash, Earl T. Barr, Charles Sutton</td>
	<td>International Conference on Software Engineering (ICSE; NIER track)</td>
	<td><p>Programmers should write code comments, but not on every line
of code. We have created a machine learning model that suggests
locations where a programmer should write a code comment. We
trained it on existing commented code to learn locations that are
chosen by developers. Once trained, the model can predict locations
in new code. Our models achieved precision of 74% and recall of
13% in identifying comment-worthy locations. This first success
opens the door to future work, both in the new where-to-comment
problem and in guiding comment generation.</p>
</td>
	<td>bimodal documentation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/liu2020automating/">Automating Just-In-Time Comment Updating</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Automating Just-In-Time Comment Updating' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Automating Just-In-Time Comment Updating' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zhongxin Liu, Xin Xia, Meng Yan, Shanping Li</td>
	<td>ASE</td>
	<td><p>Code comments are valuable for program comprehension and software maintenance, and also require maintenance with code evolution. However, when changing code, developers sometimes neglect updating the related comments, bringing in inconsistent or obsolete comments (aka., bad comments). Such comments are detrimental since they may mislead developers and lead to future bugs. Therefore, it is necessary to fix and avoid bad comments. In this work, we argue that bad comments can be reduced and even avoided by automatically performing comment updates with code changes. We refer to this task as “Just-In-Time (JIT) Comment Updating” and propose an approach named CUP (Comment UPdater) to automate this task. CUP can be used to assist developers in updating comments during code changes and can consequently help avoid the introduction of bad comments. Specifically, CUP leverages a novel neural sequence-to-sequence model to learn comment update patterns from extant code-comment co-changes and can automatically generate a new comment based on its corresponding old comment and code change. Several customized enhancements, such as a special tokenizer and a novel co-attention mechanism, are introduced in CUP by us to handle the characteristics of this task. We build a dataset with over 108K comment-code co-change samples and evaluate CUP on it. The evaluation results show that CUP outperforms an information-retrieval-based and a rule-based baselines by substantial margins, and can reduce developers’ edits required for JIT comment updating. In addition, the comments generated by our approach are identical to those updated by developers in 1612 (16.7%) test samples, 7 times more than the best-performing baseline.</p>
</td>
	<td>documentation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/ling2020adaptive/">Adaptive Deep Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Adaptive Deep Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Adaptive Deep Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Chunyang Ling, Zeqi Lin, Yanzhen Zou, Bing Xie</td>
	<td>ICPC</td>
	<td><p>Searching code in a large-scale codebase using natural language queries is a common practice during software development. Deep learning-based code search methods demonstrate superior performance if models are trained with large amount of text-code pairs. However, few deep code search models can be easily transferred from one codebase to another. It can be very costly to prepare training data for a new codebase and re-train an appropriate deep learning model. In this paper, we propose AdaCS, an adaptive deep code search method that can be trained once and transferred to new codebases. AdaCS decomposes the learning process into embedding domain-specific words and matching general syntactic patterns. Firstly, an unsupervised word embedding technique is used to construct a matching matrix to represent the lexical similarities. Then, a recurrent neural network is used to capture latent syntactic patterns from these matching matrices in a supervised way. As the supervised task learns general syntactic patterns that exist across domains, AdaCS is transferable to new codebases. Experimental results show that: when extended to new software projects never seen in the training data, AdaCS is more robust and significantly outperforms state-of-the-art deep code search methods.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/ling2020deep/">Deep Graph Matching and Searching for Semantic Code Retrieval</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Graph Matching and Searching for Semantic Code Retrieval' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Graph Matching and Searching for Semantic Code Retrieval' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xiang Ling, Lingfei Wu, Saizhuo Wang, Gaoning Pan, Tengfei Ma, Fangli Xu, Alex X. Liu, Chunming Wu, Shouling Ji</td>
	<td>TKDD</td>
	<td><p>Code retrieval is to find the code snippet from a large corpus of source code repositories that highly matches the query of natural language description. Recent work mainly uses natural language processing techniques to process both query texts (i.e., human natural language) and code snippets (i.e., machine programming language), however neglecting the deep structured features of query texts and source codes, both of which contain rich semantic information. In this paper, we propose an end-to-end deep graph matching and searching (DGMS) model based on graph neural networks for the task of semantic code retrieval. To this end, we first represent both natural language query texts and programming language code snippets with the unified graph-structured data, and then use the proposed graph matching and searching model to retrieve the best matching code snippet. In particular, DGMS not only captures more structural information for individual query texts or code snippets but also learns the fine-grained similarity between them by cross-attention based semantic matching operations. We evaluate the proposed DGMS model on two public code retrieval datasets with two representative programming languages (i.e., Java and Python). Experiment results demonstrate that DGMS significantly outperforms state-of-the-art baseline models by a large margin on both datasets. Moreover, our extensive ablation studies systematically investigate and illustrate the impact of each part of DGMS.</p>
</td>
	<td>search GNN </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/zhang2020generating/">Generating Adversarial Examples for Holding Robustness of Source Code Processing Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Generating Adversarial Examples for Holding Robustness of Source Code Processing Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Generating Adversarial Examples for Holding Robustness of Source Code Processing Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Huangzhao Zhang, Zhuo Li, Ge Li, Lei Ma, Yang Liu, Zhi Jin</td>
	<td>AAAI</td>
	<td><p>Automated  processing,  analysis,  and  generation  of  source code are among the key activities
in software and system life-cycle. To this end, while deep learning (DL) exhibits a certain level
of capability in handling these tasks, the current state-of-the-art DL models still suffer from
non-robust issues and can be easily fooled by adversarial attacks.</p>

<p>Different  from  adversarial 
attacks  for  image,  audio,  andnatural  languages,  the  structured  nature  of  programming
languages  brings  new  challenges.  In  this  paper,  we  propose a Metropolis-Hastings
sampling-based identifier renaming technique, named Metropolis-Hastings Modifier (MHM),
which  generates  adversarial  examples  for  DL  models  specialized for source code processing.
Our in-depth evaluation on a functionality classification benchmark demonstrates the
effectiveness  of  MHM  in  generating  adversarial  examples of source code. The higher robustness
and performance enhanced through our  adversarial training with MHM further confirms the usefulness
of DL models-based method for future fully automated source code processing.</p>
</td>
	<td>adversarial </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/wan2020naturalcc/">NaturalCC: A Toolkit to Naturalize the Source Code Corpus</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=NaturalCC: A Toolkit to Naturalize the Source Code Corpus' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=NaturalCC: A Toolkit to Naturalize the Source Code Corpus' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yao Wan, Yang He, Jian-Guo Zhang, Yulei Sui, Hai Jin, Guandong Xu, Caiming Xiong, Philip S. Yu</td>
	<td></td>
	<td><p>We present NaturalCC, an efficient and extensible toolkit to bridge the gap between natural language and programming language, and facilitate the research on big code analysis. Using NaturalCC, researchers both from natural language or programming language communities can quickly and easily reproduce the state-of-the-art baselines and implement their approach. NaturalCC is built upon Fairseq and PyTorch, providing (1) an efficient computation with multi-GPU and mixed-precision data processing for fast model training, (2) a modular and extensible framework that makes it easy to reproduce or implement an approach for big code analysis, and (3) a command line interface and a graphical user interface to demonstrate each model’s performance. Currently, we have included several state-of-the-art baselines across different tasks (e.g., code completion, code comment generation, and code retrieval) for demonstration. The video of this demo is available at https://www.youtube.com/watch?v=q4W5VSI-u3E&amp;t=25s.</p>
</td>
	<td>documentation search summarization </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/mammadli2020static/">Static Neural Compiler Optimization via Deep Reinforcement Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Static Neural Compiler Optimization via Deep Reinforcement Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Static Neural Compiler Optimization via Deep Reinforcement Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rahim Mammadli, Ali Jannesari, Felix Wolf</td>
	<td></td>
	<td><p>The phase-ordering problem of modern compilers has received a lot of attention from the research community over the years, yet remains largely unsolved. Various optimization sequences exposed to the user are manually designed by compiler developers. In designing such a sequence developers have to choose the set of optimization passes, their parameters and ordering within a sequence. Resulting sequences usually fall short of achieving optimal runtime for a given source code and may sometimes even degrade the performance when compared to unoptimized version. In this paper, we employ a deep reinforcement learning approach to the phase-ordering problem. Provided with sub-sequences constituting LLVM’s O3 sequence, our agent learns to outperform the O3 sequence on the set of source codes used for training and achieves competitive performance on the validation set, gaining up to 1.32x speedup on previously-unseen programs. Notably, our approach differs from autotuning methods by not depending on one or more test runs of the program for making successful optimization decisions. It has no dependence on any dynamic feature, but only on the statically-attainable intermediate representation of the source code. We believe that the models trained using our approach can be integrated into modern compilers as neural optimization agents, at first to complement, and eventually replace the hand-crafted optimization sequences.</p>
</td>
	<td>compilation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/mehrotra2020modeling/">Modeling Functional Similarity in Source Code with Graph-Based Siamese Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Modeling Functional Similarity in Source Code with Graph-Based Siamese Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Modeling Functional Similarity in Source Code with Graph-Based Siamese Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Nikita Mehrotra, Navdha Agarwal, Piyush Gupta, Saket Anand, David Lo, Rahul Purandare</td>
	<td></td>
	<td><p>Code clones are duplicate code fragments that share (nearly) similar syntax or semantics. Code clone detection plays an important role in software maintenance, code refactoring, and reuse. A substantial amount of research has been conducted in the past to detect clones. A majority of these approaches use lexical and syntactic information to detect clones. However, only a few of them target semantic clones. Recently, motivated by the success of deep learning models in other fields, including natural language processing and computer vision, researchers have attempted to adopt deep learning techniques to detect code clones. These approaches use lexical information (tokens) and(or) syntactic structures like abstract syntax trees (ASTs) to detect code clones. However, they do not make sufficient use of the available structural and semantic information hence, limiting their capabilities.</p>

<p>This paper addresses the problem of semantic code clone detection using program dependency graphs and geometric neural networks, leveraging the structured syntactic and semantic information. We have developed a prototype tool HOLMES, based on our novel approach, and empirically evaluated it on popular code clone benchmarks. Our results show that HOLMES performs considerably better than the other state-of-the-art tool, TBCCD. We also evaluated HOLMES on unseen projects and performed cross dataset experiments to assess the generalizability of HOLMES. Our results affirm that HOLMES outperforms TBCCD since most of the pairs that HOLMES detected were either undetected or suboptimally reported by TBCCD.</p>
</td>
	<td>clone GNN </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/panthaplackel2020deep/">Deep Just-In-Time Inconsistency Detection Between Comments and Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Just-In-Time Inconsistency Detection Between Comments and Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Just-In-Time Inconsistency Detection Between Comments and Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sheena Panthaplackel, Junyi Jessy Li, Milos Gligoric, Raymond J. Mooney</td>
	<td></td>
	<td><p>Natural language comments convey key aspects of source code such as implementation, usage, and pre- and post-conditions. Failure to update comments accordingly when the corresponding code is modified introduces inconsistencies, which is known to lead to confusion and software bugs. In this paper, we aim to detect whether a comment becomes inconsistent as a result of changes to the corresponding body of code, in order to catch potential inconsistencies just-in-time, i.e., before they are committed to a version control system. To achieve this, we develop a deep-learning approach that learns to correlate a comment with code changes. By evaluating on a large corpus of comment/code pairs spanning various comment types, we show that our model outperforms multiple baselines by significant margins. For extrinsic evaluation, we show the usefulness of our approach by combining it with a comment update model to build a more comprehensive automatic comment maintenance system which can both detect and resolve inconsistent comments based on code changes.</p>
</td>
	<td>edit bimodal documentation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/sun2020pscs/">PSCS: A Path-based Neural Model for Semantic Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=PSCS: A Path-based Neural Model for Semantic Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=PSCS: A Path-based Neural Model for Semantic Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zhensu Sun, Yan Liu, Chen Yang, Yu Qian</td>
	<td></td>
	<td><p>To obtain code snippets for reuse, programmers prefer to search for related documents, e.g., blogs or Q&amp;A, instead of code itself. The major reason is due to the semantic diversity and mismatch between queries and code snippets. Deep learning models have been proposed to address this challenge. Compared with approaches using information retrieval techniques, deep learning models do not suffer from the information loss caused by refining user intention into keywords. However, the performance of previous works is not satisfactory because they ignore the importance of code structure. When the semantics of code (e.g., identifier names, APIs) are ambiguous, code structure may be the only feature for the model to utilize. In that case, previous works relearn the structural information from lexical tokens of code, which is extremely difficult for a model without any domain knowledge. In this work, we propose PSCS, a path-based neural model for semantic code search. Our model encodes both the semantics and structures of code represented by AST paths. We train and evaluate our model over 330k-19k query-function pairs, respectively. The evaluation results demonstrate that PSCS achieves a SuccessRate of 47.6% and a Mean Reciprocal Rank (MRR) of 30.4% when considering the top-10 results with a match. The proposed approach significantly outperforms both DeepCS, the first approach that applies deep learning to code search task, and CARLCS, a state-of-the-art approach that introduces a co-attentive representation learning model on the basis of DeepCS. The importance of code structure is demonstrated with an ablation study on code features, which enlightens model design for further studies.</p>
</td>
	<td>grammar search </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/ye2020leveraging/">Leveraging Code Generation to Improve Code Retrieval and Summarization via Dual Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Leveraging Code Generation to Improve Code Retrieval and Summarization via Dual Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Leveraging Code Generation to Improve Code Retrieval and Summarization via Dual Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Wei Ye, Rui Xie, Jinglei Zhang, Tianxiang Hu, Xiaoyin Wang, Shikun Zhang</td>
	<td>WWW</td>
	<td><p>Code summarization generates brief natural language description given a source code snippet, while code retrieval fetches relevant source code given a natural language query. Since both tasks aim to model the association between natural language and programming language, recent studies have combined these two tasks to improve their performance. However, researchers have yet been able to effectively leverage the intrinsic connection between the two tasks as they train these tasks in a separate or pipeline manner, which means their performance can not be well balanced. In this paper, we propose a novel end-to-end model for the two tasks by introducing an additional code generation task. More specifically, we explicitly exploit the probabilistic correlation between code summarization and code generation with dual learning, and utilize the two encoders for code summarization and code generation to train the code retrieval task via multi-task learning. We have carried out extensive experiments on an existing dataset of SQL and Python, and results show that our model can significantly improve the results of the code retrieval task over the-state-of-art models, as well as achieve competitive performance in terms of BLEU score for the code summarization task.</p>
</td>
	<td>search summarization </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/mukherjee2020searching/">Searching a Database of Source Codes Using Contextualized Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Searching a Database of Source Codes Using Contextualized Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Searching a Database of Source Codes Using Contextualized Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rohan Mukherjee, Swarat Chaudhuri, Chris Jermaine</td>
	<td></td>
	<td><p>We assume a database containing a large set of program source codes and consider the problem of contextualized code search over that database. A programmer has written some part of a program, but has left part of the program (such as a method or a function body) incomplete. The goal is to use the context surrounding the missing code to automatically ‘figure out’ which of the codes in the database would be useful to the programmer in order to help complete the missing code, in the sense that the programmer could either re-purpose the retrieved code and use the re-purposed code to fill the missing spot in the program. Or, the user could use the retrieved code as a model for implementing the missing code. The search is ‘contextualized’ in the sense that the search engine should use clues in the partially-completed code to figure out which database code is most useful. The user should not be required to formulate an explicit query.</p>

<p>We cast contextualized code search as a learning problem, where the goal is to learn a distribution function computing the likelihood that each database code completes the program, and propose a neural model for predicting which database code is likely to be most useful. Because it will be prohibitively expensive to apply a neural model to each code in a database of millions or billions of codes at search time, one of our key technical concerns is ensuring a speedy search. We address this by learning a ‘reverse encoder’ that can be used to reduce the problem of evaluating each database code to computing a convolution of two normal distributions, making it possible to search a large database of codes in a reasonable time.</p>
</td>
	<td>search representation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/wei2020lambdanet/">LambdaNet: Probabilistic Type Inference using Graph Neural Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=LambdaNet: Probabilistic Type Inference using Graph Neural Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=LambdaNet: Probabilistic Type Inference using Graph Neural Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jiayi Wei, Maruth Goyal, Greg Durrett, Isil Dillig</td>
	<td>ICLR</td>
	<td><p>As gradual typing becomes increasingly popular in languages like Python and TypeScript, there is a growing need to infer type annotations automatically. While type annotations help with tasks like code completion and static error catching, these annotations cannot be fully inferred by compilers and are tedious to annotate by hand. This paper proposes a probabilistic type inference scheme for TypeScript based on a graph neural network. Our approach first uses lightweight source code analysis to generate a program abstraction called a type dependency graph, which links type variables with logical constraints as well as name and usage information. Given this program abstraction, we then use a graph neural network to propagate information between related type variables and eventually make type predictions. Our neural architecture can predict both standard types, like number or string, as well as user-defined types that have not been encountered during training. Our experimental results show that our approach outperforms prior work in this space by 14% (absolute) on library types, while having the ability to make type predictions that are out of scope for existing techniques.</p>
</td>
	<td>GNN types </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/cummins2020programl/">ProGraML: Graph-based Deep Learning for Program Optimization and Analysis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=ProGraML: Graph-based Deep Learning for Program Optimization and Analysis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=ProGraML: Graph-based Deep Learning for Program Optimization and Analysis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Chris Cummins, Zacharias V. Fisches, Tal Ben-Nun, Torsten Hoefler, Hugh Leather</td>
	<td></td>
	<td><p>The increasing complexity of computing systems places a tremendous burden on optimizing compilers, requiring ever more accurate and aggressive optimizations. Machine learning offers significant benefits for constructing optimization heuristics but there remains a gap between what state-of-the-art methods achieve and the performance of an optimal heuristic. Closing this gap requires improvements in two key areas: a representation that accurately captures the semantics of programs, and a model architecture with sufficient expressiveness to reason about this representation.</p>

<p>We introduce ProGraML - Program Graphs for Machine Learning - a novel graph-based program representation using a low level, language agnostic, and portable format; and machine learning models capable of performing complex downstream tasks over these graphs. The ProGraML representation is a directed attributed multigraph that captures control, data, and call relations, and summarizes instruction and operand types and ordering. Message Passing Neural Networks propagate information through this structured representation, enabling whole-program or per-vertex classification tasks.</p>

<p>ProGraML provides a general-purpose program representation that equips learnable models to perform the types of program analysis that are fundamental to optimization. To this end, we evaluate the performance of our approach first on a suite of traditional compiler analysis tasks: control flow reachability, dominator trees, data dependencies, variable liveness, and common subexpression detection. On a benchmark dataset of 250k LLVM-IR files covering six source programming languages, ProGraML achieves an average 94.0 F1 score, significantly outperforming the state-of-the-art approaches. We then apply our approach to two high-level tasks - heterogeneous device mapping and program classification - setting new state-of-the-art performance in both.</p>
</td>
	<td>dataset GNN </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/compton2020embedding/">Embedding Java Classes with code2vec: Improvements from Variable Obfuscation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Embedding Java Classes with code2vec: Improvements from Variable Obfuscation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Embedding Java Classes with code2vec: Improvements from Variable Obfuscation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rhys Compton, Eibe Frank, Panos Patros, Abigail Koay</td>
	<td>MSR</td>
	<td><p>Automatic source code analysis in key areas of software engineering, such as code security, can benefit from Machine Learning (ML). However, many standard ML approaches require a numeric representation of data and cannot be applied directly to source code. Thus, to enable ML, we need to embed source code into numeric feature vectors while maintaining the semantics of the code as much as possible. code2vec is a recently released embedding approach that uses the proxy task of method name prediction to map Java methods to feature vectors. However, experimentation with code2vec shows that it learns to rely on variable names for prediction, causing it to be easily fooled by typos or adversarial attacks. Moreover, it is only able to embed individual Java methods and cannot embed an entire collection of methods such as those present in a typical Java class, making it difficult to perform predictions at the class level (e.g., for the identification of malicious Java classes). Both shortcomings are addressed in the research presented in this paper. We investigate the effect of obfuscating variable names during the training of a code2vec model to force it to rely on the structure of the code rather than specific names and consider a simple approach to creating class-level embeddings by aggregating sets of method embeddings. Our results, obtained on a challenging new collection of source-code classification problems, indicate that obfuscating variable names produces an embedding model that is both impervious to variable naming and more accurately reflects code semantics. The datasets, models, and code are shared for further ML research on source code.</p>
</td>
	<td>naming adversarial </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/clement2020pymt5/">PyMT5: multi-mode translation of natural language and Python code with transformers</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=PyMT5: multi-mode translation of natural language and Python code with transformers' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=PyMT5: multi-mode translation of natural language and Python code with transformers' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Colin B. Clement, Dawn Drain, Jonathan Timcheck, Alexey Svyatkovskiy, Neel Sundaresan</td>
	<td>EMNLP</td>
	<td><p>Simultaneously modeling source code and natural language has many exciting applications in automated software development and understanding. Pursuant to achieving such technology, we introduce PyMT5, the Python method text-to-text transfer transformer, which is trained to translate between all pairs of Python method feature combinations: a single model that can both predict whole methods from natural language documentation strings (docstrings) and summarize code into docstrings of any common style. We present an analysis and modeling effort of a large-scale parallel corpus of 26 million Python methods and 7.7 million method-docstring pairs, demonstrating that for docstring and method generation, PyMT5 outperforms similarly-sized auto-regressive language models (GPT2) which were English pre-trained or randomly initialized. On the CodeSearchNet test set, our best model predicts 92.1% syntactically correct method bodies, achieved a BLEU score of 8.59 for method generation and 16.3 for docstring generation (summarization), and achieved a ROUGE-L F-score of 24.8 for method generation and 36.7 for docstring generation.</p>
</td>
	<td>bimodal code generation summarization documentation language model pretraining </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/ciurumelea2020suggesting/">Suggesting Comment Completions for Python using Neural Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Suggesting Comment Completions for Python using Neural Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Suggesting Comment Completions for Python using Neural Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Adelina Ciurumelea; Sebastian Proksch; Harald C. Gall</td>
	<td>SANER</td>
	<td><p>Source-code comments are an important communication medium between developers to better understand and maintain software. Current research focuses on auto-generating comments by summarizing the code. However, good comments contain additional details, like important design decisions or required trade-offs, and only developers can decide on the proper comment content. Automated summarization techniques cannot include information that does not exist in the code, therefore fully-automated approaches while helpful, will be of limited use. In our work, we propose to empower developers through a semi-automated system instead. We investigate the feasibility of using neural language models trained on a large corpus of Python documentation strings to generate completion suggestions and obtain promising results. By focusing on confident predictions, we can obtain a top-3 accuracy of over 70%, although this comes at the cost of lower suggestion frequency. Our models can be improved by leveraging context information like the signature and the full body of the method. Additionally, we are able to return good accuracy completions even for new projects, suggesting the generalizability of our approach.</p>
</td>
	<td>bimodal autocomplete documentation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/chirkova2020empirical/">Empirical Study of Transformers for Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Empirical Study of Transformers for Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Empirical Study of Transformers for Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Nadezhda Chirkova, Sergey Troshin</td>
	<td></td>
	<td><p>Initially developed for natural language processing (NLP), Transformers are now widely used for source code processing, due to the format similarity between source code and text. In contrast to natural language, source code is strictly structured, i. e. follows the syntax of the programming language. Several recent works develop Transformer modifications for capturing syntactic information in source code. The drawback of these works is that they do not compare to each other and all consider different tasks. In this work, we conduct a thorough empirical study of the capabilities of Transformers to utilize syntactic information in different tasks. We consider three tasks (code completion, function naming and bug fixing) and re-implement different syntax-capturing modifications in a unified framework. We show that Transformers are able to make meaningful predictions based purely on syntactic information and underline the best practices of taking the syntactic information into account for improving the performance of the model.</p>
</td>
	<td>Transformer </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/xu2020incorporating/">Incorporating External Knowledge through Pre-training for Natural Language to Code Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Incorporating External Knowledge through Pre-training for Natural Language to Code Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Incorporating External Knowledge through Pre-training for Natural Language to Code Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Frank F. Xu, Zhengbao Jiang, Pengcheng Yin, Bogdan Vasilescu, Graham Neubig</td>
	<td>ACL</td>
	<td><p>Open-domain code generation aims to generate code in a general-purpose programming language (such as Python) from natural language (NL) intents. Motivated by the intuition that developers usually retrieve resources on the web when writing code, we explore the effectiveness of incorporating two varieties of external knowledge into NL-to-code generation: automatically mined NL-code pairs from the online programming QA forum StackOverflow and programming language API documentation. Our evaluations show that combining the two sources with data augmentation and retrieval-based data re-sampling improves the current state-of-the-art by up to 2.2% absolute BLEU score on the code generation testbed CoNaLa. The code and resources are available at [Open-domain code generation aims to generate code in a general-purpose programming language (such as Python) from natural language (NL) intents. Motivated by the intuition that developers usually retrieve resources on the web when writing code, we explore the effectiveness of incorporating two varieties of external knowledge into NL-to-code generation: automatically mined NL-code pairs from the online programming QA forum StackOverflow and programming language API documentation. Our evaluations show that combining the two sources with data augmentation and retrieval-based data re-sampling improves the current state-of-the-art by up to 2.2% absolute BLEU score on the code generation testbed CoNaLa. The code and resources are available at <a href="https://github.com/neulab/external-knowledge-codegen">https://github.com/neulab/external-knowledge-codegen</a>.</p>
</td>
	<td>bimodal code generation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/wang2020modular/">Modular Tree Network for Source Code Representation Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Modular Tree Network for Source Code Representation Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Modular Tree Network for Source Code Representation Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Wenhan Wang, Ge Li, Sijie Shen, Xin Xia, Zhi Jin</td>
	<td>TOSEM</td>
	<td><p>Learning representation for source code is a foundation of many program analysis tasks. In recent years, neural networks have already shown success in this area, but most existing models did not make full use of the unique structural information of programs. Although abstract syntax tree (AST)-based neural models can handle the tree structure in the source code, they cannot capture the richness of different types of substructure in programs. In this article, we propose a modular tree network that dynamically composes different neural network units into tree structures based on the input AST. Different from previous tree-structural neural network models, a modular tree network can capture the semantic differences between types of AST substructures. We evaluate our model on two tasks: program classification and code clone detection. Our model achieves the best performance compared with state-of-the-art approaches in both tasks, showing the advantage of leveraging more elaborate structure information of the source code.</p>
</td>
	<td>grammar representation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/wang2020cocogum/">CoCoGUM: Contextual Code Summarization with Multi-Relational GNN on UMLs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CoCoGUM: Contextual Code Summarization with Multi-Relational GNN on UMLs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CoCoGUM: Contextual Code Summarization with Multi-Relational GNN on UMLs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yanlin Wang, Lun Du, Ensheng Shi, Yuxuan Hu, Shi Han, Dongmei Zhang</td>
	<td></td>
	<td><p>Code summaries are short natural language (NL) descriptions of code snippets that help developers better understand and maintain source code. Due to the pivotal role of code summaries in software development and maintenance, there is a surge of works on automatic code summarization to reduce the heavy burdens of developers. However, contemporary approaches only leverage the information within the boundary of the method being summarized (i.e., local context), and ignore that using broader context could assist with code summarization. In this paper, we explore two global context information, namely intra-class and inter-class context information, and propose the model CoCoGUM: Contextual Code Summarization with Multi-Relational Graph Neural Networks on UMLs. CoCoGUM first incorporates class names as the intra-class context, which is further fed to a Transformer-based sentence embedding model to extract the class lexical embeddings. Then, relevant Unified Modeling Language (UML) class diagrams are extracted as inter-class context and we use a Multi-Relational Graph Neural Network (MR-GNN) to encode the class relational embeddings. Class lexical embeddings and class relational embeddings, together with the outputs from code token encoder and AST encoder, are passed to the decoder armed with a two-level attention mechanism to generate high-quality context-aware code summaries. We conduct extensive experiments to evaluate our approach and compare it with other automatic code summarization models. The experimental results show that CoCoGUM outperforms state-of-the-art methods.</p>
</td>
	<td>summarization </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/cai2020tag/">TAG : Type Auxiliary Guiding for Code Comment Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=TAG : Type Auxiliary Guiding for Code Comment Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=TAG : Type Auxiliary Guiding for Code Comment Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ruichu Cai, Zhihao Liang, Boyan Xu, Zijian Li, Yuexing Hao, Yao Chen</td>
	<td>ACL</td>
	<td><p>Existing leading code comment generation approaches with the structure-to-sequence framework ignores the type information of the interpretation of the code, e.g., operator, string, etc. However, introducing the type information into the existing framework is non-trivial due to the hierarchical dependence among the type information. In order to address the issues above, we propose a Type Auxiliary Guiding encoder-decoder framework for the code comment generation task which considers the source code as an N-ary tree with type information associated with each node. Specifically, our framework is featured with a Type-associated Encoder and a Type-restricted Decoder which enables adaptive summarization of the source code. We further propose a hierarchical reinforcement learning method to resolve the training difficulties of our proposed framework. Extensive evaluations demonstrate the state-of-the-art performance of our framework with both the auto-evaluated metrics and case studies.</p>
</td>
	<td>bimodal documentation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/brody2020structural/">A Structural Model for Contextual Code Changes</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Structural Model for Contextual Code Changes' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Structural Model for Contextual Code Changes' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shaked Brody, Uri Alon, Eran Yahav</td>
	<td>OOPSLA</td>
	<td><p>We address the problem of predicting edit completions based on a learned model that was trained on past edits. Given a code snippet that is partially edited, our goal is to predict a completion of the edit for the rest of the snippet. We refer to this task as the EditCompletion task and present a novel approach for tackling it. The main idea is to directly represent structural edits. This allows us to model the likelihood of the edit itself, rather than learning the likelihood of the edited code. We represent an edit operation as a path in the program’s Abstract Syntax Tree (AST), originating from the source of the edit to the target of the edit. Using this representation, we present a powerful and lightweight neural model for the EditCompletion task. We conduct a thorough evaluation, comparing our approach to a variety of representation and modeling approaches that are driven by multiple strong models such as LSTMs, Transformers, and neural CRFs. Our experiments show that our model achieves 28% relative gain over state-of-the-art sequential models and 2× higher accuracy than syntactic models that learn to generate the edited code instead of modeling the edits directly. Our code, dataset, and trained models are publicly available at https://github.com/tech-srl/c3po/ .</p>
</td>
	<td>edit grammar autocomplete </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/briem2020offside/">OffSide: Learning to Identify Mistakes in Boundary Conditions</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=OffSide: Learning to Identify Mistakes in Boundary Conditions' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=OffSide: Learning to Identify Mistakes in Boundary Conditions' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jón Arnar Briem, Jordi Smit, Hendrig Sellik, Pavel Rapoport, Georgios Gousios, Maurício Aniche.</td>
	<td>2nd Workshop on Testing for Deep Learning and Deep Learning for Testing</td>
	<td><p>Mistakes in boundary conditions are the cause of many bugs in software.
These mistakes happen when, e.g., developers make use of <code class="language-plaintext highlighter-rouge">&lt;</code> or <code class="language-plaintext highlighter-rouge">&gt;</code> in cases
where they should have used <code class="language-plaintext highlighter-rouge">&lt;=</code> or <code class="language-plaintext highlighter-rouge">&gt;=</code>. Mistakes in boundary conditions
are often hard to find and manually detecting them might be very time-consuming
for developers. While researchers have been proposing techniques to cope with
mistakes in the boundaries for a long time, the automated detection of such bugs still
remains a challenge. We conjecture that, for a tool to be able to precisely identify mistakes
in boundary conditions, it should be able to capture the overall context of the source code
under analysis. In this work, we propose a deep learning model that learn mistakes in boundary
conditions and, later, is able to identifythem in unseen code snippets. We train and test a
model on over 1.5 million code snippets, with and without mistakes in different boundary conditions.
Our model shows an accuracy from 55% up to 87%. The model is also able to detect 24 out of 41
real-world bugs;however, with a high false positive rate. The existing state-of-the-practice linter
tools are not able to detect any of the bugs. We hope this paper can pave the road towards deep
learning models that will be able to support developers in detecting mistakes in boundary conditions.</p>
</td>
	<td>defect </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/brauckmann2020compiler/">Compiler-based graph representations for deep learning models of code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Compiler-based graph representations for deep learning models of code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Compiler-based graph representations for deep learning models of code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Alexander Brauckmann, Andres Goens, Sebastian Ertel, Jeronimo Castrillon</td>
	<td>CC</td>
	<td><p>In natural language processing, novel methods in deep learning, like recurrent neural networks (RNNs) on sequences of words, have been very successful. These methods have also been used recently for tasks in compiler optimization, like heterogeneous mapping of OpenCL kernels or predicting thread coarsening factors for optimal execution times. In contrast to natural languages, programming languages usually have a well-defined structure. This structure is what enables compilers to reason about programs on the foundations of graphs, such as abstract syntax trees (ASTs) or control-data flow graphs (CDFGs).
In this paper, we argue that we should use these graph structures instead of word sequences for learning compiler optimization tasks. To this end we apply recently proposed graph neural networks (GNNs) for learning predictive compiler tasks on two representations based on ASTs and CDFGs. Experimental results show how these representations improve upon the accuracy of the state-of-the-art in the task of heterogeneous OpenCL mapping, while providing orders of magnitude faster inference times, which are crucial for compiler optimizations. When testing on benchmark suites not included for training, our graph-based methods significantly outperform the state-of-the art by 12 percentage points in terms of accuracy, and are the only ones to perform better than a random mapping. When testing on the task of predicting thread coarsening factors, we expose current limitations of deep learning in compilers. We show how all of the deep learning approaches proposed so far, including our graph-based models, fail to produce an overall speedup with their predictions.</p>
</td>
	<td>representation compilation optimization GNN </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/brauckmann2020compy/">ComPy-Learn: A toolbox for exploring machine learning representations for compilers</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=ComPy-Learn: A toolbox for exploring machine learning representations for compilers' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=ComPy-Learn: A toolbox for exploring machine learning representations for compilers' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Alexander Brauckmann, Andrés Goens, Jeronimo Castrillon</td>
	<td>FDL</td>
	<td><p>Deep Learning methods have not only shown to improve software performance in compiler heuristics, but also e.g. to improve security in vulnerability prediction or to boost developer productivity in software engineering tools. A key to the success of such methods across these use cases is the expressiveness of the representation used to abstract from the program code. Recent work has shown that different such representations have unique advantages in terms of performance. However, determining the best-performing one for a given task is often not obvious and requires empirical evaluation.
Therefore, we present ComPy-Learn, a toolbox for conveniently defining, extracting, and exploring representations of program code. With syntax-level language information from the Clang compiler frontend and low-level information from the LLVM compiler backend, the tool supports the construction of linear and graph representations and enables an efficient search for the best-performing representation and model for tasks on program code.</p>
</td>
	<td>representation compilation optimization GNN </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/bielik2020adversarial/">Adversarial Robustness for Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Adversarial Robustness for Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Adversarial Robustness for Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Pavol Bielik, Martin Vechev</td>
	<td></td>
	<td><p>We propose a novel technique which addresses the challenge of learning accurate and robust models of code in a principled way. Our method consists of three key components: (i) learning to abstain from making a prediction if uncertain, (ii) adversarial training, and (iii) representation refinement which learns the program parts relevant for the prediction and abstracts the rest. These components are used to iteratively train multiple models, each of which learns a suitable program representation necessary to make robust predictions on a different subset of the dataset. We instantiated our approach to the task of type inference for dynamically typed languages and demonstrate its effectiveness by learning a model that achieves 88% accuracy and 84% robustness. Further, our evaluation shows that using the combination of all three components is key to obtaining accurate and robust models.</p>
</td>
	<td>adversarial types </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/bieber2020learning/">Learning to Execute Programs with Instruction Pointer Attention Graph Neural Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Execute Programs with Instruction Pointer Attention Graph Neural Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Execute Programs with Instruction Pointer Attention Graph Neural Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>David Bieber, Charles Sutton, Hugo Larochelle, Daniel Tarlow</td>
	<td>NeurIPS</td>
	<td><p>Graph neural networks (GNNs) have emerged as a powerful tool for learning software engineering tasks including code completion, bug finding, and program repair. They benefit from leveraging program structure like control flow graphs, but they are not well-suited to tasks like program execution that require far more sequential reasoning steps than number of GNN propagation steps. Recurrent neural networks (RNNs), on the other hand, are well-suited to long sequential chains of reasoning, but they do not naturally incorporate program structure and generally perform worse on the above tasks. Our aim is to achieve the best of both worlds, and we do so by introducing a novel GNN architecture, the Instruction Pointer Attention Graph Neural Networks (IPA-GNN), which achieves improved systematic generalization on the task of learning to execute programs using control flow graphs. The model arises by considering RNNs operating on program traces with branch decisions as latent variables. The IPA-GNN can be seen either as a continuous relaxation of the RNN model or as a GNN variant more tailored to execution. To test the models, we propose evaluating systematic generalization on learning to execute using control flow graphs, which tests sequential reasoning and use of program structure. More practically, we evaluate these models on the task of learning to execute partial programs, as might arise if using the model as a heuristic function in program synthesis. Results show that the IPA-GNN outperforms a variety of RNN and GNN baselines on both tasks.</p>
</td>
	<td>representation dynamic </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/bian2020sinkfinder/">SinkFinder: harvesting hundreds of unknown interesting function pairs with just one seed</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=SinkFinder: harvesting hundreds of unknown interesting function pairs with just one seed' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=SinkFinder: harvesting hundreds of unknown interesting function pairs with just one seed' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Pan Bian, Bin Liang, Jianjun Huang, Wenchang Shi, Xidong Wang, Jian Zhang</td>
	<td>FSE</td>
	<td><p>Mastering the knowledge about security-sensitive functions that can potentially result in bugs is valuable to detect them. However, identifying this kind of functions is not a trivial task. Introducing machine learning-based techniques to do the task is a natural choice. Unfortunately, the approach also requires considerable prior knowledge, e.g., sufficient labelled training samples. In practice, the requirement is often hard to meet.</p>

<p>In this paper, to solve the problem, we propose a novel and practical method called SinkFinder to automatically discover function pairs that we are interested in, which only requires very limited prior knowledge. SinkFinder first takes just one pair of well-known interesting functions as the initial seed to infer enough positive and negative training samples by means of sub-word word embedding. By using these samples, a support vector machine classifier is trained to identify more interesting function pairs. Finally, checkers equipped with the obtained knowledge can be easily developed to detect bugs in target systems. The experiments demonstrate that SinkFinder can successfully discover hundreds of interesting functions and detect dozens of previously unknown bugs from large-scale systems, such as Linux, OpenSSL and PostgreSQL.</p>
</td>
	<td>program analysis </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/yang2020survey/">A Survey on Deep Learning for Software Engineering</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Survey on Deep Learning for Software Engineering' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Survey on Deep Learning for Software Engineering' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yanming Yang, Xin Xia, David Lo, John Grundy</td>
	<td></td>
	<td><p>In 2006, Geoffrey Hinton proposed the concept of training ‘‘Deep Neural Networks (DNNs)’’ and an improved model training method to break the bottleneck of neural network development. More recently, the introduction of AlphaGo in 2016 demonstrated the powerful learning ability of deep learning and its enormous potential. Deep learning has been increasingly used to develop state-of-the-art software engineering (SE) research tools due to its ability to boost performance for various SE tasks. There are many factors, e.g., deep learning model selection, internal structure differences, and model optimization techniques, that may have an impact on the performance of DNNs applied in SE. Few works to date focus on summarizing, classifying, and analyzing the application of deep learning techniques in SE. To fill this gap, we performed a survey to analyse the relevant studies published since 2006. We first provide an example to illustrate how deep learning techniques are used in SE. We then summarize and classify different deep learning techniques used in SE. We analyzed key optimization technologies used in these deep learning models, and finally describe a range of key research topics using DNNs in SE. Based on our findings, we present a set of current challenges remaining to be investigated and outline a proposed research road map highlighting key opportunities for future work.</p>
</td>
	<td>survey </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/ren2020codebleu/">CodeBLEU: a Method for Automatic Evaluation of Code Synthesis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeBLEU: a Method for Automatic Evaluation of Code Synthesis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeBLEU: a Method for Automatic Evaluation of Code Synthesis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shuo Ren, Daya Guo, Shuai Lu, Long Zhou, Shujie Liu, Duyu Tang, Neel Sundaresan, Ming Zhou, Ambrosio Blanco, Shuai Ma</td>
	<td></td>
	<td><p>Evaluation metrics play a vital role in the growth of an area as it defines the standard of distinguishing between good and bad models. In the area of code synthesis, the commonly used evaluation metric is BLEU or perfect accuracy, but they are not suitable enough to evaluate codes, because BLEU is originally designed to evaluate the natural language, neglecting important syntactic and semantic features of codes, and perfect accuracy is too strict thus it underestimates different outputs with the same semantic logic. To remedy this, we introduce a new automatic evaluation metric, dubbed CodeBLEU. It absorbs the strength of BLEU in the n-gram match and further injects code syntax via abstract syntax trees (AST) and code semantics via data-flow. We conduct experiments by evaluating the correlation coefficient between CodeBLEU and quality scores assigned by the programmers on three code synthesis tasks, i.e., text-to-code, code translation, and code refinement. Experimental results show that our proposed CodeBLEU can achieve a better correlation with programmer assigned scores compared with BLEU and accuracy.</p>
</td>
	<td>evaluation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/wang2020blended/">Blended, precise semantic program embeddings</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Blended, precise semantic program embeddings' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Blended, precise semantic program embeddings' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ke Wang, Zhendong Su</td>
	<td>PLDI</td>
	<td><p>Learning neural program embeddings is key to utilizing deep neural networks in program languages research — precise and efficient program representations enable the application of deep models to a wide range of program analysis tasks. Existing approaches predominately learn to embed programs from their source code, and, as a result, they do not capture deep, precise program semantics. On the other hand, models learned from runtime information critically depend on the quality of program executions, thus leading to trained models with highly variant quality. This paper tackles these inherent weaknesses of prior approaches by introducing a new deep neural network, Liger, which learns program representations from a mixture of symbolic and concrete execution traces. We have evaluated Liger on two tasks: method name prediction and semantics classification. Results show that Liger is significantly more accurate than the state-of-the-art static model code2seq in predicting method names, and requires on average around 10x fewer executions covering nearly 4x fewer paths than the state-of-the-art dynamic model DYPRO in both tasks. Liger offers a new, interesting design point in the space of neural program embeddings and opens up this new direction for exploration.</p>
</td>
	<td>dynamic </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/yan2020are/">Are the Code Snippets What We Are Searching for? A Benchmark and an Empirical Study on Code Search with Natural-Language Queries</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Are the Code Snippets What We Are Searching for? A Benchmark and an Empirical Study on Code Search with Natural-Language Queries' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Are the Code Snippets What We Are Searching for? A Benchmark and an Empirical Study on Code Search with Natural-Language Queries' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shuhan Yan, Hang Yu, Yuting Chen, Beijun Shen, Lingxiao Jiang</td>
	<td>SANER</td>
	<td><p>Code search methods, especially those that allow programmers to raise queries in a natural language, plays an important role in software development. It helps to improve programmers’ productivity by returning sample code snippets from the Internet and/or source-code repositories for their natural-language queries. Meanwhile, there are many code search methods in the literature that support natural-language queries. Difficulties exist in recognizing the strengths and weaknesses of each method and choosing the right one for different usage scenarios, because (1) the implementations of those methods and the datasets for evaluating them are usually not publicly available, and (2) some methods leverage different training datasets or auxiliary data sources and thus their effectiveness cannot be fairly measured and may be negatively affected in practical uses. To build a common ground for measuring code search methods, this paper builds CosBench, a dataset that consists of 1000 projects, 52 code-independent natural-language queries with ground truths, and a set of scripts for calculating four metrics on code research results. We have evaluated four IR (Information Retrieval)-based and two DL (Deep Learning)-based code search methods on CosBench. The empirical evaluation results clearly show the usefulness of the CosBench dataset and various strengths of each code search method. We found that DL-based methods are more suitable for queries on reusing code, and IR-based ones for queries on resolving bugs and learning API uses.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/aye2020learning/">Learning Autocompletion from Real-World Datasets</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Autocompletion from Real-World Datasets' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Autocompletion from Real-World Datasets' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Gareth Ari Aye, Seohyun Kim, Hongyu Li</td>
	<td></td>
	<td><p>Code completion is a popular software development tool integrated into all major IDEs. Many neural language models have achieved promising results in completion suggestion prediction on synthetic benchmarks. However, a recent study When Code Completion Fails: a Case Study on Real-World Completions demonstrates that these results may not translate to improvements in real-world performance. To combat this effect, we train models on real-world code completion examples and find that these models outperform models trained on committed source code and working version snapshots by 12.8% and 13.8% accuracy respectively. We observe this improvement across modeling technologies and show through A/B testing that it corresponds to a 6.2% increase in programmers’ actual autocompletion usage. Furthermore, our study characterizes a large corpus of logged autocompletion usages to investigate why training on real-world examples leads to stronger models.</p>
</td>
	<td>autocomplete </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/ashwath2020predicting/">Predicting Vulnerability in Large Codebases With Deep Code Representation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Predicting Vulnerability in Large Codebases With Deep Code Representation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Predicting Vulnerability in Large Codebases With Deep Code Representation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Anshul Tanwar, Krishna Sundaresan, Parmesh Ashwath, Prasanna Ganesan, Sathish Kumar Chandrasekaran, Sriram Ravi</td>
	<td></td>
	<td><p>Currently, while software engineers write code for various modules, quite often, various types of errors - coding, logic, semantic, and others (most of which are not caught by compilation and other tools) get introduced. Some of these bugs might be found in the later stage of testing, and many times it is reported by customers on production code. Companies have to spend many resources, both money and time in finding and fixing the bugs which would have been avoided if coding was done right. Also, concealed flaws in software can lead to security vulnerabilities that potentially allow attackers to compromise systems and applications. Interestingly, same or similar issues/bugs, which were fixed in the past (although in different modules), tend to get introduced in production code again.
We developed a novel AI-based system which uses the deep representation of Abstract Syntax Tree (AST) created from the source code and also the active feedback loop to identify and alert the potential bugs that could be caused at the time of development itself i.e. as the developer is writing new code (logic and/or function). This tool integrated with IDE as a plugin would work in the background, point out existing similar functions/code-segments and any associated bugs in those functions. The tool would enable the developer to incorporate suggestions right at the time of development, rather than waiting for UT/QA/customer to raise a defect.
We assessed our tool on both open-source code and also on Cisco codebase for C and C++ programing language. Our results confirm that deep representation of source code and the active feedback loop is an assuring approach for predicting security and other vulnerabilities present in the code.</p>
</td>
	<td>grammar program analysis static analysis </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/aye2020sequence/">Sequence Model Design for Code Completion in the Modern IDE</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Sequence Model Design for Code Completion in the Modern IDE' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Sequence Model Design for Code Completion in the Modern IDE' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Gareth Ari Aye, Gail E. Kaiser</td>
	<td>Optional</td>
	<td><p>Code completion plays a prominent role in modern integrated development environments (IDEs). Machine learning has become ubiquitous in analogous natural language writing and search software, surfacing more relevant autocompletions and search suggestions in fewer keystrokes. Prior research has reported training high-accuracy, deep neural networks for modeling source code, but little attention has been given to the practical constraints imposed by interactive developer tools. In particular, neural language models for source code modeling like the one described in Maybe Deep Neural Networks are the Best Choice for Modeling Source Code are framed around code completion, but only report accuracy of next-token prediction. However, in order for a language model (LM) to work well within real-world code completion systems, it must also always make suggestions that produce valid code that typechecks to support code completion’s role in correctness-checking; return instantaneous results to help programmers code more efficiently in fewer keystrokes; and be small enough to fit comfortably on disk and in memory on developer workstations, since virtually all modern IDEs run locally and support offline usage. To meet these additional requirements, we propose a novel design for predicting top-k next tokens that combines static analysis’ ability to enumerate all valid keywords and in-scope identifiers with the ability of a language model to place a probability distribution over them. Our model mixes character-level input representation with token output to represent out-of-vocabulary (OOV) tokens meaningfully and minimize prediction latency. OOV tokens can be predicted through detection of local repetition common in software. This design achieves state-of-art accuracy in source code modeling and fits the constraints imposed by real-world code completion implementations in modern IDEs.</p>
</td>
	<td>autocomplete </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/arakelyan2020towards/">Towards Learning Representations of Binary Executable Files for Security Tasks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Towards Learning Representations of Binary Executable Files for Security Tasks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Towards Learning Representations of Binary Executable Files for Security Tasks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shushan Arakelyan, Sima Arasteh, Christophe Hauser, Erik Kline, Aram Galstyan</td>
	<td>AAAI</td>
	<td><p>Tackling binary analysis problems has traditionally implied manually defining rules and heuristics. As an alternative, we are suggesting using machine learning models for learning distributed representations of binaries that can be applicable for a number of downstream tasks. We construct a computational graph from the binary executable and use it with a graph convolutional neural network to learn a high dimensional representation of the program. We show the versatility of this approach by using our representations to solve two semantically different binary analysis tasks – algorithm classification and vulnerability discovery. We compare the proposed approach to our own strong baseline as well as published results and demonstrate improvement on the state of the art methods for both tasks.</p>
</td>
	<td>GNN representation </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/wang2020detecting/">Detecting Code Clones with Graph Neural Network and Flow-Augmented Abstract Syntax Tree</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Detecting Code Clones with Graph Neural Network and Flow-Augmented Abstract Syntax Tree' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Detecting Code Clones with Graph Neural Network and Flow-Augmented Abstract Syntax Tree' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Wenhan Wang, Ge Li, Bo Ma, Xin Xia, Zhi Jin</td>
	<td>IEEE International Conference on Software Analysis, Evolution, and Reengineering</td>
	<td><p>Code clones are semantically similar code fragments pairs that are syntactically similar or different. Detection of code clones can help to reduce the cost of software maintenance and prevent bugs. Numerous approaches of detecting code clones have been proposed previously, but most of them focus on detecting syntactic clones and do not work well on semantic clones with different syntactic features. To detect semantic clones, researchers have tried to adopt deep learning for code clone detection to automatically learn latent semantic features from data. Especially, to leverage grammar information, several approaches used abstract syntax trees (AST) as input and achieved significant progress on code clone benchmarks in various programming languages. However, these AST-based approaches still can not fully leverage the structural information of code fragments, especially semantic information such as control flow and data flow. To leverage control and data flow information, in this paper, we build a graph representation of programs called flow-augmented abstract syntax tree (FA-AST). We construct FA-AST by augmenting original ASTs with explicit control and data flow edges. Then we apply two different types of graph neural networks (GNN) on FA-AST to measure the similarity of code pairs. As far as we have concerned, we are the first to apply graph neural networks on the domain of code clone detection. We apply our FA-AST and graph neural networks on two Java datasets: Google Code Jam and BigCloneBench. Our approach outperforms the state-of-the-art approaches on both Google Code Jam and BigCloneBench tasks.</p>
</td>
	<td>clone GNN </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/allamanis2020typilus/">Typilus: Neural Type Hints</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Typilus: Neural Type Hints' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Typilus: Neural Type Hints' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Miltiadis Allamanis, Earl T. Barr, Soline Ducousso, Zheng Gao</td>
	<td>PLDI</td>
	<td><p>Type inference over partial contexts in dynamically typed languages is challenging. In this work, we present a graph neural network model that predicts types by probabilistically reasoning over a program’s structure, names, and patterns. The network uses deep similarity learning to learn a TypeSpace – a continuous relaxation of the discrete space of types – and how to embed the type properties of a symbol (i.e. identifier) into it. Importantly, our model can employ one-shot learning to predict an open vocabulary of types, including rare and user-defined ones. We realise our approach in Typilus for Python that combines the TypeSpace with an optional type checker. We show that Typilus accurately predicts types. Typilus confidently predicts types for 70% of all annotatable symbols; when it predicts a type, that type optionally type checks 95% of the time. Typilus can also find incorrect type annotations; two important and popular open source libraries, fairseq and allennlp, accepted our pull requests that fixed the annotation errors Typilus discovered.</p>
</td>
	<td>types GNN </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/derezendemartins2020concra/">CoNCRA: A Convolutional Neural Network Code Retrieval Approach</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CoNCRA: A Convolutional Neural Network Code Retrieval Approach' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CoNCRA: A Convolutional Neural Network Code Retrieval Approach' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Marcelo de Rezende Martins, Marco Aurélio Gerosa</td>
	<td>SBES '20</td>
	<td><p>Software developers routinely search for code using general-purpose search engines. However, these search engines cannot find code semantically unless it has an accompanying description. We propose a technique for semantic code search: A Convolutional Neural Network approach to code retrieval (CoNCRA). Our technique aims to find the code snippet that most closely matches the developer’s intent, expressed in natural language. We evaluated our approach’s efficacy on a dataset composed of questions and code snippets collected from Stack Overflow. Our preliminary results showed that our technique, which prioritizes local interactions (words nearby), improved the state-of-the-art (SOTA) by 5% on average, retrieving the most relevant code snippets in the top 3 (three) positions by almost 80% of the time. Therefore, our technique is promising and can improve the efficacy of semantic code retrieval.</p>

</td>
	<td>search </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/heyman2020neural/">Neural Code Search Revisited: Enhancing Code Snippet Retrieval through Natural Language Intent</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Code Search Revisited: Enhancing Code Snippet Retrieval through Natural Language Intent' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Code Search Revisited: Enhancing Code Snippet Retrieval through Natural Language Intent' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Geert Heyman, Tom Van Cutsem</td>
	<td></td>
	<td><p>In this work, we propose and study annotated code search: the retrieval of code snippets paired with brief descriptions of their intent using natural language queries. On three benchmark datasets, we investigate how code retrieval systems can be improved by leveraging descriptions to better capture the intents of code snippets. Building on recent progress in transfer learning and natural language processing, we create a domain-specific retrieval model for code annotated with a natural language description. We find that our model yields significantly more relevant search results (with absolute gains up to 20.6% in mean reciprocal rank) compared to state-of-the-art code retrieval methods that do not use descriptions but attempt to compute the intent of snippets solely from unannotated code.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/ahmad2020transformer/">A Transformer-based Approach for Source Code Summarization</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Transformer-based Approach for Source Code Summarization' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Transformer-based Approach for Source Code Summarization' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Wasi Uddin Ahmad, Saikat Chakraborty, Baishakhi Ray, Kai-Wei Chang</td>
	<td>ACL</td>
	<td><p>Generating a readable summary that describes the functionality of a program is known as source code summarization. In this task, learning code representation by modeling the pairwise relationship between code tokens to capture their long-range dependencies is crucial. To learn code representation for summarization, we explore the Transformer model that uses a self-attention mechanism and has shown to be effective in capturing long-range dependencies. In this work, we show that despite the approach is simple, it outperforms the state-of-the-art techniques by a significant margin. We perform extensive analysis and ablation studies that reveal several important findings, e.g., the absolute encoding of source code tokens’ position hinders, while relative encoding significantly improves the summarization performance. We have made our code publicly available to facilitate future research.</p>
</td>
	<td>summarization </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/abdelaziz2020graph4code/">Graph4Code: A Machine Interpretable Knowledge Graph for Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Graph4Code: A Machine Interpretable Knowledge Graph for Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Graph4Code: A Machine Interpretable Knowledge Graph for Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ibrahim Abdelaziz, Julian Dolby, James P. McCusker, Kavitha Srinivas</td>
	<td></td>
	<td><p>Knowledge graphs have proven extremely useful in powering diverse applications in semantic search and natural language understanding. Graph4Code is a knowledge graph about program code that can similarly power diverse applications such as program search, code understanding, refactoring, bug detection, and code automation. The graph uses generic techniques to capture the semantics of Python code: the key nodes in the graph are classes, functions and methods in popular Python modules. Edges indicate function usage (e.g., how data flows through function calls, as derived from program analysis of real code), and documentation about functions (e.g., code documentation, usage documentation, or forum discussions such as StackOverflow). We make extensive use of named graphs in RDF to make the knowledge graph extensible by the community. We describe a set of generic extraction techniques that we applied to over 1.3M Python files drawn from GitHub, over 2,300 Python modules, as well as 47M forum posts to generate a graph with over 2 billion triples. We also provide a number of initial use cases of the knowledge graph in code assistance, enforcing best practices, debugging and type inference. The graph and all its artifacts are available to the community for use.</p>
</td>
	<td>dataset </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/zhou2019devign/">Devign: Effective Vulnerability Identification by Learning Comprehensive Program Semantics via Graph Neural Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Devign: Effective Vulnerability Identification by Learning Comprehensive Program Semantics via Graph Neural Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Devign: Effective Vulnerability Identification by Learning Comprehensive Program Semantics via Graph Neural Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yaqin Zhou, Shangqing Liu, Jingkai Siow, Xiaoning Du, Yang Liu</td>
	<td>NeurIPS</td>
	<td><p>Vulnerability identification is crucial to protect the software systems from attacks for cyber security. It is especially important to localize the vulnerable functions among the source code to facilitate the fix. However, it is a challenging and tedious process, and also requires specialized security expertise. Inspired by the work on manually-defined patterns of vulnerabilities from various code representation graphs and the recent advance on graph neural networks, we propose Devign, a general graph neural network based model for graph-level classification through learning on a rich set of code semantic representations. It includes a novel Conv module to efficiently extract useful features in the learned rich node representations for graph-level classification. The model is trained over manually labeled datasets built on 4 diversified large-scale open-source C projects that incorporate high complexity and variety of real source code instead of synthesis code used in previous works. The results of the extensive evaluation on the datasets demonstrate that Devign outperforms the state of the arts significantly with an average of 10.51% higher accuracy and 8.68% F1 score, increases averagely 4.66% accuracy and 6.37% F1 by the Conv module.</p>
</td>
	<td>GNN static analysis </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/wang2020learning2/">Learning to Represent Programs with Heterogeneous Graphs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Represent Programs with Heterogeneous Graphs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Represent Programs with Heterogeneous Graphs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Wenhan Wang, Kechi Zhang, Ge Li, Zhi Jin</td>
	<td></td>
	<td><p>Program source code contains complex structure information, which can be represented in structured data forms like trees or graphs. To acquire the structural information in source code, most existing researches use abstract syntax trees (AST). A group of works add additional edges to ASTs to convert source code into graphs and use graph neural networks to learn representations for program graphs. Although these works provide additional control or data flow information to ASTs for downstream tasks, they neglect an important aspect of structure information in AST itself: the different types of nodes and edges. In ASTs, different nodes contain different kinds of information like variables or control flow, and the relation between a node and all its children can also be different.</p>

<p>To address the information of node and edge types, we bring the idea of heterogeneous graphs to learning on source code and present a new formula of building heterogeneous program graphs from ASTs with additional type information for nodes and edges. We use the ASDL grammar of programming language to define the node and edge types of program graphs. Then we use heterogeneous graph neural networks to learn on these graphs. We evaluate our approach on two tasks: code comment generation and method naming. Both tasks require reasoning on the semantics of complete code snippets. Experiment results show that our approach outperforms baseline models, including homogeneous graph-based models, showing that leveraging the type information of nodes and edges in program graphs can help in learning program semantics.</p>
</td>
	<td>GNN summarization </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/nair2020funcgnn/">funcGNN: A Graph Neural Network Approach to Program Similarity</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=funcGNN: A Graph Neural Network Approach to Program Similarity' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=funcGNN: A Graph Neural Network Approach to Program Similarity' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Aravind Nair, Avijit Roy, Karl Meinke</td>
	<td>ESEM</td>
	<td><p>Program similarity is a fundamental concept, central to the solution of software engineering tasks such as software plagiarism, clone identification, code refactoring and code search. Accurate similarity estimation between programs requires an in-depth understanding of their structure, semantics and flow. A control flow graph (CFG), is a graphical representation of a program which captures its logical control flow and hence its semantics. A common approach is to estimate program similarity by analysing CFGs using graph similarity measures, e.g. graph edit distance (GED). However, graph edit distance is an NP-hard problem and computationally expensive, making the application of graph similarity techniques to complex software programs impractical. This study intends to examine the effectiveness of graph neural networks to estimate program similarity, by analysing the associated control flow graphs. We introduce funcGNN, which is a graph neural network trained on labeled CFG pairs to predict the GED between unseen program pairs by utilizing an effective embedding vector. To our knowledge, this is the first time graph neural networks have been applied on labeled CFGs for estimating the similarity between high-level language programs. Results: We demonstrate the effectiveness of funcGNN to estimate the GED between programs and our experimental analysis demonstrates how it achieves a lower error rate (0.00194), with faster (23 times faster than the quickest traditional GED approximation method) and better scalability compared with the state of the art methods. funcGNN posses the inductive learning ability to infer program structure and generalise to unseen programs. The graph embedding of a program proposed by our methodology could be applied to several related software engineering problems (such as code plagiarism and clone identification) thus opening multiple research directions.</p>
</td>
	<td>GNN clone </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/panthaplackel2020associating/">Associating Natural Language Comment and Source Code Entities</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Associating Natural Language Comment and Source Code Entities' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Associating Natural Language Comment and Source Code Entities' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sheena Panthaplackel, Milos Gligoric, Raymond J. Mooney, Junyi Jessy Li</td>
	<td>AAAI</td>
	<td><p>Comments are an integral part of software development; they are natural language descriptions associated with source code elements. Understanding explicit associations can be useful in improving code comprehensibility and maintaining the consistency between code and comments. As an initial step towards this larger goal, we address the task of associating entities in Javadoc comments with elements in Java source code. We propose an approach for automatically extracting supervised data using revision histories of open source projects and present a manually annotated evaluation dataset for this task. We develop a binary classifier and a sequence labeling model by crafting a rich feature set which encompasses various aspects of code, comments, and the relationships between them. Experiments show that our systems outperform several baselines learning from the proposed supervision.</p>
</td>
	<td>dataset bimodal </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/shuai2020improving/">Improving Code Search with Co-Attentive Representation Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Improving Code Search with Co-Attentive Representation Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Improving Code Search with Co-Attentive Representation Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jianhang Shuai, Ling Xu, Chao Liu, Meng Yan, Xin Xia, Yan Lei</td>
	<td>ICPC</td>
	<td><p>Searching and reusing existing code from a large-scale codebase, e.g, GitHub, can help developers complete a programming task efficiently. Recently, Gu et al. proposed a deep learning-based model (i.e., DeepCS), which significantly outperformed prior models. The DeepCS embedded codebase and natural language queries into vectors by two LSTM (long and short-term memory) models separately, and returned developers the code with higher similarity to a code search query. However, such embedding method learned two isolated representations for code and query but ignored their internal semantic correlations. As a result, the learned isolated representations of code and query may limit the effectiveness of code search.</p>

<p>To address the aforementioned issue, we propose a co-attentive representation learning model, i.e., Co-Attentive Representation Learning Code Search-CNN (CARLCS-CNN). CARLCS-CNN learns interdependent representations for the embedded code and query with a co-attention mechanism. Generally, such mechanism learns a correlation matrix between embedded code and query, and co-attends their semantic relationship via row/column-wise max-pooling. In this way, the semantic correlation between code and query can directly affect their individual representations. We evaluate the effectiveness of CARLCS-CNN on Gu et al.’s dataset with 10k queries. Experimental results show that the proposed CARLCS-CNN model significantly outperforms DeepCS by 26.72% in terms of MRR (mean reciprocal rank). Additionally, CARLCS-CNN is five times faster than DeepCS in model training and four times in testing.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/shrivastava2020on-the-fly/">On-the-Fly Adaptation of Source Code Models using Meta-Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=On-the-Fly Adaptation of Source Code Models using Meta-Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=On-the-Fly Adaptation of Source Code Models using Meta-Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Disha Shrivastava, Hugo Larochelle, Daniel Tarlow</td>
	<td></td>
	<td><p>The ability to adapt to unseen, local contexts is an important challenge that successful models of source code must overcome. One of the most popular approaches for the adaptation of such models is dynamic evaluation. With dynamic evaluation, when running a model on an unseen file, the model is updated immediately after having observed each token in that file. In this work, we propose instead to frame the problem of context adaptation as a meta-learning problem. We aim to train a base source code model that is best able to learn from information in a file to deliver improved predictions of missing tokens. Unlike dynamic evaluation, this formulation allows us to select more targeted information (support tokens) for adaptation, that is both before and after a target hole in a file. We consider an evaluation setting that we call line-level maintenance, designed to reflect the downstream task of code auto-completion in an IDE. Leveraging recent developments in meta-learning such as first-order MAML and Reptile, we demonstrate improved performance in experiments on a large scale Java GitHub corpus, compared to other adaptation baselines including dynamic evaluation. Moreover, our analysis shows that, compared to a non-adaptive baseline, our approach improves performance on identifiers and literals by 44% and 15%, respectively.</p>
</td>
	<td>language model autocomplete </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/nguyen2020suggesting/">Suggesting Natural Method Names to Check Name Consistencies</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Suggesting Natural Method Names to Check Name Consistencies' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Suggesting Natural Method Names to Check Name Consistencies' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Son Nguyen, Hung Phan, Trinh Le, Tien N. Nguyen</td>
	<td>ICSE</td>
	<td><p>Misleading names of the methods in a project or the APIs in a software library confuse developers about program functionality
and API usages, leading to API misuses and defects. In this paper,we introduce MNire, a machine learning approach to check the
consistency between the name of a given method and its implementation. MNire first generates a candidate name and compares the
current name against it. If the two names are sufficiently similar, we consider the method as consistent. To generate the method name,
we draw our ideas and intuition from an empirical study on the nature of method names in a large dataset. Our key finding is that
high proportions of the tokens of method names can be found in the three contexts of a given method including its body,
the interface (the method’s parameter types and return type), and the enclosing class’ name. Even when such tokens are not there,
MNire uses the contexts to predict the tokens due to the high likelihoods of their co-occurrences. Our unique idea is to treat
the name generation as an abstract summarization on the tokens collected from the names of the program entities in the three
above contexts.</p>

<p>We conducted several experiments to evaluate MNire in method name consistency checking and in method name
recommending on large datasets with +14M methods. In detecting inconsistency method names, MNire improves the state-of-the-art
approach by 10.4% and 11% relatively in recall and precision, respectively. In method name recommendation, MNire improves relatively
over the state-of-the-art technique, code2vec, in both recall (18.2% higher) and precision (11.1% higher). To assess MNire’s usefulness,
we used it to detect inconsistent methods and suggest new names in several active, GitHub projects. We made 50 pull requests (PRs) and received
42 responses. Among them, five PRs were merged into the main branch, and 13 were approved for later merging. In total, in 31/42 cases,
the developer teams agree that our suggested names are more meaningful than the current names, showing MNire’s usefulness.</p>
</td>
	<td>naming </td>
</tr>

<tr>
	<td>2020</td>
	<td><a href="/publications/pandi2020opttyper/">OptTyper: Probabilistic Type Inference by Optimising Logical and Natural Constraints</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=OptTyper: Probabilistic Type Inference by Optimising Logical and Natural Constraints' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=OptTyper: Probabilistic Type Inference by Optimising Logical and Natural Constraints' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Irene Vlassi Pandi, Earl T. Barr, Andrew D. Gordon, Charles Sutton</td>
	<td></td>
	<td><p>We present a new approach to the type inference problem for dynamic languages. Our goal is to combine logical constraints, that is, deterministic information from a type system, with natural constraints, uncertain information about types from sources like identifier names. To this end, we introduce a framework for probabilistic type inference that combines logic and learning: logical constraints on the types are extracted from the program, and deep learning is applied to predict types from surface-level code properties that are statistically associated, such as variable names. The main insight of our method is to constrain the predictions from the learning procedure to respect the logical constraints, which we achieve by relaxing the logical inference problem of type prediction into a continuous optimisation problem. To evaluate the idea, we built a tool called OptTyper to predict a TypeScript declaration file for a JavaScript library. OptTyper combines a continuous interpretation of logical constraints derived by a simple program transformation and static analysis of the JavaScript code, with natural constraints obtained from a deep learning model, which learns naming conventions for types from a large codebase. We evaluate OptTyper on a data set of 5,800 open-source JavaScript projects that have type annotations in the well-known DefinitelyTyped repository. We find that combining logical and natural constraints yields a large improvement in performance over either kind of information individually, and produces 50% fewer incorrect type predictions than previous approaches.</p>
</td>
	<td>types bimodal </td>
</tr>



<tr>
	<td>2019</td>
	<td><a href="/publications/wan2019multimodal/">Multi-Modal Attention Network Learning for Semantic Source Code Retrieval</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Multi-Modal Attention Network Learning for Semantic Source Code Retrieval' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Multi-Modal Attention Network Learning for Semantic Source Code Retrieval' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yao Wan, Jingdong Shu, Yulei Sui, Guandong Xu, Zhou Zhao, Jian Wu, Philip S. Yu</td>
	<td></td>
	<td><p>Code retrieval techniques and tools have been playing a key role in facilitating software developers to retrieve existing code fragments from available open-source repositories given a user query. Despite the existing efforts in improving the effectiveness of code retrieval, there are still two main issues hindering them from being used to accurately retrieve satisfiable code fragments from large-scale repositories when answering complicated queries. First, the existing approaches only consider shallow features of source code such as method names and code tokens, but ignoring structured features such as abstract syntax trees (ASTs) and control-flow graphs (CFGs) of source code, which contains rich and well-defined semantics of source code. Second, although the deep learning-based approach performs well on the representation of source code, it lacks the explainability, making it hard to interpret the retrieval results and almost impossible to understand which features of source code contribute more to the final results.</p>

<p>To tackle the two aforementioned issues, this paper proposes MMAN, a novel Multi-Modal Attention Network for semantic source code retrieval. A comprehensive multi-modal representation is developed for representing unstructured and structured features of source code, with one LSTM for the sequential tokens of code, a Tree-LSTM for the AST of code and a GGNN (Gated Graph Neural Network) for the CFG of code. Furthermore, a multi-modal attention fusion layer is applied to assign weights to different parts of each modality of source code and then integrate them into a single hybrid representation. Comprehensive experiments and analysis on a large-scale real-world dataset show that our proposed model can accurately retrieve code snippets and outperforms the state-of-the-art methods.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/goens2019case/">A case study on machine learning for synthesizing benchmarks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A case study on machine learning for synthesizing benchmarks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A case study on machine learning for synthesizing benchmarks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Andrés Goens, Alexander Brauckmann, Sebastian Ertel, Chris Cummins, Hugh Leather, Jeronimo Castrillon</td>
	<td>MAPL</td>
	<td><p>Good benchmarks are hard to find because they require a substantial effort to keep them representative for the constantly changing challenges of a particular field. Synthetic benchmarks are a common approach to deal with this, and methods from machine learning are natural candidates for synthetic benchmark generation. In this paper we investigate the usefulness of machine learning in the prominent CLgen benchmark generator. We re-evaluate CLgen by comparing the benchmarks generated by the model with the raw data used to train it. This re-evaluation indicates that, for the use case considered, machine learning did not yield additional benefit over a simpler method using the raw data. We investigate the reasons for this and provide further insights into the challenges the problem could pose for potential future generators.</p>
</td>
	<td>code generation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/vasic2019neural/">Neural Program Repair by Jointly Learning to Localize and Repair</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Program Repair by Jointly Learning to Localize and Repair' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Program Repair by Jointly Learning to Localize and Repair' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Marko Vasic, Aditya Kanade, Petros Maniatis, David Bieber, Rishabh Singh</td>
	<td>ICLR</td>
	<td><p>Due to its potential to improve programmer productivity and software quality, automated program repair has been an active topic of research. Newer techniques harness neural networks to learn directly from examples of buggy programs and their fixes. In this work, we consider a recently identified class of bugs called variable-misuse bugs. The state-of-the-art solution for variable misuse enumerates potential fixes for all possible bug locations in a program, before selecting the best prediction. We show that it is beneficial to train a model that jointly and directly localizes and repairs variable-misuse bugs. We present multi-headed pointer networks for this purpose, with one head each for localization and repair. The experimental results show that the joint model significantly outperforms an enumerative solution that uses a pointer based model for repair alone.</p>
</td>
	<td>repair program analysis variable misuse </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/gao2019neural/">A Neural Model for Method Name Generation from Functional Description</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Neural Model for Method Name Generation from Functional Description' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Neural Model for Method Name Generation from Functional Description' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sa Gao, Chunyang Chen, Zhenchang Xing, Yukun Ma, Wen Song, Shang-Wei Lin</td>
	<td>SANER</td>
	<td><p>The names of software artifacts, e.g., method names, are important for software understanding and maintenance, as good names can help developers easily understand others’ code. However, the existing naming guidelines are difficult for developers, especially novices, to come up with meaningful, concise and compact names for the variables, methods, classes and files. With the popularity of open source, an enormous amount of project source code can be accessed, and the exhaustiveness and instability of manually naming methods could now be relieved by automatically learning a naming model from a large code repository. Nevertheless, building a comprehensive naming system is still challenging, due to the gap between natural language functional descriptions and method names. Specifically, there are three challenges: how to model the relationship between the functional descriptions and formal method names, how to handle the explosion of vocabulary when dealing with large repositories, and how to leverage the knowledge learned from large repositories to a specific project. To answer these questions, we propose a neural network to directly generate readable method names from natural language description. The proposed method is built upon the encoder-decoder framework with the attention and copying mechanisms. Our experiments show that our method can generate meaningful and accurate method names and achieve significant improvement over the state-of-the-art baseline models. We also address the cold-start problem using a training trick to utilize big data in GitHub for specific projects.</p>
</td>
	<td>naming summarization </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/fu2019coda/">Coda: An End-to-End Neural Program Decompiler</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Coda: An End-to-End Neural Program Decompiler' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Coda: An End-to-End Neural Program Decompiler' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Cheng Fu, Huili Chen, Haolan Liu, Xinyun Chen, Yuandong Tian, Farinaz Koushanfar, Jishen Zhao</td>
	<td>NeurIPS</td>
	<td><p>Reverse engineering of binary executables is a critical problem in the computer security domain. On the one hand, malicious parties may recover interpretable source codes from the software products to gain commercial advantages. On the other hand, binary decompilation can be leveraged for code vulnerability analysis and malware detection. However, efficient binary decompilation is challenging. Conventional decompilers have the following major limitations: (i) they are only applicable to specific source-target language pair, hence incurs undesired development cost for new language tasks; (ii) their output high-level code cannot effectively preserve the correct functionality of the input binary; (iii) their output program does not capture the semantics of the input and the reversed program is hard to interpret. To address the above problems, we propose Coda1, the first end-to-end neural-based framework for code decompilation. Coda decomposes the decompilation task into of two key phases: First, Coda employs an instruction type-aware encoder and a tree decoder for generating an abstract syntax tree (AST) with attention feeding during the code sketch generation stage. Second, Coda then updates the code sketch using an iterative error correction machine guided by an ensembled neural error predictor. By finding a good approximate candidate and then fixing it towards perfect, Coda achieves superior with performance compared to baseline approaches. We assess Coda’s performance with extensive experiments on various benchmarks. Evaluation results show that Coda achieves an average of 82% program recovery accuracy on unseen binary samples, where the state-of-the-art decompilers yield 0% accuracy. Furthermore, Coda outperforms the sequence-to-sequence model with attention by a margin of 70% program accuracy. Our work reveals the vulnerability of binary executables and imposes a new threat to the protection of Intellectual Property (IP) for software development.</p>
</td>
	<td>decompilation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/fernandes2019structured/">Structured Neural Summarization</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Structured Neural Summarization' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Structured Neural Summarization' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Patrick Fernandes, Miltiadis Allamanis, Marc Brockschmidt</td>
	<td>ICLR</td>
	<td><p>Summarization of long sequences into a concise statement is a core problem in natural language processing, requiring non-trivial understanding of the input. Based on the promising results of graph neural networks on highly structured data, we develop a framework to extend existing sequence encoders with a graph component that can reason about long-distance relationships in weakly structured data such as text. In an extensive evaluation, we show that the resulting hybrid sequence-graph models outperform both pure sequence models as well as pure graph models on a range of summarization tasks.</p>
</td>
	<td>summarization GNN documentation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/efstathiou2019semantic/">Semantic Source Code Models Using Identifier Embeddings</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Semantic Source Code Models Using Identifier Embeddings' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Semantic Source Code Models Using Identifier Embeddings' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vasiliki Efstathiou, Diomidis Spinellis</td>
	<td>MSR</td>
	<td><p>The emergence of online open source repositories in the recent years has led to an explosion in the volume of openly available source code, coupled with metadata that relate to a variety of software development activities. As an effect, in line with recent advances in machine learning research, software maintenance activities are switching from symbolic formal methods to data-driven methods. In this context, the rich semantics hidden in source code identifiers provide opportunities for building semantic representations of code which can assist tasks of code search and reuse. To this end, we deliver in the form of pretrained vector space models, distributed code representations for six popular programming languages, namely, Java, Python, PHP, C, C++, and C#. The models are produced using fastText, a state-of-the-art library for learning word representations. Each model is trained on data from a single programming language; the code mined for producing all models amounts to over 13.000 repositories. We indicate dissimilarities between natural language and source code, as well as variations in coding conventions in between the different programming languages we processed. We describe how these heterogeneities guided the data preprocessing decisions we took and the selection of the training parameters in the released models. Finally, we propose potential applications of the models and discuss limitations of the models.</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/ederhardt2019unsupervised/">Unsupervised Learning of API Aliasing Specifications</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Unsupervised Learning of API Aliasing Specifications' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Unsupervised Learning of API Aliasing Specifications' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jan Eberhardt, Samuel Steffen, Veselin Raychev, Martin Vechev</td>
	<td>PLDI</td>
	<td><p>Real world applications make heavy use of powerful libraries
and frameworks, posing a significant challenge for static analysis
as the library implementation may be very complex or unavailable.
Thus, obtaining specifications that summarize the behaviors of
the library is important as it enables static analyzers to precisely
track the effects of APIs on the client program, without requiring
the actual API implementation.</p>

<p>In this work, we propose a novel method
for discovering aliasing specifications of APIs by learning from a large
dataset of programs. Unlike prior work, our method does not require
manual annotation, access to the library’s source code or ability to
run its APIs. Instead, it learns specifications in a fully unsupervised manner,
by statically observing usages of APIs in the dataset. The core idea is to
learn a probabilistic model of interactions between API methods and aliasing
objects, enabling identification of additional likely aliasing relations,
and to then infer aliasing specifications ofAPIs that explain these relations.
The learned specifications are then used to augment an API-aware points-to analysis.</p>

<p>We implemented our approach in a tool called USpec and used it to automatically
learn aliasing specifications from millions of source code files.
USpec learned over 2000 specifications of various Java and Python APIs, in the process
improving the results of the points-to analysis and its clients.</p>
</td>
	<td>API program analysis </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/edelmann2019neural/">Neural-Network Guided Expression Transformation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural-Network Guided Expression Transformation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural-Network Guided Expression Transformation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Romain Edelmann, Viktor Kunčak</td>
	<td></td>
	<td><p>Optimizing compilers, as well as other translator systems, often work by rewriting expressions according to equivalence preserving rules. Given an input expression and its optimized form, finding the sequence of rules that were applied is a non-trivial task. Most of the time, the tools provide no proof, of any kind, of the equivalence between the original expression and its optimized form. In this work, we propose to reconstruct proofs of equivalence of simple mathematical expressions, after the fact, by finding paths of equivalence preserving transformations between expressions. We propose to find those sequences of transformations using a search algorithm, guided by a neural network heuristic. Using a Tree-LSTM recursive neural network, we learn a distributed representation of expressions where the Manhattan distance between vectors approximately corresponds to the rewrite distance between expressions. We then show how the neural network can be efficiently used to search for transformation paths, leading to substantial gain in speed compared to an uninformed exhaustive search. In one of our experiments, our neural-network guided search algorithm is able to solve more instances with a 2 seconds timeout per instance than breadth-first search does with a 5 minutes timeout per instance.</p>
</td>
	<td>optimization grammar </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/ding2019asm2vec/">Asm2Vec: Boosting Static Representation Robustness for Binary Clone Search against Code Obfuscation and Compiler Optimization</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Asm2Vec: Boosting Static Representation Robustness for Binary Clone Search against Code Obfuscation and Compiler Optimization' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Asm2Vec: Boosting Static Representation Robustness for Binary Clone Search against Code Obfuscation and Compiler Optimization' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Steven H. H. Ding, Benjamin C. M. Fung, Philippe Charland</td>
	<td>IEEE Symposium on Security and Privacy</td>
	<td><p>Reverse engineering is a manually intensive but necessary technique for understanding the inner workings of new malware, finding vulnerabilities in existing systems, and detecting patent infringements in released software. An assembly clone search engine facilitates the work of reverse engineers by identifying those duplicated or known parts. However, it is challenging to design a robust clone search engine, since there exist various compiler optimization options and code obfuscation techniques that make logically similar assembly functions appear to be very different. A practical clone search engine relies on a robust vector representation of assembly code. However, the existing clone search approaches, which rely on a manual feature engineering process to form a feature vector for an assembly function, fail to consider the relationships between features and identify those unique patterns that can statistically distinguish assembly functions. To address this problem, we propose to jointly learn the lexical semantic relationships and the vector representation of assembly functions based on assembly code. We have developed an assembly code representation learning model \emph{Asm2Vec}. It only needs assembly code as input and does not require any prior knowledge such as the correct mapping between assembly functions. It can find and incorporate rich semantic relationships among tokens appearing in assembly code. We conduct extensive experiments and benchmark the learning model with state-of-the-art static and dynamic clone search approaches. We show that the learned representation is more robust and significantly outperforms existing methods against changes introduced by obfuscation and optimizations.</p>
</td>
	<td>representation clone </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/tran2019recovering/">Recovering Variable Names for Minified Code with Usage Contexts</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Recovering Variable Names for Minified Code with Usage Contexts' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Recovering Variable Names for Minified Code with Usage Contexts' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hieu Tran, Ngoc Tran, Son Nguyen, Hoan Nguyen, Tien N. Nguyen</td>
	<td>ICSE</td>
	<td><p>In modern Web technology, JavaScript (JS) code plays an important role. To avoid the exposure of original source code, the variable names in JS code deployed in the wild are often replaced by short, meaningless names, thus making the code extremely difficult to manually understand and analysis. This paper presents JSNeat, an information retrieval (IR)-based approach to recover the variable names in minified JS code. JSNeat follows a data-driven approach to recover names by searching for them in a large corpus of open-source JS code. We use three types of contexts to match a variable in given minified code against the corpus including the context of properties and roles of the variable, the context of that variable and relations with other variables under recovery, and the context of the task of the function to which the variable contributes. We performed several empirical experiments to evaluate JSNeat on the dataset of more than 322K JS files with 1M functions, and 3.5M variables with 176K unique variable names. We found that JSNeat achieves a high accuracy of 69.1%, which is the relative improvements of 66.1% and 43% over two state-of-the-art approaches JSNice and JSNaughty, respectively. The time to recover for a file or for a variable with JSNeat is twice as fast as with JSNice and 4x as fast as with JNaughty, respectively.</p>
</td>
	<td>naming deobfuscation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/pradel2019typewriter/">TypeWriter: Neural Type Prediction with Search-based Validation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=TypeWriter: Neural Type Prediction with Search-based Validation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=TypeWriter: Neural Type Prediction with Search-based Validation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Michael Pradel, Georgios Gousios, Jason Liu, Satish Chandra.</td>
	<td></td>
	<td><p>Maintaining large code bases written in dynamically typed languages, such as JavaScript or Python, can be challenging: simple data compatibility errors proliferate, IDE support is lacking and APIs are harder to comprehend. Recent work attempts to address those issues through either static analysis or probabilistic type inference. Unfortunately, static type inference for dynamic languages is inherently limited, while probabilistic approaches suffer from imprecision. This paper presents TypeWriter, the first combination of probabilistic prediction with search-based refinement of predicted types. TypeWriter’s predictor learns to infer the return and argument types for functions from partially annotated code bases by combining the natural language properties of code with programming language-level information. To validate predicted types, TypeWriter invokes a gradual type checker with different combinations of the predicted types, while navigating the space of possible type combinations in a feedback-directed manner. We implement the TypeWriter approach for Python and evaluate it on two code corpora: a multi-million line code base at Facebook and a collection of 500 popular open-source projects. We show that TypeWriter’s type predictor achieves a precision of 64% (91%) and a recall of 52% (68%) in the top-1 (top-5) predictions, and demonstrate that usage contexts are a helpful addition to neural type predictors. By combining predictions with search-based validation, TypeWriter can fully annotate between 42% to 64% of the files in a randomly selected corpus, while ensuring type correctness. A comparison with a static type inference tool shows that TypeWriter adds many more non-trivial types. Overall, TypeWriter provides developers with an effective way to help with the transition to fully type-annotated code.</p>
</td>
	<td>types bimodal </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/hajipour2019samplefix/">SampleFix: Learning to Correct Programs by Sampling Diverse Fixes</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=SampleFix: Learning to Correct Programs by Sampling Diverse Fixes' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=SampleFix: Learning to Correct Programs by Sampling Diverse Fixes' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hossein Hajipour, Apratim Bhattacharyya, Cristian-Alexandru Staicu, Mario Fritz</td>
	<td></td>
	<td><p>Automatic program correction is an active topic of research, which holds the potential of dramatically improving productivity of programmers during the software development process and correctness of software in general. Recent advances in machine learning, deep learning and NLP have rekindled the hope to eventually fully automate the process of repairing programs. A key challenges is ambiguity, as multiple codes – or fixes – can implement the same functionality. In addition, dataset by nature fail to capture the variance introduced by such ambiguities. Therefore, we propose a deep generative model to automatically correct programming errors by learning a distribution of potential fixes. Our model is formulated as a deep conditional variational autoencoder that samples diverse fixes for the given erroneous programs. In order to account for ambiguity and inherent lack of representative datasets, we propose a novel regularizer to encourage the model to generate diverse fixes. Our evaluations on common programming errors show for the first time the generation of diverse fixes and strong improvements over the state-of-the-art approaches by fixing up to 61% of the mistakes.</p>
</td>
	<td>repair code generation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/habib2019neural/">Neural Bug Finding: A Study of Opportunities and Challenges</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Bug Finding: A Study of Opportunities and Challenges' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Bug Finding: A Study of Opportunities and Challenges' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Andrew Habib, Michael Pradel</td>
	<td></td>
	<td><p>Static analysis is one of the most widely adopted techniques to find software bugs before code is put in production. Designing and implementing effective and efficient static analyses is difficult and requires high expertise, which results in only a few experts able to write such analyses. This paper explores the opportunities and challenges of an alternative way of creating static bug detectors: neural bug finding. The basic idea is to formulate bug detection as a classification problem, and to address this problem with neural networks trained on examples of buggy and non-buggy code. We systematically study the effectiveness of this approach based on code examples labeled by a state-of-the-art, static bug detector. Our results show that neural bug finding is surprisingly effective for some bug patterns, sometimes reaching a precision and recall of over 80%, but also that it struggles to understand some program properties obvious to a traditional analysis. A qualitative analysis of the results provides insights into why neural bug finders sometimes work and sometimes do not work. We also identify pitfalls in selecting the code examples used to train and validate neural bug finders, and propose an algorithm for selecting effective training data.</p>
</td>
	<td>program analysis </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/tomczak2019simulating/">Simulating Execution Time of Tensor Programs using Graph Neural Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Simulating Execution Time of Tensor Programs using Graph Neural Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Simulating Execution Time of Tensor Programs using Graph Neural Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jakub M. Tomczak, Romain Lepert, Auke Wiggers</td>
	<td>Representation Learning on Graphs and Manifolds at ICLR</td>
	<td><p>Optimizing the execution time of tensor program, e.g., a convolution, involves finding its optimal configuration. Searching the configuration space exhaustively is typically infeasible in practice. In line with recent research using TVM, we propose to learn a surrogate model to overcome this issue. The model is trained on an acyclic graph called an abstract syntax tree, and utilizes a graph convolutional network to exploit structure in the graph. We claim that a learnable graph-based data processing is a strong competitor to heuristic-based feature extraction. We present a new dataset of graphs corresponding to configurations and their execution time for various tensor programs. We provide baselines for a runtime prediction task.</p>
</td>
	<td>GNN </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/gupta2019neural/">Neural Attribution for Semantic Bug-Localization in Student Programs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Attribution for Semantic Bug-Localization in Student Programs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Attribution for Semantic Bug-Localization in Student Programs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rahul Gupta, Aditya Kanade, Shirish Shevade</td>
	<td>NeurIPS</td>
	<td><p>Providing feedback is an integral part of teaching. Most open online courses on programming make use of automated grading systems to support programming assignments and give real-time feedback. These systems usually rely on test results to quantify the programs’ functional correctness. They return failing tests to the students as feedback. However, students may find it difficult to debug their programs if they receive no hints about where the bug is and how to fix it. In this work, we present NeuralBugLocator, a deep learning based technique, that can localize the bugs in a faulty program with respect to a failing test, without even running the program. At the heart of our technique is a novel tree convolutional neural network which is trained to predict whether a program passes or fails a given test. To localize the bugs, we analyze the trained network using a state-of-the-art neural prediction attribution technique and see which lines of the programs make it predict the test outcomes. Our experiments show that NeuralBugLocator is generally more accurate than two state-of-the-art program-spectrum based and one syntactic difference based bug-localization baselines.</p>
</td>
	<td>defect representation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/schrouff2019inferring/">Inferring Javascript types using Graph Neural Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Inferring Javascript types using Graph Neural Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Inferring Javascript types using Graph Neural Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jessica Schrouff, Kai Wohlfahrt, Bruno Marnette, Liam Atkinson</td>
	<td>Representation Learning on Graphs and Manifolds ICLR 2019 workshop</td>
	<td><p>The recent use of `Big Code’ with state-of-the-art deep learning methods offers promising avenues to ease program source code writing and correction. As a first step towards automatic code repair, we implemented a graph neural network model that predicts token types for Javascript programs. The predictions achieve an accuracy above 90%, which improves on previous similar work.</p>
</td>
	<td>GNN types program analysis </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/lu2019program/">Program Classification Using Gated Graph Attention Neural Network for Online Programming Service</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Program Classification Using Gated Graph Attention Neural Network for Online Programming Service' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Program Classification Using Gated Graph Attention Neural Network for Online Programming Service' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Mingming Lu, Dingwu Tan, Naixue Xiong, Zailiang Chen, Haifeng Li</td>
	<td></td>
	<td><p>The online programing services, such as Github, TopCoder, and EduCoder, have promoted a lot of social interactions among the service users. However, the existing social interactions is rather limited and inefficient due to the rapid increasing of source-code repositories, which is difficult to explore manually. The emergence of source-code mining provides a promising way to analyze those source codes, so that those source codes can be relatively easy to understand and share among those service users. Among all the source-code mining attempts,program classification lays a foundation for various tasks related to source-code understanding, because it is impossible for a machine to understand a computer program if it cannot classify the program correctly. Although numerous machine learning models, such as the Natural Language Processing (NLP) based models and the Abstract Syntax Tree (AST) based models, have been proposed to classify computer programs based on their corresponding source codes, the existing works cannot fully characterize the source codes from the perspective of both the syntax and semantic information. To address this problem, we proposed a Graph Neural Network (GNN) based model, which integrates data flow and function call information to the AST,and applies an improved GNN model to the integrated graph, so as to achieve the state-of-art program classification accuracy. The experiment results have shown that the proposed work can classify programs with accuracy over 97%.</p>
</td>
	<td>GNN representation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/he2019learning/">Learning to Fuzz from Symbolic Execution with Application to Smart Contracts</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Fuzz from Symbolic Execution with Application to Smart Contracts' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Fuzz from Symbolic Execution with Application to Smart Contracts' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jingxuan He, Mislav Balunović, Nodar Ambroladze, Petar Tsankov, Martin Vechev</td>
	<td>CCS</td>
	<td><p>Fuzzing and symbolic execution are two complementary techniques for discovering software vulnerabilities. Fuzzing is fast and scalable, but can be ineffective when it fails to randomly select the right inputs. Symbolic execution is thorough but slow and often does not scale to deep program paths with complex path conditions. In this work, we propose to learn an effective and fast fuzzer from symbolic execution, by phrasing the learning task in the framework of imitation learning. During learning, a symbolic execution expert generates a large number of quality inputs improving coverage on thousands of programs. Then, a fuzzing policy, represented with a suitable architecture of neural networks, is trained on the generated dataset. The learned policy can then be used to fuzz new programs. We instantiate our approach to the problem of fuzzing smart contracts, a domain where contracts often implement similar functionality (facilitating learning) and security is of utmost importance. We present an end-to-end system, ILF (for Imitation Learning based Fuzzer), and an extensive evaluation over &gt;18K contracts. Our results show that ILF is effective: (i) it is fast, generating 148 transactions per second, (ii) it outperforms existing fuzzers (e.g., achieving 33% more coverage), and (iii) it detects more vulnerabilities than existing fuzzing and symbolic execution tools for Ethereum.</p>
</td>
	<td>fuzzing GNN </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/tufano2019learning/">On Learning Meaningful Code Changes via Neural Machine Translation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=On Learning Meaningful Code Changes via Neural Machine Translation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=On Learning Meaningful Code Changes via Neural Machine Translation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Michele Tufano, Cody Watson, Gabriele Bavota, Massimiliano Di Penta, Martin White, Denys Poshyvanyk</td>
	<td>ICSE</td>
	<td><p>Recent years have seen the rise of Deep Learning (DL) techniques applied to source code. Researchers have exploited DL to automate several development and maintenance tasks, such as writing commit messages, generating comments and detecting vulnerabilities among others. One of the long lasting dreams of applying DL to code is the possibility to automate non-trivial coding activities. While some steps in this direction have been taken (e.g., learning how to fix bugs), there is still a lack of empirical evidence on the types of code changes that can be learned and automatically applied by DL. Our goal is to make this first step by quantitatively and qualitatively investigating the ability of a Neural Machine Translation (NMT) model to learn how to automatically apply code changes implemented by developers during pull requests. We train and experiment with the NMT model on a set of 236k pairs of code components before and after the implementation of the changes provided in the pull requests. We show that, when applied in a narrow enough context (i.e., small/medium-sized pairs of methods before/after the pull request changes), NMT can automatically replicate the changes implemented by developers during pull requests in up to 36% of the cases. Moreover, our qualitative analysis shows that the model is capable of learning and replicating a wide variety of meaningful code changes, especially refactorings and bug-fixing activities. Our results pave the way to novel research in the area of DL on code, such as the automatic learning and applications of refactoring.</p>
</td>
	<td>repair edit </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/sharma2019feasibility/">On the Feasibility of Transfer-learning Code Smells using Deep Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=On the Feasibility of Transfer-learning Code Smells using Deep Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=On the Feasibility of Transfer-learning Code Smells using Deep Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Tushar Sharma, Vasiliki Efstathiou, Panos Louridas, Diomidis Spinellis</td>
	<td></td>
	<td><p><strong>Context</strong>: A substantial amount of work has been done to detect smells in source code using metrics-based and heuristics-based methods. Machine learning methods have been recently applied to detect source code smells; however, the current practices are considered far from mature.</p>

<p><strong>Objective</strong>: First, explore the feasibility of applying deep learning models to detect smells without extensive feature engineering, just by feeding the source code in tokenized form. Second, investigate the possibility of applying transfer-learning in the context of deep learning models for smell detection.</p>

<p><strong>Method</strong>: We use existing metric-based state-of-the-art methods for detecting three implementation smells and one design smell in C# code. Using these results as the annotated gold standard, we train smell detection models on three different deep learning architectures. These architectures use Convolution Neural Networks (CNNs) of one or two dimensions, or Recurrent Neural Networks (RNNs) as their principal hidden layers. For the first objective of our study, we perform training and evaluation on C# samples, whereas for the second objective, we train the models from C# code and evaluate the models over Java code samples. We perform the experiments with various combinations of hyper-parameters for each model.</p>

<p><strong>Results</strong>: We find it feasible to detect smells using deep learning methods. Our comparative experiments find that there is no clearly superior method between CNN-1D and CNN-2D. We also observe that performance of the deep learning models is smell-specific. Our transfer-learning experiments show that transfer-learning is definitely feasible for implementation smells with performance comparable to that of direct-learning. This work opens up a new paradigm to detect code smells by transfer-learning especially for the programming languages where the comprehensive code smell detection tools are not available.</p>
</td>
	<td>representation program analysis </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/liu2019learning/">Learning to Sport and Refactor Inconsistent Method Names</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Sport and Refactor Inconsistent Method Names' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Sport and Refactor Inconsistent Method Names' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Kui Liu, Dongsun Kim, Tegawendé F. Bissyandé, Taeyoung Kim, Kisub Kim, Anil Koyuncu, Suntae Kim, Yves Le Traon</td>
	<td>ICSE</td>
	<td><p>To ensure code readability and facilitate software maintenance, program methods must be named properly. In particular, method names must be consistent with the corresponding method implementations. Debugging method names remains an important topic in the literature, where various approaches analyze commonalities among method names in a large dataset to detect inconsistent method names and suggest better ones. We note that the state-of-the-art does not analyze the implemented code itself to assess consistency. We thus propose a novel automated approach to debugging method names based on the analysis of consistency between method names and method code. The approach leverages deep feature representation techniques adapted to the nature of each artifact. Experimental results on over 2.1 million Java methods show that we can achieve up to 15 percentage points improvement over the state-of-the-art, establishing a record performance of 67.9% F1-measure in identifying inconsistent method names. We further demonstrate that our approach yields up to 25% accuracy in suggesting full names, while the state-of-the-art lags far behind at 1.1% accuracy. Finally, we report on our success in fixing 66 inconsistent method names in a live study on projects in the wild.</p>
</td>
	<td>naming </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/rabin2019testing/">Testing Neural Program Analyzers</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Testing Neural Program Analyzers' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Testing Neural Program Analyzers' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Md Rafiqul Islam Rabin, Ke Wang, Mohammad Amin Alipour</td>
	<td>ASE (LBR-Track)</td>
	<td><p>Deep neural networks have been increasingly used in software engineering and program analysis tasks. They usually take a program and make some predictions about it, e.g., bug prediction. We call these models neural program analyzers. The reliability of neural programs can impact the reliability of the encompassing analyses. In this paper, we describe our ongoing efforts to develop effective techniques for testing neural programs. We discuss the challenges involved in developing such tools and our future plans. In our preliminary experiment on a neural model recently proposed in the literature, we found that the model is very brittle, and simple perturbations in the input can cause the model to make mistakes in its prediction.</p>
</td>
	<td>evaluation refactoring </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/liu2019deepfuzz/">DeepFuzz: Automatic Generation of Syntax Valid C Programs for Fuzz Testing</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DeepFuzz: Automatic Generation of Syntax Valid C Programs for Fuzz Testing' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DeepFuzz: Automatic Generation of Syntax Valid C Programs for Fuzz Testing' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xiao Liu, Xiaoting Li, Rupesh Prajapati, Dinghao Wu</td>
	<td>AAAI</td>
	<td><p>Compilers  are among  the  most  fundamental  programming
tools for building software. However, production compilers
remain  buggy.  Fuzz  testing  is  often  leveraged  with  newly-generated,
or  mutated  inputs  in  order  to  find  new  bugs  or security vulnerabilities.
In this paper, we propose a grammar-based fuzzing tool called DeepFuzz. Based on a generative
Sequence-to-Sequence model, DeepFuzz automatically and continuously generates well-formed
C programs. We use this set of new C programs to fuzz off-the-shelf C compilers, e.g. GCC and Clang/LLVM.
We present a detailed case study to analyze  the  success  rate  and  coverage  improvement  of  the
generated C programs for fuzz testing. We analyze the performance of DeepFuzz with three types of sampling
methods  as  well  as  three  types  of  generation  strategies.  Consequently, DeepFuzz 
improved the testing efficacy in regards to the line, function, and branch coverage. In our preliminary
study, we found and reported 8 bugs of GCC, all of which are actively being addressed by developers.</p>
</td>
	<td>fuzzing code generation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/markovtsev2019style/">STYLE-ANALYZER: fixing code style inconsistencies with interpretable unsupervised algorithms</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=STYLE-ANALYZER: fixing code style inconsistencies with interpretable unsupervised algorithms' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=STYLE-ANALYZER: fixing code style inconsistencies with interpretable unsupervised algorithms' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vadim Markovtsev, Waren Long, Hugo Mougard, Konstantin Slavnov, Egor Bulychev</td>
	<td>MSR</td>
	<td><p>Source code reviews are manual, time-consuming, and expensive. Human involvement should be focused on analyzing the most relevant aspects of the program, such as logic and maintainability, rather than amending style, syntax, or formatting defects. Some tools with linting capabilities can format code automatically and report various stylistic violations for supported programming languages. They are based on rules written by domain experts, hence, their configuration is often tedious, and it is impractical for the given set of rules to cover all possible corner cases. Some machine learning-based solutions exist, but they remain uninterpretable black boxes. This paper introduces STYLE-ANALYZER, a new open source tool to automatically fix code formatting violations using the decision tree forest model which adapts to each codebase and is fully unsupervised. STYLE-ANALYZER is built on top of our novel assisted code review framework, Lookout. It accurately mines the formatting style of each analyzed Git repository and expresses the found format patterns with compact human-readable rules. STYLE-ANALYZER can then suggest style inconsistency fixes in the form of code review comments. We evaluate the output quality and practical relevance of STYLE-ANALYZER by demonstrating that it can reproduce the original style with high precision, measured on 19 popular JavaScript projects, and by showing that it yields promising results in fixing real style mistakes. STYLE-ANALYZER includes a web application to visualize how the rules are triggered. We release STYLE-ANALYZER as a reusable and extendable open source software package on GitHub for the benefit of the community.</p>
</td>
	<td>style </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/david2019neural/">Neural Reverse Engineering of Stripped Binaries</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Reverse Engineering of Stripped Binaries' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Reverse Engineering of Stripped Binaries' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yaniv David, Uri Alon, Eran Yahav</td>
	<td>ICLR</td>
	<td><p>We address the problem of predicting procedure names in stripped executables which contain no debug information.
Predicting procedure names can dramatically ease the task of reverse engineering, saving precious time and human effort. 
We present a novel approach that leverages static analysis of binaries with encoder-decoder-based neural networks.
The main idea is to use static analysis to obtain enriched representations of API call sites; encode a set of sequences
of these call sites; and finally, attend to the encoded sequences while decoding the target name token-by-token. 
We evaluate our model by predicting procedure names over 60,000 procedures in 10,000 stripped executables.
Our model achieves 81.70 precision and 80.12 recall in predicting procedure names within GNU packages, and 55.48
precision and 51.31 recall in a diverse, cross-package, dataset. Comparing to previous approaches,
the predictions made by our model are much more accurate and informative.</p>
</td>
	<td>naming deobfuscation GNN </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/commit2vec2019lozoya/">Commit2Vec: Learning Distributed Representations of Code Changes</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Commit2Vec: Learning Distributed Representations of Code Changes' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Commit2Vec: Learning Distributed Representations of Code Changes' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Adelina Ciurumelea; Sebastian Proksch; Harald C. Gall</td>
	<td></td>
	<td><p>Deep learning methods, which have found successful applications in fields like image classification and natural language processing, have recently been applied to source code analysis too, due to the enormous amount of freely available source code (e.g., from open-source software repositories).</p>

<p>In this work, we elaborate upon a state-of-the-art approach to the representation of source code that uses information about its syntactic structure, and we adapt it to represent source changes (i.e., commits). We use this representation to classify security-relevant commits.</p>

<p>Because our method uses transfer learning (that is, we train a network on a “pretext task” for which abundant labeled data is available, and then we use such network for the target task of commit classification, for which fewer labeled instances are available), we studied the impact of pre-training the network using two different pretext tasks versus a randomly initialized model.</p>

<p>Our results indicate that representations that leverage the structural information obtained through code syntax outperform token-based representations. Furthermore, the performance metrics obtained when pre-training on a loosely related pretext task with a very large dataset (&gt;10e6 samples) were surpassed when pretraining on a smaller dataset (&gt;10e4 samples) but for a pretext task that is more closely related to the target task.</p>
</td>
	<td>edit </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/rahman2019natural/">Natural Software Revisited</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Natural Software Revisited' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Natural Software Revisited' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Musfiqur Rahman, Dharani Palani, Peter C. Rigby</td>
	<td>ICSE</td>
	<td><p>Recent works have concluded that software is more repetitive and predictable, i.e. more natural, than English texts. These works included “simple/artificial” syntax rules in their language models. When we remove SyntaxTokens we find that code is still repetitive and predictable but only at levels slightly above English. Furthermore, previous works have compared individual Java programs to general English corpora, such as Gutenberg, which contains a historically large range of styles and subjects (e.g. Saint Augustine to Oscar Wilde). We perform an additional comparison of technical StackOverflow English discussions with source code and find that this restricted English is similarly repetitive to code. Although we find that code is less repetitive than previously thought, we suspect that API code element usage will be repetitive across software projects. For example a file is opened and closed in the same manner irrespective of domain. When we restrict our n-grams to those contained in the Java API we find that the entropy is significantly lower than the English corpora. Previous works have focused on sequential sequences of tokens. When we extract program graphs of size 2, 3, and 4 nodes we see that the abstract graph representation is much more concise and repetitive than the sequential representations of the same code. This suggests that future work should focus on statistical graph models that go beyond linear sequences of tokens. Our anonymous replication package makes our scripts and data available to future researchers and reviewers.</p>
</td>
	<td></td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/chibotaru2019scalable/">Scalable Taint Specification Inference with Big Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Scalable Taint Specification Inference with Big Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Scalable Taint Specification Inference with Big Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>V. Chibotaru, B. Bichsel, Veselin Raychev, Martin Vechev</td>
	<td>PLDI</td>
	<td><p>We present a new scalable, semi-supervised method for inferring
taint analysis specifications by learning from a large dataset of programs.
Taint specifications capture the role of library APIs (source, sink, sanitizer)
and are a critical ingredient of any taint analyzer that aims to detect
security violations based on information flow.</p>

<p>The core idea of our method
is to formulate the taint specification learning problem as a linear
optimization task over a large set of information flow constraints.
The resulting constraint system can then be efficiently solved with
state-of-the-art solvers. Thanks to its scalability, our method can infer
many new and interesting taint specifications by simultaneously learning from
a large dataset of programs (e.g., as found on GitHub), while requiring 
few manual annotations.</p>

<p>We implemented our method in an end-to-end system,
called Seldon, targeting Python, a language where static specification
inference is particularly hard due to lack of typing information.
We show that Seldon is practically effective: it learned almost 7,000 API
roles from over 210,000 candidate APIs with very little supervision
(less than 300 annotations) and with high estimated precision (67%).
Further,using the learned specifications, our taint analyzer flagged more than
20,000 violations in open source projects, 97% of which were
undetectable without the inferred specifications.</p>
</td>
	<td>defect program analysis </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/chen2019sequencer/">SequenceR: Sequence-to-Sequence Learning for End-to-End Program Repair</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=SequenceR: Sequence-to-Sequence Learning for End-to-End Program Repair' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=SequenceR: Sequence-to-Sequence Learning for End-to-End Program Repair' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zimin Chen, Steve Kommrusch, Michele Tufano, Louis-Noël Pouchet, Denys Poshyvanyk, Martin Monperrus</td>
	<td></td>
	<td><p>This paper presents a novel end-to-end approach to program repair based on sequence-to-sequence learning. We devise, implement, and evaluate a system, called SequenceR, for fixing bugs based on sequence-to-sequence learning on source code. This approach uses the copy mechanism to overcome the unlimited vocabulary problem that occurs with big code. Our system is data-driven; we train it on 35,578 commits, carefully curated from open-source repositories. We evaluate it on 4,711 independent real bug fixes, as well on the Defects4J benchmark used in program repair research. SequenceR is able to perfectly predict the fixed line for 950/4711 testing samples. It captures a wide range of repair operators without any domain-specific top-down design.</p>
</td>
	<td>repair code generation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/chen2019capturing/">Capturing source code semantics via tree-based convolution over API-enhanced AST</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Capturing source code semantics via tree-based convolution over API-enhanced AST' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Capturing source code semantics via tree-based convolution over API-enhanced AST' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Long Chen, Wei Ye, Shikun Zhang</td>
	<td>Computing Frontiers</td>
	<td><p>When deep learning meets big code, a key question is how to efficiently learn a distributed representation for source code that can capture its semantics effectively. We propose to use tree-based convolution over API-enhanced AST. To demonstrate the effectiveness of our approach, we apply it to detect semantic clones—code fragments with similar semantics but dissimilar syntax. Experiment results show that our approach outperforms an existing state-of-the-art approach that uses tree-based LSTM, with an increase of 0.39 and 0.12 in F1-score on OJClone and BigCloneBench respectively. We further propose architectures that incorporate our approach for code search and code summarization.</p>
</td>
	<td>grammar representation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/chen2019literature/">A Literature Study of Embeddings on Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Literature Study of Embeddings on Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Literature Study of Embeddings on Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zimin Chen, Martin Monperrus</td>
	<td></td>
	<td><p>Natural language processing has improved tremendously after the success of word embedding techniques such as word2vec. Recently, the same idea has been applied on source code with encouraging results. In this survey, we aim to collect and discuss the usage of word embedding techniques on programs and source code. The articles in this survey have been collected by asking authors of related work and with an extensive search on Google Scholar. Each article is categorized into five categories: 1. embedding of tokens 2. embedding of functions or methods 3. embedding of sequences or sets of method calls 4. embedding of binary code 5. other embeddings. We also provide links to experimental data and show some remarkable visualization of code embeddings. In summary, word embedding has been successfully applied on different granularities of source code. With access to countless open-source repositories, we see a great potential of applying other data-driven natural language processing techniques on source code in the future.</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/yefet2019adversarial/">Adversarial Examples for Models of Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Adversarial Examples for Models of Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Adversarial Examples for Models of Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Noam Yefet, Uri Alon, Eran Yahav</td>
	<td></td>
	<td><p>Neural models of code have shown impressive performance for tasks such as predicting method names and identifying certain kinds of bugs. In this paper, we show that these models are vulnerable to adversarial examples, and introduce a novel approach for attacking trained models of code with adversarial examples. The main idea is to force a given trained model to make an incorrect prediction as specified by the adversary by introducing small perturbations that do not change the program’s semantics. To find such perturbations, we present a new technique for Discrete Adversarial Manipulation of Programs (DAMP). DAMP works by deriving the desired prediction with respect to the model’s inputs while holding the model weights constant and following the gradients to slightly modify the code.</p>

<p>To defend a model against such attacks, we propose placing a defensive model (Anti-DAMP) in front of it. Anti-DAMP detects unlikely mutations and masks them before feeding the input to the downstream model.</p>

<p>We show that our DAMP attack is effective across three neural architectures: code2vec, GGNN, and GNN-FiLM, in both Java and C#. We show that DAMP has up to 89% success rate in changing a prediction to the adversary’s choice (“targeted attack”), and a success rate of up to 94% in changing a given prediction to any incorrect prediction (“non-targeted attack”). By using Anti-DAMP, the success rate of the attack drops drastically for both targeted and non-targeted attacks, with a minor penalty of 2% relative degradation in accuracy while not performing under attack.</p>
</td>
	<td>adversarial </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/chen2019mining/">Mining Likely Analogical APIs across Third-Party Libraries via Large-Scale Unsupervised API Semantics Embedding</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Mining Likely Analogical APIs across Third-Party Libraries via Large-Scale Unsupervised API Semantics Embedding' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Mining Likely Analogical APIs across Third-Party Libraries via Large-Scale Unsupervised API Semantics Embedding' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Chunyang Chen, Zhenchang Xing, Yang Liu, Kent Ong Long Xiong</td>
	<td>TSE</td>
	<td><p>Establishing API mappings between third-party libraries is a prerequisite step for library migration tasks. Manually establishing API mappings is tedious due to the large number of APIs to be examined. Having an automatic technique to create a database of likely API mappings can significantly ease the task. Unfortunately, existing techniques either adopt supervised learning mechanism that requires already-ported or functionality similar applications across major programming languages or platforms, which are difficult to come by for an arbitrary pair of third-party libraries, or cannot deal with lexical gap in the API descriptions of different libraries. To overcome these limitations, we present an unsupervised deep learning based approach to embed both API usage semantics and API description (name and document) semantics into vector space for inferring likely analogical API mappings between libraries. Based on deep learning models trained using tens of millions of API call sequences, method names and comments of 2.8 millions of methods from 135,127 GitHub projects, our approach significantly outperforms other deep learning or traditional information retrieval (IR) methods for inferring likely analogical APIs. We implement a proof-of-concept website which can recommend analogical APIs for 583,501 APIs of 111 pairs of analogical Java libraries with diverse functionalities. This scale of third-party analogical-API database has never been achieved before.</p>
</td>
	<td>API representation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/cambronero2019deep/">When Deep Learning Met Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=When Deep Learning Met Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=When Deep Learning Met Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jose Cambronero, Hongyu Li, Seohyun Kim, Koushik Sen, Satish Chandra</td>
	<td></td>
	<td><p>There have been multiple recent proposals on using deep neural networks for code search using natural language. Common across these proposals is the idea of embedding code and natural language queries, into real vectors and then using vector distance to approximate semantic correlation between code and the query. Multiple approaches exist for learning these embeddings, including unsupervised techniques, which rely only on a corpus of code examples, and supervised techniques, which use an aligned corpus of paired code and natural language descriptions. The goal of this supervision is to produce embeddings that are more similar for a query and the corresponding desired code snippet.</p>

<p>Clearly, there are choices in whether to use supervised techniques at all, and if one does, what sort of network and training to use for supervision. This paper is the first to evaluate these choices systematically. To this end, we assembled implementations of state-of-the-art techniques to run on a common platform, training and evaluation corpora. To explore the design space in network complexity, we also introduced a new design point that is a minimal supervision extension to an existing unsupervised technique.</p>

<p>Our evaluation shows that: 1. adding supervision to an existing unsupervised technique can improve performance, though not necessarily by much; 2. simple networks for supervision can be more effective that more sophisticated sequence-based networks for code search; 3. while it is common to use docstrings to carry out supervision, there is a sizeable gap between the effectiveness of docstrings and a more query-appropriate supervision corpus.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/bui2019learning/">SAR: Learning Cross-Language API Mappings with Little Knowledge</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=SAR: Learning Cross-Language API Mappings with Little Knowledge' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=SAR: Learning Cross-Language API Mappings with Little Knowledge' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>N. D. Q. Bui, Y. Yu, L. Jiang</td>
	<td>FSE</td>
	<td><p>To save manual effort, developers often translate programs from one programming language to another, instead of implementing it from scratch. Translating application program interfaces (APIs) used in one language to functionally equivalent ones available in another language is an important aspect of program translation. Existing approaches facilitate the translation by automatically identifying the API mappings across programming languages. However, all these approaches still require large amount of manual effort in preparing parallel program corpora, ranging from pairs of APIs, to manually identified code in different languages that are considered as functionally equivalent. To minimize the manual effort in identifying parallel program corpora and API mappings, this paper aims at an automated approach to map APIs across languages with much less knowledge a priori needed than other existing approaches. The approach is based on an realization of the notion of domain adaption combined with code embedding, which can better align two vector spaces: taking as input large sets of programs, our approach first generates numeric vector representations of the programs, especially the APIs used in each language, and it adapts generative adversarial networks (GAN) to align the vectors from the spaces of two languages. For a better alignment, we initialize the GAN with parameters derived from optional API mapping seeds that can be identified accurately with a simple automatic signature-based matching heuristic. Then the cross-language API mappings can be identified via nearest-neighbors queries in the aligned vector spaces.</p>
</td>
	<td>representation API </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/she2019neuzz/">NEUZZ: Efficient Fuzzing with Neural Program Smoothing</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=NEUZZ: Efficient Fuzzing with Neural Program Smoothing' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=NEUZZ: Efficient Fuzzing with Neural Program Smoothing' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Dongdong She, Kexin Pei, Dave Epstein, Junfeng Yang, Baishakhi Ray, Suman Jana</td>
	<td>IEEE S&P</td>
	<td><p>Fuzzing has become the de facto standard technique for finding software vulnerabilities. However, even state-of-the-art fuzzers are not very efficient at finding hard-to-trigger software bugs. Most popular fuzzers use evolutionary guidance to generate inputs that can trigger different bugs. Such evolutionary algorithms, while fast and simple to implement, often get stuck in fruitless sequences of random mutations. Gradient-guided optimization presents a promising alternative to evolutionary guidance. Gradient-guided techniques have been shown to significantly outperform evolutionary algorithms at solving high-dimensional structured optimization problems in domains like machine learning by efficiently utilizing gradients or higher-order derivatives of the underlying function. However, gradient-guided approaches are not directly applicable to fuzzing as real-world program behaviors contain many discontinuities, plateaus, and ridges where the gradient-based methods often get stuck. We observe that this problem can be addressed by creating a smooth surrogate function approximating the discrete branching behavior of target program. In this paper, we propose a novel program smoothing technique using surrogate neural network models that can incrementally learn smooth approximations of a complex, real-world program’s branching behaviors. We further demonstrate that such neural network models can be used together with gradient-guided input generation schemes to significantly improve the fuzzing efficiency. Our extensive evaluations demonstrate that NEUZZ significantly outperforms 10 state-of-the-art graybox fuzzers on 10 real-world programs both at finding new bugs and achieving higher edge coverage. NEUZZ found 31 unknown bugs that other fuzzers failed to find in 10 real world programs and achieved 3X more edge coverage than all of the tested graybox fuzzers for 24 hours running.</p>
</td>
	<td>fuzzing </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/buech2019learning/">Learning-based Recursive Aggregation of Abstract Syntax Trees for Code Clone Detection</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning-based Recursive Aggregation of Abstract Syntax Trees for Code Clone Detection' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning-based Recursive Aggregation of Abstract Syntax Trees for Code Clone Detection' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Lutz Büch, Artur Andrzejak</td>
	<td>SANER</td>
	<td><p>Code clone detection remains a crucial challenge in maintaining software projects. Many classic approaches rely on handcrafted aggregation schemes, while recent work uses supervised or unsupervised learning. In this work, we study several aspects of aggregation schemes for code clone detection based on supervised learning. To this aim, we implement an AST-based Recursive Neural Network. Firstly, our ablation study shows the influence of model choices and hyperparameters. We introduce error scaling as a way to effectively and efficiently address the class imbalance problem arising in code clone detection. Secondly, we study the influence of pretrained embeddings representing nodes in ASTs. We show that simply averaging all node vectors of a given AST yields strong baseline aggregation scheme. Further, learned AST aggregation schemes greatly benefit from pretrained node embeddings. Finally, we show the importance of carefully separating training and test data by clone clusters, to reliably measure generalization of models learned with supervision.</p>
</td>
	<td>grammar grammar clone </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/brockschmidt2019generative/">Generative Code Modeling with Graphs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Generative Code Modeling with Graphs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Generative Code Modeling with Graphs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Marc Brockschmidt, Miltiadis Allamanis, Alexander L. Gaunt, Oleksandr Polozov</td>
	<td>ICLR</td>
	<td><p>Generative models forsource code are an interesting structured prediction problem, requiring to reason about both hard syntactic and semantic constraints as well as about natural, likely programs. We present a novel model for this problem that uses a graph to represent the intermediate state of the generated output. Our model generates code by interleaving grammar-driven expansion steps with graph augmentation and neural message passing steps. An experimental evaluation shows that our new model can generate semantically meaningful expressions, outperforming a range of strong baselines.</p>
</td>
	<td>grammar code generation GNN </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/xu2019commit/">Commit Message Generation for Source Code Changes</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Commit Message Generation for Source Code Changes' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Commit Message Generation for Source Code Changes' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shengbin Xu, Yuan Yao, Feng Xu, Tianxiao Gu, Hanghang Tong, Jian Lu</td>
	<td>IJCAI</td>
	<td><p>Commit  messages,  which  summarize  the  source
code changes in natural language, are essential for
program comprehension and software evolution understanding.  Unfortunately, due to the lack of direct
motivation,  commit  messages  are  sometimes neglected  by  developers,  making  it  necessary  to
automatically  generate  such  messages.    State-of-the-art  adopts  learning  based  approaches  such  as
neural machine translation models for the commitmessage generation problem.  However, they tend
to  ignore  the  code  structure  information  and  suffer from the out-of-vocabulary issue.
In this paper, we  propose  CODISUM to  address  the  above  two limitations. In particular,
we first extract both code structure and code semantics from the source code changes, and then
jointly model these two sources of  information  so  as  to  better  learn  the  representations
 of  the  code  changes.   Moreover,  we  augment  the  model  with  copying  mechanism  to  further
mitigate  the  out-of-vocabulary  issue.   Experimental  evaluations  on  real  data  demonstrate  that
the  proposed  approach  significantly  outperforms the state-of-the-art in terms of accurately generating the commit messages.</p>
</td>
	<td>edit summarization </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/bavishi2019autopandas/">AutoPandas: neural-backed generators for program synthesis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=AutoPandas: neural-backed generators for program synthesis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=AutoPandas: neural-backed generators for program synthesis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rohan Bavishi, Caroline Lemieux, Roy Fox, Koushik Sen, Ion Stoica</td>
	<td>OOPSLA</td>
	<td><p>Developers nowadays have to contend with a growing number of APIs. While in the long-term they are very useful to developers, many modern APIs have an incredibly steep learning curve, due to their hundreds of functions handling many arguments, obscure documentation, and frequently changing semantics. For APIs that perform data transformations, novices can often provide an I/O example demonstrating the desired transformation, but may be stuck on how to translate it to the API. A programming-by-example synthesis engine that takes such I/O examples and directly produces programs in the target API could help such novices. Such an engine presents unique challenges due to the breadth of real-world APIs, and the often-complex constraints over function arguments. We present a generator-based synthesis approach to contend with these problems. This approach uses a program candidate generator, which encodes basic constraints on the space of programs. We introduce neural-backed operators which can be seamlessly integrated into the program generator. To improve the efficiency of the search, we simply use these operators at non-deterministic decision points, instead of relying on domain-specific heuristics. We implement this technique for the Python pandas library in AutoPandas. AutoPandas supports 119 pandas dataframe transformation functions. We evaluate AutoPandas on 26 real-world benchmarks and find it solves 17 of them.</p>
</td>
	<td>synthesis GNN API </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/yonai2019mercem/">Mercem: Method Name Recommendation Based on Call Graph Embedding</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Mercem: Method Name Recommendation Based on Call Graph Embedding' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Mercem: Method Name Recommendation Based on Call Graph Embedding' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hiroshi Yonai, Yasuhiro Hayase, Hiroyuki Kitagawa</td>
	<td></td>
	<td><p>Comprehensibility of source code is strongly affected by identifier names, therefore software developers need to give good (e.g. meaningful but short) names to identifiers. On the other hand, giving a good name is sometimes a difficult and time-consuming task even for experienced developers. To support naming identifiers, several techniques for recommending identifier name candidates have been proposed. These techniques, however, still have challenges on the goodness of suggested candidates and limitations on applicable situations. This paper proposes a new approach to recommending method names by applying graph embedding techniques to the method call graph. The evaluation experiment confirms that the proposed technique can suggest more appropriate method name candidates in difficult situations than the state of the art approach.</p>
</td>
	<td>naming representation refactoring </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/barchi2019code/">Code Mapping in Heterogeneous Platforms Using Deep Learning and LLVM-IR</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Code Mapping in Heterogeneous Platforms Using Deep Learning and LLVM-IR' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Code Mapping in Heterogeneous Platforms Using Deep Learning and LLVM-IR' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Francesco Barchi, Gianvito Urgese, Enrico Macii, Andrea Acquaviva</td>
	<td>DAC</td>
	<td><p>Modern heterogeneous platforms require compilers capable of choosing the appropriate device for the execution of program portions. This paper presents a machine learning method designed for supporting mapping decisions through the analysis of the program source code represented in LLVM assembly language (IR) for exploiting the advantages offered by this generalised and optimised representation. To evaluate our solution, we trained an LSTM neural network on OpenCL kernels compiled in LLVM-IR and processed with our tokenizer capable of filtering less-informative tokens. We tested the network that reaches an accuracy of 85% in distinguishing the best computational unit.</p>
</td>
	<td>optimization program analysis static analysis natural language processing </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/yao2019coacor/">CoaCor: Code Annotation for Code Retrieval with Reinforcement Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CoaCor: Code Annotation for Code Retrieval with Reinforcement Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CoaCor: Code Annotation for Code Retrieval with Reinforcement Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ziyu Yao, Jayavardhan Reddy Peddamail, Huan Sun</td>
	<td></td>
	<td><p>To accelerate software development, much research has been performed
to help people understand and reuse the huge amount of available code
resources. Two important tasks have been widely studied: code retrieval,
which aims to retrieve code snippets relevant to a given natural language
query from a code base, and code annotation, where the goal is to annotate a 
code snippet with anatural language description. Despite their advancement in recent
years, the two tasks are mostly explored separately. In this work, we
investigate a novel perspective of Code annotation for Code retrieval 
(hence called “CoaCor”), where a code annotation model is trained
to generate a natural language annotation that can represent the
semantic meaning of a given code snippet and can be leveraged by
a code retrieval model to better distinguish relevant code snippets
from others. To this end, we propose an effective framework based
on reinforcement learning, which explicitly encourages the code
annotation model to generate annotations that can be used for the
retrieval task. Through extensive experiments, we show that code
annotations generated by our framework are much more detailed
and more useful for code retrieval, and they can further improve
the performance of existing code retrieval models significantly.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/sun2019grammar/">A Grammar-Based Structural CNN Decoder for Code Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Grammar-Based Structural CNN Decoder for Code Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Grammar-Based Structural CNN Decoder for Code Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zeyu Sun, Qihao Zhu, Lili Mou, Yingfei Xiong, Ge Li, Lu Zhang</td>
	<td>AAAI</td>
	<td><p>Code  generation  maps  a  program  description  to  executable
source code in a programming language. Existing approaches
mainly rely on a recurrent neural network (RNN) as the decoder. However, we find that a program contains significantly
more tokens than a natural language sentence, and thus it may
be inappropriate for RNN to capture such a long sequence. In
this paper, we propose a grammar-based structural convolutional neural network (CNN) for code generation. Our model
generates a program by predicting the grammar rules of the
programming language; we design several CNN modules, including the tree-based convolution and pre-order convolution,
whose information is further aggregated by dedicated attentive pooling layers. Experimental results on the HearthStone
benchmark dataset show that our CNN code generator significantly outperforms the previous state-of-the-art method by 5
percentage points; additional experiments on several semantic parsing tasks demonstrate the robustness of our model. We
also conduct in-depth ablation test to better understand each
component of our model.</p>
</td>
	<td>code generation grammar </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/alon2019code2vec/">code2vec: Learning Distributed Representations of Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=code2vec: Learning Distributed Representations of Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=code2vec: Learning Distributed Representations of Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Uri Alon, Omer Levy, Eran Yahav</td>
	<td>POPL</td>
	<td><p>We present a neural model for representing snippets of code as continuous distributed vectors (“code embeddings”).
 The main idea is to represent a code snippet as a single fixed-length
code vector, which can be used to
predict semantic properties of the snippet. To this end, code is first decomposed to a collection of paths in its
abstract syntax tree. Then, the network learns the atomic representation of each path while
simultaneously
learning how to aggregate a set of them.</p>

<p>We demonstrate the effectiveness of our approach by using it to predict a method’s name from the vector
representation of its body. We evaluate our approach by training a model on a dataset of 12M methods. We
show that code vectors trained on this dataset can predict method names from files that were unobserved
during training. Furthermore, we show that our model learns useful method name vectors that capture
semantic similarities, combinations, and analogies.</p>

<p>A comparison of our approach to previous techniques over the same dataset shows an improvement of
more than 75%, making it the first to successfully predict method names based on a large, cross-project
corpus. Our trained model, visualizations and vector similarities are available as an interactive online demo at
http://code2vec.org. The code, data and trained models are available at
https://github.com/tech-srl/code2vec.</p>
</td>
	<td>naming summarization representation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/alon2019structural/">Structural Language Models for Any-Code Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Structural Language Models for Any-Code Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Structural Language Models for Any-Code Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Uri Alon, Roy Sadaka, Omer Levy, Eran Yahav</td>
	<td></td>
	<td><p>We address the problem of Any-Code Generation (AnyGen) - generating code without any restriction on the vocabulary or structure. The state-of-the-art in this problem is the sequence-to-sequence (seq2seq) approach, which treats code as a sequence and does not leverage any structural information. We introduce a new approach to AnyGen that leverages the strict syntax of programming languages to model a code snippet as a tree - structural language modeling (SLM). SLM estimates the probability of the program’s abstract syntax tree (AST) by decomposing it into a product of conditional probabilities over its nodes. We present a neural model that computes these conditional probabilities by considering all AST paths leading to a target node. Unlike previous structural techniques that have severely restricted the kinds of expressions that can be generated, our approach can generate arbitrary expressions in any programming language. Our model significantly outperforms both seq2seq and a variety of existing structured approaches in generating Java and C# code. We make our code, datasets, and models available online.</p>
</td>
	<td>code generation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/allamanis2019adverse/">The Adverse Effects of Code Duplication in Machine Learning Models of Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=The Adverse Effects of Code Duplication in Machine Learning Models of Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=The Adverse Effects of Code Duplication in Machine Learning Models of Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Miltiadis Allamanis</td>
	<td></td>
	<td><p>The field of big code relies on mining large corpora of code to perform some learning task. A significant threat to this approach has been recently identified by Lopes et al. (2017) who found a large amount of code duplication on GitHub. However, the impact of code duplication has not been noticed by researchers devising machine learning models for source code. In this article, we study the effect of code duplication to machine learning models showing that reported metrics are sometimes inflated by up to 100% when testing on duplicated code corpora compared to the performance on de-duplicated corpora which more accurately represent how machine learning models of code are used by software engineers. We present an “errata” for widely used datasets, list best practices for collecting code corpora and evaluating machine learning models on them, and release tools to help the community avoid this problem in future research.</p>
</td>
	<td>dataset evaluation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/xu2019method/">Method name suggestion with hierarchical attention networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Method name suggestion with hierarchical attention networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Method name suggestion with hierarchical attention networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sihan Xu, Sen Zhang, Weijing Wang, Xinya Cao, Chenkai Guo, Jing Xu.</td>
	<td>PEPM</td>
	<td><p>Method Rename has been a widely used refactoring operation that improves program comprehension and maintenance. Descriptive method names that summarize functionalities of source code can facilitate program comprehension. Much research has been done to suggest method names through source code summarization. However, unlike natural language, a code snippet consists of basic blocks organized by complicated structures. In this work, we observe a hierarchical structure — tokens form basic blocks and basic blocks form a code snippet. Based on this observation, we exploit a hierarchical attention network to learn the representation of methods. Specifically, we apply two-level attention mechanism to learn the importance of each token in a basic block and that of a basic block in a method respectively. We evaluated our approach on 10 open source repositories and compared it against three state-of-the-art approaches. The results on these open-source data show the superiority of our hierarchical attention networks in terms of effectiveness.</p>
</td>
	<td>naming </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/yin2019learning/">Learning to Represent Edits</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Represent Edits' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Represent Edits' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Pengcheng Yin, Graham Neubig, Miltiadis Allamanis, Marc Brockschmidt, Alexander L. Gaunt</td>
	<td>ICLR</td>
	<td><p>We introduce the problem of learning distributed representations of edits. By combining a
“neural editor” with an “edit encoder”, our models learn to represent the salient
information of an edit and can be used to apply edits to new inputs.
We experiment on natural language and source code edit data. Our evaluation yields
promising results that suggest that our neural network models learn to capture
the structure and semantics of edits. We hope that this interesting task and
data source will inspire other researchers to work further on this problem.</p>
</td>
	<td>edit </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/ahmed2019learning/">Learning Lenient Parsing & Typing via Indirect Supervision</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Lenient Parsing & Typing via Indirect Supervision' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Lenient Parsing & Typing via Indirect Supervision' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Toufique Ahmed, Vincent Hellendoorn, Premkumar Devanbu</td>
	<td></td>
	<td><p>Both professional coders and teachers frequently deal with imperfect (fragmentary, incomplete, ill-formed) code. Such fragments are common in StackOverflow; students also frequently produce ill-formed code, for which instructors, TAs (or students themselves) must find repairs. In either case, the developer experience could be greatly improved if such code could somehow be parsed &amp; typed; this makes them more amenable to use within IDEs and allows early detection and repair of potential errors. We introduce a lenient parser, which can parse &amp; type fragments, even ones with simple errors. Training a machine learner to leniently parse &amp; type imperfect code requires a large training set of pairs of imperfect code and its repair (and/or type information); such training sets are limited by human effort and curation. In this paper, we present a novel indirectly supervised approach to train a lenient parser, without access to such human-curated training data. We leverage the huge corpus of mostly correct code available on Github, and the massive, efficient learning capacity of Transformer-based NN architectures. Using GitHub data, we first create a large dataset of fragments of code and corresponding tree fragments and type annotations; we then randomly corrupt the input fragments (while requiring correct output) by seeding errors that mimic corruptions found in StackOverflow and student data. Using this data, we train high-capacity transformer models to overcome both fragmentation and corruption. With this novel approach, we can achieve reasonable performance on parsing &amp; typing StackOverflow fragments; we also demonstrate that our approach achieves best-in-class performance on a large dataset of student errors.</p>
</td>
	<td>types </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/alon2018code2seq/">code2seq: Generating Sequences from Structured Representations of Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=code2seq: Generating Sequences from Structured Representations of Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=code2seq: Generating Sequences from Structured Representations of Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Uri Alon, Omer Levy, Eran Yahav</td>
	<td>ICLR</td>
	<td><p>The ability to generate natural language sequences from source code snippets has a variety of applications such as code summarization, documentation, and retrieval. Sequence-to-sequence (seq2seq) models, adopted from neural machine translation (NMT), have achieved state-of-the-art performance on these tasks by treating source code as a sequence of tokens. We present code2seq: an alternative approach that leverages the syntactic structure of programming languages to better encode source code. Our model represents a code snippet as the set of compositional paths in its abstract syntax tree (AST) and uses attention to select the relevant paths while decoding.</p>

<p>We demonstrate the effectiveness of our approach for two tasks, two programming languages, and four datasets of up to 16M examples. Our model significantly outperforms previous models that were specifically designed for programming languages, as well as general state-of-the-art NMT models. An interactive online demo of our model is available at http://code2seq.org.</p>
</td>
	<td>naming summarization representation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/agashe2019julce/">JuICe: A Large Scale Distantly Supervised Dataset for Open Domain Context-based Code Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=JuICe: A Large Scale Distantly Supervised Dataset for Open Domain Context-based Code Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=JuICe: A Large Scale Distantly Supervised Dataset for Open Domain Context-based Code Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rajas Agashe, Srinivasan Iyer, Luke Zettlemoyer</td>
	<td></td>
	<td><p>Interactive programming with interleaved code snippet cells and natural language markdown is recently gaining popularity in the form of Jupyter notebooks, which accelerate prototyping and collaboration. To study code generation conditioned on a long context history, we present JuICe, a corpus of 1.5 million examples with a curated test set of 3.7K instances based on online programming assignments. Compared with existing contextual code generation datasets, JuICe provides refined human-curated data, open-domain code, and an order of magnitude more training data. Using JuICe, we train models for two tasks: (1) generation of the API call sequence in a code cell, and (2) full code cell generation, both conditioned on the NL-Code history up to a particular code cell. Experiments using current baseline code generation models show that both context and distant supervision aid in generation, and that the dataset is challenging for current systems.</p>
</td>
	<td>dataset bimodal </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/siow2019core/">CORE: Automating Review Recommendation for Code Changes</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CORE: Automating Review Recommendation for Code Changes' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CORE: Automating Review Recommendation for Code Changes' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>JingKai Siow, Cuiyun Gao, Lingling Fan, Sen Chen, Yang Liu</td>
	<td>SANER</td>
	<td><p>Code review is a common process that is used by developers, in which a reviewer provides useful comments or points out defects in the submitted source code changes via pull request. Code review has been widely used for both industry and open-source projects due to its capacity in early defect identification, project maintenance, and code improvement. With rapid updates on project developments, code review becomes a non-trivial and labor-intensive task for reviewers. Thus, an automated code review engine can be beneficial and useful for project development in practice. Although there exist prior studies on automating the code review process by adopting static analysis tools or deep learning techniques, they often require external sources such as partial or full source code for accurate review suggestion. In this paper, we aim at automating the code review process only based on code changes and the corresponding reviews but with better performance. The hinge of accurate code review suggestion is to learn good representations for both code changes and reviews. To achieve this with limited source, we design a multi-level embedding (i.e., word embedding and character embedding) approach to represent the semantics provided by code changes and reviews. The embeddings are then well trained through a proposed attentional deep learning model, as a whole named CORE. We evaluate the effectiveness of CORE on code changes and reviews collected from 19 popular Java projects hosted on Github. Experimental results show that our model CORE can achieve significantly better performance than the state-of-the-art model (DeepMem), with an increase of 131.03% in terms of Recall@10 and 150.69% in terms of Mean Reciprocal Rank. Qualitative general word analysis among project developers also demonstrates the performance of CORE in automating code review.</p>
</td>
	<td>review </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/nguyen2019graph/">Graph-based Mining of In-the-Wild, Fine-grained, Semantic Code Change Patterns</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Graph-based Mining of In-the-Wild, Fine-grained, Semantic Code Change Patterns' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Graph-based Mining of In-the-Wild, Fine-grained, Semantic Code Change Patterns' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hoan Anh Nguyen, Tien N. Nguyen, Danny Dig, Son Nguyen, Hieu Tran, and Michael Hilton</td>
	<td>ICSE</td>
	<td><p>Existing approaches for detecting repetitive code changes relying on syntactic similarity cannot effectively detect semantic change patterns. In this work, we introduce a novel graph-based mining approach, CPatMiner, which is capable of detecting semantic code change patterns from a large number of open-source repositories by capturing dependencies between fine-grained change elements. We evaluated CPatMiner by mining change patterns in a diverse corpus of 5,000+ open-source projects from GitHub with 170,000+ developers. We use three complementary methods. First, we sent the mined patterns to the authors and received 108 responses. 70% of respondents recognized those patterns as their meaningful frequent changes. 79% of respondents even named the patterns, and 44% wanted IDEs to automate such repetitive changes. The mined patterns belong to various activities: adaptive (9%), perfective (20%), corrective (35%) and preventive (36%). Second, we compared CPatMiner with the state-of-the-art, AST-based technique, and reported that CPatMiner detects 2.1x more meaningful patterns. Third, we used CPatMiner to search for patterns in a corpus of 88 GitHub projects with longer histories consisting of 164M SLOCs. It constructed 322K fine-grained change graphs containing 3M nodes, and detected 17K change patterns which provide unique insights on the practice of change patterns among individuals and teams. We found that a large percentage (75%) of the patterns from individual developers are commonly shared with others, and this holds true for teams. Moreover, we found that the patterns spread widely over time. Thus, we call for a community-based change pattern database to provide important resources in novel applications.</p>
</td>
	<td>edit pattern mining </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/li2019using/">Using GGNN to recommend log statement level</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Using GGNN to recommend log statement level' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Using GGNN to recommend log statement level' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Mingzhe Li, Jianrui Pei, Jin He, Kevin Song, Frank Che, Yongfeng Huang, Chitai Wang</td>
	<td></td>
	<td><p>In software engineering, log statement is an important part because programmers can’t access to users’ program and they can only rely on log message to find the root of bugs. The mechanism of “log level” allows developers and users to specify the appropriate amount of logs to print during the execution of the software. And 26\% of the log statement modification is to modify the level. We tried to use ML method to predict the suitable level of log statement. The specific model is GGNN(gated graph neural network) and we have drawn lessons from Microsoft’s research. In this work, we apply Graph Neural Networks to predict the usage of log statement level of some open source java projects from github. Given the good performance of GGNN in this task, we are confident that GGNN is an excellent choice for processing source code. We envision this model can play an important role in applying AI/ML technique for Software Development Life Cycle more broadly.</p>
</td>
	<td>GNN logging </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/kacmajor2019automatic/">Automatic Acquisition of Annotated Training Corpora for Test-Code Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Automatic Acquisition of Annotated Training Corpora for Test-Code Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Automatic Acquisition of Annotated Training Corpora for Test-Code Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Magdalena Kacmajor, John D. Kelleher.</td>
	<td>Information</td>
	<td><p>Open software repositories make large amounts of source code publicly available. Potentially, this source code could be used as training data to develop new, machine learning-based programming tools. For many applications, however, raw code scraped from online repositories does not constitute an adequate training dataset. Building on the recent and rapid improvements in machine translation (MT), one possibly very interesting application is code generation from natural language descriptions. One of the bottlenecks in developing these MT-inspired systems is the acquisition of parallel text-code corpora required for training code-generative models. This paper addresses the problem of automatically synthetizing parallel text-code corpora in the software testing domain. Our approach is based on the observation that self-documentation through descriptive method names is widely adopted in test automation, in particular for unit testing. Therefore, we propose synthesizing parallel corpora comprised of parsed test function names serving as code descriptions, aligned with the corresponding function bodies. We present the results of applying one of the state-of-the-art MT methods on such a generated dataset. Our experiments show that a neural MT model trained on our dataset can generate syntactically correct and semantically relevant short Java functions from quasi-natural language descriptions of functionality.</p>
</td>
	<td></td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/katz2019towards/">Towards Neural Decompilation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Towards Neural Decompilation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Towards Neural Decompilation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Omer Katz, Yuval Olshaker, Yoav Goldberg, Eran Yahav</td>
	<td></td>
	<td><p>We address the problem of automatic decompilation, converting a program in low-level representation back to a higher-level human-readable programming language. The problem of decompilation is extremely important for security researchers. Finding vulnerabilities and understanding how malware operates is much easier when done over source code.</p>

<p>The importance of decompilation has motivated the construction of hand-crafted rule-based decompilers. Such decompilers have been designed by experts to detect specific control-flow structures and idioms in low-level code and lift them to source level. The cost of supporting additional languages or new language features in these models is very high.</p>

<p>We present a novel approach to decompilation based on neural machine translation. The main idea is to automatically learn a decompiler from a given compiler. Given a compiler from a source language S to a target language T , our approach automatically trains a decompiler that can translate (decompile) T back to S . We used our framework to decompile both LLVM IR and x86 assembly to C code with high success rates. Using our LLVM and x86 instantiations, we were able to successfully decompile over 97% and 88% of our benchmarks respectively.</p>
</td>
	<td>decompilation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/karampatsis2019deep/">Maybe Deep Neural Networks are the Best Choice for Modeling Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Maybe Deep Neural Networks are the Best Choice for Modeling Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Maybe Deep Neural Networks are the Best Choice for Modeling Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rafael-Michael Karampatsis, Charles Sutton</td>
	<td></td>
	<td><p>Statistical language modeling techniques have successfully been applied to source code, yielding a variety of new software development tools, such as tools for code suggestion and improving readability. A major issue with these techniques is that code introduces new vocabulary at a far higher rate than natural language, as new identifier names proliferate. But traditional language models limit the vocabulary to a fixed set of common words. For code, this strong assumption has been shown to have a significant negative effect on predictive performance. But the open vocabulary version of the neural network language models for code have not been introduced in the literature. We present a new open-vocabulary neural language model for code that is not limited to a fixed vocabulary of identifier names. We employ a segmentation into subword units, subsequences of tokens chosen based on a compression criterion, following previous work in machine translation. Our network achieves best in class performance, outperforming even the state-of-the-art methods of Hellendoorn and Devanbu that are designed specifically to model code. Furthermore, we present a simple method for dynamically adapting the model to a new test project, resulting in increased performance. We showcase our methodology on code corpora in three different languages of over a billion tokens each, hundreds of times larger than in previous work. To our knowledge, this is the largest neural language model for code that has been reported.</p>
</td>
	<td>language model </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/shido2019automatic/">Automatic Source Code Summarization with Extended Tree-LSTM</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Automatic Source Code Summarization with Extended Tree-LSTM' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Automatic Source Code Summarization with Extended Tree-LSTM' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yusuke Shido, Yasuaki Kobayashi, Akihiro Yamamoto, Atsushi Miyamoto, Tadayuki Matsumura</td>
	<td>International Joint Conference on Neural Networks</td>
	<td><p>Neural machine translation models are used to automatically generate a document from given source code since this can be regarded as a machine translation task. Source code summarization is one of the components for automatic document generation, which generates a summary in natural language from given source code. This suggests that techniques used in neural machine translation, such as Long Short-Term Memory (LSTM), can be used for source code summarization. However, there is a considerable difference between source code and natural language: Source code is essentially structured, having loops and conditional branching, etc. Therefore, there is some obstacle to apply known machine translation models to source code.Abstract syntax trees (ASTs) capture these structural properties and play an important role in recent machine learning studies on source code. Tree-LSTM is proposed as a generalization of LSTMs for tree-structured data. However, there is a critical issue when applying it to ASTs: It cannot handle a tree that contains nodes having an arbitrary number of children and their order simultaneously, which ASTs generally have such nodes. To address this issue, we propose an extension of Tree-LSTM, which we call Multi-way Tree-LSTM and apply it for source code summarization. As a result of computational experiments, our proposal achieved better results when compared with several state-of-the-art techniques.</p>
</td>
	<td>summarization grammar </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/mesbah2019deepdelta/">DeepDelta: Learning to Repair Compilation Errors</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DeepDelta: Learning to Repair Compilation Errors' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DeepDelta: Learning to Repair Compilation Errors' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ali Mesbah, Andrew Rice, Emily Johnston, Nick Glorioso, Edward Aftandilian.</td>
	<td></td>
	<td><p>Programmers spend a substantial amount of time manually repairing
code that does not compile. We observe that the repairs for
any particular error class typically follow a pattern and are highly
mechanical. We propose a novel approach that automatically learns
these patterns with a deep neural network and suggests program
repairs for the most costly classes of build-time compilation failures.
We describe how we collect all build errors and the human-authored,
in-progress code changes that cause those failing builds to transition
to successful builds at Google. We generate an AST diff from the
textual code changes and transform it into a domain-specific
language called Delta that encodes the change that must be made
to make the code compile. We then feed the compiler diagnostic
information (as source) and the Delta changes that resolved the
diagnostic (as target) into a Neural Machine Translation network for
training. For the two most prevalent and costly classes of Java compilation errors,
namely missing symbols and mismatched methodsignatures, our system called DeepDelta,
generates the correct repair changes for 19,314 out of 38,788 (50%) of unseen compilation
errors. The correct changes are in the top three suggested axes 86% of the time on average.</p>
</td>
	<td>repair edit compilation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/svyatkovskiy2019pythia/">Pythia: AI-assisted Code Completion System</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Pythia: AI-assisted Code Completion System' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Pythia: AI-assisted Code Completion System' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Alexey Svyatkovskiy, Ying Zhao, Shengyu Fu, Neel Sundaresan</td>
	<td>KDD</td>
	<td><p>In this paper, we propose a novel end-to-end approach for AI-assisted code completion called Pythia. It generates ranked lists of method and API recommendations which can be used by software developers at edit time. The system is currently deployed as part of Intellicode extension in Visual Studio Code IDE. Pythia exploits state-of-the-art large-scale deep learning models trained on code contexts extracted from abstract syntax trees. It is designed to work at a high throughput predicting the best matching code completions on the order of 100 ms.</p>

<p>We describe the architecture of the system, perform comparisons to frequency-based approach and invocation-based Markov Chain language model, and discuss challenges serving Pythia models on lightweight client devices.</p>

<p>The offline evaluation results obtained on 2700 Python open source software GitHub repositories show a top-5 accuracy of 92%, surpassing the baseline models by 20% averaged over classes, for both intra and cross-project settings.</p>

</td>
	<td>autocomplete language model </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/liu2019neural/">Neural query expansion for code search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural query expansion for code search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural query expansion for code search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jason Liu, Seohyun Kim, Vijayaraghavan Murali, Swarat Chaudhuri, Satish Chandra</td>
	<td>MAPL</td>
	<td><p>Searching repositories of existing source code for code snippets is a key task in software engineering. Over the years, many approaches to this problem have been proposed. One recent tool called NCS, takes in a natural language query and outputs relevant code snippets, often being able to correctly answer Stack Overflow questions. But what happens when the developer doesn’t provide a query with a clear intent? What if shorter queries are used to demonstrate a more vague intent?</p>

<p>We find that the performance of NCS regresses with shorter queries. Furthermore, data from developers’ code search history logs shows that shorter queries have a less successful code search session: there are more query reformulations and more time is spent browsing the results. These observations lead us to believe that using NCS alone with short queries may not be productive enough.</p>

<p>In this paper, we explore an additional way of using neural networks in code search: the automatic expansion of queries. We present NQE, a neural model that takes in a set of keywords and predicts a set of keywords to expand the query to NCS. NQE learns to predict keywords that co-occur with the query keywords in the underlying corpus, which helps expand the query in a productive way. Our results show that with query expansion, NQE + NCS is able to perform better than using NCS alone.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/zhang2019novel/">A Novel Neural Source Code Representation based on Abstract Syntax Tree</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Novel Neural Source Code Representation based on Abstract Syntax Tree' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Novel Neural Source Code Representation based on Abstract Syntax Tree' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jian Zhang, Xu Wang, Hongyu Zhang, Hailong Sun, Kaixuan Wang, Xudong Liu</td>
	<td>ICSE</td>
	<td><p>Exploiting machine learning techniques for analyzing programs has attracted much attention. One key problem is how to represent code fragments well for follow-up analysis. Traditional information retrieval based methods often treat programs as natural language texts, which could miss important semantic information of source code. Recently, state-of-the-art studies demonstrate that abstract syntax tree (AST) based neural models can better represent source code. However, the sizes of ASTs are usually large and the existing models are prone to the long-term dependency problem. In this paper, we propose a novel AST-based Neural Network (ASTNN) for source code representation. Unlike existing models that work on entire ASTs, ASTNN splits each large AST into a sequence of small statement trees, and encodes the statement trees to vectors by capturing the lexical and syntactical knowledge of statements. Based on the sequence of statement vectors, a bidirectional RNN model is used to leverage the naturalness of statements and finally produce the vector representation of a code fragment. We have applied our neural network based source code representation method to two common program comprehension tasks: source code classification and code clone detection. Experimental results on the two tasks indicate that our model is superior to state-of-the-art approaches.</p>
</td>
	<td>representation grammar </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/wang2019learning/">Learning Scalable and Precise Representation of Program Semantics</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Scalable and Precise Representation of Program Semantics' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Scalable and Precise Representation of Program Semantics' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ke Wang</td>
	<td></td>
	<td><p>Neural program embedding has shown potential in aiding the analysis of large-scale, complicated software. Newly proposed deep neural architectures pride themselves on learning program semantics rather than superficial syntactic features. However, by considering the source code only, the vast majority of neural networks do not capture a deep, precise representation of program semantics. In this paper, we present \dypro, a novel deep neural network that learns from program execution traces. Compared to the prior dynamic models, not only is \dypro capable of generalizing across multiple executions for learning a program’s dynamic semantics in its entirety, but \dypro is also more efficient when dealing with programs yielding long execution traces. For evaluation, we task \dypro with semantic classification (i.e. categorizing programs based on their semantics) and compared it against two prominent static models: Gated Graph Neural Network and TreeLSTM. We find that \dypro achieves the highest prediction accuracy among all models. To further reveal the capacity of all aforementioned deep neural architectures, we examine if the models can learn to detect deeper semantic properties of a program. In particular given a task of recognizing loop invariants, we show \dypro beats all static models by a wide margin.</p>
</td>
	<td>representation dynamic </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/malik2019nl2type/">NL2Type: Inferring JavaScript Function Types from Natural Language Information</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=NL2Type: Inferring JavaScript Function Types from Natural Language Information' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=NL2Type: Inferring JavaScript Function Types from Natural Language Information' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rabee Sohail Malik, Jibesh Patra, Michael Pradel</td>
	<td>ICSE</td>
	<td><p>JavaScript is dynamically typed and hence lacks thetype safety  of  statically  typed  languages,
leading  to  suboptimal IDE support, difficult to understand APIs, and unexpected run-time behavior.
Several gradual type systems have been proposed, e.g., Flow and TypeScript, but they rely on developers
to annotatecode with types. This paper presents NL2Type, a learning-based approach for predicting likely
type signatures of JavaScript functions. The key idea is to exploit natural language information in
source code, such as comments, function names, and parameternames,  a  rich  source  of  knowledge
that  is  typically  ignored by  type  inference  algorithms.  We  formulate  the  problem  of predicting
types as a classification problem and train a recurrent, LSTM-based neural model that, after learning
from an annotatedcode  base,  predicts  function  types  for  unannotated  code.  We evaluate   the 
approach   with   a   corpus   of   162,673   JavaScript files  from  real-world  projects. 
NL2Type  predicts  types  with  aprecision of 84.1% and a recall of 78.9% when considering only
the  top-most  suggestion,  and  with  a  precision  of  95.5%  and  arecall  of  89.6%  when
considering  the  top-5  suggestions.  The
approach  outperforms  both  JSNice,  a  state-of-the-art  approach that  analyzes  implementations 
of  functions  instead  of  natural language  information,  and  DeepTyper,  a  recent  type  prediction
approach that is also based on deep learning. Beyond predicting types,  NL2Type  serves  as  a
consistency  checker  for  existing type  annotations.  We  show  that  it  discovers  39  inconsistencies
that  deserve  developer  attention  (from  a  manual  analysis  of  50 warnings), most of which 
are due to incorrect type annotations.</p>
</td>
	<td>bimodal types </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/jayasundara2019treecaps/">TreeCaps: Tree-Structured Capsule Networks for Program Source Code Processing</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=TreeCaps: Tree-Structured Capsule Networks for Program Source Code Processing' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=TreeCaps: Tree-Structured Capsule Networks for Program Source Code Processing' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, Luke Zettlemoyer</td>
	<td></td>
	<td><p>Program comprehension is a fundamental task in software development and maintenance processes. Software developers often need to understand a large amount of existing code before they can develop new features or fix bugs in existing programs. Being able to process programming language code automatically and provide summaries of code functionality accurately can significantly help developers to reduce time spent in code navigation and understanding, and thus increase productivity. Different from natural language articles, source code in programming languages often follows rigid syntactical structures and there can exist dependencies among code elements that are located far away from each other through complex control flows and data flows. Existing studies on tree-based convolutional neural networks (TBCNN) and gated graph neural networks (GGNN) are not able to capture essential semantic dependencies among code elements accurately. In this paper, we propose novel tree-based capsule networks (TreeCaps) and relevant techniques for processing program code in an automated way that encodes code syntactical structures and captures code dependencies more accurately. Based on evaluation on programs written in different programming languages, we show that our TreeCaps-based approach can outperform other approaches in classifying the functionalities of many programs.</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/iyer2019learning/">Learning Programmatic Idioms for Scalable Semantic Parsing</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Programmatic Idioms for Scalable Semantic Parsing' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Programmatic Idioms for Scalable Semantic Parsing' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Srinivasan Iyer, Alvin Cheung, Luke Zettlemoyer</td>
	<td></td>
	<td><p>Programmers typically organize executable source code using high-level coding patterns or idiomatic structures such as nested loops, exception handlers and recursive blocks, rather than as individual code tokens. In contrast, state of the art semantic parsers still map natural language instructions to source code by building the code syntax tree one node at a time. In this paper, we introduce an iterative method to extract code idioms from large source code corpora by repeatedly collapsing most-frequent depth-2 subtrees of their syntax trees, and we train semantic parsers to apply these idioms during decoding. We apply this idiom-based code generation to a recent context-dependent semantic parsing task, and improve the state of the art by 2.2% BLEU score while reducing training time by more than 50%. This improved speed enables us to scale up the model by training on an extended training set that is 5x times larger, to further move up the state of the art by an additional 2.3% BLEU and 0.9% exact match.</p>
</td>
	<td>pattern mining code generation grammar </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/theeten2019import2vec/">Import2vec - Learning Embeddings for Software Libraries</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Import2vec - Learning Embeddings for Software Libraries' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Import2vec - Learning Embeddings for Software Libraries' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Bart Theeten, Frederik Vandeputte, Tom Van Cutsem</td>
	<td>MSR</td>
	<td><p>We consider the problem of developing suitable learning representations (embeddings) for library packages that capture semantic similarity among libraries. Such representations are known to improve the performance of downstream learning tasks (e.g. classification) or applications such as contextual search and analogical reasoning.</p>

<p>We apply word embedding techniques from natural language processing (NLP) to train embeddings for library packages (“library vectors”). Library vectors represent libraries by similar context of use as determined by import statements present in source code. Experimental results obtained from training such embeddings on three large open source software corpora reveals that library vectors capture semantically meaningful relationships among software libraries, such as the relationship between frameworks and their plug-ins and libraries commonly used together within ecosystems such as big data infrastructure projects (in Java), front-end and back-end web development frameworks (in JavaScript) and data science toolkits (in Python).</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/shi2019learning/">Learning Execution through Neural Code Fusion</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Execution through Neural Code Fusion' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Execution through Neural Code Fusion' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zhan Shi, Kevin Swersky, Daniel Tarlow, Parthasarathy Ranganathan, Milad Hashemi</td>
	<td></td>
	<td><p>As the performance of computer systems stagnates due to the end of Moore’s Law, there is a need for new models that can understand and optimize the execution of general purpose code. While there is a growing body of work on using Graph Neural Networks (GNNs) to learn representations of source code, these representations do not understand how code dynamically executes. In this work, we propose a new approach to use GNNs to learn fused representations of general source code and its execution. Our approach defines a multi-task GNN over low-level representations of source code and program state (i.e., assembly code and dynamic memory states), converting complex source code constructs and complex data structures into a simpler, more uniform format. We show that this leads to improved performance over similar methods that do not use execution and it opens the door to applying GNN models to new tasks that would not be feasible from static code alone. As an illustration of this, we apply the new model to challenging dynamic tasks (branch prediction and prefetching) from the SPEC CPU benchmark suite, outperforming the state-of-the-art by 26% and 45% respectively. Moreover, we use the learned fused graph embeddings to demonstrate transfer learning with high performance on an indirectly related task (algorithm classification).</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/husain2019codesearchnet/">CodeSearchNet Challenge: Evaluating the State of Semantic Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeSearchNet Challenge: Evaluating the State of Semantic Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeSearchNet Challenge: Evaluating the State of Semantic Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hamel Husain, Ho-Hsiang Wu, Tiferet Gazit, Miltiadis Allamanis, Marc Brockschmidt</td>
	<td></td>
	<td><p>Semantic code search is the task of retrieving relevant code given a natural language query. While related to other information retrieval tasks, it requires bridging the gap between the language used in code (often abbreviated and highly technical) and natural language more suitable to describe vague concepts and ideas.</p>

<p>To enable evaluation of progress on code search, we are releasing the CodeSearchNet Corpus and are presenting the CodeSearchNet Challenge, which consists of 99 natural language queries with about 4k expert relevance annotations of likely results from CodeSearchNet Corpus. The corpus contains about 6 million functions from open-source code spanning six programming languages (Go, Java, JavaScript, PHP, Python, and Ruby). The CodeSearchNet Corpus also contains automatically generated query-like natural language for 2 million functions, obtained from mechanically scraping and preprocessing associated function documentation. In this article, we describe the methodology used to obtain the corpus and expert labels, as well as a number of simple baseline solutions for the task.</p>

<p>We hope that CodeSearchNet Challenge encourages researchers and practitioners to study this interesting task further and will host a competition and leaderboard to track the progress on the challenge. We are also keen on extending CodeSearchNet Challenge to more queries and programming languages in the future.</p>
</td>
	<td>dataset search </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/hussain2019deep/">Deep Transfer Learning for Source Code Modeling</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Transfer Learning for Source Code Modeling' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Transfer Learning for Source Code Modeling' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yasir Hussain, Zhiqiu Huang, Yu Zhou, Senzhang Wang</td>
	<td></td>
	<td><p>In recent years, deep learning models have shown great potential in source code modeling and analysis. Generally, deep learning-based approaches are problem-specific and data-hungry. A challenging issue of these approaches is that they require training from starch for a different related problem. In this work, we propose a transfer learning-based approach that significantly improves the performance of deep learning-based source code models. In contrast to traditional learning paradigms, transfer learning can transfer the knowledge learned in solving one problem into another related problem. First, we present two recurrent neural network-based models RNN and GRU for the purpose of transfer learning in the domain of source code modeling. Next, via transfer learning, these pre-trained (RNN and GRU) models are used as feature extractors. Then, these extracted features are combined into attention learner for different downstream tasks. The attention learner leverages from the learned knowledge of pre-trained models and fine-tunes them for a specific downstream task. We evaluate the performance of the proposed approach with extensive experiments with the source code suggestion task. The results indicate that the proposed approach outperforms the state-of-the-art models in terms of accuracy, precision, recall, and F-measure without training the models from scratch.</p>
</td>
	<td>pretraining </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/kovalenko2019pathminer/">PathMiner : A Library for Mining of Path-Based Representations of Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=PathMiner : A Library for Mining of Path-Based Representations of Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=PathMiner : A Library for Mining of Path-Based Representations of Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vladimir Kovalenko, Egor Bogomolov, Timofey Bryksin, Alberto Bacchelli.</td>
	<td>MSR</td>
	<td><p>One recent, significant advance in modeling source code for machine learning algorithms has been the introduction of path-based representation – an approach consisting in representing a snippet of code as a collection of paths from its syntax tree. Such representation efficiently captures the structure of code, which, in turn, carries its semantics and other information.
Building the path-based representation involves parsing the code and extracting the paths from its syntax tree; these steps build up to a substantial technical job. With no common reusable toolkit existing for this task, the burden of mining diverts the focus of researchers from the essential work and hinders newcomers in the field of machine learning on code.</p>

<p>In this paper, we present PathMiner – an open-source library for mining path-based representations of code. PathMiner is fast, flexible, well-tested, and easily extensible to support input code in any common programming language. Preprint [https://doi.org/10.5281/zenodo.2595271]; released tool [https://doi.org/10.5281/zenodo.2595257].</p>
</td>
	<td>representation grammar </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/zhao2019neural/">Neural Networks for Modeling Source Code Edits</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Networks for Modeling Source Code Edits' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Networks for Modeling Source Code Edits' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rui Zhao, David Bieber, Kevin Swersky, Daniel Tarlow</td>
	<td></td>
	<td><p>Programming languages are emerging as a challenging and interesting domain for machine learning. A core task, which has received significant attention in recent years, is building generative models of source code. However, to our knowledge, previous generative models have always been framed in terms of generating static snapshots of code. In this work, we instead treat source code as a dynamic object and tackle the problem of modeling the edits that software developers make to source code files. This requires extracting intent from previous edits and leveraging it to generate subsequent edits. We develop several neural networks and use synthetic data to test their ability to learn challenging edit patterns that require strong generalization. We then collect and train our models on a large-scale dataset of Google source code, consisting of millions of fine-grained edits from thousands of Python developers. From the modeling perspective, our main conclusion is that a new composition of attentional and pointer network components provides the best overall performance and scalability. From the application perspective, our results provide preliminary evidence of the feasibility of developing tools that learn to predict future edits.</p>
</td>
	<td>edit </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/lin2019impact/">On the Impact of Refactoring Operations on Code Naturalness</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=On the Impact of Refactoring Operations on Code Naturalness' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=On the Impact of Refactoring Operations on Code Naturalness' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Bin Lin, Csaba Nagy, Gabriele Bavota, Michele Lanza</td>
	<td>SANER</td>
	<td><p>Recent studies have demonstrated that software is natural, that is, its source code is highly repetitive and predictable like human languages. Also, previous studies suggested the existence of a relationship between code quality and its naturalness, presenting empirical evidence showing that buggy code is “less natural” than non-buggy code. We conjecture that this qualitynaturalness relationship could be exploited to support refactoring activities (e.g., to locate source code areas in need of refactoring). We perform a first step in this direction by analyzing whether refactoring can improve the naturalness of code. We use state-of-the-art tools to mine a large dataset of refactoring operations performed in open source systems. Then, we investigate the impact of different types of refactoring operations on the naturalness of the impacted code. We found that (i) code refactoring does not necessarily increase the naturalness of the refactored code; and (ii) the impact on the code naturalness strongly depends on the type of refactoring operations.</p>
</td>
	<td>language model refactoring </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/lacomis2019neural/">A Neural Approach to Decompiled Identifier Renaming</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Neural Approach to Decompiled Identifier Renaming' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Neural Approach to Decompiled Identifier Renaming' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jeremy Lacomis, Pengcheng Yin, Edward J. Schwartz, Miltiadis Allamanis, Claire Le Goues, Graham Neubig, Bogdan Vasilescu</td>
	<td>ASE</td>
	<td><p>The decompiler is one of the most common tools for examining binaries without corresponding source code. It transforms binaries into high-level code, reversing the compilation process. However, compilation loses information contained within the original source code (e.g. structure, type information, and variable names). Semantically meaningful variable names are known to increase code understandability, but they generally cannot be recovered by decompilers. We propose the Decompiled Identifier Renaming Engine (DIRE), a novel probabilistic technique for variable name recovery that uses both lexical and structural information. We also present a technique for generating corpora suitable for training and evaluating models of decompiled code renaming, which we use to create a corpus of 164,632 unique x86-64 binaries generated from C projects mined from GitHub. Our results show that on this corpus DIRE can predict variable names identical to the names in the original source code up to 74.3% of the time.</p>
</td>
	<td>deobfuscation naming compilation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/leclair2019neural/">A Neural Model for Generating Natural Language Summaries of Program Subroutines</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Neural Model for Generating Natural Language Summaries of Program Subroutines' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Neural Model for Generating Natural Language Summaries of Program Subroutines' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Alexander LeClair, Siyuan Jiang, Collin McMillan</td>
	<td>ICSE</td>
	<td><p>Source code summarization – creating natural language descriptions of source code behavior – is a rapidly-growing research topic with applications to automatic documentation generation, program comprehension, and software maintenance. Traditional techniques relied on heuristics and templates built manually by human experts. Recently, data-driven approaches based on neural machine translation have largely overtaken template-based systems. But nearly all of these techniques rely almost entirely on programs having good internal documentation; without clear identifier names, the models fail to create good summaries. In this paper, we present a neural model that combines words from code with code structure from an AST. Unlike previous approaches, our model processes each data source as a separate input, which allows the model to learn code structure independent of the text in code. This process helps our approach provide coherent summaries in many cases even when zero internal documentation is provided. We evaluate our technique with a dataset we created from 2.1m Java methods. We find improvement over two baseline techniques from SE literature and one from NLP literature.</p>
</td>
	<td>summarization documentation </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/tarlow2019learning/">Learning to Fix Build Errors with Graph2Diff Neural Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Fix Build Errors with Graph2Diff Neural Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Fix Build Errors with Graph2Diff Neural Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Daniel Tarlow, Subhodeep Moitra, Andrew Rice, Zimin Chen, Pierre-Antoine Manzagol, Charles Sutton, Edward Aftandilian</td>
	<td></td>
	<td><p>Professional software developers spend a significant amount oftime fixing builds, but this has received little attention as a prob-lem in automatic program repair. We present a new deep learningarchitecture, called Graph2Diff, for automatically localizing andfixing build errors. We represent source code, build configurationfiles, and compiler diagnostic messages as a graph, and then use aGraph Neural Network model to predict a diff. A diff specifies howto modify the code’s abstract syntax tree, represented in the neuralnetwork as a sequence of tokens and of pointers to code locations.Our network is an instance of a more general abstraction which wecall Graph2Tocopo, which is potentially useful in any developmenttool for predicting source code changes. We evaluate the model ona dataset of over 500k real build errors and their resolutions fromprofessional developers. Compared to the approach of DeepDelta, our approach tackles the harder task of predicting a moreprecise diff but still achieves over double the accuracy.</p>
</td>
	<td>edit repair </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/zhang2019learning/">Learning Uniform Semantic Features for Natural Language and Programming Language Globally, Locally and Sequentially</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Uniform Semantic Features for Natural Language and Programming Language Globally, Locally and Sequentially' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Uniform Semantic Features for Natural Language and Programming Language Globally, Locally and Sequentially' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yudong Zhang, Wenhao Zheng, Ming Li</td>
	<td>AAAI</td>
	<td><p>Semantic feature learning for natural language and programming language is a preliminary step in addressing many software mining tasks. Many existing methods leverage
information in lexicon and syntax to learn features for textual data.
However, such information is inadequate to represent the entire semantics in either text sentence or code snippet. This
motivates us to propose a new approach to learn semantic
features for both languages, through extracting three levels of
information, namely global, local and sequential information,
from textual data. For tasks involving both modalities, we
project the data of both types into a uniform feature space so
that the complementary knowledge in between can be utilized
in their representation. In this paper, we build a novel and
general-purpose feature learning framework called UniEmbed, to uniformly learn comprehensive semantic representation for both natural language and programming language.
Experimental results on three real-world software mining
tasks show that UniEmbed outperforms state-of-the-art models in feature learning and prove the capacity and effectiveness of our model.</p>
</td>
	<td>representation bimodal </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/kulal2019spoc/">SPoC: Search-based Pseudocode to Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=SPoC: Search-based Pseudocode to Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=SPoC: Search-based Pseudocode to Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sumith Kulal, Panupong Pasupat, Kartik Chandra, Mina Lee, Oded Padon, Alex Aiken, Percy S. Liang</td>
	<td></td>
	<td><p>We consider the task of mapping pseudocode to long programs that are functionally correct. Given test cases as a mechanism to validate programs, we search over the space of possible translations of the pseudocode to find a program that passes the validation. However, without proper credit assignment to localize the sources of program failures, it is difficult to guide search toward more promising programs. We propose to perform credit assignment based on signals from compilation errors, which constitute 88.7% of program failures. Concretely, we treat the translation of each pseudocode line as a discrete portion of the program, and whenever a synthesized program fails to compile, an error localization method tries to identify the portion of the program responsible for the failure. We then focus search over alternative translations of the pseudocode for those portions. For evaluation, we collected the SPoC dataset (Search-based Pseudocode to Code) containing 18,356 programs with human-authored pseudocode and test cases. Under a budget of 100 program compilations, performing search improves the synthesis success rate over using the top-one translation of the pseudocode from 25.6% to 44.7%.</p>
</td>
	<td>bimodal synthesis </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/leclair2019recommendations/">Recommendations for Datasets for Source Code Summarization</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Recommendations for Datasets for Source Code Summarization' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Recommendations for Datasets for Source Code Summarization' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Alexander LeClair, Collin McMillan</td>
	<td>NAACL 2019</td>
	<td><p>Source Code Summarization is the task of writing short, natural language descriptions of source code. The main use for these descriptions is in software documentation e.g. the one-sentence Java method descriptions in JavaDocs. Code summarization is rapidly becoming a popular research problem, but progress is restrained due to a lack of suitable datasets. In addition, a lack of community standards for creating datasets leads to confusing and unreproducible research results – we observe swings in performance of more than 33% due only to changes in dataset design. In this paper, we make recommendations for these standards from experimental results. We release a dataset based on prior work of over 2.1m pairs of Java methods and one sentence method descriptions from over 28k Java projects. We describe the dataset and point out key differences from natural language data, to guide and support future researchers.</p>
</td>
	<td>summarization dataset </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/liu2019generating/">Generating commit messages from diffs using pointer-generator network</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Generating commit messages from diffs using pointer-generator network' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Generating commit messages from diffs using pointer-generator network' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Qin Liu, Zihe Liu, Hongming Zhu, Hongfei Fan, Bowen Du, Yu Qian.</td>
	<td>MSR</td>
	<td><p>The commit messages in source code repositories are valuable but not easy to be generated manually in time for tracking issues, reporting bugs, and understanding codes. Recently published works indicated that the deep neural machine translation approaches have drawn considerable attentions on automatic generation of commit messages. However, they could not deal with out-of-vocabulary (OOV) words, which are essential context-specific identifiers such as class names and method names in code diffs. In this paper, we propose PtrGNCMsg, a novel approach which is based on an improved sequence-to-sequence model with the pointer-generator network to translate code diffs into commit messages. By searching the smallest identifier set with the highest probability, PtrGNCMsg outperforms recent approaches based on neural machine translation, and first enables the prediction of OOV words. The experimental results based on the corpus of diffs and manual commit messages from the top 2,000 Java projects in GitHub show that PtrGNCMsg outperforms the state-of-the-art approach with improved BLEU by 1.02, ROUGE-1 by 4.00 and ROUGE-L by 3.78, respectively.</p>
</td>
	<td>edit </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/li2019improving/">Improving Bug Detection via Context-Based Code Representation Learning and Attention-Based Neural Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Improving Bug Detection via Context-Based Code Representation Learning and Attention-Based Neural Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Improving Bug Detection via Context-Based Code Representation Learning and Attention-Based Neural Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yi Li, Shaohua Wang, Tien N. Nguyen, Son Van Nguyen</td>
	<td>OOPSLA</td>
	<td><p>Bug detection has been shown to be an effective way to help developers in detecting bugs early, thus, saving much effort and time in software development process. Recently, deep learning-based bug detection approaches have gained successes over the traditional machine learning-based approaches, the rule-based program analysis approaches, and mining-based approaches. However, they are still limited in detecting bugs that involve multiple methods and suffer high rate of false positives. In this paper, we propose a combination approach with the use of contexts and attention neural network to overcome those limitations. We propose to use as the global context the Program Dependence Graph (PDG) and Data Flow Graph (DFG) to connect the method under investigation with the other relevant methods that might contribute to the buggy code. The global context is complemented by the local context extracted from the path on the AST built from the method’s body. The use of PDG and DFG enables our model to reduce the false positive rate, while to complement for the potential reduction in recall, we make use of the attention neural network mechanism to put more weights on the buggy paths in the source code. That is, the paths that are similar to the buggy paths will be ranked higher, thus, improving the recall of our model. We have conducted several experiments to evaluate our approach on a very large dataset with +4.973M methods in 92 different project versions. The results show that our tool can have a relative improvement up to 160% on F-score when comparing with the state-of-the-art bug detection approaches. Our tool can detect 48 true bugs in the list of top 100 reported bugs, which is 24 more true bugs when comparing with the baseline approaches. We also reported that our representation is better suitable for bug detection and relatively improves over the other representations up to 206% in accuracy.</p>
</td>
	<td>representation defect </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/li2019neural/">Neural Code Search Evaluation Dataset</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Code Search Evaluation Dataset' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Code Search Evaluation Dataset' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hongyu Li, Seohyun Kim, Satish Chandra</td>
	<td></td>
	<td><p>There has been an increase of interest in code search using natural language. Assessing the performance of such code search models can be difficult without a readily available evaluation suite. In this paper, we present an evaluation dataset consisting of natural language query and code snippet pairs, with the hope that future work in this area can use this dataset as a common benchmark. We also provide the results of two code search models ([1] and [6]) from recent work.</p>
</td>
	<td>dataset search </td>
</tr>

<tr>
	<td>2019</td>
	<td><a href="/publications/wei2019code/">Code Generation as a Dual Task of Code Summarization</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Code Generation as a Dual Task of Code Summarization' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Code Generation as a Dual Task of Code Summarization' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Bolin Wei, Ge Li, Xin Xia, Zhiyi Fu, Zhi Jin</td>
	<td>NeurIPS</td>
	<td><p>Code summarization (CS) and code generation (CG) are two crucial tasks in the field of automatic software development. Various neural network-based approaches are proposed to solve these two tasks separately. However, there exists a specific intuitive correlation between CS and CG, which have not been exploited in previous work. In this paper, we apply the relations between two tasks to improve the performance of both tasks. In other words, exploiting the duality between the two tasks, we propose a dual training framework to train the two tasks simultaneously. In this framework, we consider the dualities on probability and attention weights, and design corresponding regularization terms to constrain the duality. We evaluate our approach on two datasets collected from GitHub, and experimental results show that our dual framework can improve the performance of CS and CG tasks over baselines.</p>
</td>
	<td>code generation summarization </td>
</tr>



<tr>
	<td>2018</td>
	<td><a href="/publications/cvitkovic2018open/">Open Vocabulary Learning on Source Code with a Graph-Structured Cache</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Open Vocabulary Learning on Source Code with a Graph-Structured Cache' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Open Vocabulary Learning on Source Code with a Graph-Structured Cache' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Milan Cvitkovic, Badal Singh, Anima Anandkumar</td>
	<td></td>
	<td><p>Machine learning models that take computer program source code as input typically use Natural Language Processing (NLP) techniques. However, a major challenge is that code is written using an open, rapidly changing vocabulary due to, e.g., the coinage of new variable and method names. Reasoning over such a vocabulary is not something for which most NLP methods are designed. We introduce a Graph-Structured Cache to address this problem; this cache contains a node for each new word the model encounters with edges connecting each word to its occurrences in the code. We find that combining this graph-structured cache strategy with recent Graph-Neural-Network-based models for supervised learning on code improves the models’ performance on a code completion task and a variable naming task — with over 100% relative improvement on the latter — at the cost of a moderate increase in computation time.</p>
</td>
	<td>GNN variable misuse defect representation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/cummins2018compiler/">Compiler Fuzzing through Deep Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Compiler Fuzzing through Deep Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Compiler Fuzzing through Deep Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Chris Cummins, Pavlos Petoumenos, Alastair Murray, Hugh Leather</td>
	<td>ISSTA</td>
	<td><p>Random program generation — fuzzing — is an effective technique
for discovering bugs in compilers but successful fuzzers require
extensive development effort for every language supported by the
compiler, and often leave parts of the language space untested.</p>

<p>We introduce DeepSmith, a novel machine learning approach
to accelerating compiler validation through the inference of generative models for compiler inputs. Our approach
infers a learned
model of the structure of real world code based on a large corpus of open source code. Then, it uses the model to automatically
generate tens of thousands of realistic programs. Finally, we apply
established differential testing methodologies on them to expose
bugs in compilers. We apply our approach to the OpenCL programming language, automatically exposing bugs with little effort on our
side. In 1,000 hours of automated testing of commercial and open
source compilers, we discover bugs in all of them, submitting 67
bug reports. Our test cases are on average two orders of magnitude
smaller than the state-of-the-art, require 3.03× less time to generate
and evaluate, and expose bugs which the state-of-the-art cannot.
Our random program generator, comprising only 500 lines of code,
took 12 hours to train for OpenCL versus the state-of-the-art taking
9 man months to port from a generator for C and 50,000 lines of
code. With 18 lines of code we extended our program generator to
a second language, uncovering crashes in Solidity compilers in 12
hours of automated testing.</p>
</td>
	<td>fuzzing code generation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/dash2018refinym/">RefiNym: Using Names to Refine Types</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=RefiNym: Using Names to Refine Types' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=RefiNym: Using Names to Refine Types' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Santanu Dash, Miltiadis Allamanis, Earl T. Barr</td>
	<td>FSE</td>
	<td><p>Source code is bimodal: it combines a formal algorithmic channel and a natural language channel of identifiers and comments. In this work, we model the bimodality of code with name lows, an assignment low graph augmented to track identiier names. Conceptual types are logically distinct types that do not always coincide with program types. Passwords and URLs are example conceptual types that can share the program type string. Our tool, RefiNym, is an unsupervised method that mines a lattice of conceptual types from name lows and reiies them into distinct nominal types. For string, RefiNym inds and splits conceptual types originally merged into a single type, reducing the number of same-type variables per scope from 8.7 to 2.2 while eliminating 21.9% of scopes that have more than one same-type variable in scope. This makes the code more self-documenting and frees the type system to prevent a developer from inadvertently assigning data across conceptual types.</p>
</td>
	<td>program analysis types </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/shirani2018evaluation/">Evaluation of Type Inference with Textual Cues</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Evaluation of Type Inference with Textual Cues' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Evaluation of Type Inference with Textual Cues' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Amirreza A. Shirani, A. Pastor Lopez-Monroy, Fabio Gonzalez, Thamar Solorio, Mohammad Amin Alipour</td>
	<td>NLSE</td>
	<td><p>Type information plays an important role in the success of information retrieval and recommendation systems in software
engineering. Thus, the absence of types in dynamically-typed
languages poses a challenge to adapt these systems to support
dynamic languages.</p>

<p>In this paper, we explore the viability of type inference using
textual cues.  That is, we formulate the type inference problem as a classification problem which uses the textual features
in  the  source  code  to  predict  the type  of  variables.   In  this
approach, a classifier learns a model to distinguish between
types of variables in a program.  The model is subsequently
used to (approximately) infer the types of other variables.</p>

<p>We  evaluate  the  feasibility  of  this  approach  on  four  Java
projects wherein type information is already available in the
source code and can be used to train and test a classifier. Our
experiments show this approach can predict the type of new
variables  with  relatively  high  accuracy  (80% F-measure).
These results suggest that textual cues can be
complementary
tools in inferring types for dynamic languages.</p>
</td>
	<td>information extraction </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/louis2018deep/">Deep Learning to Detect Redundant Method Comments</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Learning to Detect Redundant Method Comments' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Learning to Detect Redundant Method Comments' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Annie Louis, Santanu Kumar Dash, Earl T. Barr, Charles Sutton</td>
	<td></td>
	<td><p>Comments in software are critical for maintenance and reuse. But apart from prescriptive advice, there is little practical support or quantitative understanding of what makes a comment useful. In this paper, we introduce the task of identifying comments which are uninformative about the code they are meant to document. To address this problem, we introduce the notion of comment entailment from code, high entailment indicating that a comment’s natural language semantics can be inferred directly from the code. Although not all entailed comments are low quality, comments that are too easily inferred, for example, comments that restate the code, are widely discouraged by authorities on software style. Based on this, we develop a tool called CRAIC which scores method-level comments for redundancy. Highly redundant comments can then be expanded or alternately removed by the developer. CRAIC uses deep language models to exploit large software corpora without requiring expensive manual annotations of entailment. We show that CRAIC can perform the comment entailment task with good agreement with human judgements. Our findings also have implications for documentation tools. For example, we find that common tags in Javadoc are at least two times more predictable from code than non-Javadoc sentences, suggesting that Javadoc tags are less informative than more free-form comments</p>
</td>
	<td>bimodal documentation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/defreez2018path/">Path-Based Function Embedding and its Application to Specification Mining</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Path-Based Function Embedding and its Application to Specification Mining' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Path-Based Function Embedding and its Application to Specification Mining' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Daniel DeFreez, Aditya V. Thakur, Cindy Rubio-González</td>
	<td>ICSE</td>
	<td><p>Identifying the relationships among program elements is useful
for program understanding, debugging, and analysis. One such
relationship is synonymy. Function synonyms are functions that
play a similar role in code, e.g. functions that perform initialization
for different device drivers, or functions that implement different
symmetric-key encryption schemes. Function synonyms are not
necessarily semantically equivalent and can be syntactically dissimilar; consequently, approaches for identifying code clones or
functional equivalence cannot be used to identify them. This paper presents <code class="language-plaintext highlighter-rouge">func2vec</code>, an algorithm that maps each function to a vector in a vector space such that function synonyms are grouped
together. We compute the function embedding by training a neu-
ral network on sentences generated from random walks over an
encoding of the program as a labeled pushdown system (ℓ-PDS).
We demonstrate that <code class="language-plaintext highlighter-rouge">func2vec</code>
is effective at identifying function
synonyms in the Linux kernel. Furthermore, we show how function
synonyms enable mining error-handling specifications with high
support in Linux file systems and drivers.</p>
</td>
	<td>program analysis representation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/murali2017bayesian/">Bayesian Sketch Learning for Program Synthesis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Bayesian Sketch Learning for Program Synthesis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Bayesian Sketch Learning for Program Synthesis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vijayaraghavan Murali, Letao Qi, Swarat Chaudhuri, Chris Jermaine</td>
	<td>ICLR</td>
	<td><p>We present a Bayesian statistical approach to the problem of automatic program synthesis. Our synthesizer starts
by learning, offline and from an existing corpus, a probabilistic model of real-world programs. During synthesis,
it is provided some ambiguous and incomplete evidence about the nature of the programming task that the user
wants automated, for example sets of API calls or data types that are relevant for the task. Given this input, the
synthesizer infers a posterior distribution over type-safe programs that assigns higher likelihood to programs
that, according to the learned model, are more likely to match the evidence.</p>

<p>We realize this approach using two key ideas. First, our learning techniques operate not over code but
syntactic abstractions, or sketches, of programs. During synthesis, we infer a posterior distribution over sketches,
then concretize samples from this distribution into type-safe programs using combinatorial techniques. Second,
our statistical model explicitly models the full intent behind a synthesis task as a latent variable. To infer
sketches, we first estimate a posterior distribution on the intent, then use samples from this posterior to generate
a distribution over possible sketches. We show that our model can be implemented effectively using the new
neural architecture of Bayesian encoder-decoders, which can be trained with stochastic gradient descent and
yields a simple inference procedure.</p>

<p>We implement our ideas in a system, called BAYOU , for the synthesis of API-heavy Java methods. We train
BAYOU on a large corpus of Android apps, and find that the trained system can often synthesize complex
methods given just a few API method names or data types as evidence. The experiments also justify the design
choice of using a latent intent variable and the levels of abstraction at which sketches and evidence are defined.</p>
</td>
	<td>code generation API </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/lanchantin2018exploring/">Exploring the Naturalness of Buggy Code with Recurrent Neural Network</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Exploring the Naturalness of Buggy Code with Recurrent Neural Network' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Exploring the Naturalness of Buggy Code with Recurrent Neural Network' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jack Lanchantin, Ji Gao</td>
	<td></td>
	<td><p>Statistical   language   models   are   powerful   tools
which  have  been  used  for  many  tasks  within  natural language processing. Recently, they have been
used for other sequential data such as source code.
(Ray et al., 2015) showed that it is possible train an
n-gram
source code language mode,  and use it to
predict buggy lines in code by determining “unnatural” lines via entropy with respect to the language
model.  In this work, we propose using a more advanced language modeling technique, Long Short-term Memory recurrent neural networks, to model
source code and classify buggy lines based on entropy.   We  show  that  our  method  slightly  outperforms an
n-gram model in the buggy line classification task using AUC</p>
</td>
	<td>language model defect </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/chakraborty2018tree2tree/">CODIT: Code Editing with Tree-Based Neural Machine Translation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CODIT: Code Editing with Tree-Based Neural Machine Translation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CODIT: Code Editing with Tree-Based Neural Machine Translation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Saikat Chakraborty, Miltiadis Allamanis, Baishakhi Ray</td>
	<td></td>
	<td><p>The way developers edit day-to-day code tends to be repetitive, often using existing code elements. Many researchers have tried to automate repetitive code changes by learning from specific change templates which are applied to limited scope. The advancement of Neural Machine Translation (NMT) and the availability of vast open-source evolutionary data opens up the possibility of automatically learning those templates from the wild. However, unlike natural languages, for which NMT techniques were originally devised, source code and its changes have certain properties. For instance, compared to natural language, source code vocabulary can be significantly larger. Further, good changes in code do not break its syntactic structure. Thus, deploying state-of-the-art NMT models without adapting the methods to the source code domain yields sub-optimal results. To this end, we propose a novel Tree based NMT system to model source code changes and learn code change patterns from the wild. We realize our model with a change suggestion engine: CODIT and train the model with more than 30k real-world changes and evaluate it on 6k patches. Our evaluation shows the effectiveness of CODIT in learning and suggesting patches.CODIT also shows promise generating bug fix patches.</p>
</td>
	<td>grammar grammar repair code generation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/santos2018syntax/">Syntax and Sensibility: Using language models to detect and correct syntax errors</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Syntax and Sensibility: Using language models to detect and correct syntax errors' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Syntax and Sensibility: Using language models to detect and correct syntax errors' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Eddie Antonio Santos, Joshua Charles Campbell, Dhvani Patel, Abram Hindle, José Nelson Amaral</td>
	<td>SANER</td>
	<td><p>Syntax errors are made by novice and experienced programmers alike; however, novice programmers lack the years of experience that help them quickly resolve these frustrating errors. Standard LR parsers are of little help, typically resolving syntax errors and their precise location poorly. We propose a methodology that locates where syntax errors occur, and suggests possible changes to the token stream that can fix the error identified. This methodology finds syntax errors by using language models trained on correct source code to find tokens that seem out of place. Fixes are synthesized by consulting the language models to determine what tokens are more likely at the estimated error location. We compare <em>n</em>-gram and LSTM (long short-term memory) language models for this task, each trained on a large corpus of Java code collected from GitHub. Unlike prior work, our methodology does not rely that the problem source code comes from the same domain as the training data. We evaluated against a repository of real student mistakes. Our tools are able to find a syntactically-valid fix within its top-2 suggestions, often producing the exact fix that the student used to resolve the error. The results show that this tool and methodology can locate and suggest corrections for syntax errors. Our methodology is of practical use to all programmers, but will be especially useful to novices frustrated with incomprehensible syntax errors.</p>
</td>
	<td>repair language model </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/iyer2018mapping/">Mapping Language to Code in Programmatic Context</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Mapping Language to Code in Programmatic Context' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Mapping Language to Code in Programmatic Context' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, Luke Zettlemoyer</td>
	<td>EMNLP</td>
	<td><p>Source code is rarely written in isolation. It depends significantly on the programmatic context, such as the class that the code would reside in. To study this phenomenon, we introduce the task of generating class member functions given English documentation and the programmatic context provided by the rest of the class. This task is challenging because the desired code can vary greatly depending on the functionality the class provides (e.g., a sort function may or may not be available when we are asked to “return the smallest element” in a particular member variable list). We introduce CONCODE, a new large dataset with over 100,000 examples consisting of Java classes from online code repositories, and develop a new encoder-decoder architecture that models the interaction between the method documentation and the class environment. We also present a detailed error analysis suggesting that there is significant room for future work on this task.</p>
</td>
	<td>bimodal code generation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/bui2018bilateral/">Bilateral Dependency Neural Networks for Cross-Language Algorithm Classification</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Bilateral Dependency Neural Networks for Cross-Language Algorithm Classification' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Bilateral Dependency Neural Networks for Cross-Language Algorithm Classification' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Nghi D. Q. Bui, Yijun Yu, Lingxiao Jiang</td>
	<td>SANER</td>
	<td><p>Algorithm  classification  is  to  automatically  identify
the  classes  of  a  program  based  on  the  algorithm(s)  and/or  data
structure(s)  implemented  in  the  program.  It  can  be  useful  for
various tasks, such as code reuse, code theft detection, and malware detection. Code similarity metrics, on the basis of features
extracted from syntax and semantics, have been used to classify
programs.  Such  features,  however,  often  need  manual  selection
effort  and  are  specific  to  individual  programming  languages,
limiting  the  classifiers  to  programs  in  the  same  language.
To recognize the similarities and differences among algorithms
implemented   in   different   languages,   this   paper   describes   a
framework  of  Bilateral  Neural  Networks  (Bi-NN)  that  builds  a
neural  network  on  top  of  two  underlying  sub-networks,  each  of
which encodes syntax and semantics of code in one language. A
whole  Bi-NN  can  be  trained  with  bilateral  programs  that  implement the same algorithms and/or data structures in different
languages  and  then  be  applied  to  recognize  algorithm  classes
across  languages.</p>

<p>We  have  instantiated  the  framework  with  several  kinds  of
token-,  tree-  and  graph-based  neural  networks  that  encode  and
learn  various  kinds  of  information  in  code.  We  have  applied
the  instances  of  the  framework  to  a  code  corpus  collected  from
GitHub containing thousands of Java and C++ programs imple-
menting 50 different algorithms and data structures. Our evalua-
tion results show that the use of Bi-NN indeed produces promising
algorithm  classification  results  both  within  one  language  and
across  languages,  and  the  encoding  of  dependencies  from  code
into  the  underlying  neural  networks  helps  improve  algorithm
classification  accuracy  further.  In  particular,  our  custom-built
dependency trees with tree-based convolutional neural networks
achieve  the  highest  classification  accuracy  among  the  different
instances  of  the  framework  that  we  have  evaluated.  Our  study
points  to  a  possible  future  research  direction  to  tailor  bilateral
and  multilateral  neural  networks  that  encode  more  relevant
semantics  for  code  learning,  mining  and  analysis  tasks</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/bui2018cross/">Cross-Language Learning for Program Classification using Bilateral Tree-Based Convolutional Neural Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Cross-Language Learning for Program Classification using Bilateral Tree-Based Convolutional Neural Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Cross-Language Learning for Program Classification using Bilateral Tree-Based Convolutional Neural Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Nghi D. Q. Bui, Lingxiao Jiang, Yijun Yu</td>
	<td>NLSE</td>
	<td><p>Towards the vision of translating code that implements an algorithm from one programming language into another, this
paper  proposes  an  approach  for  automated  program  classification using
bilateral tree-based convolutional neural networks
(BiTBCNNs).  It  is  layered  on  top  of  two  tree-based
convolutional neural networks (TBCNNs), each of which recognizes the algorithm of code written in an individual programming language. The combination layer of the networks
recognizes the similarities and differences among code in different programming languages. The BiTBCNNs are trained
using  the  source  code  in  different  languages  but  known  to
implement  the  same  algorithms  and/or  functionalities.  For
a  preliminary  evaluation,  we  use  3591  Java  and  3534  C++
code snippets from 6 algorithms we crawled systematically
from GitHub. We obtained over 90% accuracy in the cross-language binary classification task to tell whether any given
two code snippets implement a same algorithm. Also, for the
algorithm classification task, i.e., to predict which one of the
six algorithm labels is implemented by an arbitrary C++ code
snippet, we achieved over 80% precision.</p>
</td>
	<td>representation grammar </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/bhatia2018neurosymbolic/">Neuro-symbolic program corrector for introductory programming assignments</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neuro-symbolic program corrector for introductory programming assignments' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neuro-symbolic program corrector for introductory programming assignments' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sahil Bhatia, Pushmeet Kohli, Rishabh Singh</td>
	<td>ICSE</td>
	<td><p>Automatic correction of programs is a challenging problem with numerous real world applications in security, verification, and education. One application that is becoming increasingly important is the correction of student submissions in online courses for providing feedback. Most existing program repair techniques analyze Abstract Syntax Trees (ASTs) of programs, which are unfortunately unavailable for programs with syntax errors. In this paper, we propose a novel Neuro-symbolic approach that combines neural networks with constraint-based reasoning. Specifically, our method first uses a Recurrent Neural Network (RNN) to perform syntax repairs for the buggy programs; subsequently, the resulting syntactically-fixed programs are repaired using constraint-based techniques to ensure functional correctness. The RNNs are trained using a corpus of syntactically correct submissions for a given programming assignment, and are then queried to fix syntax errors in an incorrect programming submission by replacing or inserting the predicted tokens at the error location. We evaluate our technique on a dataset comprising of over 14,500 student submissions with syntax errors. Our method is able to repair syntax errors in 60% (8689) of submissions, and finds functionally correct repairs for 23.8% (3455) submissions.</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/bennun2018neural/">Neural Code Comprehension: A Learnable Representation of Code Semantics</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Code Comprehension: A Learnable Representation of Code Semantics' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Code Comprehension: A Learnable Representation of Code Semantics' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Tal Ben-Nun, Alice Shoshana Jakobovits, Torsten Hoefler</td>
	<td>NeurIPS</td>
	<td><p>With the recent success of embeddings in natural language processing, research has been conducted into applying similar methods to code analysis. Most works attempt to process the code directly or use a syntactic tree representation, treating it like sentences written in a natural language. However, none of the existing methods are sufficient to comprehend program semantics robustly, due to structural features such as function calls, branching, and interchangeable order of statements. In this paper, we propose a novel processing technique to learn code semantics, and apply it to a variety of program analysis tasks. In particular, we stipulate that a robust distributional hypothesis of code applies to both human- and machine-generated programs. Following this hypothesis, we define an embedding space, inst2vec, based on an Intermediate Representation (IR) of the code that is independent of the source programming language. We provide a novel definition of contextual flow for this IR, leveraging both the underlying data- and control-flow of the program. We then analyze the embeddings qualitatively using analogies and clustering, and evaluate the learned representation on three different high-level tasks. We show that with a single RNN architecture and pre-trained fixed embeddings, inst2vec outperforms specialized approaches for performance prediction (compute device mapping, optimal thread coarsening); and algorithm classification from raw code (104 classes), where we set a new state-of-the-art.</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/si2018learning/">Learning Loop Invariants for Program Verification</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Loop Invariants for Program Verification' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Loop Invariants for Program Verification' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xujie Si, Hanjun Dai, Mukund Raghothaman, Mayur Naik, Le Song</td>
	<td>NeurIPS</td>
	<td><p>A fundamental problem in program verification concerns inferring loop invariants.
The problem is undecidable and even practical instances are challenging. Inspired
by how human experts construct loop invariants, we propose a reasoning framework
CODE2INV
that constructs the solution by multi-step decision making and querying
an external program graph memory block. By training with reinforcement learning,
CODE2INV
captures rich program features and avoids the need for ground truth
solutions as supervision.  Compared to previous learning tasks in domains with
graph-structured data, it addresses unique challenges, such as a binary objective
function and an extremely sparse reward that is given by an automated theorem
prover only after the complete loop invariant is proposed. We evaluate
CODE2INV on
a suite of 133 benchmark problems and compare it to three state-of-the-art systems.
It solves 106 problems compared to 73 by a stochastic search-based system, 77 by
a heuristic search-based system, and 100 by a decision tree learning-based system.
Moreover, the strategy learned can be generalized to new programs: compared to
solving new instances from scratch, the pre-trained agent is more sample efficient
in finding solutions.</p>
</td>
	<td>program analysis verification </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/ott2018deep/">A Deep Learning Approach to Identifying Source Code in Images and Video</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Deep Learning Approach to Identifying Source Code in Images and Video' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Deep Learning Approach to Identifying Source Code in Images and Video' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jordan Ott, Abigail Atchison, Paul Harnack, Adrienne Bergh, Erik Linstead.</td>
	<td>MSR</td>
	<td><p>While substantial progress has been made in mining code on an
Internet scale, efforts to date have been overwhelmingly focused on
data sets where source code is represented natively as text. Large
volumes of source code available online and embedded in technical
videos have remained largely unexplored, due in part to the complexity of extraction when code is represented with images. Existing
approaches to code extraction and indexing in this environment rely
heavily on computationally intense optical character recognition.
To improve the ease and efficiency of identifying this embedded
code, as well as identifying similar code examples, we develop a
deep learning solution based on convolutional neural networks and
autoencoders. Focusing on Java for proof of concept, our technique
is able to identify the presence of typeset and handwritten source
code in thousands of video images with 85.6%-98.6% accuracy based
on syntactic and contextual features learned through deep architectures. When combined with traditional approaches, this provides
a more scalable basis for video indexing that can be incorporated
into existing software search and mining tools.</p>
</td>
	<td>information extraction </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/alon2018general/">A General Path-Based Representation for Predicting Program Properties</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A General Path-Based Representation for Predicting Program Properties' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A General Path-Based Representation for Predicting Program Properties' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Uri Alon, Meital Zilberstein, Omer Levy, Eran Yahav</td>
	<td>PLDI</td>
	<td><p>Predicting program properties such as names or expression types has a wide range of applications. It can ease the task of programming and increase programmer productivity. A major challenge when learning from programs is how to represent programs in a way that facilitates effective learning. 
We present a general path-based representation for learning from programs. Our representation is purely syntactic and extracted automatically. The main idea is to represent a program using paths in its abstract syntax tree (AST). This allows a learning model to leverage the structured nature of code rather than treating it as a flat sequence of tokens. 
We show that this representation is general and can: (i) cover different prediction tasks, (ii) drive different learning algorithms (for both generative and discriminative models), and (iii) work across different programming languages. 
We evaluate our approach on the tasks of predicting variable names, method names, and full types. We use our representation to drive both CRF-based and word2vec-based learning, for programs of four languages: JavaScript, Java, Python and C#. Our evaluation shows that our approach obtains better results than task-specific handcrafted representations across different tasks and programming languages.</p>
</td>
	<td>naming representation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/markovtsev2018public/">Public Git Archive: a Big Code dataset for all</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Public Git Archive: a Big Code dataset for all' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Public Git Archive: a Big Code dataset for all' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vadim Markovtsev, Waren Long</td>
	<td>MSR</td>
	<td><p>The number of open source software projects has been growing exponentially. The major online software repository host, GitHub, has accumulated tens of millions of publicly available Git version-controlled repositories. Although the research potential enabled by the available open source code is clearly substantial, no significant large-scale open source code datasets exist. In this paper, we present the Public Git Archive – dataset of 182,014 top-bookmarked Git repositories from GitHub. We describe the novel data retrieval pipeline to reproduce it. We also elaborate on the strategy for performing dataset updates and legal issues. The Public Git Archive occupies 3.0 TB on disk and is an order of magnitude larger than the current source code datasets. The dataset is made available through HTTP and provides the source code of the projects, the related metadata, and development history. The data retrieval pipeline employs an optimized worker queue model and an optimized archive format to efficiently store forked Git repositories, reducing the amount of data to download and persist. Public Git Archive aims to open a myriad of new opportunities for Big Code research.</p>
</td>
	<td>dataset </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/allamanis2018learning/">Learning to Represent Programs with Graphs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Represent Programs with Graphs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Represent Programs with Graphs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Miltiadis Allamanis, Marc Brockschmidt, Mahmoud Khademi</td>
	<td>ICLR</td>
	<td><p>Learning tasks on source code (i.e., formal languages) have been considered recently, but most work has tried to transfer natural language methods and does not capitalize on the unique opportunities offered by code’s known syntax. For example, long-range dependencies induced by using the same variable or function in distant locations are often not considered. We propose to use graphs to represent both the syntactic and semantic structure of code and use graph-based deep learning methods to learn to reason over program structures.</p>

<p>In this work, we present how to construct graphs from source code and how to scale Gated Graph Neural Networks training to such large graphs. We evaluate our method on two tasks: VarNaming, in which a network attempts to predict the name of a variable given its usage, and VarMisuse, in which the network learns to reason about selecting the correct variable that should be used at a given program location. Our comparison to methods that use less structured program representations shows the advantages of modeling known structure, and suggests that our models learn to infer meaningful names and to solve the VarMisuse task in many cases. Additionally, our testing showed that VarMisuse identifies a number of bugs in mature open-source projects.</p>
</td>
	<td>naming GNN representation variable misuse defect </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/loyola2018content/">Content Aware Source Code Change Description Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Content Aware Source Code Change Description Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Content Aware Source Code Change Description Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Pablo Loyola, Edison Marrese-Taylor, Jorge Balazs, Yutaka Matsuo, Fumiko Satoh</td>
	<td>International Natural Language Generation Conference</td>
	<td><p>We propose to study the generation of descriptions from source code changes by integrating  the  messages  included  on  code
commits and the intra-code documentation
inside the source in the form of docstrings.
Our hypothesis is that although both types
of descriptions are not directly aligned in
semantic terms —one explaining a change
and  the  other  the  actual  functionality  of
the code being modified— there could be
certain common ground that is useful for
the  generation.   To  this  end,  we  propose
an architecture that uses the source code-docstring relationship to guide the description generation.  We discuss the results of
the approach comparing against a baseline
based  on  a  sequence-to-sequence  model,
using standard automatic natural language
generation metrics as well as with a human
study, thus offering a comprehensive view
of the feasibility of the approach.</p>
</td>
	<td>edit summarization </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/bui2018hierarchical/">Hierarchical Learning of Cross-Language Mappings through Distributed Vector Representations for Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Hierarchical Learning of Cross-Language Mappings through Distributed Vector Representations for Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Hierarchical Learning of Cross-Language Mappings through Distributed Vector Representations for Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Nghi D. Q. Bui, Lingxiao Jiang</td>
	<td>ICSE</td>
	<td><p>Translating a program written in one programming language to another can be useful for software development tasks that need functionality implementations in different languages. Although past studies have considered this problem, they may be either specific to the language grammars, or specific to certain kinds of code elements (e.g., tokens, phrases, API uses). This paper proposes a new approach to automatically learn cross-language representations for various kinds of structural code elements that may be used for program translation. Our key idea is two folded: First, we normalize and enrich code token streams with additional structural and semantic information, and train cross-language vector representations for the tokens (a.k.a. shared embeddings based on word2vec, a neural-network-based technique for producing word embeddings; Second, hierarchically from bottom up, we construct shared embeddings for code elements of higher levels of granularity (e.g., expressions, statements, methods) from the embeddings for their constituents, and then build mappings among code elements across languages based on similarities among embeddings. 
Our preliminary evaluations on about 40,000 Java and C# source files from 9 software projects show that our approach can automatically learn shared embeddings for various code elements in different languages and identify their cross-language mappings with reasonable Mean Average Precision scores. When compared with an existing tool for mapping library API methods, our approach identifies many more mappings accurately. The mapping results and code can be accessed at this https URL. We believe that our idea for learning cross-language vector representations with code structural information can be a useful step towards automated program translation.</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/tufano2018deep/">Deep Learning Similarities from Different Representations of Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Learning Similarities from Different Representations of Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Learning Similarities from Different Representations of Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Michele Tufano, Cody Watson, Gabriele Bavota, Massimiliano Di Penta, Martin White, Denys Poshyvanyk</td>
	<td>MSR</td>
	<td><p>Assessing the similarity between code components plays a pivotal
role in a number of Software Engineering (SE) tasks, such as clone
detection, impact analysis, refactoring, <em>etc.</em> 
Code similarity is generally measured by relying on manually defined or hand-crafted
features,  e.g.,  by analyzing the overlap among identifiers or comparing the Abstract Syntax Trees of two code components. These
features represent a  best guess at what SE researchers can utilize to
exploit and reliably assess code similarity for a given task. Recent
work has shown, when using a stream of identifiers to represent
the code, that Deep Learning (DL) can effectively replace manual
feature engineering for the task of clone detection. However, source
code can be represented at different levels of abstraction: identifiers, Abstract Syntax Trees, Control Flow Graphs, and Bytecode.
We conjecture that each code representation can provide a different,
yet orthogonal view of the same code fragment, thus, enabling a
more reliable detection of similarities in code. In this paper, we
demonstrate how SE tasks can benefit from a DL-based approach,
which can automatically learn code similarities from different representations.</p>
</td>
	<td>representation clone </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/richardson2018polyglot/">Polyglot Semantic Parsing in APIs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Polyglot Semantic Parsing in APIs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Polyglot Semantic Parsing in APIs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Kyle Richardson, Jonathan Berant, Jonas Kuhn</td>
	<td>NAACL</td>
	<td><p>Traditional approaches to semantic parsing (SP) work by training individual models for each available parallel dataset of text-meaning pairs. In this paper, we explore the idea of polyglot semantic translation, or learning semantic parsing models that are trained on multiple datasets and natural languages. In particular, we focus on translating text to code signature representations using the software component datasets of Richardson and Kuhn (2017a,b). The advantage of such models is that they can be used for parsing a wide variety of input natural languages and output programming languages, or mixed input languages, using a single unified model. To facilitate modeling of this type, we develop a novel graph-based decoding framework that achieves state-of-the-art performance on the above datasets, and apply this method to two other benchmark SP tasks.</p>
</td>
	<td>bimodal API </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/yao2018staqc/">StaQC: A Systematically Mined Question-Code Dataset from Stack Overflow</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=StaQC: A Systematically Mined Question-Code Dataset from Stack Overflow' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=StaQC: A Systematically Mined Question-Code Dataset from Stack Overflow' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ziyu Yao, Daniel S. Weld, Wei-Peng Chen, Huan Sun</td>
	<td>WWW 2018</td>
	<td><p>Stack Overflow (SO) has been a great source of natural language questions and their code solutions (i.e., question-code pairs), which are critical for many tasks including code retrieval and annotation. In most existing research, question-code pairs were collected heuristically and tend to have low quality. In this paper, we investigate a new problem of systematically mining question-code pairs from Stack Overflow (in contrast to heuristically collecting them). It is formulated as predicting whether or not a code snippet is a standalone solution to a question. We propose a novel Bi-View Hierarchical Neural Network which can capture both the programming content and the textual context of a code snippet (i.e., two views) to make a prediction. On two manually annotated datasets in Python and SQL domain, our framework substantially outperforms heuristic methods with at least 15% higher F1 and accuracy. Furthermore, we present StaQC (Stack Overflow Question-Code pairs), the largest dataset to date of ∼148K Python and ∼120K SQL question-code pairs, automatically mined from SO using our framework. Under various case studies, we demonstrate that StaQC can greatly help develop data-hungry models for associating natural language with programming language.</p>
</td>
	<td>dataset </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/tufano2018empirical/">An Empirical Study on Learning Bug-Fixing Patches in the Wild via Neural Machine Translation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=An Empirical Study on Learning Bug-Fixing Patches in the Wild via Neural Machine Translation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=An Empirical Study on Learning Bug-Fixing Patches in the Wild via Neural Machine Translation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Michele Tufano, Cody Watson, Gabriele Bavota, Massimiliano Di Penta, Martin White, Denys Poshyvanyk</td>
	<td></td>
	<td><p>Millions of open-source projects with numerous bug fixes are available in code repositories. This proliferation of software development histories can be leveraged to learn how to fix common programming bugs. To explore such a potential, we perform an empirical study to assess the feasibility of using Neural Machine Translation techniques for learning bug-fixing patches for real defects. First, we mine millions of bug-fixes from the change histories of projects hosted on GitHub, in order to extract meaningful examples of such bug-fixes. Next, we abstract the buggy and corresponding fixed code, and use them to train an Encoder-Decoder model able to translate buggy code into its fixed version. In our empirical investigation we found that such a model is able to fix thousands of unique buggy methods in the wild. Overall, this model is capable of predicting fixed patches generated by developers in 9-50% of the cases, depending on the number of candidate patches we allow it to generate. Also, the model is able to emulate a variety of different Abstract Syntax Tree operations and generate candidate patches in a split second.</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/saini2018oreo/">Oreo: detection of clones in the twilight zone</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Oreo: detection of clones in the twilight zone' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Oreo: detection of clones in the twilight zone' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vaibhav Saini, Farima Farmahinifarahani, Yadong Lu, Pierre Baldi, Cristina Lopes</td>
	<td>ESEC/FSE</td>
	<td><p>Source code clones are categorized into four types of increasing difficulty of detection, ranging from purely textual (Type-1) to purely semantic (Type-4). Most clone detectors reported in the literature work well up to Type-3, which accounts for syntactic differences. In between Type-3 and Type-4, however, there lies a spectrum of clones that, although still exhibiting some syntactic similarities, are extremely hard to detect – the Twilight Zone. Most clone detectors reported in the literature fail to operate in this zone. We present Oreo, a novel approach to source code clone detection that not only detects Type-1 to Type-3 clones accurately, but is also capable of detecting harder-to-detect clones in the Twilight Zone. Oreo is built using a combination of machine learning, information retrieval, and software metrics. We evaluate the recall of Oreo on BigCloneBench, and perform manual evaluation for precision. Oreo has both high recall and precision. More importantly, it pushes the boundary in detection of clones with moderate to weak syntactic similarity in a scalable manner.</p>
</td>
	<td>clone </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/hellendoorn2018deep/">Deep Learning Type Inference</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Learning Type Inference' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Learning Type Inference' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>V. J. Hellendoorn, Christian Bird, Earl T. Barr, Miltiadis Allamanis</td>
	<td>FSE</td>
	<td><p>Dynamically typed languages such as JavaScript and Python are
increasingly popular, yet static typing has not been totally eclipsed:
Python now supports type annotations and languages like TypeScript offer a middle-ground for JavaScript: a strict superset of
JavaScript, to which it transpiles, coupled with a type system that
permits partially typed programs. However, static typing has a cost:
adding annotations, reading the added syntax, and wrestling with
the type system to fix type errors. Type inference can ease the
transition to more statically typed code and unlock the benefits of
richer compile-time information, but is limited in languages like
JavaScript as it cannot soundly handle duck-typing or runtime evaluation
via eval. We propose DeepTyper, a deep learning model
that understands which types naturally occur in certain contexts
and relations and can provide type suggestions, which can often
be verified by the type checker, even if it could not infer the type
initially. DeepTyper, leverages an automatically aligned corpus
of tokens and types to accurately predict thousands of variable
and function type annotations. Furthermore, we demonstrate that
context is key in accurately assigning these types and introduce a
technique to reduce overfitting on local cues while highlighting the
need for further improvements. Finally, we show that our model
can interact with a compiler to provide more than 4,000 additional
type annotations with over 95% precision that could not be inferred
without the aid of DeepTyper.</p>
</td>
	<td>representation types </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/russell2018automated/">Automated Vulnerability Detection in Source Code Using Deep Representation Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Automated Vulnerability Detection in Source Code Using Deep Representation Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Automated Vulnerability Detection in Source Code Using Deep Representation Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rebecca L. Russell, Louis Kim, Lei H. Hamilton, Tomo Lazovich, Jacob A. Harer, Onur Ozdemir, Paul M. Ellingwood, Marc W. McConley</td>
	<td></td>
	<td><p>Increasing numbers of software vulnerabilities are discovered every year whether they are reported publicly or discovered internally in proprietary code. These vulnerabilities can pose serious risk of exploit and result in system compromise, information leaks, or denial of service. We leveraged the wealth of C and C++ open-source code available to develop a large-scale function-level vulnerability detection system using machine learning. To supplement existing labeled vulnerability datasets, we compiled a vast dataset of millions of open-source functions and labeled it with carefully-selected findings from three different static analyzers that indicate potential exploits. Using these datasets, we developed a fast and scalable vulnerability detection tool based on deep feature representation learning that directly interprets lexed source code. We evaluated our tool on code from both real software packages and the NIST SATE IV benchmark dataset. Our results demonstrate that deep feature representation learning on source code is a promising approach for automated software vulnerability detection.</p>
</td>
	<td>program analysis </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/liu2018neural/">Neural-Machine-Translation-Based Commit Message Generation: How Far Are We?</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural-Machine-Translation-Based Commit Message Generation: How Far Are We?' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural-Machine-Translation-Based Commit Message Generation: How Far Are We?' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zhongxin Liu, Xin Xia, Ahmed E. Hassan, David Lo, Zhenchang Xing, Xinyu Wang</td>
	<td>ASE</td>
	<td><p>Commit messages can be regarded as the documentation of software changes. These messages describe the content and purposes of changes, hence are useful for program comprehension and software maintenance. However, due to the lack of time and direct motivation, commit messages sometimes are neglected by developers. To address this problem, Jiang et al. proposed an approach (we refer to it as NMT), which leverages a neural machine translation algorithm to automatically generate short commit messages from code. The reported performance of their approach is promising, however, they did not explore why their approach performs well. Thus, in this paper, we first perform an in-depth analysis of their experimental results. We find that (1) Most of the test &lt;pre&gt;diffs&lt;/pre&gt; from which NMT can generate high-quality messages are similar to one or more training &lt;pre&gt;diffs&lt;/pre&gt; at the token level. (2) About 16% of the commit messages in Jiang et al.’s dataset are noisy due to being automatically generated or due to them describing repetitive trivial changes. (3) The performance of NMT declines by a large amount after removing such noisy commit messages. In addition, NMT is complicated and time-consuming. Inspired by our first finding, we proposed a simpler and faster approach, named NNGen (Nearest Neighbor Generator), to generate concise commit messages using the nearest neighbor algorithm. Our experimental results show that NNGen is over 2,600 times faster than NMT, and outperforms NMT in terms of BLEU (an accuracy measure that is widely used to evaluate machine translation systems) by 21%. Finally, we also discuss some observations for the road ahead for automated commit message generation to inspire other researchers.</p>
</td>
	<td>edit summarization </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/hashimoto2018retrieve/">A Retrieve-and-Edit Framework for Predicting Structured Outputs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Retrieve-and-Edit Framework for Predicting Structured Outputs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Retrieve-and-Edit Framework for Predicting Structured Outputs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Tatsunori B. Hashimoto, Kelvin Guu, Yonatan Oren, Percy S. Liang</td>
	<td>NeurIPS</td>
	<td><p>For the task of generating complex outputs such as source code, editing existing
outputs can be easier than generating complex outputs from scratch.  With this
motivation, we propose an approach that first retrieves a training example based on
the input (e.g., natural language description) and then edits it to the desired output
(e.g., code). Our contribution is a computationally efficient method for learning
a retrieval model that embeds the input in a task-dependent way without relying
on a hand-crafted metric or incurring the expense of jointly training the retriever
with the editor.  Our retrieve-and-edit framework can be applied on top of any
base model. We show that on a new autocomplete task for GitHub Python code
and the Hearthstone cards benchmark, retrieve-and-edit significantly boosts the
performance of a vanilla sequence-to-sequence model on both tasks.</p>
</td>
	<td>bimodal search code generation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/raghothaman2018user/">User-guided program reasoning using Bayesian inference</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=User-guided program reasoning using Bayesian inference' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=User-guided program reasoning using Bayesian inference' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Mukund Raghothaman, Sulekha Kulkarni, Kihong Heo, Mayur Naik</td>
	<td>PLDI</td>
	<td><p>Program analyses necessarily make approximations that often lead them to report true alarms interspersed with many false alarms. We propose a new approach to leverage user feedback to guide program analyses towards true alarms and away from false alarms. Our approach associates each alarm with a confidence value by performing Bayesian inference on a probabilistic model derived from the analysis rules. In each iteration, the user inspects the alarm with the highest confidence and labels its ground truth, and the approach recomputes the confidences of the remaining alarms given this feedback. It thereby maximizes the return on the effort by the user in inspecting each alarm. We have implemented our approach in a tool named Bingo for program analyses expressed in Datalog. Experiments with real users and two sophisticated analyses—a static datarace analysis for Java programs and a static taint analysis for Android apps—show significant improvements on a range of metrics, including false alarm rates and number of bugs found.</p>
</td>
	<td>program analysis </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/hata2018learning/">Learning to Generate Corrective Patches using Neural Machine Translation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Generate Corrective Patches using Neural Machine Translation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Generate Corrective Patches using Neural Machine Translation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hideaki Hata, Emad Shihab, Graham Neubig</td>
	<td></td>
	<td><p>Bug fixing is generally a manually-intensive task. However, recent work has proposed the idea of automated program repair, which aims to repair (at least a subset of) bugs in different ways such as code mutation, etc. Following in the same line of work as automated bug repair, in this paper we aim to leverage past fixes to propose fixes of current/future bugs. Specifically, we propose Ratchet, a corrective patch generation system using neural machine translation. By learning corresponding pre-correction and post-correction code in past fixes with a neural sequence-to-sequence model, Ratchet is able to generate a fix code for a given bug-prone code query. We perform an empirical study with five open source projects, namely Ambari, Camel, Hadoop, Jetty and Wicket, to evaluate the effectiveness of Ratchet. Our findings show that Ratchet can generate syntactically valid statements 98.7% of the time, and achieve an F1-measure between 0.41-0.83 with respect to the actual fixes adopted in the code base. In addition, we perform a qualitative validation using 20 participants to see whether the generated statements can be helpful in correcting bugs. Our survey showed that Ratchet’s output was considered to be helpful in fixing the bugs on many occasions, even if fix was not 100% correct.</p>
</td>
	<td>repair code generation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/wan2018improving/">Improving Automatic Source Code Summarization via Deep Reinforcement Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Improving Automatic Source Code Summarization via Deep Reinforcement Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Improving Automatic Source Code Summarization via Deep Reinforcement Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yao Wan, Zhou Zhao, Min Yang, Guandong Xu, Haochao Ying, Jian Wu, Philip S. Yu</td>
	<td>ASE</td>
	<td><p>Code summarization provides a high level natural language description of the function performed by code, as it can benefit the software maintenance, code categorization and retrieval. To the best of our knowledge, most state-of-the-art approaches follow an encoder-decoder framework which encodes the code into a hidden space and then decode it into natural language space, suffering from two major drawbacks: a) Their encoders only consider the sequential content of code, ignoring the tree structure which is also critical for the task of code summarization; b) Their decoders are typically trained to predict the next word by maximizing the likelihood of next ground-truth word with previous ground-truth word given. However, it is expected to generate the entire sequence from scratch at test time. This discrepancy can cause an exposure bias issue, making the learnt decoder suboptimal. In this paper, we incorporate an abstract syntax tree structure as well as sequential content of code snippets into a deep reinforcement learning framework (i.e., actor-critic network). The actor network provides the confidence of predicting the next word according to current state. On the other hand, the critic network evaluates the reward value of all possible extensions of the current state and can provide global guidance for explorations. We employ an advantage reward composed of BLEU metric to train both networks. Comprehensive experiments on a real-world dataset show the effectiveness of our proposed model when compared with some state-of-the-art methods.</p>
</td>
	<td>summarization documentation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/tufano2018learning/">Learning How to Mutate Source Code from Bug-Fixes</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning How to Mutate Source Code from Bug-Fixes' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning How to Mutate Source Code from Bug-Fixes' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Michele Tufano, Cody Watson, Gabriele Bavota, Massimiliano Di Penta, Martin White, Denys Poshyvanyk</td>
	<td></td>
	<td><p>Mutation testing has been widely accepted as an approach to guide test case generation or to assess the effectiveness of test suites. Empirical studies have shown that mutants are representative of real faults; yet they also indicated a clear need for better, possibly customized, mutation operators and strategies. While some recent papers have tried to devise domain-specific or general purpose mutator operators by manually analyzing real faults, such an activity is effort- (and error-) prone and does not deal with an important practical question as to how to really mutate a given source code element. We propose a novel approach to automatically learn mutants from faults in real programs. First, our approach processes bug fixing changes using fine-grained differencing, code abstraction, and change clustering. Then, it learns mutation models using a deep learning strategy. We have trained and evaluated our technique on a set of ~787k bugs mined from GitHub. Starting from code fixed by developers in the context of a bug-fix, our empirical evaluation showed that our models are able to predict mutants that resemble original fixed bugs in between 9% and 45% of the cases (depending on the model). Moreover, over 98% of the automatically generated mutants are lexically and syntactically correct.</p>
</td>
	<td>repair edit </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/harer2018learning/">Learning to Repair Software Vulnerabilities with Generative Adversarial Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Repair Software Vulnerabilities with Generative Adversarial Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Repair Software Vulnerabilities with Generative Adversarial Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jacob Harer, Onur Ozdemir, Tomo Lazovich, Christopher P. Reale, Rebecca L. Russell, Louis Y. Kim, Peter Chin</td>
	<td>NeurIPS</td>
	<td><p>Motivated by the problem of automated repair of software vulnerabilities, we propose an adversarial learning approach that maps from one discrete source domain to another target domain without requiring paired labeled examples or source and target domains to be bijections. We demonstrate that the proposed adversarial learning approach is an effective technique for repairing software vulnerabilities, performing close to seq2seq approaches that require labeled pairs. The proposed Generative Adversarial Network approach is application-agnostic in that it can be applied to other problems similar to code repair, such as grammar correction or sentiment translation.</p>
</td>
	<td>repair code generation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/lin2018nl2bash/">NL2Bash: A Corpus and Semantic Parser for Natural Language Interface to the Linux Operating System</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=NL2Bash: A Corpus and Semantic Parser for Natural Language Interface to the Linux Operating System' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=NL2Bash: A Corpus and Semantic Parser for Natural Language Interface to the Linux Operating System' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xi Victoria Lin, Chenglong Wang, Luke Zettlemoyer, Michael D. Ernst</td>
	<td>LREC</td>
	<td><p>We present new data and semantic parsing methods for the problem of mapping english sentences to Bash commands (NL2Bash). Our long-term goal is to enable any user to easily solve otherwise repetitive tasks (such as file manipulation, search, and application-specific scripting) by simply stating their intents in English. We take a first step in this domain, by providing a large new dataset of challenging but commonly used commands paired with their English descriptions, along with the baseline methods to establish performance levels on this task.</p>
</td>
	<td>bimodal code generation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/gu2018deep/">Deep Code Search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Code Search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Code Search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xiaodong Gu, Hongyu Zhang, Sunghun Kim.</td>
	<td>ICSE</td>
	<td><p>To implement a program functionality, developers can reuse previously written code snippets by searching through a large-scale codebase. Over the years, many code search tools have been proposed to help developers. The existing approaches often treat source code as textual documents and utilize information retrieval models to retrieve relevant code snippets that match a given query. These approaches mainly rely on the textual similarity between source code and natural language query. They lack a deep understanding of the semantics of queries and source code.</p>

<p>In this paper, we propose a novel deep neural network named CODEnn (Code-Description Embedding Neural Network). Instead of matching text similarity, CODEnn jointly embeds code snippets and natural language descriptions into a high-dimensional vector space, in such a way that code snippet and its corresponding description have similar vectors. Using the unified vector representation, code snippets related to a natural language query can be retrieved according to their vectors. Semantically related words can also be recognized and irrelevant/noisy keywords in queries can be handled.</p>

<p>As a proof-of-concept application, we implement a code search tool named DeepCS using the proposed CODEnn model. We empirically evaluate DeepCS on a large scale codebase collected from GitHub. The experimental results show that our approach can effectively retrieve relevant code snippets and outperforms previous techniques.</p>

</td>
	<td>search </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/zhao2018neural/">Neural-Augumented Static Analysis of Android Communication</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural-Augumented Static Analysis of Android Communication' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural-Augumented Static Analysis of Android Communication' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jinman Zhao, Aws Albarghouthi, Vaibhav Rastogi, Somesh Jha, Damien Octeau</td>
	<td>FSE</td>
	<td><p>We address the problem of discovering communication links between applications in the popular Android mobile operating system, an important problem for security and privacy in Android. Any scalable static analysis in this complex setting is bound to produce an excessive amount of false-positives, rendering it impractical. To improve precision, we propose to augment static analysis with a trained neural-network model that estimates the probability that a communication link truly exists. We describe a neural-network architecture that encodes abstractions of communicating objects in two applications and estimates the probability with which a link indeed exists. At the heart of our architecture are type-directed encoders (TDE), a general framework for elegantly constructing encoders of a compound data type by recursively composing encoders for its constituent types. We evaluate our approach on a large corpus of Android applications, and demonstrate that it achieves very high accuracy. Further, we conduct thorough interpretability studies to understand the internals of the learned neural networks.</p>
</td>
	<td>program analysis </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/gupta2018intelligent/">Intelligent code reviews using deep learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Intelligent code reviews using deep learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Intelligent code reviews using deep learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Anshul Gupta, Neel Sundaresan</td>
	<td>KDD</td>
	<td><p>Peer code review is a best practice in Software Engineering where source code is reviewed manually by one or more peers(reviewers) of the code author. It is widely acceptable both in industry and open-source software (OSS) systems as a process for early detection and reduction of software defects. A larger chunk of reviews given during peer reviews are related to common issues such as coding style, documentations, and best practices. This makes the code review process less effective as reviewers focus less on finding important defects. Hence, there is a need to automatically find such common issues and help reviewers perform focused code reviews. Some of this is solved by rule based systems called linters but they are rigid and needs a lot of manual effort to adapt them for a new issue.</p>

<p>In this work, we present an automatic, flexible, and adaptive code analysis system called DeepCodeReviewer (DCR). DCR learns how to recommend code reviews related to common issues using historical peer reviews and deep learning. DCR uses deep learning to learn review relevance to a code snippet and recommend the right review from a repository of common reviews. DCR is trained on histroical peer reviews available from internal code repositories at Microsoft. Experiments demonstrate strong performance of developed deep learning model in classifying relevant and non-relevant reviews w.r.t to a code snippet, and ranking reviews given a code snippet. We have also evaluated DCR recommentations using a user study and survey. The results of our user study show good acceptance rate and answers of our survey questions are strongly correlated with our system’s goal of making code reviews focused on finding defects.</p>
</td>
	<td>representation review </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/zhong2018generating/">Generating Regular Expressions from Natural Language Specifications: Are We There Yet?</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Generating Regular Expressions from Natural Language Specifications: Are We There Yet?' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Generating Regular Expressions from Natural Language Specifications: Are We There Yet?' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zexuan Zhong, Jiaqi Guo, Wei Yang, Tao Xie, Jian-Guang Lou, Ting Liu, Dongmei Zhang</td>
	<td>NLSE</td>
	<td><p>Recent  state-of-the-art  approaches  automatically  generate
regular  expressions  from  natural  language  specifications.
Given that these approaches use only synthetic data in both
training datasets and validation/test datasets, a natural question arises: are these approaches effective to address various
real-world  situations?  To  explore  this  question,  in  this  paper, we conduct a characteristic study on comparing two synthetic datasets used by the recent research and a real-world
dataset  collected  from  the  Internet,  and  conduct  an  experimental study on applying a state-of-the-art approach on the
real-world dataset. Our study results suggest the existence of
distinct characteristics between the synthetic datasets and the
real-world  dataset,  and  the  state-of-the-art  approach  (based
on  a  model  trained  from  a  synthetic  dataset)  achieves  extremely low effectiveness when evaluated on real-world data,
much lower than the effectiveness when evaluated on the synthetic  dataset.  We  also  provide  initial  analysis  on  some  of
those challenging cases and discuss future directions.</p>
</td>
	<td>bimodal code generation </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/yin2018mining/">Learning to Mine Aligned Code and Natural Language Pairs from Stack Overflow</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Mine Aligned Code and Natural Language Pairs from Stack Overflow' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Mine Aligned Code and Natural Language Pairs from Stack Overflow' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Pengcheng Yin, B. Deng, E. Chen, B. Vasilescu, Graham Neubig</td>
	<td>MSR</td>
	<td><p>For tasks like code synthesis from natural language, code retrieval, and code summarization, data-driven models have shown great promise. However, creating these models require parallel data between natural language (NL) and code with fine-grained alignments. Stack Overflow (SO) is a promising source to create such a data set: the questions are diverse and most of them have corresponding answers with high-quality code snippets. However, existing heuristic methods (e.g., pairing the title of a post with the code in the accepted answer) are limited both in their coverage and the correctness of the NL-code pairs obtained. In this paper, we propose a novel method to mine high-quality aligned data from SO using two sets of features: hand-crafted features considering the structure of the extracted snippets, and correspondence features obtained by training a probabilistic model to capture the correlation between NL and code using neural networks. These features are fed into a classifier that determines the quality of mined NL-code pairs. Experiments using Python and Java as test beds show that the proposed method greatly expands coverage and accuracy over existing mining methods, even when using only a small number of labeled examples. Further, we find that reasonable results are achieved even when training the classifier on one language and testing on another, showing promise for scaling NL-code mining to a wide variety of programming languages beyond those for which we are able to annotate data.</p>

</td>
	<td>dataset </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/parvez2018building/">Building Language Models for Text with Named Entities</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Building Language Models for Text with Named Entities' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Building Language Models for Text with Named Entities' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>M.R. Parvez, Saikat Chakraborty, Baishakhi Ray, KW Chang</td>
	<td>ACL</td>
	<td><p>Text  in  many  domains  involves  a  significant amount of named entities.   Predicting the entity names is often challenging
for a language model as they appear less
frequent  on  the  training  corpus.   In  this
paper,  we  propose  a  novel  and  effective
approach to building a discriminative language  model  which  can  learn  the  entity
names by leveraging their entity type information.  We also introduce two benchmark  datasets  based  on  recipes  and  Java
programming codes,  on which we evaluate the proposed model.  Experimental results show that our model achieves 52.2%
better perplexity in recipe generation and
22.06% on code generation than the state-of-the-art language models.</p>
</td>
	<td>language model </td>
</tr>

<tr>
	<td>2018</td>
	<td><a href="/publications/gupta2018deep/">Deep Reinforcement Learning for Programming Language Correction</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Reinforcement Learning for Programming Language Correction' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Reinforcement Learning for Programming Language Correction' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rahul Gupta, Aditya Kanade, Shirish Shevade</td>
	<td></td>
	<td><p>Novice programmers often struggle with the formal
syntax of programming languages.  To assist them,
we design a novel programming language correction  framework  amenable  to  reinforcement  learning.  The framework allows an agent to mimic human  actions  for  text  navigation  and  editing.   We
demonstrate that the agent can be trained through
self-exploration directly from the raw input, that is,
program text itself, without any knowledge of the
formal syntax of the programming language.   We
leverage expert demonstrations for one tenth of the
training data to accelerate training.  The proposed
technique  is  evaluated  on 6975
erroneous  C  programs with typographic errors, written by students
during an introductory programming course.  Our
technique fixes 14%
more programs and 29% more
compiler error messages relative to those fixed by
a state-of-the-art tool, DeepFix, which uses a fully
supervised neural machine translation approach.</p>
</td>
	<td>repair code generation </td>
</tr>



<tr>
	<td>2017</td>
	<td><a href="/publications/white2017sorting/">Sorting and Transforming Program Repair Ingredients via Deep Learning Code Similarities</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Sorting and Transforming Program Repair Ingredients via Deep Learning Code Similarities' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Sorting and Transforming Program Repair Ingredients via Deep Learning Code Similarities' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Martin White, Michele Tufano, Matias Martinez, Martin Monperrus, Denys Poshyvanyk</td>
	<td>SANER</td>
	<td><p>In  the  field  of  automated  program  repair,  the  redundancy  assumption  claims  large  programs  contain  the  seeds
of  their  own  repair.  However,  most  redundancy-based  program
repair  techniques  do  not  reason  about  the  repair  ingredients—the code that is reused to craft a patch. We aim to reason about
the repair ingredients by using code similarities to prioritize and
transform  statements  in  a  codebase  for  patch  generation.  Our
approach,  DeepRepair,  relies  on  deep  learning  to  reason  about
code  similarities.  Code  fragments  at  well-defined  levels  of  granularity in a codebase can be sorted according to their similarity
to suspicious elements (i.e., code elements that contain suspicious
statements) and statements can be transformed by mapping out-of-scope  identifiers  to  similar  identifiers  in  scope.  We  examined
these new search strategies for patch generation with respect to
effectiveness  from  the  viewpoint  of  a  software  maintainer.  Our
comparative experiments were executed on six open-source Java
projects  including  374  buggy  program  revisions  and  consisted
of  19,949  trials  spanning  2,616  days  of  computation  time.  DeepRepair’s  search  strategy  using  code  similarities  generally  found
compilable  ingredients  faster  than  the  baseline,  jGenProg,  but
this improvement neither yielded test-adequate patches in fewer
attempts (on average) nor found significantly more patches than
the  baseline.  Although  the  patch  counts  were  not  statistically
different,  there  were  notable  differences  between  the  nature  of
DeepRepair  patches  and  baseline  patches.  The  results  demonstrate that our learning-based approach finds patches that cannot
be  found  by  existing  redundancy-based  repair  techniques</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/beltramelli2017pix2code/">pix2code: Generating Code from a Graphical User Interface Screenshot</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=pix2code: Generating Code from a Graphical User Interface Screenshot' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=pix2code: Generating Code from a Graphical User Interface Screenshot' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Tony Beltramelli</td>
	<td></td>
	<td><p>Transforming a graphical user interface screenshot created by a designer into computer code is a typical task conducted by a developer in order to build customized software, websites and mobile applications. In this paper, we show that Deep Learning techniques can be leveraged to automatically generate code given a graphical user interface screenshot as input. Our model is able to generate code targeting three different platforms (i.e. iOS, Android and web-based technologies) from a single input image with over 77% of accuracy.</p>

</td>
	<td>code generation bimodal </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/bavishi2017context2name/">Context2Name: A Deep Learning-Based Approach to Infer Natural Variable Names from Usage Contexts</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Context2Name: A Deep Learning-Based Approach to Infer Natural Variable Names from Usage Contexts' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Context2Name: A Deep Learning-Based Approach to Infer Natural Variable Names from Usage Contexts' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rohan Bavishi, Michael Pradel, Koushik Sen</td>
	<td></td>
	<td><p>Most of the JavaScript code deployed in the wild has been minified, a process in which identifier names are replaced
with short, arbitrary and meaningless names. Minified code occupies less space, but also makes the code extremely difficult to manually inspect and understand. This paper presents Context2Name, a deep learning-based technique that partially reverses the effect of minification by predicting natural
identifier names for minified names. The core idea is to predict from the usage context of a variable a name that captures
the meaning of the variable. The approach combines a lightweight, token-based static analysis with an auto-encoder
neural network that summarizes usage contexts and a recurrent neural network that predict natural names for a given
usage context. We evaluate Context2Name
with a large corpus of real-world JavaScript code and show that it successfully predicts 60.4% of all minified identifiers. A comparison
with the state-of-the-art tools JSNice and JSNaughty shows
that our approach predicts 17% and 43% more names than the
best existing approaches, while taking only 2.6 milliseconds
to predict a name, on average.</p>
</td>
	<td>naming </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/nguyen2017exploring/">Exploring API Embedding for API Usages and Applications</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Exploring API Embedding for API Usages and Applications' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Exploring API Embedding for API Usages and Applications' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Trong Duc Nguyen, Anh Tuan Nguyen, Hung Dang Phan, Tien N. Nguyen</td>
	<td>ICSE</td>
	<td><p>Word2Vec is a class of neural network models that
as being trained from a large corpus of texts, they can produce for
each unique word a corresponding vector in a continuous space in
which linguistic contexts of words can be observed. In this work,
we study the characteristics of Word2Vec vectors, called API 2 VEC
or API embeddings, for the API elements within the API sequences in source code. Our empirical study shows that the close
proximity of the API 2 VEC vectors for API elements reflects the
similar usage contexts containing the surrounding APIs of those
API elements. Moreover, API 2 VEC can capture several similar
semantic relations between API elements in API usages via vector
offsets. We demonstrate the usefulness of API 2 VEC vectors for
API elements in three applications. First, we build a tool that mines the pairs of API elements that share the same usage relations
among them. The other applications are in the code migration
domain. We develop API 2 API , a tool to automatically learn the
API mappings between Java and C# using a characteristic of the
API 2 VEC vectors for API elements in the two languages: semantic
relations among API elements in their usages are observed in the
two vector spaces for the two languages as similar geometric
arrangements among their API 2 VEC vectors. Our empirical
evaluation shows that API 2 API relatively improves 22.6% and
40.1% top-1 and top-5 accuracy over a state-of-the-art mining
approach for API mappings. Finally, as another application in
code migration, we are able to migrate equivalent API usages
from Java to C# with up to 90.6% recall and 87.2% precision.</p>
</td>
	<td>API representation </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/jiang2017automatically/">Automatically Generating Commit Messages from Diffs using Neural Machine Translation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Automatically Generating Commit Messages from Diffs using Neural Machine Translation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Automatically Generating Commit Messages from Diffs using Neural Machine Translation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Siyuan Jiang, Ameer Armaly, Collin McMillan</td>
	<td>ASE</td>
	<td><p>Commit messages are a valuable resource in comprehension of software evolution, since they provide a record of changes such as feature additions and bug repairs. Unfortunately, programmers often neglect to write good commit messages. Different techniques have been proposed to help programmers by automatically writing these messages. These techniques are effective at describing what changed, but are often verbose and lack context for understanding the rationale behind a change. In contrast, humans write messages that are short and summarize the high level rationale. In this paper, we adapt Neural Machine Translation (NMT) to automatically “translate” diffs into commit messages. We trained an NMT algorithm using a corpus of diffs and human-written commit messages from the top 1k Github projects. We designed a filter to help ensure that we only trained the algorithm on higher-quality commit messages. Our evaluation uncovered a pattern in which the messages we generate tend to be either very high or very low quality. Therefore, we created a quality-assurance filter to detect cases in which we are unable to produce good messages, and return a warning instead.</p>
</td>
	<td>edit bimodal </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/devlin2017semantic/">Semantic Code Repair using Neuro-Symbolic Transformation Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Semantic Code Repair using Neuro-Symbolic Transformation Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Semantic Code Repair using Neuro-Symbolic Transformation Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jacob Devlin, Jonathan Uesato, Rishabh Singh, Pushmeet Kohli</td>
	<td></td>
	<td><p>We study the problem of semantic code repair, which can be broadly defined as automatically fixing
non-syntactic bugs in source code. The majority of past work in semantic code repair assumed access
to unit tests against which candidate repairs could be validated. In contrast, the goal here is to
develop a strong statistical model to accurately predict both bug locations and exact fixes without
access to information about the intended correct behavior of the program. Achieving such a goal
requires a robust contextual repair model, which we train on a large corpus of real-world source
code that has been augmented with synthetically injected bugs. Our framework adopts a two-stage
approach where first a large set of repair candidates are generated by rule-based processors, and
then these candidates are scored by a statistical model using a novel neural network architecture
which we refer to as Share, Specialize, and Compete. Specifically, the architecture (1) generates
a shared encoding of the source code using an RNN over the abstract syntax tree, 
(2) scores each candidate repair using specialized network modules, and (3) then normalizes these
scores together so they can compete against one another in comparable probability space. We evaluate
our model on a real-world test set gathered from GitHub containing four common categories of bugs.
Our model is able to predict the exact correct repair 41% of the time with a single guess, compared
to 13% accuracy for an attentional sequence-to-sequence model.</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/barone2017parallel/">A parallel corpus of Python functions and documentation strings for automated code documentation and code generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A parallel corpus of Python functions and documentation strings for automated code documentation and code generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A parallel corpus of Python functions and documentation strings for automated code documentation and code generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Antonio Valerio Miceli Barone, Rico Sennrich</td>
	<td></td>
	<td><p>Automated documentation of programming source code and automated code generation from natural language are challenging tasks of both practical and scientific interest. Progress in these areas has been limited by the low availability of parallel corpora of code and natural language descriptions, which tend to be small and constrained to specific domains.</p>

<p>In this work we introduce a large and diverse parallel corpus of a hundred thousands Python functions with their documentation strings (“docstrings”) generated by scraping open source repositories on GitHub. We describe baseline results for the code documentation and code generation tasks obtained by neural machine translation. We also experiment with 
data augmentation techniques to further increase the amount of training data.</p>

<p>We release our datasets and processing scripts in order to stimulate research in these areas.</p>

</td>
	<td>documentation summarization dataset </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/yin2017syntactic/">A Syntactic Neural Model for General-Purpose Code Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Syntactic Neural Model for General-Purpose Code Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Syntactic Neural Model for General-Purpose Code Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Pengcheng Yin, Graham Neubig</td>
	<td>ACL</td>
	<td><p>We consider the problem of parsing natural language descriptions into source code
written in a general-purpose programming
language like Python. Existing data-driven methods treat this problem as a language generation task without considering
the underlying syntax of the target programming language. Informed by previous work in semantic parsing, in this paper we propose a novel neural architecture
powered by a grammar model to explicitly
capture the target syntax as prior knowledge. Experiments find this an effective
way to scale up to generation of complex
programs from natural language descriptions, achieving state-of-the-art results that
well outperform previous code generation
and semantic parsing approaches.</p>
</td>
	<td>code generation grammar bimodal </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/loyola2017neural/">A Neural Architecture for Generating Natural Language Descriptions from Source Code Changes</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Neural Architecture for Generating Natural Language Descriptions from Source Code Changes' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Neural Architecture for Generating Natural Language Descriptions from Source Code Changes' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Pablo Loyola, Edison Marrese-Taylor, Yutaka Matsuo</td>
	<td></td>
	<td><p>We propose a model to automatically describe changes introduced in the source code of a program using natural language. Our method receives as input a set of code commits, which contains both the modifications and message introduced by an user. These two modalities are used to train an encoder-decoder architecture. We evaluated our approach on twelve real world open source projects from four different programming languages. Quantitative and qualitative results showed that the proposed approach can generate feasible and semantically sound descriptions not only in standard in-project settings, but also in a cross-project setting.</p>
</td>
	<td>edit summarization </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/amodio2017neural/">Neural Attribute Machines for Program Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Attribute Machines for Program Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Attribute Machines for Program Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Matthew Amodio, Swarat Chaudhuri, Thomas W. Reps</td>
	<td></td>
	<td><p>Recurrent neural networks have achieved remarkable success at generating sequences with complex structures, thanks to advances that include richer embeddings of input and cures for vanishing gradients. Trained only on sequences from a known grammar, though, they can still struggle to learn rules and constraints of the grammar. Neural Attribute Machines (NAMs) are equipped with a logical machine that represents the underlying grammar, which is used to teach the constraints to the neural machine by (i) augmenting the input sequence, and (ii) optimizing a custom loss function. Unlike traditional RNNs, NAMs are exposed to the grammar, as well as samples from the language of the grammar. During generation, NAMs make significantly fewer violations of the constraints of the underlying grammar than RNNs trained only on samples from the language of the grammar.</p>

</td>
	<td>grammar code generation representation </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/hellendoorn2017deep/">Are Deep Neural Networks the Best Choice for Modeling Source Code?</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Are Deep Neural Networks the Best Choice for Modeling Source Code?' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Are Deep Neural Networks the Best Choice for Modeling Source Code?' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vincent J. Hellendoorn, Premkumar Devanbu</td>
	<td>FSE</td>
	<td><p>Current statistical language modeling techniques, including deep-learning based models, have proven to be quite effective for source
code. We argue here that the special properties of source code can
be exploited for further improvements. In this work, we enhance
established language modeling approaches to handle the special
challenges of modeling source code, such as: frequent changes,
larger, changing vocabularies, deeply nested scopes, etc. We present
a fast, nested language modeling toolkit specifically designed for
software, with the ability to add &amp; remove text, and mix &amp; swap out
many models. Specifically, we improve upon prior cache-modeling
work and present a model with a much more expansive, multi-level
notion of locality that we show to be well-suited for modeling
software. We present results on varying corpora in comparison
with traditional N -gram, as well as RNN, and LSTM deep-learning
language models, and release all our source code for public use.
Our evaluations suggest that carefully adapting N-gram models for
source code can yield performance that surpasses even RNN and
LSTM based deep-learning models.</p>
</td>
	<td>language model </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/koc2017learning/">Learning a Classifier for False Positive Error Reports Emitted by Static Code Analysis Tools</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning a Classifier for False Positive Error Reports Emitted by Static Code Analysis Tools' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning a Classifier for False Positive Error Reports Emitted by Static Code Analysis Tools' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ugur Koc, Parsa Saadatpanah, Jeffrey S. Foster, Adam A. Porter.</td>
	<td>MAPL</td>
	<td><p>The large scale and high complexity of modern software systems
make perfectly precise static code analysis (SCA) infeasible. Therefore SCA tools often over-approximate, so not to miss any real
problems. This, however, comes at the expense of raising false
alarms, which, in practice, reduces the usability of these tools.</p>

<p>To partially address this problem, we propose a novel learning
process whose goal is to discover program structures that cause
a given SCA tool to emit false error reports, and then to use this
information to predict whether a new error report is likely to be a
false positive as well. To do this, we first preprocess code to isolate
the locations that are related to the error report. Then, we apply
machine learning techniques to the preprocessed code to discover
correlations and to learn a classifier.</p>

<p>We evaluated this approach in an initial case study of a widely-used SCA tool for Java. Our results showed that for our dataset
we could accurately classify a large majority of false positive error
reports. Moreover, we identified some common coding patterns that
led to false positive errors. We believe that SCA developers may be
able to redesign their methods to address these patterns and reduce
false positive error reports.</p>
</td>
	<td>static analysis </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/allamanis2017mining/">Mining Semantic Loop Idioms from Big Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Mining Semantic Loop Idioms from Big Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Mining Semantic Loop Idioms from Big Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Miltiadis Allamanis, Earl T. Barr, Christian Bird, Mark Marron, Charles Sutton</td>
	<td>TSE</td>
	<td><p>During maintenance, developers spend a lot of time transforming existing code: refactoring, optimizing, and adding checks to make it more robust. Much of this work is the drudgery of identifying and replacing specific patterns, yet it resists automation, because of meaningful patterns are hard to automatically find. We present a technique for mining loop idioms, surprisingly probable semantic patterns that occur in loops, from big code to find meaningful patterns. First, we show that automatically identifiable patterns exist, in great numbers, with a large scale empirical study of loop over 25 MLOC. We find that loops in this corpus are simple and predictable: 90% of them have fewer than 15LOC and 90% have no nesting and very simple control structure. Encouraged by this result, we coil loops to abstract away syntactic diversity to define information rich loop idioms. We show that only 50 loop idioms cover 50% of the concrete loops. We show how loop idioms can help a tool developers identify and prioritize refactorings. We also show how our framework opens the door to data-driven tool and language design discovering opportunities to introduce new API calls and language constructs: loop idioms show that LINQ would benefit from an Enumerate operator, a result confirmed by the fact that precisely this feature is one of the most requested features on StackOverflow with 197 votes and 95k views.</p>
</td>
	<td>pattern mining grammar </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/allamanis2017smartpaste/">SmartPaste: Learning to Adapt Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=SmartPaste: Learning to Adapt Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=SmartPaste: Learning to Adapt Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Miltiadis Allamanis, Marc Brockschmidt</td>
	<td></td>
	<td><p>Deep Neural Networks have been shown to succeed at a range of natural
language tasks such as machine translation and text summarization.
While tasks on source code (ie, formal languages) have been considered
recently, most work in this area does not attempt to capitalize on the
unique opportunities offered by its known syntax and structure. In this
work, we introduce SmartPaste, a first task that requires to use such
information. The task is a variant of the program repair problem that
requires to adapt a given (pasted) snippet of code to surrounding,
existing source code. As first solutions, we design a set of deep
neural models that learn to represent the context of each variable
location and variable usage in a data flow-sensitive way. Our
evaluation suggests that our models can learn to solve the SmartPaste
task in many cases, achieving 58.6% accuracy, while learning meaningful
representation of variable usages.</p>
</td>
	<td>representation variable misuse </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/guo2017semantically/">Semantically enhanced software traceability using deep learning techniques</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Semantically enhanced software traceability using deep learning techniques' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Semantically enhanced software traceability using deep learning techniques' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jin Guo, Jinghui Cheng, Jane Cleland-Huang</td>
	<td>ICSE</td>
	<td><p>In most safety-critical domains the need for traceability is prescribed by certifying bodies. Trace links are generally created among requirements, design, source code, test cases and other artifacts; however, creating such links manually is time consuming and error prone. Automated solutions use information retrieval and machine learning techniques to generate trace links; however, current techniques fail to understand semantics of the software artifacts or to integrate domain knowledge into the tracing process and therefore tend to deliver imprecise and inaccurate results. In this paper, we present a solution that uses deep learning to incorporate requirements artifact semantics and domain knowledge into the tracing solution. We propose a tracing network architecture that utilizes Word Embedding and Recurrent Neural Network (RNN) models to generate trace links. Word embedding learns word vectors that represent knowledge of the domain corpus and RNN uses these word vectors to learn the sentence semantics of requirements artifacts. We trained 360 different configurations of the tracing network using existing trace links in the Positive Train Control domain and identified the Bidirectional Gated Recurrent Unit (BI-GRU) as the best model for the tracing task. BI-GRU significantly out-performed state-of-the-art tracing methods including the Vector Space Model and Latent Semantic Indexing.</p>
</td>
	<td>traceability representation </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/pradel2017deep/">Deep Learning to Find Bugs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Learning to Find Bugs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Learning to Find Bugs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Michael Pradel, Koushik Sen</td>
	<td></td>
	<td><p>Automated bug detection, e.g., through pattern-based static
analysis, is an increasingly popular technique to find programming errors and other code quality issues. Traditionally,
bug detectors are program analyses that are manually written and carefully tuned by an analysis expert. Unfortunately,
the huge amount of possible bug patterns makes it difficult
to cover more than a small fraction of all bugs. This paper
presents a new approach toward creating bug detectors. The
basic idea is to replace manually writing a program analysis
with training a machine learning model that distinguishes
buggy from non-buggy code. To address the challenge that
effective learning requires both positive and negative train-
ing examples, we use simple code transformations that create likely incorrect code from existing code examples. We
present a general framework, called DeepBugs, that extracts
positive training examples from a code corpus, leverages
simple program transformations to create negative training
examples, trains a model to distinguish these two, and then
uses the trained model for identifying programming mistakes in previously unseen code. As a proof of concept, we
create four bug detectors for JavaScript that find a diverse set
of programming mistakes, e.g., accidentally swapped function arguments, incorrect assignments, and incorrect binary
operations. To find bugs, the trained models use information
that is usually discarded by program analyses, such as identifier names of variables and functions. Applying the approach
to a corpus of 150,000 JavaScript files shows that learned bug
detectors have a high accuracy, are very efficient, and reveal
132 programming mistakes in real-world code.</p>

</td>
	<td>defect program analysis </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/yang2017language/">A Language Model for Statements of Software Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Language Model for Statements of Software Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Language Model for Statements of Software Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yixiao Yang, Yu Jiang, Ming Gu, Jiaguang Sun, Jian Gao, Han Liu</td>
	<td>ASE</td>
	<td><p>Building language models for source code enables a large set of improvements on traditional software engineering tasks. One promising application is automatic code completion. State-of-the-art techniques capture code regularities at token level with lexical information. Such language models are more suitable for predicting short token sequences, but become less effective with respect to long statement level predictions. In this paper, we have proposed PCC to optimize the token level based language modeling. Specifically, PCC introduced an intermediate representation (IR) for source code, which puts tokens into groups using lexeme and variable relative order. In this way, PCC is able to handle long token sequences, i.e., group sequences, to suggest a complete statement with the precise synthesizer. Further more, PCC employed a fuzzy matching technique which combined genetic and longest common sub-sequence algorithms to make the prediction more accurate. We have implemented a code completion plugin for Eclipse and evaluated it on open-source Java projects. The results have demonstrated the potential of PCC in generating precise long statement level predictions. In 30%-60% of the cases, it can correctly suggest the complete statement with only six candidates, and 40%-90% of the cases with ten candidates.</p>
</td>
	<td>language model </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/yuan2017abridging/">Abridging Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Abridging Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Abridging Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Binhang Yuan, Vijayaraghavan Murali, Christopher Jermaine</td>
	<td>OOPSLA</td>
	<td><p>In this paper, we consider the problem of source code abridgment, where the goal is to remove statements from a source code in order to display the source code in a small space, while at the same time leaving the ``important’’ parts of the source code intact, so that an engineer can read the code and quickly understand purpose of the code. To this end, we develop an algorithm that looks at a number of examples, human-created source code abridgments, and learns how to remove lines from the code in order to mimic the human abridger. The learning algorithm takes into account syntactic features of the code, as well as semantic features such as control flow and data dependencies. Through a comprehensive user study, we show that the abridgments that our system produces can decrease the time that a user must look at code in order to understand its functionality, as well as increase the accuracy of the assessment, while displaying the code in a greatly reduced area.</p>
</td>
	<td>summarization </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/vasilescu2017recovering/">Recovering Clear, Natural Identifiers from Obfuscated JS Names</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Recovering Clear, Natural Identifiers from Obfuscated JS Names' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Recovering Clear, Natural Identifiers from Obfuscated JS Names' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Bogdan Vasilescu, Casey Casalnuovo, Premkumar Devanbu</td>
	<td>FSE</td>
	<td><p>Well-chosen variable names are critical to source code readability, reusability, and maintainability. Unfortunately, in deployed JavaScript code (which is ubiquitous on the web) the identifier names are frequently minified and overloaded. This is done both for efficiency and also to protect potentially proprietary intellectual property. In this paper, we describe an approach based on statistical machine translation (SMT) that recovers some of the original names from the JavaScript programs minified by the very popular UglifyJS. This simple tool, Autonym, performs comparably to the best currently available deobfuscator for JavaScript, JSNice, which uses sophisticated static analysis. In fact, Autonym is quite complementary to JSNice, performing well when it does not, and vice versa. We also introduce a new tool, JSNaughty, which blends Autonym and JSNice, and significantly outperforms both at identifier name recovery, while remaining just as easy to use as JSNice. JSNaughty is available online at http://jsnaughty.org.</p>
</td>
	<td>deobfuscation naming </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/gu2017deepam/">DeepAM: Migrate APIs with Multi-modal Sequence to Sequence Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DeepAM: Migrate APIs with Multi-modal Sequence to Sequence Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DeepAM: Migrate APIs with Multi-modal Sequence to Sequence Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xiaodong Gu, Hongyu Zhang, Dongmei Zhang, Sunghun Kim</td>
	<td>IJCAI</td>
	<td><p>Computer programs written in one language are often required to be ported to other languages to support multiple devices and environments. When programs use language specific APIs (Application Programming Interfaces), it is very challenging to migrate these APIs to the corresponding APIs written in other languages. Existing approaches mine API mappings from projects that have corresponding versions in two languages. They rely on the sparse availability of bilingual projects, thus producing a limited number of API mappings. In this paper, we propose an intelligent system called DeepAM for automatically mining API mappings from a large-scale code corpus without bilingual projects. The key component of DeepAM is based on the multimodal sequence to sequence learning architecture that aims to learn joint semantic representations of bilingual API sequences from big source code data. Experimental results indicate that DeepAM significantly increases the accuracy of API mappings as well as the number of API mappings, when compared with the state-of-the-art approaches.</p>
</td>
	<td>API </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/murali2017finding/">Finding Likely Errors with Bayesian Specifications</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Finding Likely Errors with Bayesian Specifications' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Finding Likely Errors with Bayesian Specifications' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vijayaraghavan Murali, Swarat Chaudhuri, Chris Jermaine</td>
	<td></td>
	<td><p>We present a Bayesian framework for learning probabilistic specifications from large, unstructured code corpora, and
a method to use this framework to statically detect anomalous, hence likely buggy, program behavior. The distinctive
insight here is to build a statistical model that correlates all
specifications hidden inside a corpus with the syntax and
observed behavior of programs that implement these specifications. During the analysis of a particular program, this
model is conditioned into a posterior distribution that prioritizes specifications that are relevant to this program. This
allows accurate program analysis even if the corpus is highly
heterogeneous. The problem of finding anomalies is now
framed quantitatively, as a problem of computing a distance
between a “reference distribution” over program behaviors
that our model expects from the program, and the distribution over behaviors that the program actually produces.</p>

<p>We present a concrete embodiment of our framework that
combines a topic model and a neural network model to learn
specifications, and queries the learned models to compute
anomaly scores. We evaluate this implementation on the
task of detecting anomalous usage of Android APIs. Our
encouraging experimental results show that the method can
automatically discover subtle errors in Android applications
in the wild, and has high precision and recall compared to
competing probabilistic approaches.</p>
</td>
	<td>program analysis API </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/levy2017learning/">Learning to Align the Source Code to the Compiled Object Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Align the Source Code to the Compiled Object Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Align the Source Code to the Compiled Object Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Dor Levy, Lior Wolf</td>
	<td>ICML</td>
	<td><p>We propose a new neural network architecture
and use it for the task of statement-by-statement
alignment of source code and its compiled object code. Our architecture learns the alignment
between the two sequences – one being the translation of the other – by mapping each statement
to a context-dependent representation vector and
aligning such vectors using a grid of the two sequence domains. Our experiments include short
C functions, both artificial and human-written,
and show that our neural network architecture
is able to predict the alignment with high accuracy, outperforming known baselines. We also
demonstrate that our model is general and can
learn to solve graph problems such as the Traveling Salesman Problem.</p>
</td>
	<td>decompilation </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/richardson2017code2text/">The Code2Text Challenge: Text Generation in Source Code Libraries</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=The Code2Text Challenge: Text Generation in Source Code Libraries' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=The Code2Text Challenge: Text Generation in Source Code Libraries' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Kyle Richardson, Sina Zarrieß, Jonas Kuhn</td>
	<td>INLG</td>
	<td><p>We propose a new shared task for tactical data-to-text generation in the domain of source code libraries. Specifically, we focus on text generation of function descriptions from example software projects. Data is drawn from existing resources used for studying the related problem of semantic parser induction (Richardson and Kuhn, 2017b; Richardson and Kuhn, 2017a), and spans a wide variety of both natural languages and programming languages. In this paper, we describe these existing resources, which will serve as training and development data for the task, and discuss plans for building new independent test sets.</p>
</td>
	<td>bimodal </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/richardson2017function/">Function Assistant: A Tool for NL Querying of APIs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Function Assistant: A Tool for NL Querying of APIs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Function Assistant: A Tool for NL Querying of APIs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Kyle Richardson, Jonas Kuhn</td>
	<td>EMNLP</td>
	<td><p>In this paper, we describe Function Assistant, a lightweight Python-based toolkit for querying and exploring source code repositories using natural language. The toolkit is designed to help end-users of a target API quickly find information about functions through high-level natural language queries and descriptions. For a given text query and background API, the tool finds candidate functions by performing a translation from the text to known representations in the API using the semantic parsing approach of Richardson and Kuhn (2017). Translations are automatically learned from example text-code pairs in example APIs. The toolkit includes features for building translation pipelines and query engines for arbitrary source code projects. To explore this last feature, we perform new experiments on 27 well-known Python projects hosted on Github.</p>
</td>
	<td>bimodal API </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/richardson2017learning/">Learning Technical Correspondences in Technical Documentation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Technical Correspondences in Technical Documentation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Technical Correspondences in Technical Documentation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Kyle Richardson, Jonas Kuhn</td>
	<td>ACL</td>
	<td><p>We consider the problem of translating high-level textual descriptions to formal representations in technical documentation as part of an effort to model the meaning of such documentation. We focus specifically on the problem of learning translational correspondences between text descriptions and grounded representations in the target documentation, such as formal representation of functions or code templates. Our approach exploits the parallel nature of such documentation, or the tight coupling between high-level text and the low-level representations we aim to learn. Data is collected by mining technical documents for such parallel text-representation pairs, which we use to train a simple semantic parsing model. We report new baseline results on sixteen novel datasets, including the standard library documentation for nine popular programming languages across seven natural languages, and a small collection of Unix utility manuals.</p>
</td>
	<td>documentation API bimodal </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/li2017code/">Code Completion with Neural Attention and Pointer Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Code Completion with Neural Attention and Pointer Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Code Completion with Neural Attention and Pointer Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jian Li, Yue Wang, Michael R. Lyu, Irwin King</td>
	<td></td>
	<td><p>Intelligent code completion has become an essential tool to accelerate modern software development. To facilitate effective code completion for dynamically-typed programming languages, we apply neural language models by learning from large codebases, and investigate the effectiveness of attention mechanism on the code completion task. However, standard neural language models even with attention mechanism cannot correctly predict out-of-vocabulary (OoV) words thus restrict the code completion performance. In this paper, inspired by the prevalence of locally repeated terms in program source code, and the recently proposed pointer networks which can reproduce words from local context, we propose a pointer mixture network for better predicting OoV words in code completion. Based on the context, the pointer mixture network learns to either generate a within-vocabulary word through an RNN component, or copy an OoV word from local context through a pointer component. Experiments on two benchmarked datasets demonstrate the effectiveness of our attention mechanism and pointer mixture network on the code completion task.</p>

</td>
	<td>language model autocomplete </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/li2017software/">Software Defect Prediction via Convolutional Neural Network</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Software Defect Prediction via Convolutional Neural Network' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Software Defect Prediction via Convolutional Neural Network' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jian Li, Pinjia He, Jieming Zhu, Michael R. Lyu</td>
	<td>QRS</td>
	<td><p>To improve software reliability, software defect prediction is utilized to assist developers in finding potential bugs
and allocating their testing efforts. Traditional defect prediction
studies mainly focus on designing hand-crafted features, which
are input into machine learning classifiers to identify defective
code. However, these hand-crafted features often fail to capture
the semantic and structural information of programs. Such
information is important in modeling program functionality and
can lead to more accurate defect prediction.
In this paper, we propose a framework called Defect Prediction
via Convolutional Neural Network (DP-CNN), which leverages
deep learning for effective feature generation. Specifically, based
on the programs’ Abstract Syntax Trees (ASTs), we first extract
token vectors, which are then encoded as numerical vectors
via mapping and word embedding. We feed the numerical
vectors into Convolutional Neural Network to automatically
learn semantic and structural features of programs. After that,
we combine the learned features with traditional hand-crafted
features, for accurate software defect prediction. We evaluate our
method on seven open source projects in terms of F-measure in
defect prediction. The experimental results show that in average,
DP-CNN improves the state-of-the-art method by 12%.</p>

</td>
	<td>defect </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/hu2017codesum/">CodeSum: Translate Program Language to Natural Language</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CodeSum: Translate Program Language to Natural Language' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CodeSum: Translate Program Language to Natural Language' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xing Hu, Yuhan Wei, Ge Li, Zhi Jin</td>
	<td></td>
	<td><p>During software maintenance, programmers spend a lot of time on code comprehension. Reading comments is an effective way for programmers to reduce the reading and navigating time when comprehending source code. Therefore, as a critical task in software engineering, code summarization aims to generate brief natural language descriptions for source code. In this paper, we propose a new code summarization model named CodeSum. CodeSum exploits the attention-based sequence-to-sequence (Seq2Seq) neural network with Structure-based Traversal (SBT) of Abstract Syntax Trees (AST). The AST sequences generated by SBT can better present the structure of ASTs and keep unambiguous. We conduct experiments on three large-scale corpora in different program languages, i.e., Java, C#, and SQL, in which Java corpus is our new proposed industry code extracted from Github. Experimental results show that our method CodeSum outperforms the state-of-the-art significantly.</p>
</td>
	<td>bimodal summarization </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/cummins2017end/">End-to-end Deep Learning of Optimization Heuristics</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=End-to-end Deep Learning of Optimization Heuristics' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=End-to-end Deep Learning of Optimization Heuristics' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Chris Cummins, Pavlos Petoumenos, Zheng Wang, Hugh Leather</td>
	<td></td>
	<td><p>Accurate automatic optimization heuristics are necessary for dealing with the complexity and diversity of modern hardware and software. Machine learning is a proven technique for learning such heuristics, but its success is bound by the quality of the features used. These features must be hand crafted by developers through a combination of expert domain knowledge and trial and error. This makes the quality of the final model directly dependent on the skill and available time of the system architect.</p>

<p>Our work introduces a better way for building heuristics. We develop a deep neural network that learns heuristics over raw code, entirely without using code features. The neural network simultaneously constructs appropriate representations of the code and learns how best to optimize, removing the need for manual feature creation. Further, we show that our neural nets can transfer learning from one optimization problem to another, improving the accuracy of new models, without the help of human experts.</p>

<p>We compare the effectiveness of our automatically generated heuristics against ones with features hand-picked by experts. We examine two challenging tasks: predicting optimal mapping for heterogeneous parallelism and GPU thread coarsening factors. In 89% of the cases, the quality of our fully automatic heuristics matches or surpasses that of state-of-the-art predictive models using hand-crafted features, providing on average 14% and 12% more performance with no human effort expended on designing features.</p>
</td>
	<td>optimization </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/cummins2017synthesizing/">Synthesizing benchmarks for predictive modeling</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Synthesizing benchmarks for predictive modeling' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Synthesizing benchmarks for predictive modeling' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Chris Cummins, Pavlos Petoumenos, Zheng Wang, Hugh Leather</td>
	<td>CGO</td>
	<td><p>Predictive modeling using machine learning is an effective method for building compiler heuristics, but there is a shortage of benchmarks. Typical machine learning experiments outside of the compilation field train over thousands or millions of examples. In machine learning for compilers, however, there are typically only a few dozen common benchmarks available. This limits the quality of learned models, as they have very sparse training data for what are often high-dimensional feature spaces. What is needed is a way to generate an unbounded number of training programs that finely cover the feature space. At the same time the generated programs must be similar to the types of programs that human developers actually write, otherwise the learning will target the wrong parts of the feature space. We mine open source repositories for program fragments and apply deep learning techniques to automatically construct models for how humans write programs. We sample these models to generate an unbounded number of runnable training programs. The quality of the programs is such that even human developers struggle to distinguish our generated programs from hand-written code. We use our generator for OpenCL programs, CLgen, to automatically synthesize thousands of programs and show that learning over these improves the performance of a state of the art predictive model by 1.27x. In addition, the fine covering of the feature space automatically exposes weaknesses in the feature design which are invisible with the sparse training examples from existing benchmark suites. Correcting these weaknesses further increases performance by 4.30x.</p>
</td>
	<td>optimization code generation </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/markovtsev2017topic/">Topic modeling of public repositories at scale using names in source code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Topic modeling of public repositories at scale using names in source code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Topic modeling of public repositories at scale using names in source code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vadim Markovtsev, Eiso Kant</td>
	<td></td>
	<td><p>Programming languages themselves have a limited number of reserved keywords and character based tokens that
define the language specification. However, programmers have a rich use of natural language within their code
through comments, text literals and naming entities. The programmer defined names that can be found in source
code are a rich source of information to build a high level understanding of the project. The goal of this paper
is to apply topic modeling to names used in over 13.6 million repositories and perceive the inferred topics.
One of the problems in such a study is the occurrence of duplicate repositories not officially marked as forks (obscure forks).
We show how to address it using the same identifiers which are extracted for topic modeling.</p>

<p>We open with a discussion on naming in source code, we then elaborate on our approach to remove exact duplicate
and fuzzy duplicate repositories using Locality Sensitive Hashing on the bag-of-words model and then discuss our work
on topic modeling; and finally present the results from our data analysis together with open-access to the source code,
tools and datasets.</p>
</td>
	<td>topic modeling pattern mining </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/lin2017program/">Program Synthesis from Natural Language Using Recurrent Neural Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Program Synthesis from Natural Language Using Recurrent Neural Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Program Synthesis from Natural Language Using Recurrent Neural Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xi Victoria Lin, Chenglong Wang, Deric Pang, Kevin Vu, Michael D. Ernst</td>
	<td>Technical Report UW-CSE-17-03-01, University of Washington Department of Computer Science and Engineering</td>
	<td><p>Oftentimes, a programmer may have difficulty implementing a
desired operation. Even when the programmer can describe her
goal in English, it can be difficult to translate into code. Existing
resources, such as question-and-answer websites, tabulate specific
operations that someone has wanted to perform in the past, but
they are not effective in generalizing to new tasks, to compound
tasks that require combining previous questions, or sometimes even
to variations of listed tasks.</p>

<p>Our goal is to make programming easier and more productive by
letting programmers use their own words and concepts to express
the intended operation, rather than forcing them to accommodate
the machine by memorizing its grammar. We have built a system
that lets a programmer describe a desired operation in natural language, then automatically translates it to a programming language
for review and approval by the programmer. Our system, Tellina,
does the translation using recurrent neural networks (RNNs), a
state-of-the-art natural language processing technique that we augmented with slot (argument) filling and other enhancements.</p>

<p>We evaluated Tellina in the context of shell scripting. We trained
Tellina’s RNNs on textual descriptions of file system operations
and bash one-liners, scraped from the web. Although recovering
completely correct commands is challenging, Tellina achieves top-3
accuracy of 80% for producing the correct command structure. In a
controlled study, programmers who had access to Tellina outperformed those who did not, even when Tellina’s predictions were
not completely correct, to a statistically significant degree.</p>
</td>
	<td>bimodal code generation </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/gupta2017deepfix/">DeepFix: Fixing Common C Language Errors by Deep Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=DeepFix: Fixing Common C Language Errors by Deep Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=DeepFix: Fixing Common C Language Errors by Deep Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Rahul Gupta, Soham Pal, Aditya Kanade, Shirish Shevade</td>
	<td>AAAI</td>
	<td><p>The problem of automatically fixing programming errors is a
very active research topic in software engineering. This is a
challenging problem as fixing even a single error may require
analysis of the entire program. In practice, a number of errors
arise due to programmer’s inexperience with the programming language or lack of attention to detail. We call these
common programming errors. These are analogous to grammatical errors in natural languages. Compilers detect such errors, but their error messages are usually inaccurate. In this
work, we present an end-to-end solution, called DeepFix, that
can fix multiple such errors in a program without relying on
any external tool to locate or fix them. At the heart of DeepFix
is a multi-layered sequence-to-sequence neural network with
attention which is trained to predict erroneous program locations along with the required correct statements. On a set of
6971 erroneous C programs written by students for 93 programming tasks, DeepFix could fix 1881 (27%) programs
completely and 1338 (19%) programs partially.</p>
</td>
	<td>repair code generation </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/rabinovich2017abstract/">Abstract Syntax Networks for Code Generation and Semantic Parsing</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Abstract Syntax Networks for Code Generation and Semantic Parsing' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Abstract Syntax Networks for Code Generation and Semantic Parsing' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Maxim Rabinovich, Mitchell Stern, Dan Klein</td>
	<td>ACL</td>
	<td><p>Tasks like code generation and semantic parsing require mapping unstructured (or partially structured) inputs to well-formed, executable outputs. We introduce abstract syntax networks, a modeling framework for these problems. The outputs are represented as abstract syntax trees (ASTs) and constructed by a decoder with a dynamically-determined modular structure paralleling the structure of the output tree. On the benchmark Hearthstone dataset for code generation, our model obtains 79.2 BLEU and 22.7% exact match accuracy, compared to previous state-of-the-art values of 67.1 and 6.1%. Furthermore, we perform competitively on the Atis, Jobs, and Geo semantic parsing datasets with no task-specific engineering.</p>
</td>
	<td>code generation grammar </td>
</tr>

<tr>
	<td>2017</td>
	<td><a href="/publications/fowkes2017autofolding/">Autofolding for Source Code Summarization</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Autofolding for Source Code Summarization' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Autofolding for Source Code Summarization' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jaroslav Fowkes, Razan Ranca, Miltiadis Allamanis, Mirella Lapata, Charles Sutton</td>
	<td>TSE</td>
	<td><p>Developers spend much of their time reading and browsing source code, raising new opportunities for summarization methods. Indeed, modern code editors provide code folding, which allows one to selectively hide blocks of code. However this is impractical to use as folding decisions must be made manually or based on simple rules. We introduce the
autofolding problem, which is to automatically create a code summary by folding less informative code regions. We present a novel solution by formulating the problem as a sequence of AST folding decisions, leveraging a scoped topic model for code tokens. On an annotated set of popular open source projects, we show that our summarizer outperforms simpler baselines, yielding a 28% error reduction. Furthermore, we find through a case study that our summarizer is strongly preferred by experienced developers. More broadly, we hope this work will aid program comprehension by turning code folding into a usable and valuable tool.</p>
</td>
	<td>summarization </td>
</tr>



<tr>
	<td>2016</td>
	<td><a href="/publications/ling2016latent/">Latent Predictor Networks for Code Generation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Latent Predictor Networks for Code Generation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Latent Predictor Networks for Code Generation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Wang Ling, Edward Grefenstette, Karl Moritz Hermann, Tomáš Kočiský, Andrew Senior, Fumin Wang, Phil Blunsom</td>
	<td>ACL</td>
	<td><p>Many  language  generation  tasks  require
the production of text conditioned on both
structured  and  unstructured  inputs.
We present  a  novel  neural  network  architecture  which  generates  an  output  sequence
conditioned on an arbitrary number of input  functions.
Crucially,  our  approach
allows  both  the  choice  of  conditioning
context and the granularity of generation,
for  example  characters  or  tokens,  to  be
marginalised, thus permitting scalable and
effective training.  Using this framework,
we address the problem of generating programming code from a mixed natural language  and  structured  specification.
We create two new data sets for this paradigm
derived  from  the  collectible  trading  card
games  Magic  the  Gathering  and  Hearthstone.   On  these,  and  a  third  preexisting
corpus,  we  demonstrate  that  marginalising multiple predictors allows our model
to outperform strong benchmarks.</p>

</td>
	<td>bimodal code generation </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/li2016gated/">Gated Graph Sequence Neural Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Gated Graph Sequence Neural Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Gated Graph Sequence Neural Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yujia Li, Daniel Tarlow, Marc Brockschmidt, Richard Zemel</td>
	<td>ICLR</td>
	<td><p>Graph-structured data appears frequently in domains including chemistry, natural
language semantics, social networks, and knowledge bases. In this work, we study
feature learning techniques for graph-structured inputs. Our starting point is previous work on Graph Neural Networks (Scarselli et al., 2009), which we modify
to use gated recurrent units and modern optimization techniques and then extend
to output sequences. The result is a flexible and broadly useful class of neural network models that has favorable inductive biases relative to purely sequence-based
models (e.g., LSTMs) when the problem is graph-structured. We demonstrate the
capabilities on some simple AI (bAbI) and graph algorithm learning tasks. We
then show it achieves state-of-the-art performance on a problem from program
verification, in which subgraphs need to be described as abstract data structures.</p>

</td>
	<td>GNN program analysis </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/yadid2016extracting/">Extracting Code from Programming Tutorial Videos</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Extracting Code from Programming Tutorial Videos' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Extracting Code from Programming Tutorial Videos' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shir Yadid, Eran Yahav</td>
	<td>Onward!</td>
	<td><p>The number of programming tutorial videos on the web
increases daily. Video hosting sites such as YouTube host
millions of video lectures, with many programming tutorials for various languages and platforms. These videos contain a wealth of valuable information, including code that
may be of interest. However, two main challenges have so
far prevented the effective indexing of programming tutorial
videos: (i) code in tutorials is typically written on-the-fly,
with only parts of the code visible in each frame, and (ii) optical character recognition (OCR) is not precise enough to
produce quality results from videos.</p>

<p>We present a novel approach for extracting code from
videos that is based on: (i) consolidating code across frames,
and (ii) statistical language models for applying corrections
at different levels, allowing us to make corrections by choosing the most likely token, combination of tokens that form a
likely line structure, and combination of lines that lead to
a likely code fragment in a particular language. We implemented our approach in a tool called ACE , and used it to extract code from 40 Android video tutorials on YouTube . Our
evaluation shows that ACE extracts code with high accuracy,
enabling deep indexing of video tutorials.</p>
</td>
	<td>information extraction </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/singh2016question/">Question Independent Grading using Machine Learning: The Case of Computer Program Grading</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Question Independent Grading using Machine Learning: The Case of Computer Program Grading' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Question Independent Grading using Machine Learning: The Case of Computer Program Grading' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Gursimran Singh, Shashank Srikant, Varun Aggarwal</td>
	<td>KDD</td>
	<td><p>Learning supervised models to grade open-ended responses is an expensive process. A model has to be trained for every prompt/question separately, which in turn requires graded samples. In automatic programming evaluation specifically, the focus of this work, this issue is amplified. The models have to be trained not only for every question but also for every language the question is offered in. Moreover, the availability and time taken by experts to create a labeled set of programs for each question is a major bottleneck in scaling such a system. We address this issue by presenting a method to grade computer programs which requires no manually assigned labeled samples for grading responses to a new, unseen question. We extend our previous work (by Srikant, Aggarwal; KDD 2014) wherein we introduced a grammar of features to learn question specific models. In this work, we propose a method to transform those features into a set of features that maintain their structural relation with the labels across questions. Using these features we learn one supervised model, across questions for a given language, which can then be applied to an ungraded response to an unseen question. We show that our method rivals the performance of both, question specific models and the consensus among human experts while substantially outperforming extant ways of evaluating codes. We demonstrate the system single s value by deploying it to grade programs in a high stakes assessment. The learning from this work is transferable to other grading tasks such as math question grading and also provides a new variation to the supervised learning approach.</p>
</td>
	<td>education </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/bichsel2016statistical/">Statistical Deobfuscation of Android Applications</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Statistical Deobfuscation of Android Applications' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Statistical Deobfuscation of Android Applications' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Benjamin Bichsel, Veselin Raychev, Petar Tsankov, Martin Vechev</td>
	<td>CCS</td>
	<td><p>This work presents a new approach for deobfuscating Android APKs based on probabilistic learning of large code bases (termed “Big Code”). The key idea is to learn a probabilistic model over thousands of non-obfuscated Android applications and to use this probabilistic model to deobfuscate new, unseen Android APKs. The concrete focus of the paper is on reversing layout obfuscation, a popular transformation which renames key program elements such as classes, packages, and methods, thus making it difficult to understand what the program does. Concretely, the paper: (i) phrases the layout deobfuscation problem of Android APKs as structured prediction in a probabilistic graphical model, (ii) instantiates this model with a rich set of features and constraints that capture the Android setting, ensuring both semantic equivalence and high prediction accuracy, and (iii) shows how to leverage powerful inference and learning algorithms to achieve overall precision and scalability of the probabilistic predictions.</p>

<p>We implemented our approach in a tool called DeGuard and used it to: (i) reverse the layout obfuscation performed by the popular ProGuard system on benign, open-source applications, (ii) predict third-party libraries imported by benign APKs (also obfuscated by ProGuard), and (iii) rename obfuscated program elements of Android malware. The experimental results indicate that DeGuard is practically effective: it recovers 79.1% of the program element names obfuscated with ProGuard, it predicts third-party libraries with accuracy of 91.3%, and it reveals string decoders and classes that handle sensitive data in Android malware.</p>

</td>
	<td>deobfuscation naming </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/bielik2016phog/">PHOG: Probabilistic Model for Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=PHOG: Probabilistic Model for Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=PHOG: Probabilistic Model for Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Pavol Bielik, Veselin Raychev, Martin Vechev</td>
	<td>ICML</td>
	<td><p>We introduce a new generative model for code called probabilistic higher order grammar (PHOG). PHOG generalizes probabilistic context free grammars (PCFGs) by allowing conditioning of a production rule beyond the parent non-terminal, thus capturing rich contexts relevant to programs. Even though PHOG is more powerful than a PCFG, it can be learned from data just as efficiently. We trained a PHOG model on a large JavaScript code corpus and show that it is more precise than existing models, while similarly fast. As a result, PHOG can immediately benefit existing programming tools based on probabilistic models of code.</p>
</td>
	<td>grammar code generation language model </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/nguyen2016mapping/">Mapping API Elements for Code Migration with Vector Representations</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Mapping API Elements for Code Migration with Vector Representations' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Mapping API Elements for Code Migration with Vector Representations' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Trong Duc Nguyen, Anh Tuan Nguyen, Tien N. Nguyen</td>
	<td>ICSE</td>
	<td><p>Mapping API elements has a significant role in software development, especially in code migration. A manual process of defining the migration is tedious and error-prone while recent approaches to automatically mine API mappings are limited to discover the mappings with textually similar APIs’ names. This leads to the low accuracy in existing migration tools.We propose an approach to automatically mine API mappings which overcomes the lexical mismatch problem. We represent an API by its usages instead of its name.To characterize an API with its context consisting of surrounding APIs in its usages, we take advantage of Word2Vec model to project the APIs of Java JDK and C# .NET into corresponding continuous vector spaces. The semantic relations among APIs will be observed in those continuous space as the geometric arrangements between their representation vectors in two vector spaces.We use a learning approach to derive the linear (e.g., rotating and scaling) transformation function between two vector spaces. Transformation function is trained from human-defined pairs of API mappings from Java to C#. To find the C# API mapping with a given Java API, we use the learned function to compute its transformed vector in the C# vector space. Then, the C# API which has the most similar vector with the transformed vector is considered as the result. Our experiment shows that for just one suggestion, we are able to correctly derive the API in C# in almost 43% of the cases. With 5 suggestions, we can correctly suggest the correct C# API in almost 3 out of 4 cases (73.2%).</p>
</td>
	<td>migration API </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/iyer2016summarizing/">Summarizing Source Code using a Neural Attention Model</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Summarizing Source Code using a Neural Attention Model' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Summarizing Source Code using a Neural Attention Model' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, Luke Zettlemoyer</td>
	<td>ACL</td>
	<td><p>High quality source code is often paired
with high level summaries of the computation it performs, for example in code
documentation or in descriptions posted
in online forums. Such summaries are
extremely useful for applications such as
code search but are expensive to manually
author, hence only done for a small fraction of all code that is produced. In this
paper, we present the first completely data-driven approach for generating high level
summaries of source code. Our model,
CODE-NN , uses Long Short Term Memory (LSTM) networks with attention to
produce sentences that describe C# code
snippets and SQL queries. CODE-NN
is trained on a new corpus that is automatically collected from StackOverflow,
which we release. Experiments demonstrate strong performance on two tasks:
(1) code summarization, where we establish the first end-to-end learning results
and outperform strong baselines, and (2)
code retrieval, where our learned model
improves the state of the art on a recently
introduced C# benchmark by a large margin.</p>
</td>
	<td>summarization bimodal </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/bhoopchand2016learning/">Learning Python Code Suggestion with a Sparse Pointer Network</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Python Code Suggestion with a Sparse Pointer Network' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Python Code Suggestion with a Sparse Pointer Network' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Avishkar Bhoopchand, Tim Rocktaschel, Earl Barr, Sebastian Riedel</td>
	<td></td>
	<td><p>To enhance developer productivity, all modern integrated development environments (IDEs) include code suggestion functionality that proposes likely next tokens at the cursor. While current IDEs work well for statically-typed languages, their reliance on type annotations means that they do not provide the same level of support for dynamic programming languages as for statically-typed languages. Moreover, suggestion engines in modern IDEs do not propose expressions or multi-statement idiomatic code. Recent work has shown that language models can improve code suggestion systems by learning from software repositories. This paper introduces a neural language model with a sparse pointer network aimed at capturing very long-range dependencies. We release a large-scale code suggestion corpus of 41M lines of Python code crawled from GitHub. On this corpus, we found standard neural language models to perform well at suggesting local phenomena, but struggle to refer to identifiers that are introduced many tokens in the past. By augmenting a neural language model with a pointer network specialized in referring to predefined classes of identifiers, we obtain a much lower perplexity and a 5 percentage points increase in accuracy for code suggestion compared to an LSTM baseline. In fact, this increase in code suggestion accuracy is due to a 13 times more accurate prediction of identifiers. Furthermore, a qualitative analysis shows this model indeed captures interesting long-range dependencies, like referring to a class member defined over 60 tokens in the past.</p>
</td>
	<td>language model autocomplete </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/bhatia2016automated/">Automated Correction for Syntax Errors in Programming Assignments using Recurrent Neural Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Automated Correction for Syntax Errors in Programming Assignments using Recurrent Neural Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Automated Correction for Syntax Errors in Programming Assignments using Recurrent Neural Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sahil Bhatia, Rishabh Singh</td>
	<td></td>
	<td><p>We present a method for automatically generating repair feedback for syntax errors for introductory programming problems. Syntax errors constitute one of the largest classes of errors (34%) in our dataset of student submissions obtained from a MOOC course on edX. The previous techniques for generating automated feedback on programming assignments have focused on functional correctness and style considerations of student programs. These techniques analyze the program AST of the program and then perform some dynamic and symbolic analyses to compute repair feedback. Unfortunately, it is not possible to generate ASTs for student programs with syntax errors and therefore the previous feedback techniques are not applicable in repairing syntax errors. We present a technique for providing feedback on syntax errors that uses Recurrent neural networks (RNNs) to model syntactically valid token sequences. Our approach is inspired from the recent work on learning language models from Big Code (large code corpus). For a given programming assignment, we first learn an RNN to model all valid token sequences using the set of syntactically correct student submissions. Then, for a student submission with
syntax errors, we query the learnt RNN model with the prefix token sequence to predict token sequences that can fix the error by either replacing or inserting the predicted token sequence at the error location. We evaluate our technique on over 14, 000 student submissions with syntax errors. Our technique can completely repair 31.69% (4501/14203) of submissions with syntax errors and in addition partially correct 6.39% (908/14203) of the submissions.</p>
</td>
	<td>repair </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/wang2016neural/">Neural Code Completion</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Neural Code Completion' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Neural Code Completion' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Chang Liu, Xin Wang, Richard Shin, Joseph E. Gonzalez, Dawn Song</td>
	<td></td>
	<td><p>Code completion, an essential part of modern software development, yet can be
challenging for dynamically typed programming languages. In this paper we explore the use of neural network techniques to automatically learn code completion
from a large corpus of dynamically typed JavaScript code. We show different
neural networks that leverage not only token level information but also structural
information, and evaluate their performance on different prediction tasks. We
demonstrate that our models can outperform the state-of-the-art approach, which
is based on decision tree techniques, on both next non-terminal and next terminal
prediction tasks by 3.8 points and 0.5 points respectively. We believe that neural
network techniques can play a transformative role in helping software developers
manage the growing complexity of software systems, and we see this work as a
first step in that direction.</p>
</td>
	<td>autocomplete </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/wang2016bugram/">Bugram: bug detection with n-gram language models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Bugram: bug detection with n-gram language models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Bugram: bug detection with n-gram language models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Song Wang, Devin Chollak, Dana Movshovitz-Attias, Lin Tan</td>
	<td>ASE</td>
	<td><p>To improve software reliability, many rule-based techniques have been proposed to infer programming rules and detect violations of these rules as bugs. These rule-based approaches often rely on the highly frequent appearances of certain patterns in a project to infer rules. It is known that if a pattern does not appear frequently enough, rules are not learned, thus missing many bugs.</p>

<p>In this paper, we propose a new approach—Bugram—that leverages n-gram language models instead of rules to detect bugs. Bugram models program tokens sequentially, using the n-gram language model. Token sequences from the program are then assessed according to their probability in the learned model, and low probability sequences are marked as potential bugs. The assumption is that low probability token sequences in a program are unusual, which may indicate bugs, bad practices, or unusual/special uses of code of which developers may want to be aware.</p>

<p>We evaluate Bugram in two ways. First, we apply Bugram on the latest versions of 16 open source Java projects. Results show that Bugram detects 59 bugs, 42 of which are manually verified as correct, 25 of which are true bugs and 17 are code snippets that should be refactored. Among the 25 true bugs, 23 cannot be detected by PR-Miner. We have reported these bugs to developers, 7 of which have already been confirmed by developers (4 of them have already been fixed), while the rest await confirmation. Second, we further compare Bugram with three additional graph- and rule-based bug detection tools, i.e., JADET, Tikanga, and GrouMiner. We apply Bugram on 14 Java projects evaluated in these three studies. Bugram detects 21 true bugs, at least 10 of which cannot be detected by these three tools. Our results suggest that Bugram is complementary to existing rule-based bug detection approaches.</p>

</td>
	<td>defect representation </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/mou2016convolutional/">Convolutional Neural Networks over Tree Structures for Programming Language Processing</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Convolutional Neural Networks over Tree Structures for Programming Language Processing' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Convolutional Neural Networks over Tree Structures for Programming Language Processing' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Lili Mou, Ge Li, Lu Zhang, Tao Wang, Zhi Jin</td>
	<td>AAAI</td>
	<td><p>Programming language processing (similar to natural language processing) is a hot research topic in the field of software engineering; it has also aroused growing interest in the
artificial intelligence community. However, different from a
natural language sentence, a program contains rich, explicit,
and complicated structural information. Hence, traditional
NLP models may be inappropriate for programs. In this paper, we propose a novel tree-based convolutional neural network (TBCNN) for programming language processing, in
which a convolution kernel is designed over programs’ abstract syntax trees to capture structural information. TBCNN
is a generic architecture for programming language processing; our experiments show its effectiveness in two different program analysis tasks: classifying programs according
to functionality, and detecting code snippets of certain patterns. TBCNN outperforms baseline methods, including several neural models for NLP.</p>
</td>
	<td>representation grammar </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/gu2016deep/">Deep API Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep API Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep API Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Xiaodong Gu, Hongyu Zhang, Dongmei Zhang, Sunghun Kim.</td>
	<td>FSE</td>
	<td><p>Developers often wonder how to implement a certain functionality (e.g., how to parse XML files) using APIs. Obtaining an API usage sequence based on an API-related natural language query is very helpful in this regard. Given a query, existing approaches utilize information retrieval models to search for matching API sequences. These approaches treat queries and APIs as bag-of-words (i.e., keyword matching or word-to-word alignment) and lack a deep understanding of the semantics of the query.</p>

<p>We propose DeepAPI, a deep learning based approach to generate API usage sequences for a given natural language query. Instead of a bags-of-words assumption, it learns the
sequence of words in a query and the sequence of associated APIs. DeepAPI adapts a neural language model named RNN Encoder-Decoder. It encodes a word sequence (user query) into a fixed-length context vector, and generates an API sequence based on the context vector. We also augment the RNN Encoder-Decoder by considering the importance of individual APIs. We empirically evaluate our approach with more than 7 million annotated code snippets collected from GitHub. The results show that our approach generates largely accurate API sequences and outperforms the related approaches.</p>

</td>
	<td>API search </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/nguyen2016learning/">Learning API Usages from Bytecode: A Statistical Approach</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning API Usages from Bytecode: A Statistical Approach' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning API Usages from Bytecode: A Statistical Approach' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Tam The Nguyen, Hung Viet Pham, Phong Minh Vu, Tung Thanh Nguyen</td>
	<td>ICSE</td>
	<td><p>Mobile app developers rely heavily on standard API frameworks and libraries. However, learning API usages is often challenging due to the fast-changing nature of API frameworks for mobile systems and the insufficiency of API documentation and source code examples. In this paper, we propose a novel approach to learn API usages from bytecode of Android mobile apps. Our core contributions include HAPI, a statistical model of API usages and three algorithms to extract method call sequences from apps’ bytecode, to train HAPI based on those sequences, and to recommend method calls in code completion using the trained HAPIs. Our empirical evaluation shows that our prototype tool can effectively learn API usages from 200 thousand apps containing 350 million method sequences. It recommends next method calls with top-3 accuracy of 90% and outperforms baseline approaches on average 10-20%.</p>
</td>
	<td>representation API </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/patra2016learning/">Learning to Fuzz: Application-Independent Fuzz Testing with Probabilistic, Generative Models of Input Data</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Fuzz: Application-Independent Fuzz Testing with Probabilistic, Generative Models of Input Data' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Fuzz: Application-Independent Fuzz Testing with Probabilistic, Generative Models of Input Data' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jibesh Patra, Michael Pradel</td>
	<td></td>
	<td><p>Fuzzing is a popular technique to create test inputs for software that processes structured data. It has been successfully
applied in various domains, ranging from compilers and interpreters over program analyses to rendering engines, image manipulation tools, and word processors. Existing fuzz
testing techniques are tailored for a particular purpose and
rely on a carefully crafted model of the data to be generated.
This paper presents TreeFuzz, a generic approach for generating structured data without an a priori known model. The
key idea is to exploit a given corpus of example data to au-
tomatically infer probabilistic, generative models that create
new data with properties similar to the corpus. To support a
wide range of different properties, TreeFuzz is designed as a
framework with an extensible set of techniques to infer generative models. We apply the idea to JavaScript programs
and HTML documents and show that the approach generates mostly valid data for both of them: 96.3% of the generated JavaScript programs are syntactically valid and there are
only 2.06 validation errors per kilobyte of generated HTML.
The performance of both learning and generation scales linearly w.r.t. the size of the corpus. Using TreeFuzz-generated
JavaScript programs for differential testing of JavaScript engines exposes various inconsistencies among browsers, including browser bugs and unimplemented language features.</p>
</td>
	<td>fuzzing </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/wang2016automatically/">Automatically Learning Semantic Features for Defect Prediction</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Automatically Learning Semantic Features for Defect Prediction' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Automatically Learning Semantic Features for Defect Prediction' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Song Wang, Taiyue Liu, Lin Tan</td>
	<td>ICSE</td>
	<td><p>Software defect prediction, which predicts defective code regions, can help developers find bugs and prioritize their testing efforts. To build accurate prediction models, previous
studies focus on manually designing features that encode the
characteristics of programs and exploring different machine
learning algorithms. Existing traditional features often fail
to capture the semantic differences of programs, and such a
capability is needed for building accurate prediction models.</p>

<p>To bridge the gap between programs’ semantics and
defect prediction features, this paper proposes to leverage a
powerful representation-learning algorithm, deep learning,
to learn semantic representation of programs automatically
from source code. Specifically, we leverage Deep Belief
Network (DBN) to automatically learn semantic features
from token vectors extracted from programs’ Abstract
Syntax Trees (ASTs).</p>

<p>Our evaluation on ten open source projects shows that
our automatically learned semantic features significantly improve both within-project defect prediction (WPDP) and
cross-project defect prediction (CPDP) compared to traditional features. Our semantic features improve WPDP on
average by 14.7% in precision, 11.5% in recall, and 14.2%
in F1. For CPDP, our semantic features based approach
outperforms the state-of-the-art technique TCA+ with traditional features by 8.9% in F1.</p>
</td>
	<td>defect representation </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/white2016deep/">Deep Learning Code Fragments for Code Clone Detection</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Deep Learning Code Fragments for Code Clone Detection' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Deep Learning Code Fragments for Code Clone Detection' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Martin White, Michele Tufano, Christopher Vendome, Denys Poshyvanyk.</td>
	<td>ASE</td>
	<td><p>Code clone detection is an important problem for software
maintenance and evolution. Many approaches consider either structure or identifiers, but none of the existing detection techniques model both sources of information. These
techniques also depend on generic, handcrafted features to
represent code fragments. We introduce learning-based detection techniques where everything for representing terms
and fragments in source code is mined from the repository.
Our code analysis supports a framework, which relies on
deep learning, for automatically linking patterns mined at
the lexical level with patterns mined at the syntactic level.
We evaluated our novel learning-based approach for code
clone detection with respect to feasibility from the point
of view of software maintainers. We sampled and manually
evaluated 398 file- and 480 method-level pairs across eight
real-world Java systems; 93% of the file- and method-level
samples were evaluated to be true positives. Among the true
positives, we found pairs mapping to all four clone types. We
compared our approach to a traditional structure-oriented
technique and found that our learning-based approach detected clones that were either undetected or suboptimally
reported by the prominent tool Deckard. Our results affirm
that our learning-based approach is suitable for clone detection and a tenable technique for researchers.</p>
</td>
	<td>clone </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/fowkes2016parameter/">Parameter-Free Probabilistic API Mining across GitHub</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Parameter-Free Probabilistic API Mining across GitHub' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Parameter-Free Probabilistic API Mining across GitHub' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Jaroslav Fowkes, Charles Sutton</td>
	<td>FSE</td>
	<td><p>Existing API mining algorithms can be difficult to use as they require expensive parameter tuning and the returned set of API calls can be large, highly redundant and difficult to understand. To address this, we present PAM (Probabilistic API Miner), a near parameter-free probabilistic algorithm for mining the most interesting API call patterns. We show that PAM significantly outperforms both MAPO and UPMiner, achieving 69% test-set precision, at retrieving relevant API call sequences from GitHub. Moreover, we focus on libraries for which the developers have explicitly provided code examples, yielding over 300,000 LOC of hand-written API example code from the 967 client projects in the data set. This evaluation suggests that the hand-written examples actually have limited coverage of real API usages.</p>

</td>
	<td>API pattern mining </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/dam2016deep/">A deep language model for software code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A deep language model for software code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A deep language model for software code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hoa Khanh Dam, Truyen Tran, Trang Pham</td>
	<td></td>
	<td><p>Existing language models such as n-grams for software code often fail to capture a long context where dependent code elements scatter far apart. In this paper, we propose a novel approach to build a language model for software code to address this particular issue. Our language model, partly inspired by human memory, is built upon the powerful deep learning-based Long Short Term Memory architecture that is capable of learning long-term dependencies which occur frequently in software code. Results from our intrinsic evaluation on a corpus of Java projects have demonstrated the effectiveness of our language model. This work contributes to realizing our vision for DeepSoft, an end-to-end, generic deep learning-based framework for modeling software and its development process.</p>
</td>
	<td>language model code generation </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/allamanis2016convolutional/">A Convolutional Attention Network for Extreme Summarization of Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Convolutional Attention Network for Extreme Summarization of Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Convolutional Attention Network for Extreme Summarization of Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Miltiadis Allamanis, Hao Peng, Charles Sutton</td>
	<td>ICML</td>
	<td><p>Attention mechanisms in neural networks have proved useful for problems in which
the input and output do not have fixed dimension. Often there exist features that
are locally translation invariant and would be valuable for directing the model’s attention,
but previous attentional architectures are not constructed to learn such features specifically.
We introduce an attentional neural network that employs convolution on the input tokens to detect
local time-invariant and long-range topical attention features in a context-dependent way. We
apply this architecture to the problem of extreme summarization of source code snippets into short,
descriptive function name-like summaries. Using those features, the model sequentially generates a
summary by marginalizing over two attention mechanisms: one that predicts the next summary token based 
n the attention weights of the input tokens and another that is able to copy a code token as-is directly
into the summary. We demonstrate our convolutional attention neural network’s performance on 10 popular Java
projects showing that it achieves better performance compared to previous attentional mechanisms.</p>
</td>
	<td>naming summarization </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/chae2016automatically/">Automatically generating features for learning program analysis heuristics</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Automatically generating features for learning program analysis heuristics' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Automatically generating features for learning program analysis heuristics' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Kwonsoo Chae, Hakjoo Oh, Kihong Heo, Hongseok Yang</td>
	<td></td>
	<td><p>We present a technique for automatically generating features for data-driven program analyses. Recently data-driven approaches for building a program analysis have been proposed, which mine existing codebases and automatically learn heuristics for finding a cost-effective abstraction for a given analysis task. Such approaches reduce the burden of the analysis designers, but they do not remove it completely; they still leave the highly nontrivial task of designing so called features to the hands of the designers. Our technique automates this feature design process. The idea is to use programs as features after reducing and abstracting them. Our technique goes through selected program-query pairs in codebases, and it reduces and abstracts the program in each pair to a few lines of code, while ensuring that the analysis behaves similarly for the original and the new programs with respect to the query. Each reduced program serves as a boolean feature for program-query pairs. This feature evaluates to true for a given program-query pair when (as a program) it is included in the program part of the pair. We have implemented our approach for three real-world program analyses. Our experimental evaluation shows that these analyses with automatically-generated features perform comparably to those with manually crafted features.</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/raychev2016learning/">Learning Programs from Noisy Data</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Programs from Noisy Data' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Programs from Noisy Data' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Veselin Raychev, Pavol lBielik, Martin Vechev, Andreas Krause</td>
	<td>POPL</td>
	<td><p>We present a new approach for learning programs from noisy
datasets. Our approach is based on two new concepts: a regularized
program generator which produces a candidate program based on a
small sample of the entire dataset while avoiding overfitting, and a
dataset sampler which carefully samples the dataset by leveraging
the candidate program’s score on that dataset. The two components
are connected in a continuous feedback-directed loop.</p>

<p>We show how to apply this approach to two settings: one where
the dataset has a bound on the noise, and another without a noise
bound. The second setting leads to a new way of performing
approximate empirical risk minimization on hypotheses classes
formed by a discrete search space.</p>

<p>We then present two new kinds of program synthesizers which
target the two noise settings. First, we introduce a novel regularized
bitstream synthesizer that successfully generates programs even in
the presence of incorrect examples. We show that the synthesizer
can detect errors in the examples while combating overfitting –
a major problem in existing synthesis techniques. We also show
how the approach can be used in a setting where the dataset grows
dynamically via new examples (e.g., provided by a human).</p>

<p>Second, we present a novel technique for constructing statistical
code completion systems. These are systems trained on massive
datasets of open source programs, also known as “Big Code”. The
key idea is to introduce a domain specific language (DSL) over
trees and to learn functions in that DSL directly from the dataset.
These learned functions then condition the predictions made by the
system. This is a flexible and powerful technique which generalizes
several existing works as we no longer need to decide a priori on
what the prediction should be conditioned (another benefit is that
the learned functions are a natural mechanism for explaining the
prediction). As a result, our code completion system surpasses the
prediction capabilities of existing, hard-wired systems.</p>
</td>
	<td>code generation grammar </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/liu2016towards/">Towards Better Program Obfuscation: Optimization via Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Towards Better Program Obfuscation: Optimization via Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Towards Better Program Obfuscation: Optimization via Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Han Liu</td>
	<td>ICSE</td>
	<td><p>As a common practice in software development, program
obfuscation aims at deterring reverse engineering and malicious attacks on released source or binary code. Owning ample obfuscation techniques, we have relatively little
knowledge on how to most effectively use them. The biggest
challenge lies in identifying the most useful combination of
these techniques. We propose a unified framework to automatically generate and optimize obfuscation based on an
obscurity language model and a Monte Carlo Markov Chain
(MCMC) based search algorithm. We further instantiate it
for JavaScript programs and developed the Closure tool.
Compared to the well-known Google Closure Compiler, Closure outperforms its default setting by 26%. For programs
which have already been well obfuscated, Closure can still
outperform by 22%.</p>
</td>
	<td>deobfuscation </td>
</tr>

<tr>
	<td>2016</td>
	<td><a href="/publications/pu2016skp/">sk_p: a neural program corrector for MOOCs</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=sk_p: a neural program corrector for MOOCs' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=sk_p: a neural program corrector for MOOCs' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yewen Pu, Karthik Narasimhan, Armando Solar-Lezama, Regina Barzilay</td>
	<td>SPLASH</td>
	<td><p>We present a novel technique for automatic program correction in MOOCs, capable of fixing both syntactic and semantic errors without manual, problem specific correction strategies. Given an incorrect student program, it generates candidate programs from a distribution of likely corrections, and checks each candidate for correctness against a test suite.</p>

<p>The key observation is that in MOOCs many programs share similar code fragments, and the seq2seq neural network model, used in the natural-language processing task of machine translation, can be modified and trained to recover these fragments.</p>

<p>Experiment shows our scheme can correct 29% of all incorrect submissions and out-performs state of the art approach which requires manual, problem specific correction strategies.</p>
</td>
	<td>repair </td>
</tr>



<tr>
	<td>2015</td>
	<td><a href="/publications/karpathy2015visualizing/">Visualizing and Understanding Recurrent Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Visualizing and Understanding Recurrent Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Visualizing and Understanding Recurrent Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Andrej Karpathy, Justin Johnson, Li Fei-Fei</td>
	<td></td>
	<td><p>Recurrent Neural Networks (RNNs), and specifically a variant with Long Short-Term Memory (LSTM), are enjoying renewed interest as a result of successful
applications in a wide range of machine learning problems that involve sequential
data. However, while LSTMs provide exceptional results in practice, the source
of their performance and their limitations remain rather poorly understood. Using character-level language models as an interpretable testbed, we aim to bridge
this gap by providing an analysis of their representations, predictions and error
types. In particular, our experiments reveal the existence of interpretable cells that
keep track of long-range dependencies such as line lengths, quotes and brackets.
Moreover, our comparative analysis with finite horizon n-gram models traces the
source of the LSTM improvements to long-range structural dependencies. Finally,
we provide analysis of the remaining errors and suggests areas for further study.</p>

</td>
	<td>language model code generation </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/allamanis2015suggesting/">Suggesting Accurate Method and Class Names</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Suggesting Accurate Method and Class Names' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Suggesting Accurate Method and Class Names' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Miltiadis Allamanis, Earl T. Barr, Christian Bird, Charles Sutton</td>
	<td>FSE</td>
	<td><p>Descriptive names are a vital part of readable, and hence maintainable, code. Recent progress on automatically suggesting names for local variables tantalizes with the prospect of replicating that success with method and class names.  However, suggesting names for methods and classes is much more difficult. This is because good method and class names need to be functionally descriptive, but suggesting such names requires that the model goes beyond local context. We introduce a neural probabilistic language model for source code that is specifically designed for the method naming problem. Our model learns which names are semantically similar by assigning them to locations, called embeddings, in a high-dimensional continuous space, in such a way that names with similar embeddings tend to be used in similar contexts. These embeddings seem to contain semantic information about tokens, even though they are learned only from statistical co-occurrences of tokens.  Furthermore, we introduce a variant of our model
that is, to our knowledge, the first that can propose neologisms, names that have not appeared in the training corpus. We obtain state of the art results on the method, class, and even the simpler variable naming tasks. More broadly, the continuous embeddings that are learned by our model have the potential for wide application within software engineering.</p>

</td>
	<td>naming </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/allamanis2015bimodal/">A Bimodal Modelling of Source Code and Natural Language</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Bimodal Modelling of Source Code and Natural Language' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Bimodal Modelling of Source Code and Natural Language' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Miltiadis Allamanis, Daniel Tarlow, Andrew Gordon, Yi Wei</td>
	<td>ICML</td>
	<td><p>We consider the problem of building probabilistic models that jointly 
model short natural language utterances and source code snippets. The
aim is to bring together recent work on statistical modelling of source
code and work on bimodal models of images and natural language. The
resulting models are useful for a variety of tasks that involve natural
language and source code. We demonstrate their performance on two
retrieval tasks: retrieving source code snippets given a natural language
query, and retrieving natural language descriptions given a source code
query (i.e., source code captioning). Experiments show there to be
promise in this direction, and that modelling the structure of source
code improves performance.</p>
</td>
	<td>search grammar grammar bimodal </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/movshovitz2015kb/">KB-LDA: Jointly Learning a Knowledge Base of Hierarchy, Relations, and Facts</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=KB-LDA: Jointly Learning a Knowledge Base of Hierarchy, Relations, and Facts' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=KB-LDA: Jointly Learning a Knowledge Base of Hierarchy, Relations, and Facts' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Dana Movshovitz-Attias, William W. Cohen</td>
	<td>ACL</td>
	<td><p>Many existing knowledge bases (KBs), including Freebase, Yago, and NELL, rely
on a fixed ontology, given as an input
to the system, which defines the data to
be cataloged in the KB, i.e., a hierarchy of categories and relations between
them. The system then extracts facts that
match the predefined ontology. We propose an unsupervised model that jointly
learns a latent ontological structure of an
input corpus, and identifies facts from the
corpus that match the learned structure.
Our approach combines mixed membership stochastic block models and topic
models to infer a structure by jointly modeling text, a latent concept hierarchy, and
latent semantic relationships among the
entities mentioned in the text. As a case
study, we apply the model to a corpus
of Web documents from the software domain, and evaluate the accuracy of the various components of the learned ontology.</p>
</td>
	<td>pattern mining </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/cerulo2015irish/">Irish: A Hidden Markov Model to detect coded information islands in free text</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Irish: A Hidden Markov Model to detect coded information islands in free text' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Irish: A Hidden Markov Model to detect coded information islands in free text' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Luigi Cerulo, Michele Ceccarelli, Massimiliano Di Penta, Gerardo Canfora</td>
	<td>Science of Computer Programming</td>
	<td><p>Developers’ communication, as contained in emails, issue trackers, and forums, is a precious source of information to support the development process. For example, it can
be used to capture knowledge about development practice or about a software project itself. Thus, extracting the content of developers’ communication can be useful to support
several software engineering tasks, such as program comprehension, source code analysis, and software analytics. However, automating the extraction process is challenging, due to the unstructured nature of free text, which mixes different coding languages (e.g., source code, stack dumps, and log traces) with natural language parts.</p>

<p>We conduct an extensive evaluation of Irish (InfoRmation ISlands Hmm), an approach we proposed to extract islands of coded information from free text at token granularity, with respect to the state of art approaches based on island parsing or island parsing combined with machine learners. The evaluation considers a wide set of natural language documents (e.g., textbooks, forum discussions, and development emails) taken from different contexts and encompassing different coding languages. Results indicate an F-measure of Irish between 74% and 99%; this is in line with existing approaches which, differently from Irish, require specific expertise for the definition of regular expressions or grammars.</p>

</td>
	<td>information extraction </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/hellendoorn2015will/">Will they like this? Evaluating Code Contributions With Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Will they like this? Evaluating Code Contributions With Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Will they like this? Evaluating Code Contributions With Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Vincent J. Hellendoorn, Premkumar Devanbu, Alberto Bacchelli</td>
	<td>MSR</td>
	<td><p>Popular open-source software projects receive and
review contributions from a diverse array of developers, many
of whom have little to no prior involvement with the project. A
recent survey reported that reviewers consider conformance to
the project’s code style to be one of the top priorities when evaluating code contributions on Github. We propose to quantitatively
evaluate the existence and effects of this phenomenon. To this aim
we use language models, which were shown to accurately capture
stylistic aspects of code. We find that rejected changesets do
contain code significantly less similar to the project than accepted
ones; furthermore, the less similar changesets are more likely
to be subject to thorough review. Armed with these results we
further investigate whether new contributors learn to conform to
the project style and find that experience is positively correlated
with conformance to the project’s code style.</p>
</td>
	<td>review language model </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/corley2015exploring/">Exploring the Use of Deep Learning for Feature Location</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Exploring the Use of Deep Learning for Feature Location' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Exploring the Use of Deep Learning for Feature Location' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Christopher S. Corley, Kostadin Damevski, Nicholas A. Kraft</td>
	<td></td>
	<td><p>Deep learning models are a class of neural networks. Relative to n-gram models, deep learning models can capture more complex statistical patterns based on smaller training corpora. In this paper we explore the use of a particular deep learning model, document vectors (DVs), for feature location. DVs seem well suited to use with source code, because they both capture the influence of context on each term in a corpus and map terms into a continuous semantic space that encodes semantic relationships such as synonymy. We present preliminary results that show that a feature location technique (FLT) based on DVs can outperform an analogous FLT based on latent Dirichlet allocation (LDA) and then suggest several directions for future work on the use of deep learning models to improve developer effectiveness in feature location.</p>
</td>
	<td>feature location representation </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/luan2019aroma/">Aroma: code recommendation via structural code search</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Aroma: code recommendation via structural code search' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Aroma: code recommendation via structural code search' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sifei Luan, Di Yang, Celeste Barnaby, Koushik Sen, Satish Chandra</td>
	<td>PACMPL</td>
	<td><p>Programmers often write code that has similarity to existing code written somewhere. A tool that could help programmers to search such similar code would be immensely useful. Such a tool could help programmers to extend partially written code snippets to completely implement necessary functionality, help to discover extensions to the partial code which are commonly included by other programmers, help to cross-check against similar code written by other programmers, or help to add extra code which would fix common mistakes and errors. We propose Aroma, a tool and technique for code recommendation via structural code search. Aroma indexes a huge code corpus including thousands of open-source projects, takes a partial code snippet as input, searches the corpus for method bodies containing the partial code snippet, and clusters and intersects the results of the search to recommend a small set of succinct code snippets which both contain the query snippet and appear as part of several methods in the corpus. We evaluated Aroma on 2000 randomly selected queries created from the corpus, as well as 64 queries derived from code snippets obtained from Stack Overflow, a popular website for discussing code. We implemented Aroma for 4 different languages, and developed an IDE plugin for Aroma. Furthermore, we conducted a study where we asked 12 programmers to complete programming tasks using Aroma, and collected their feedback. Our results indicate that Aroma is capable of retrieving and recommending relevant code snippets efficiently.</p>
</td>
	<td>search </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/white2015toward/">Toward Deep Learning Software Repositories</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Toward Deep Learning Software Repositories' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Toward Deep Learning Software Repositories' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Martin White, Christopher Vendome, Mario Linares-Vasquez, Denys Poshyvanyk</td>
	<td>MSR</td>
	<td><p>Deep learning subsumes algorithms that automatically learn compositional representations. The ability of these
models to generalize well has ushered in tremendous advances
in many fields such as natural language processing (NLP).
Recent research in the software engineering (SE) community
has demonstrated the usefulness of applying NLP techniques to
software corpora. Hence, we motivate deep learning for software
language modeling, highlighting fundamental differences between
state-of-the-practice software language models and connectionist
models. Our deep learning models are applicable to source
code files (since they only require lexically analyzed source
code written in any programming language) and other types
of artifacts. We show how a particular deep learning model
can remember its state to effectively model sequential data,
e.g., streaming software tokens, and the state is shown to be
much more expressive than discrete tokens in a prefix. Then we
instantiate deep learning models and show that deep learning
induces high-quality models compared to n-grams and cache-based n-grams on a corpus of Java projects. We experiment
with two of the models’ hyperparameters, which govern their
capacity and the amount of context they use to inform predictions,
before building several committees of software language models
to aid generalization. Then we apply the deep learning models to
code suggestion and demonstrate their effectiveness at a real SE
task compared to state-of-the-practice models. Finally, we propose
avenues for future work, where deep learning can be brought to
bear to support model-based testing, improve software lexicons,
and conceptualize software artifacts. Thus, our work serves as
the first step toward deep learning software repositories.</p>
</td>
	<td>representation </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/proksch2015intelligent/">Intelligent Code Completion with Bayesian Networks</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Intelligent Code Completion with Bayesian Networks' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Intelligent Code Completion with Bayesian Networks' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sebastian Proksch, Johannes Lerch, Mira Mezini</td>
	<td>TSE</td>
	<td><p>Code completion is an integral part of modern Integrated Development Environments (IDEs). Developers
often use it to explore Application Programming Interfaces (APIs). It is also useful to reduce the required
amount of typing and to help avoid typos. Traditional code completion systems propose all type-correct
methods to the developer. Such a list is often very long with many irrelevant items. More intelligent code
completion systems have been proposed in prior work to reduce the list of proposed methods to relevant
items.</p>

<p>This work extends one of these existing approaches, the Best Matching Neighbor (BMN) algorithm. We
introduce Bayesian networks as an alternative underlying model, use additional context information for
more precise recommendations, and apply clustering techniques to improve model sizes. We compare our
new approach, Pattern-based Bayesian Networks (PBN), to the existing BMN algorithm. We extend previously used evaluation methodologies and, in addition to prediction quality, we also evaluate model size and
inference speed.</p>

<p>Our results show that the additional context information we collect improves prediction quality, especially
for queries that do not contain method calls. We also show that PBN can obtain comparable prediction
quality to BMN, while model size and inference speed scale better with large input sizes.</p>
</td>
	<td>autocomplete </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/saraiva2015products/">Products, Developers, and Milestones: How Should I Build My N-Gram Language Model</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Products, Developers, and Milestones: How Should I Build My N-Gram Language Model' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Products, Developers, and Milestones: How Should I Build My N-Gram Language Model' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Juliana Saraiva, Christian Bird, Thomas Zimmermann</td>
	<td>FSE</td>
	<td><p>Recent work has shown that although programming languages en-
able source code to be rich and complex, most code tends to be
repetitive and predictable. The use of natural language processing
(NLP) techniques applied to source code such as n-gram language
models show great promise in areas such as code completion, aiding impaired developers, and code search. In this paper, we address
three questions related to different methods of constructing lan-
guage models in an industrial context. Specifically, we ask: (1) Do
application specific, but smaller language models perform better
than language models across applications? (2) Are developer specific language models effective and do they differ depending on
what parts of the codebase a developer is working in? (3) Finally,
do language models change over time, i.e., does a language model
from early development model change later on in development?
The answers to these questions enable techniques that make use of
programming language models in development to choose the model
training corpus more effectively.</p>

<p>We evaluate these questions by building 28 language models across
developers, time periods, and applications within Microsoft Office
and present the results in this paper. We find that developer and
application specific language models perform better than models
from the entire codebase, but that temporality has little to no effect
on language model performance.</p>
</td>
	<td>language model </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/sharma2015nirmal/">NIRMAL: Automatic Identification of Software Relevant Tweets Leveraging Language Model</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=NIRMAL: Automatic Identification of Software Relevant Tweets Leveraging Language Model' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=NIRMAL: Automatic Identification of Software Relevant Tweets Leveraging Language Model' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Abhishek Sharma, Yuan Tian, David Lo</td>
	<td>SANER</td>
	<td><p>Twitter is one of the most widely used social media
platforms today. It enables users to share and view short 140-character messages called “tweets”. About 284 million active
users generate close to 500 million tweets per day. Such rapid
generation of user generated content in large magnitudes results
in the problem of information overload. Users who are interested
in information related to a particular domain have limited means
to filter out irrelevant tweets and tend to get lost in the huge
amount of data they encounter. A recent study by Singer et
al. found that software developers use Twitter to stay aware of
industry trends, to learn from others, and to network with other
developers. However, Singer et al. also reported that developers
often find Twitter streams to contain too much noise which is a
barrier to the adoption of Twitter. In this paper, to help developers
cope with noise, we propose a novel approach named NIRMAL,
which automatically identifies software relevant tweets from a
collection or stream of tweets. Our approach is based on language
modeling which learns a statistical model based on a training
corpus (i.e., set of documents). We make use of a subset of posts
from StackOverflow, a programming question and answer site, as
a training corpus to learn a language model. A corpus of tweets
was then used to test the effectiveness of the trained language
model. The tweets were sorted based on the rank the model
assigned to each of the individual tweets. The top 200 tweets
were then manually analyzed to verify whether they are software
related or not, and then an accuracy score was calculated. The
results show that decent accuracy scores can be achieved by
various variants of NIRMAL, which indicates that NIRMAL can
effectively identify software related tweets from a huge corpus of
tweets.</p>
</td>
	<td>information extraction </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/gvero2015synthesizing/">Synthesizing Java expressions from free-form queries</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Synthesizing Java expressions from free-form queries' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Synthesizing Java expressions from free-form queries' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Tihomir Gvero, Viktor Kuncak</td>
	<td>OOPSLA</td>
	<td><p>We present a new code assistance tool for integrated development environments. Our system accepts as input free-form queries containing a mixture of English and Java, and produces Java code expressions that take the query into account and respect syntax, types, and scoping rules of Java, as well as statistical usage patterns. In contrast to solutions based on code search, the results returned by our tool need not directly correspond to any previously seen code fragment. As part of our system we have constructed a probabilistic context free grammar for Java constructs and library invocations, as well as an algorithm that uses a customized natural language processing tool chain to extract information from free-form text queries. We present the results on a number of examples showing that our technique (1) often produces the expected code fragments, (2) tolerates much of the flexibility of natural language, and (3) can repair incorrect Java expressions that use, for example, the wrong syntax or missing arguments.</p>
</td>
	<td>synthesis code generation bimodal </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/mangal2015user/">A User-Guided Approach to Program Analysis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A User-Guided Approach to Program Analysis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A User-Guided Approach to Program Analysis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ravi Mangal, Xin Zhang, Aditya V. Nori, Mayur Naik</td>
	<td>FSE</td>
	<td><p>Program analysis tools often produce undesirable output
due to various approximations. We present an approach
and a system Eugene that allows user feedback to guide
such approximations towards producing the desired output.
We formulate the problem of user-guided program analysis in terms of solving a combination of hard rules and soft
rules: hard rules capture soundness while soft rules capture
degrees of approximations and preferences of users. Our
technique solves the rules using an off-the-shelf solver in a
manner that is sound (satisfies all hard rules), optimal (maximally satisfies soft rules), and scales to real-world analy-
ses and programs. We evaluate Eugene on two different
analyses with labeled output on a suite of seven Java pro-
grams of size 131–198 KLOC. We also report upon a user
study involving nine users who employ Eugene to guide an
information-flow analysis on three Java micro-benchmarks.
In our experiments, Eugene significantly reduces misclassified reports upon providing limited amounts of feedback.</p>
</td>
	<td>program analysis </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/ray2015naturalness/">On the “Naturalness” of Buggy Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=On the “Naturalness” of Buggy Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=On the “Naturalness” of Buggy Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Baishakhi Ray, Vincent Hellendoorn, Saheel Godhane, Zhaopeng Tu, Alberto Bacchelli, Premkumar Devanbu</td>
	<td>ICSE</td>
	<td><p>Real software, the kind working programmers produce by the kLOC
to solve real-world problems, tends to be “natural”, like speech or
natural language; it tends to be highly repetitive and predictable.
Researchers have captured this naturalness of software through statistical models and used them to good effect in suggestion engines,
porting tools, coding standards checkers, and idiom miners. This
suggests that code that appears improbable, or surprising, to a good
statistical language model is “unnatural” in some sense, and thus
possibly suspicious. In this paper, we investigate this hypothesis. We consider a large corpus of bug fix commits (ca. 8,296),
from 10 different Java projects, and we focus on its language statistics, evaluating the naturalness of buggy code and the corresponding fixes. We find that code with bugs tends to be more entropic
(i.e. unnatural), becoming less so as bugs are fixed. Focusing on
highly entropic lines is similar in cost-effectiveness to some well-known static bug finders (PMD, FindBugs) and ordering warnings
from these bug finders using an entropy measure improves the cost-effectiveness of inspecting code implicated in warnings. This suggests that entropy may be a valid language-independent and simple
way to complement the effectiveness of PMD or FindBugs, and
that search-based bug-fixing methods may benefit from using entropy both for fault-localization and searching for fixes.</p>

</td>
	<td>defect </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/franks2015cacheca/">CACHECA: A Cache Language Model Based Code Suggestion Tool</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=CACHECA: A Cache Language Model Based Code Suggestion Tool' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=CACHECA: A Cache Language Model Based Code Suggestion Tool' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Christine Franks, Zhaopeng Tu, Premkumar Devanbu, Vincent Hellendoorn</td>
	<td>ICSE</td>
	<td><p>Nearly every Integrated Development Environment includes a form of code completion. The suggested completions (“suggestions”) are typically based on information available at compile time, such as type signatures and variables in scope. A statistical approach, based on estimated models of code patterns in large code corpora, has been demonstrated to be effective at predicting tokens given a context. In this demo, we present CACHECA, an Eclipse plugin that combines the native suggestions with a statistical suggestion regime. We demonstrate that a combination of the two approaches more than doubles Eclipse’s suggestion accuracy. A video demonstration is available at <a href="https://www.youtube.com/watch?v=3INk0N3JNtc">https://www.youtube.com/watch?v=3INk0N3JNtc</a>.</p>
</td>
	<td>language model </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/oh2015learning/">Learning a Strategy for Adapting a Program Analysis via Bayesian Optimisation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning a Strategy for Adapting a Program Analysis via Bayesian Optimisation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning a Strategy for Adapting a Program Analysis via Bayesian Optimisation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hakjoo Oh, Hongseok Yang, Kwangkeun Yi.</td>
	<td>OOPSLA</td>
	<td><p>Building a cost-effective static analyser for real-world programs is still regarded an art. One key contributor to this
grim reputation is the difficulty in balancing the cost and the
precision of an analyser. An ideal analyser should be adap-
tive to a given analysis task, and avoid using techniques that
unnecessarily improve precision and increase analysis cost.
However, achieving this ideal is highly nontrivial, and it requires a large amount of engineering efforts.</p>

<p>In this paper we present a new approach for building
an adaptive static analyser. In our approach, the analyser
includes a sophisticated parameterised strategy that decides, for each part of a given program, whether to apply
a precision-improving technique to that part or not. We
present a method for learning a good parameter for such
a strategy from an existing codebase via Bayesian optimisation. The learnt strategy is then used for new, unseen programs. Using our approach, we developed partially flow-
and context-sensitive variants of a realistic C static analyser.
The experimental results demonstrate that using Bayesian
optimisation is crucial for learning from an existing codebase. Also, they show that among all program queries that
require flow- or context-sensitivity, our partially flow- and
context-sensitive analysis answers the 75% of them, while
increasing the analysis cost only by 3.3x of the baseline
flow- and context-insensitive analysis, rather than 40x or
more of the fully sensitive version.</p>
</td>
	<td>program analysis </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/oda2015learning/">Learning to Generate Pseudo-code from Source Code using Statistical Machine Translation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Generate Pseudo-code from Source Code using Statistical Machine Translation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Generate Pseudo-code from Source Code using Statistical Machine Translation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Yusuke Oda, Hiroyuki Fudaba, Graham Neubig, Hideaki Hata, Sakriani Sakti, Tomoki Toda, Satoshi Nakamura</td>
	<td>ASE</td>
	<td><p>Pseudo-code written in natural language can aid
the comprehension of source code in unfamiliar programming
languages. However, the great majority of source code has no
corresponding pseudo-code, because pseudo-code is redundant
and laborious to create. If pseudo-code could be generated
automatically and instantly from given source code, we could
allow for on-demand production of pseudo-code without human
effort. In this paper, we propose a method to automatically
generate pseudo-code from source code, specifically adopting the
statistical machine translation (SMT) framework. SMT, which
was originally designed to translate between two natural languages, allows us to automatically learn the relationship between
source code/pseudo-code pairs, making it possible to create a
pseudo-code generator with less human effort. In experiments,
we generated English or Japanese pseudo-code from Python
statements using SMT, and find that the generated pseudo-code
is largely accurate, and aids code understanding.</p>
</td>
	<td>representation bimodal grammar </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/aggarwal2015using/">Using Machine Translation for Converting Python 2 to Python 3 Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Using Machine Translation for Converting Python 2 to Python 3 Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Using Machine Translation for Converting Python 2 to Python 3 Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Karan Aggarwal, Mohammad Salameh, Abram Hindle</td>
	<td></td>
	<td><p>In this paper, we have tried to use Statistical machine translation in order to convert Python 2 code to Python 3 code. We use data from two projects and achieve a high BLEU score. We also investigate the cross-project training and testing to analyze the errors so as to ascertain differences with previous case. We have described a pilot study on modeling programming languages as natural language to build translation models on the lines of natural languages. This can be further worked on to translate between versions of a programming language or cross-programming-languages code translation.</p>
</td>
	<td>migration </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/piech2015learning/">Learning Program Embeddings to Propagate Feedback on Student Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Program Embeddings to Propagate Feedback on Student Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Program Embeddings to Propagate Feedback on Student Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Chris Piech, Jonathan Huang, Andy Nguyen, Mike Phulsuksombati, Mehran Sahami, Leonidas Guibas</td>
	<td>ICML</td>
	<td><p>Providing feedback, both assessing final work
and giving hints to stuck students, is difficult
for open-ended assignments in massive online
classes which can range from thousands to millions of students. We introduce a neural network
method to encode programs as a linear mapping
from an embedded precondition space to an embedded postcondition space and propose an algorithm for feedback at scale using these linear maps as features. We apply our algorithm
to assessments from the Code.org Hour of Code
and Stanford University’s CS1 course, where we
propagate human comments on student assignments to orders of magnitude more submissions.</p>
</td>
	<td>representation repair education </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/raychev2015predicting/">Predicting Program Properties from “Big Code”</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Predicting Program Properties from “Big Code”' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Predicting Program Properties from “Big Code”' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Veselin Raychev, Martin Vechev, Andreas Krause</td>
	<td>POPL</td>
	<td><p>We present a new approach for predicting program properties from
massive codebases (aka “Big Code”). Our approach first learns a
probabilistic model from existing data and then uses this model to
predict properties of new, unseen programs.</p>

<p>The key idea of our work is to transform the input program into
a representation which allows us to phrase the problem of inferring program properties as structured prediction in machine learning. This formulation enables us to leverage powerful probabilistic
graphical models such as conditional random fields (CRFs) in order
to perform joint prediction of program properties.</p>

<p>As an example of our approach, we built a scalable prediction
engine called JSNICE 1 for solving two kinds of problems in the
context of JavaScript: predicting (syntactic) names of identifiers
and predicting (semantic) type annotations of variables. Experimentally, JSNICE predicts correct names for 63% of name identifiers and its type annotation predictions are correct in 81% of the
cases. In the first week since its release, JSN ICE was used by more
than 30,000 developers and in only few months has become a popular tool in the JavaScript developer community.</p>

<p>By formulating the problem of inferring program properties as
structured prediction and showing how to perform both learning
and inference in this context, our work opens up new possibilities
for attacking a wide range of difficult problems in the context of
“Big Code” including invariant generation, de-compilation, synthesis and others.</p>
</td>
	<td>program analysis naming types deobfuscation </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/nguyen2015graph/">Graph-based Statistical Language Model for Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Graph-based Statistical Language Model for Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Graph-based Statistical Language Model for Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Anh Tuan Nguyen, Tien N. Nguyen</td>
	<td>ICSE</td>
	<td><p>n-gram statistical language model has been successfully applied to capture programming patterns to support code
completion and suggestion. However, the approaches using n-gram face challenges in capturing the patterns at higher levels
of abstraction due to the mismatch between the sequence nature
in n-grams and the structure nature of syntax and semantics
in source code. This paper presents GraLan, a graph-based
statistical language model and its application in code suggestion. GraLan can learn from a source code corpus and compute
the appearance probabilities of any graphs given the observed
(sub)graphs. We use GraLan to develop an API suggestion
engine and an AST-based language model, ASTLan. ASTLan
supports the suggestion of the next valid syntactic template
and the detection of common syntactic templates. Our empirical
evaluation on a large corpus of open-source projects has shown
that our engine is more accurate in API code suggestion than
the state-of-the-art approaches, and in 75% of the cases, it can
correctly suggest the API with only five candidates. ASTLan also
has high accuracy in suggesting the next syntactic template and
is able to detect many useful and common syntactic templates.</p>
</td>
	<td>representation language model autocomplete </td>
</tr>

<tr>
	<td>2015</td>
	<td><a href="/publications/glassman2015overcode/">OverCode: visualizing variation in student solutions to programming problems at scale</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=OverCode: visualizing variation in student solutions to programming problems at scale' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=OverCode: visualizing variation in student solutions to programming problems at scale' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Elena L. Glassman, Jeremy Scott, Rishabh Singh, Philip J. Guo, Robert C. Miller</td>
	<td></td>
	<td><p>In MOOCs, a single programming exercise may produce thousands of solutions from learners. Understanding solution variation is important for providing appropriate feedback to students at scale. The wide variation among these solutions can be a source of pedagogically valuable examples and can be used to refine the autograder for the exercise by exposing corner cases. We present OverCode, a system for visualizing and exploring thousands of programming solutions. OverCode uses both static and dynamic analysis to cluster similar solutions, and lets teachers further filter and cluster solutions based on different criteria. We evaluated OverCode against a nonclustering baseline in a within-subjects study with 24 teaching assistants and found that the OverCode interface allows teachers to more quickly develop a high-level view of students’ understanding and misconceptions, and to provide feedback that is relevant to more students’ solutions.</p>
</td>
	<td>repair </td>
</tr>



<tr>
	<td>2014</td>
	<td><a href="/publications/allamanis2014learning/">Learning Natural Coding Conventions</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning Natural Coding Conventions' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning Natural Coding Conventions' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Miltiadis Allamanis, Earl T. Barr, Christian Bird, Charles Sutton</td>
	<td>FSE</td>
	<td><p>Every programmer has a characteristic style, ranging from preferences
about identifier naming to preferences about object relationships and
design patterns. Coding conventions define a consistent syntactic style,
fostering readability and hence maintainability. When collaborating,
programmers strive to obey a project’s coding conventions. However,
one third of reviews of changes contain feedback about coding conventions,
indicating that programmers do not always follow them and that project
members care deeply about adherence. Unfortunately, programmers are
often unaware of coding conventions because inferring them requires a
global view, one that aggregates the many local decisions programmers
make and identifies emergent consensus on style. We present Naturalize,
a framework that learns the style of a codebase, and suggests revisions
to improve stylistic consistency. Naturalize builds on recent work in
applying statistical natural language processing to source code. We
apply Naturalize to suggest natural identifier names and formatting
conventions. We present four tools focused on ensuring natural code
during development and release management, including code review.
Naturalize achieves 94% accuracy in its top suggestions for identifier
names. We used Naturalize to generate 18 patches for 5 open source
projects: 14 were accepted.</p>
</td>
	<td>naming language model style </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/maddison2014structured/">Structured Generative Models of Natural Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Structured Generative Models of Natural Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Structured Generative Models of Natural Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Chris J. Maddison, Daniel Tarlow</td>
	<td>ICML</td>
	<td><p>We study the problem of building generative
models of natural source code (NSC); that is,
source code written by humans and meant to
be understood by humans. Our primary con-
tribution is to describe new generative models
that are tailored to NSC. The models are based
on probabilistic context free grammars (PCFGs)
and neuro-probabilistic language models (Mnih
&amp; Teh, 2012), which are extended to incorporate
additional source code-specific structure. These
models can be efficiently trained on a corpus
of source code and outperform a variety of less
structured baselines in terms of predictive log
likelihoods on held-out data.</p>

</td>
	<td>language model code generation grammar grammar </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/nguyen2014statistical/">Statistical Learning Approach for Mining API Usage Mappings for Code Migration</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Statistical Learning Approach for Mining API Usage Mappings for Code Migration' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Statistical Learning Approach for Mining API Usage Mappings for Code Migration' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Anh Tuan Nguyen, Hoan Anh Nguyen, Tung Thanh Nguyen, Tien N. Nguyen</td>
	<td>ASE</td>
	<td><p>The same software product nowadays could appear in multiple platforms and devices. To address business needs, software companies
develop a software product in a programming language and then
migrate it to another one. To support that process, semi-automatic
migration tools have been proposed. However, they require users
to manually define the mappings between the respective APIs of
the libraries used in two languages. To reduce such manual effort,
we introduce StaMiner, a novel data-driven approach that statistically learns the mappings between APIs from the corpus of the
corresponding client code of the APIs in two languages Java and
C#. Instead of using heuristics on the textual or structural similarity
between APIs in two languages to map API methods and classes
as in existing mining approaches, StaMiner is based on a statistical
model that learns the mappings in such a corpus and provides mappings for APIs with all possible arities. Our empirical evaluation
on several projects shows that StaMiner can detect API usage mappings with higher accuracy than a state-of-the-art approach. With
the resulting API mappings mined by StaMiner, Java2CSharp, an
existing migration tool, could achieve a higher level of accuracy.</p>
</td>
	<td>migration API </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/hsiao2014using/">Using Web Corpus Statistics for Program Analysis</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Using Web Corpus Statistics for Program Analysis' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Using Web Corpus Statistics for Program Analysis' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Chun-Hung Hsiao, Michael Cafarella, Satish Narayanasamy</td>
	<td>OOPSLA</td>
	<td><p>Several program analysis tools—such as plagiarism detection and bug finding—rely on knowing a piece of code’s
relative semantic importance. For example, a plagiarism detector should not bother reporting two programs that have
an identical simple loop counter test, but should report programs that share more distinctive code. Traditional program
analysis techniques (e.g., finding data and control dependencies) are useful, but do not say how surprising or common
a line of code is. Natural language processing researchers
have encountered a similar problem and addressed it using
an n-gram model of text frequency, derived from statistics
computed over text corpora.</p>

<p>We propose and compute an n-gram model for programming languages, computed over a corpus of 2.8 million
JavaScript programs we downloaded from the Web. In contrast to previous techniques, we describe a code n-gram as
a subgraph of the program dependence graph that contains
all nodes and edges reachable in n steps from the statement.
We can count n-grams in a program and count the frequency
of n-grams in the corpus, enabling us to compute tf-idf-style
measures that capture the differing importance of different
lines of code. We demonstrate the power of this approach by
implementing a plagiarism detector with accuracy that beats
previous techniques, and a bug-finding tool that discovered
over a dozen previously unknown bugs in a collection of real
deployed programs.</p>
</td>
	<td>defect </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/gulwani2014nlyze/">NLyze: Interactive Programming by Natural Language for SpreadSheet Data Analysis and Manipulation</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=NLyze: Interactive Programming by Natural Language for SpreadSheet Data Analysis and Manipulation' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=NLyze: Interactive Programming by Natural Language for SpreadSheet Data Analysis and Manipulation' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Sumit Gulwani, Mark Marron</td>
	<td>SIGMOD</td>
	<td><p>Millions of computer end users need to perform tasks over tabular spreadsheet data, yet lack the programming knowledge to do such tasks automatically. This paper describes
the design and implementation of a robust natural language
based interface to spreadsheet programming. Our methodology involves designing a typed domain-specific language
(DSL) that supports an expressive algebra of map, filter, reduce, join, and formatting capabilities at a level of abstraction appropriate for non-expert users. The key algorithmic
component of our methodology is a translation algorithm
for converting a natural language specification in the context of a given spreadsheet to a ranked set of likely programs
in the DSL. The translation algorithm leverages the spreadsheet spatial and temporal context to assign interpretations
to specifications with implicit references, and is thus robust
to a variety of ways in which end users can express the same
task. The translation algorithm builds over ideas from keyword programming and semantic parsing to achieve both
high precision and high recall. We implemented the system
as an Excel add-in called NLyze that supports a rich user
interaction model including annotating the user’s natural
language specification and explaining the synthesized DSL
programs by paraphrasing them into structured English. We
collected a total of 3570 English descriptions for 40 spreadsheet tasks and our system was able to generate the intended
interpretation as the top candidate for 94% (97% for the top
3) of those instances.</p>

</td>
	<td>code generation bimodal synthesis </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/allamanis2014mining/">Mining Idioms from Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Mining Idioms from Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Mining Idioms from Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Miltiadis Allamanis, Charles Sutton</td>
	<td>FSE</td>
	<td><p>We present the first method for automatically mining code idioms from a corpus of previously written, idiomatic software projects. We take the view that a code idiom is a syntactic fragment that recurs across projects and has a single semantic purpose. Idioms may have metavariables, such as the body of a for loop. Modern IDEs commonly provide facilities for manually defining idioms and inserting them on demand, but this does not help programmers to write idiomatic code in languages or using libraries with which they are unfamiliar. We present Haggis, a system for mining code idioms that builds on recent advanced techniques from statistical natural language processing, namely, nonparametric Bayesian probabilistic tree substitution grammars. We apply Haggis to several of the most popular open source projects from GitHub. We present a wide range of evidence that the resulting idioms are semantically meaningful, demonstrating that they do indeed recur across software projects and that they occur more frequently in illustrative code examples collected from a Q&amp;A site. Manual examination of the most common idioms indicate that they describe important program concepts, including object creation, exception handling, and resource management.</p>
</td>
	<td>pattern mining grammar grammar </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/raychev2014code/">Code Completion with Statistical Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Code Completion with Statistical Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Code Completion with Statistical Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Veselin Raychev, Martin Vechev, Eran Yahav</td>
	<td>PLDI</td>
	<td><p>We address the problem of synthesizing code completions for programs using APIs. Given a program with holes, we synthesize completions for holes with the most likely sequences of method calls.</p>

<p>Our main idea is to reduce the problem of code completion to
a natural-language processing problem of predicting probabilities
of sentences. We design a simple and scalable static analysis that
extracts sequences of method calls from a large codebase, and
index these into a statistical language model. We then employ
the language model to find the highest ranked sentences, and use
them to synthesize a code completion. Our approach is able to
synthesize sequences of calls across multiple objects together with
their arguments.</p>

<p>Experiments show that our approach is fast and effective. Virtually all computed completions typecheck, and the desired completion appears in the top 3 results in 90% of the cases.</p>
</td>
	<td>language model autocomplete code generation </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/mou2014building/">Building Program Vector Representations for Deep Learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Building Program Vector Representations for Deep Learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Building Program Vector Representations for Deep Learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hao Peng, Lili Mou, Ge Li, Yuxuan Liu, Lu Zhang, Zhi Jin.</td>
	<td>International Conference on Knowledge Science, Engineering and Management</td>
	<td><p>Deep learning has made significant breakthroughs
in various fields of artificial intelligence. Advantages of deep
learning include the ability to capture highly complicated features, weak involvement of human engineering, etc. However,
it is still virtually impossible to use deep learning to analyze
programs since deep architectures cannot be trained effectively
with pure back propagation. In this pioneering paper, we propose
the “coding criterion” to build program vector representations,
which are the premise of deep learning for program analysis. Our
representation learning approach directly makes deep learning a
reality in this new field. We evaluate the learned vector representations both qualitatively and quantitatively. We conclude, based
on the experiments, the coding criterion is successful in building
program representations. To evaluate whether deep learning
is beneficial for program analysis, we feed the representations
to deep neural networks, and achieve higher accuracy in the
program classification task than “shallow” methods, such as
logistic regression and the support vector machine. This result
confirms the feasibility of deep learning to analyze programs. It
also gives primary evidence of its success in this new field. We
believe deep learning will become an outstanding technique for
program analysis in the near future.</p>

</td>
	<td>representation grammar </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/nguyen2015divide/">Divide-and-Conquer Approach for Multi-phase Statistical Migration for Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Divide-and-Conquer Approach for Multi-phase Statistical Migration for Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Divide-and-Conquer Approach for Multi-phase Statistical Migration for Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Anh Tuan Nguyen, Tung Thanh Nguyen, Tien N. Nguyen</td>
	<td>ASE</td>
	<td><p>Prior research shows that directly applying phrase-based SMT on lexical tokens to migrate Java to C# produces
much semantically incorrect code. A key limitation is the use of
sequences in phrase-based SMT to model and translate source
code with well-formed structures. We propose mppSMT, a divideand-conquer technique to address that with novel training and migration algorithms using phrase-based SMT in three phases. First,
mppSMT treats a program as a sequence of syntactic units and
maps/translates such sequences in two languages to one another.
Second, with a syntax-directed fashion, it deals with the tokens
within syntactic units by encoding them with semantic symbols to
represent their data and token types. This encoding via semantic
symbols helps better migration of API usages. Third, the lexical
tokens corresponding to each sememe are mapped or migrated.
The resulting sequences of tokens are merged together to form
the final migrated code. Such divide-and-conquer and syntax-direction strategies enable phrase-based SMT to adapt well to
syntactical structures in source code, thus, improving migration
accuracy. Our empirical evaluation on several real-world systems
shows that 84.8–97.9% and 70–83% of the migrated methods are
syntactically and semantically correct, respectively. 26.3–51.2%
of total migrated methods are exactly matched to the human-written C# code in the oracle. Compared to Java2CSharp, a rule-based migration tool, it achieves higher semantic accuracy from
6.6–57.7% relatively. Importantly, it does not require manual
labeling for training data or manual definition of rules.</p>
</td>
	<td>migration </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/campbell2014syntax/">Syntax Errors Just Aren’t Natural: Improving Error Reporting with Language Models</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Syntax Errors Just Aren’t Natural: Improving Error Reporting with Language Models' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Syntax Errors Just Aren’t Natural: Improving Error Reporting with Language Models' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Joshua Charles Campbell, Abram Hindle, José Nelson Amaral</td>
	<td>MSR</td>
	<td><p>A frustrating aspect of software development is that compiler error messages often fail to locate the actual cause of a syntax error. An errant semicolon or brace can result in
many errors reported throughout the file. We seek to find the actual source of these syntax errors by relying on the consistency of software: valid source code is usually repetitive and unsurprising. We exploit this consistency by constructing a simple N-gram language model of lexed source code tokens. We implemented an automatic Java syntax-error locator using the corpus of the project itself and evaluated its performance on mutated source code from several projects. Our tool, trained on the past versions of a project, can effectively augment the syntax error locations produced by the native compiler. Thus we provide a methodology and tool that exploits the naturalness of software source code to detect syntax errors alongside the parser.</p>
</td>
	<td>repair language model </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/srikant2014system/">A system to grade computer programming skills using machine learning</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A system to grade computer programming skills using machine learning' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A system to grade computer programming skills using machine learning' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Shashank Srikant, Varun Aggarwal</td>
	<td>KDD</td>
	<td><p>The automatic evaluation of computer programs is a nascent area of research with a potential for large-scale impact. Extant program assessment systems score mostly based on the number of test-cases passed, providing no insight into the competency of the programmer. In this paper, we present a system to grade computer programs automatically. In addition to grading a program on its programming practices and complexity, the key kernel of the system is a machine-learning based algorithm which determines closeness of the logic of the given program to a correct program. This algorithm uses a set of highly-informative features, derived from the abstract representations of a given program, that capture the program’s functionality. These features are then used to learn a model to grade the programs, which are built against evaluations done by experts. We show that the regression models provide much better grading than the ubiquitous test-case-pass based grading and rivals the grading accuracy of other open-response problems such as essay grading . We also show that our novel features add significant value over and above basic keyword/expression count features. In addition to this, we propose a novel way of posing computer-program grading as a one-class modeling problem and report encouraging preliminary results. We show the value of the system through a case study in a real-world industrial deployment. To the best of the authors’ knowledge, this is the first time a system using machine learning has been developed and used for grading programs. The work is timely with regard to the recent boom in Massively Online Open Courseware (MOOCs), which promises to produce a significant amount of hand-graded digitized data.</p>
</td>
	<td>education </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/tu2014localness/">On the Localness of Software</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=On the Localness of Software' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=On the Localness of Software' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Zhaopeng Tu, Zhendong Su, Premkumar Devanbu</td>
	<td>FSE</td>
	<td><p>The n-gram language model, which has its roots in statistical natural
language processing, has been shown to successfully capture the
repetitive and predictable regularities (“naturalness”) of source code,
and help with tasks such as code suggestion, porting, and designing
assistive coding devices. However, we show in this paper that this
natural-language-based model fails to exploit a special property of
source code: localness. We find that human-written programs are
localized: they have useful local regularities that can be captured
and exploited. We introduce a novel cache language model that
consists of both an n-gram and an added “cache” component to
exploit localness. We show empirically that the additional cache
component greatly improves the n-gram approach by capturing
the localness of software, as measured by both cross-entropy and
suggestion accuracy. Our model’s suggestion accuracy is actually
comparable to a state-of-the-art, semantically augmented language
model; but it is simpler and easier to implement. Our cache language
model requires nothing beyond lexicalization, and thus is applicable
to all programming languages.</p>
</td>
	<td>language model </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/zaremba2014learning/">Learning to Execute</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning to Execute' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning to Execute' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Wojciech Zaremba, Ilya Sutskever</td>
	<td></td>
	<td><p>Recurrent Neural Networks (RNNs) with Long Short-Term Memory units (LSTM) are widely used because they are expressive and are easy to train. Our interest lies in empirically evaluating the expressiveness and the learnability of LSTMs in the sequence-to-sequence regime by training them to evaluate short computer programs, a domain that has traditionally been seen as too complex for neural networks. We consider a simple class of programs that can be evaluated with a single left-to-right pass using constant memory. Our main result is that LSTMs can learn to map the character-level representations of such programs to their correct outputs. Notably, it was necessary to use curriculum learning, and while conventional curriculum learning proved ineffective, we developed a new variant of curriculum learning that improved our networks’ performance in all experimental conditions. The improved curriculum had a dramatic impact on an addition problem, making it possible to train an LSTM to add two 9-digit numbers with 99% accuracy.</p>
</td>
	<td>execution representation </td>
</tr>

<tr>
	<td>2014</td>
	<td><a href="/publications/karaivanov2014phrase/">Phrase-Based Statistical Translation of Programming Languages</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Phrase-Based Statistical Translation of Programming Languages' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Phrase-Based Statistical Translation of Programming Languages' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>S. Karaivanov, Veselin Raychev, Martin Vechev</td>
	<td>Onward</td>
	<td><p>Phrase-based statistical machine translation approaches have been
highly successful in translating between natural languages and are
heavily used by commercial systems (e.g. Google Translate).</p>

<p>The main objective of this work is to investigate the applicability of
these approaches for translating between programming languages.
Towards that, we investigated several variants of the phrase-based
translation approach: i) a direct application of the approach to
programming languages, ii) a novel modification of the approach
to incorporate the grammatical structure of the target programming
language (so to avoid generating target programs which do not
parse), and iii) a combination of ii) with custom rules added to
improve the quality of the translation.</p>

<p>To experiment with the above systems, we investigated machine
translation from C# to Java. For the training, which takes about
60 hours, we used a parallel corpus of 20, 499 C#-to-Java method
translations. We then evaluated each of the three systems above by
translating 1,000 C# methods. Our experimental results indicate
that with the most advanced system, about 60% of the translated
methods compile (the top ranked) and out of a random sample of 50
correctly compiled methods, 68% (34 methods) were semantically
equivalent to the reference solution.</p>
</td>
	<td>migration code generation </td>
</tr>



<tr>
	<td>2013</td>
	<td><a href="/publications/nguyen2013statistical/">A Statistical Semantic Language Model for Source Code</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Statistical Semantic Language Model for Source Code' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Statistical Semantic Language Model for Source Code' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Tung Thanh Nguyen, Anh Tuan Nguyen, Hoan Anh Nguyen, Tien N. Nguyen</td>
	<td>FSE</td>
	<td><p>Recent research has successfully applied the statistical n-gram language model to show that source code exhibits a
good level of repetition. The n-gram model is shown to have
good predictability in supporting code suggestion and completion. However, the state-of-the-art n-gram approach to
capture source code regularities/patterns is based only on
the lexical information in a local context of the code units.
To improve predictability, we introduce SLAMC, a novel statistical semantic language model for source code. It incorporates semantic information into code tokens and models the
regularities/patterns of such semantic annotations, called sememes, rather than their lexemes. It combines the local context in semantic n-grams with the global technical concerns/functionality into an n-gram topic model, together with pairwise associations of program elements. Based on SLAMC,
we developed a new code suggestion method, which is empirically evaluated on several projects to have relatively 18–68%
higher accuracy than the state-of-the-art approach.</p>

</td>
	<td>language model </td>
</tr>

<tr>
	<td>2013</td>
	<td><a href="/publications/kushman2013using/">Using Semantic Unification to Generate Regular Expressions from Natural Language</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Using Semantic Unification to Generate Regular Expressions from Natural Language' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Using Semantic Unification to Generate Regular Expressions from Natural Language' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Nate Kushman, Regina Barzilay</td>
	<td>NAACL</td>
	<td><p>We consider the problem of translating natural language text queries into regular expressions which represent their meaning. The mismatch in the level of abstraction between the natural language representation and the regular expression representation make this a novel and challenging problem. However, a given regular expression can be written in many semantically equivalent forms, and we exploit this flexibility to facilitate translation by finding a form which more directly corresponds to the natural language. We evaluate our technique on a set of natural language queries and their associated regular expressions which we gathered from Amazon Mechanical Turk. Our model substantially outperforms a state-of-the-art semantic parsing baseline, yielding a 29% absolute improvement in accuracy.</p>
</td>
	<td>bimodal code generation </td>
</tr>

<tr>
	<td>2013</td>
	<td><a href="/publications/omar2013structured/">Structured Statistical Syntax Tree Prediction</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Structured Statistical Syntax Tree Prediction' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Structured Statistical Syntax Tree Prediction' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Cyrus Omar</td>
	<td>SPLASH</td>
	<td><p>Statistical models of source code can be used to improve
code completion systems, assistive interfaces, and code
compression engines. We are developing a statistical model
where programs are represented as syntax trees, rather than
simply a stream of tokens. Our model, initially for the Java
language, combines corpus data with information about syntax, types and the program context. We tested this model
using open source code corpuses and find that our model
is significantly more accurate than the current state of the
art, providing initial evidence for our claim that combining
structural and statistical information is a fruitful strategy.</p>
</td>
	<td>language model grammar </td>
</tr>

<tr>
	<td>2013</td>
	<td><a href="/publications/nguyen2013lexical/">Lexical Statistical Machine Translation for Language Migration</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Lexical Statistical Machine Translation for Language Migration' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Lexical Statistical Machine Translation for Language Migration' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Anh Tuan Nguyen, Tung Thanh Nguyen, Tien N. Nguyen</td>
	<td>FSE</td>
	<td><p>Prior research has shown that source code also exhibits naturalness, i.e. it is written by humans and is likely to be
repetitive. The researchers also showed that the n-gram language model is useful in predicting the next token in a source
file given a large corpus of existing source code. In this paper, we investigate how well statistical machine translation
(SMT) models for natural languages could help in migrating source code from one programming language to another.
We treat source code as a sequence of lexical tokens and
apply a phrase-based SMT model on the lexemes of those
tokens. Our empirical evaluation on migrating two Java
projects into C# showed that lexical, phrase-based SMT
could achieve high lexical translation accuracy ( BLEU from
81.3-82.6%). Users would have to manually edit only 11.9-15.8% of the total number of tokens in the resulting code to
correct it. However, a high percentage of total translation
methods (49.5-58.6%) is syntactically incorrect. Therefore,
our result calls for a more program-oriented SMT model that
is capable of better integrating the syntactic and semantic
information of a program to support language migration.</p>
</td>
	<td>migration API </td>
</tr>

<tr>
	<td>2013</td>
	<td><a href="/publications/movshovitz2013natural/">Natural Language Models for Predicting Programming Comments</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Natural Language Models for Predicting Programming Comments' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Natural Language Models for Predicting Programming Comments' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Dana Movshovitz-Attias, William W. Cohen</td>
	<td>ACL</td>
	<td><p>Statistical language models have successfully been used to describe and analyze
natural language documents. Recent work
applying language models to programming languages is focused on the task
of predicting code, while mainly ignoring
the prediction of programmer comments.
In this work, we predict comments from
JAVA source files of open source projects,
using topic models and n-grams, and we
analyze the performance of the models
given varying amounts of background data
on the project being predicted. We evaluate models on their comment-completion
capability in a setting similar to code completion tools built into standard code
editors, and show that using a comment
completion tool can save up to 47% of the
comment typing.</p>

</td>
	<td>bimodal documentation summarization </td>
</tr>

<tr>
	<td>2013</td>
	<td><a href="/publications/cerulo2013hidden/">A Hidden Markov Model to Detect Coded Information Islands in Free Text</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Hidden Markov Model to Detect Coded Information Islands in Free Text' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Hidden Markov Model to Detect Coded Information Islands in Free Text' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Luigi Cerulo, Michele Ceccarelli, Massimiliano Di Penta, Gerardo Canfora</td>
	<td>SCAM</td>
	<td><p>Emails and issue reports capture useful knowledge about development practices, bug fixing, and change activities. Extracting such a content is challenging, due to the mix-up of
source code and natural language, unstructured text.</p>

<p>In this paper we introduce an approach, based on Hidden Markov Models (HMMs), to extract coded information islands, such as source code, stack traces, and patches, from free text at a token level of granularity. We train a HMM for each category of information contained in the text, and adopt the Viterbi algorithm to recognize whether the sequence of tokens — e.g., words, language keywords, numbers, parentheses, punctuation marks, etc. — observed in a text switches among those HMMs. Although our implementation focuses on extracting source code from emails, the approach could be easily extended to include in principle any text-interleaved language.</p>

<p>We evaluated our approach with respect to the state of art on a set of development emails and bug reports drawn from the software repositories of well known open source systems. Results indicate an accuracy between 82% and 99%, which is in line with existing approaches which, differently from ours, require the manual definition of regular expressions or parsers.</p>

</td>
	<td>information extraction </td>
</tr>

<tr>
	<td>2013</td>
	<td><a href="/publications/nguyen2013study/">A Study of Repetitiveness of Code Changes in Software Evolution</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Study of Repetitiveness of Code Changes in Software Evolution' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Study of Repetitiveness of Code Changes in Software Evolution' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Hoan Anh Nguyen, Anh Tuan Nguyen, Tung Thanh Nguyen, Tien N. Nguyen, and Hridesh Rajan</td>
	<td>ASE</td>
	<td><p>In this paper, we present a large-scale study of
repetitiveness of code changes in software evolution. We collected
a large data set of 2,841 Java projects, with 1.7 billion source lines
of code (SLOC) at the latest revisions, 1.8 million code change
revisions (0.4 million fixes), 6.2 million changed files, and 2.5
billion changed SLOCs. A change is considered repeated within
or cross-project if it matches another change having occurred
in the history of the project or another project, respectively. We
report the following important findings. First, repetitiveness of
changes could be as high as 70–100% at small sizes and decreases
exponentially as size increases. Second, repetitiveness is higher
and more stable in the cross-project setting than in the project-within one. Third, fixing changes repeat similarly to general
changes. Importantly, learning code changes and recommending
them in software evolution is beneficial with accuracy for top-1
recommendation of over 30% and top-3 of nearly 35%. Repeated
fixing changes could also be useful for automatic program repair.</p>

</td>
	<td>edit </td>
</tr>

<tr>
	<td>2013</td>
	<td><a href="/publications/menon2013machine/">A Machine Learning Framework for Programming by Example</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Machine Learning Framework for Programming by Example' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Machine Learning Framework for Programming by Example' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Aditya Menon, Omer Tamuz, Sumit Gulwani, Butler Lampson, Adam Kalai</td>
	<td>ICML</td>
	<td><p>Learning programs is a timely and interesting challenge. In Programming by Example
(PBE), a system attempts to infer a program
from input and output examples alone, by
searching for a composition of some set of
base functions. We show how machine learning can be used to speed up this seemingly
hopeless search problem, by learning weights
that relate textual features describing the
provided input-output examples to plausible
sub-components of a program. This generic
learning framework lets us address problems
beyond the scope of earlier PBE systems.
Experiments on a prototype implementation
show that learning improves search and ranking on a variety of text processing tasks found
on help forums.</p>
</td>
	<td>code generation </td>
</tr>

<tr>
	<td>2013</td>
	<td><a href="/publications/allamanis2013mining/">Mining Source Code Repositories at Massive Scale Using Language Modeling </a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Mining Source Code Repositories at Massive Scale Using Language Modeling ' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Mining Source Code Repositories at Massive Scale Using Language Modeling ' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Miltiadis Allamanis, Charles Sutton</td>
	<td>MSR</td>
	<td><p>The tens of thousands of high-quality open source software projects on the Internet raise the exciting possibility of studying software development by finding patterns across truly large source code repositories. This could enable new tools for developing code, encouraging reuse, and navigating large projects. In this paper, we build the first giga-token probabilistic language model of source code, based on 352 million lines of Java. This is 100 times the scale of the pioneering work by Hindle et al. The giga-token model is significantly better at the code suggestion task than previous models. More broadly, our approach provides a new “lens” for analyzing software projects, enabling new complexity metrics based on statistical analysis of large corpora. We call these metrics data-driven complexity metrics. We propose new metrics that measure the complexity of a code module and the topical centrality of a module to a software project. In particular, it is possible to distinguish reusable utility classes from classes that are part of a program’s core logic based solely on general information theoretic criteria.</p>
</td>
	<td>language model </td>
</tr>



<tr>
	<td>2012</td>
	<td><a href="/publications/hindle2012naturalness/">On the Naturalness of Software</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=On the Naturalness of Software' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=On the Naturalness of Software' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Abram Hindle, Earl T. Barr, Mark Gabel, Zhendong Su, Premkumar Devanbu</td>
	<td>ICSE</td>
	<td><p>Natural languages like English are rich, complex,
and powerful. The highly creative and graceful use of languages
like English and Tamil, by masters like Shakespeare and
Avvaiyar, can certainly delight and inspire. But in practice,
given cognitive constraints and the exigencies of daily life, most
human utterances are far simpler and much more repetitive
and predictable. In fact, these utterances can be very usefully
modeled using modern statistical methods. This fact has led
to the phenomenal success of statistical approaches to speech
recognition, natural language translation, question-answering,
and text mining and comprehension.</p>

<p>We begin with the conjecture that most software is also
natural, in the sense that it is created by humans at work,
with all the attendant constraints and limitations—and thus,
like natural language, it is also likely to be repetitive and
predictable. We then proceed to ask whether a) code can
be usefully modeled by statistical language models and b)
such models can be leveraged to support software engineers.
Using the widely adopted n-gram model, we provide empirical
evidence supportive of a positive answer to both these questions.
We show that code is also very repetitive, and in fact even more
so than natural languages. As an example use of the model,
we have developed a simple code completion engine for Java
that, despite its simplicity, already improves Eclipse’s built-in
completion capability. We conclude the paper by laying out a
vision for future research in this area.</p>

</td>
	<td>language model autocomplete </td>
</tr>



<tr>
	<td>2009</td>
	<td><a href="/publications/bruch2009learning/">Learning from Examples to Improve Code Completion Systems</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=Learning from Examples to Improve Code Completion Systems' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=Learning from Examples to Improve Code Completion Systems' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Marcel Bruch, Martin Monperrus, Mira Mezini.</td>
	<td>ESEC/FSE</td>
	<td><p>The suggestions made by current IDE’s code completion features are based exclusively on static type system of the programming language. As a result, often proposals are made which are irrelevant for a particular working context. Also, these suggestions are ordered alphabetically rather than by their relevance in a particular context. In this paper, we present intelligent code completion systems that learn from existing code repositories. We have implemented three such systems, each using the information contained in
repositories in a different way. We perform a large-scale quantitative evaluation of these systems, integrate the best performing one into Eclipse, and evaluate the latter also by a user study. Our experiments give evidence that intelligent code completion systems which learn from examples significantly outperform mainstream code completion systems in terms of the relevance of their suggestions and thus have the potential to enhance developers’ productivity.</p>
</td>
	<td>autocomplete </td>
</tr>



<tr>
	<td>2007</td>
	<td><a href="/publications/kremenek2007factor/">A Factor Graph Model for Software Bug Finding</a>
		<span class="externallinks">
			&nbsp;<a href='http://scholar.google.com/scholar?q=A Factor Graph Model for Software Bug Finding' target="_blank"><img  style="display: inline; margin: 0;" src="/public/media/google-scholar.png"/></a>
			<a href='https://www.semanticscholar.org/search?q=A Factor Graph Model for Software Bug Finding' target="_blank"><img style="display: inline; margin: 0;" src="/public/media/semscholar.png"/></a>
		</span>
	</td>
	<td>Ted Kremenek, Andrew Y. Ng, Dawson R. Engler.</td>
	<td>IJCAI</td>
	<td><p>Automatic tools for finding software errors require
knowledge of the rules a program must obey, or
“specifications,” before they can identify bugs. We
present a method that combines factor graphs and
static program analysis to automatically infer specifications directly from programs. We illustrate the
approach on inferring functions in C programs that
allocate and release resources, and evaluate the approach on three codebases: SDL, OpenSSH, and
the OS kernel for Mac OS X (XNU). The inferred
specifications are highly accurate and with them we
have discovered numerous bugs.</p>

</td>
	<td>program analysis </td>
</tr>


</tbody></table>

<script>
var datatable;

function searchTable() {
    var hash = decodeURIComponent(window.location.hash.substr(1));
    datatable.search(hash).draw();
}


$(document).ready( function () {
    datatable = $('#allPapers').DataTable({
		paging: false,
		"order": [[ 0, 'desc' ], [ 1, 'asc' ]],
		columnDefs: [
			{
				targets: [3, 4, 5],
				visible: false,
				searchable: true
			}]
		});
    searchTable();
});

$(window).on('hashchange', function() {
  searchTable();
});
</script>


    </div>

  </body>
</html>
